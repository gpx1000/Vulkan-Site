<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Multithreading with Vulkan :: Vulkan Documentation Project</title>
    <meta name="generator" content="Antora 3.1.10">
    <script>
      !function (theme) {
        if (theme === 'dark') document.documentElement.classList.add('dark')
        else document.documentElement.classList.add('light')
      }(localStorage && localStorage.getItem('theme') || (matchMedia('(prefers-color-scheme: dark)')?.matches && 'dark'))
    </script>
    <link rel="stylesheet" href="../../_/css/site.css">
    <link rel="stylesheet" href="../../_/css/vendor/tabs.css">
    <link rel="apple-touch-icon" sizes="180x180" href="../../_/img/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../../_/img/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../../_/img/favicon-16x16.png">
    <link rel="manifest" href="../../_/site.webmanifest">
    <link rel="mask-icon" href="../../_/img/safari-pinned-tab.svg" color="#a41e22">
    <meta name="msapplication-TileColor" content="#ffc40d">
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="../.."><img class="navbar-item no-invert" alt="Vulkan White Label" src="../../_/Vulkan_Docs.svg" /></a>
      <div class="navbar-item search hide-for-print">
        <div id="search-field" class="field has-filter">
          <label for="search-input"></label>
          <input id="search-input" type="text" placeholder="Search the docs" aria-label="Search the docs">
          <label class="filter checkbox">
            <input type="checkbox" data-facet-filter="component:tutorial" checked> In this component
          </label>
        </div>
      </div>
      <button class="navbar-burger" aria-controls="topbar-nav" aria-expanded="false" aria-label="Toggle main menu">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <!-- <a class="navbar-item" href="#">Home</a> -->
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Specs</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="../../spec/latest/chapters/introduction.html">Vulkan API</a>
            <a class="navbar-item" href="../../glsl/latest/index.html">GLSL</a>
            <a class="navbar-item" href="../../guide/latest/hlsl.html">HLSL</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Education</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="../../refpages/latest/refpages/index.html">Vulkan Reference Pages</a>
            <a class="navbar-item" href="../../features/latest/features/index.html">Vulkan Feature Descriptions</a>
            <a class="navbar-item" href="../../guide/latest/index.html">Vulkan Guide</a>
            <a class="navbar-item" href="../../samples/latest/README.html">Vulkan Samples</a>
            <a class="navbar-item" href="../../tutorial/latest/index.html">Vulkan Tutorial</a>
            <a class="navbar-item" href="https://www.youtube.com/c/vulkan">YouTube</a>
            <a class="navbar-item" href="https://vulkan.org">More Info at Vulkan.org</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Feedback</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="https://github.com/KhronosGroup/Vulkan-Site/issues/new/choose" target="_blank">Report a Problem</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Community</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="https://discord.gg/vulkan">Vulkan Discord</a>
            <a class="navbar-item" href="https://reddit.com/r/vulkan">Reddit</a>
            <a class="navbar-item" href="https://stackoverflow.com/questions/tagged/vulkan">Stack Overflow</a>
            <a class="navbar-item" href="https://fosstodon.org/@vulkan">Mastodon</a>
          </div>
        </div>
      </div>
    </div>
    <label class="theme-toggler">
      <input type="checkbox" id="switch-theme-checkbox" name="switch-theme-checkbox" aria-label="Toggle color theme" title="Toggle color theme"/>
      <span class="icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="moon" class="svg-inline--fa fa-moon moon" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><path fill="currentColor" d="M223.5 32C100 32 0 132.3 0 256S100 480 223.5 480c60.6 0 115.5-24.2 155.8-63.4c5-4.9 6.3-12.5 3.1-18.7s-10.1-9.7-17-8.5c-9.8 1.7-19.8 2.6-30.1 2.6c-96.9 0-175.5-78.8-175.5-176c0-65.8 36-123.1 89.3-153.3c6.1-3.5 9.2-10.5 7.7-17.3s-7.3-11.9-14.3-12.5c-6.3-.5-12.6-.8-19-.8z"></path>
        </svg>
        <svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="sun" class="svg-inline--fa fa-sun sun" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M361.5 1.2c5 2.1 8.6 6.6 9.6 11.9L391 121l107.9 19.8c5.3 1 9.8 4.6 11.9 9.6s1.5 10.7-1.6 15.2L446.9 256l62.3 90.3c3.1 4.5 3.7 10.2 1.6 15.2s-6.6 8.6-11.9 9.6L391 391 371.1 498.9c-1 5.3-4.6 9.8-9.6 11.9s-10.7 1.5-15.2-1.6L256 446.9l-90.3 62.3c-4.5 3.1-10.2 3.7-15.2 1.6s-8.6-6.6-9.6-11.9L121 391 13.1 371.1c-5.3-1-9.8-4.6-11.9-9.6s-1.5-10.7 1.6-15.2L65.1 256 2.8 165.7c-3.1-4.5-3.7-10.2-1.6-15.2s6.6-8.6 11.9-9.6L121 121 140.9 13.1c1-5.3 4.6-9.8 9.6-11.9s10.7-1.5 15.2 1.6L256 65.1 346.3 2.8c4.5-3.1 10.2-3.7 15.2-1.6zM160 256a96 96 0 1 1 192 0 96 96 0 1 1 -192 0zm224 0a128 128 0 1 0 -256 0 128 128 0 1 0 256 0z"></path>
        </svg></span>
    </label>
  </nav>
</header>
<script>
  window.onload = function() {
    let e = document.getElementById("switch-theme-checkbox")
    e.checked = document.documentElement.classList.contains("dark");
    e.checked ? e.parentElement.classList.add("active") : e.parentElement.classList.remove("active")
  }
  !function() {
    let e = document.getElementById("switch-theme-checkbox")
    e.checked = document.documentElement.classList.contains("dark")
    e.addEventListener("change", function() {
      if (document.documentElement.classList.contains("light")) {
        document.documentElement.classList.remove("light")
        document.documentElement.classList.add("dark")
      } else if (document.documentElement.classList.contains("dark")) {
        document.documentElement.classList.remove("dark")
        document.documentElement.classList.add("light")
      } else {
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
          document.documentElement.classList.add("dark")
        } else {
          document.documentElement.classList.add("light")
        }
      }
      document.documentElement.setAttribute("data-theme", this.checked ? "dark" : "light"),
        function(e) {
          window.localStorage && window.localStorage.setItem("theme", e)
        }(this.checked ? "dark" : "light"), this.checked ? this.parentElement.classList.add("active") : this.parentElement.classList.remove("active")
    }.bind(e))
  }();
</script>
<div class="body">
<div class="nav-container" data-component="tutorial" data-version="latest" id="split-0">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <button class="nav-menu-toggle" aria-label="Toggle expand/collapse all" style="display: none"></button>
    <h3 class="title"><a href="00_Introduction.html">Khronos Vulkan Tutorial</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="00_Introduction.html">Introduction</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="01_Overview.html">Overview</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="02_Development_environment.html">Development environment</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="03_Drawing_a_triangle/00_Setup/00_Base_code.html">Drawing a triangle</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="03_Drawing_a_triangle/00_Setup/00_Base_code.html">Setup</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="03_Drawing_a_triangle/00_Setup/00_Base_code.html">Base Code</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="03_Drawing_a_triangle/00_Setup/01_Instance.html">Instance</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="03_Drawing_a_triangle/00_Setup/02_Validation_layers.html">Validation layers</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="03_Drawing_a_triangle/00_Setup/03_Physical_devices_and_queue_families.html">Physical devices and queue families</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="03_Drawing_a_triangle/00_Setup/04_Logical_device_and_queues.html">Logical device and queues</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="03_Drawing_a_triangle/01_Presentation/00_Window_surface.html">Presentation</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="03_Drawing_a_triangle/01_Presentation/00_Window_surface.html">Window surface</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="03_Drawing_a_triangle/01_Presentation/01_Swap_chain.html">Swap chain</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="03_Drawing_a_triangle/01_Presentation/02_Image_views.html">Image views</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="03_Drawing_a_triangle/02_Graphics_pipeline_basics/00_Introduction.html">Graphics pipeline basics</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="03_Drawing_a_triangle/02_Graphics_pipeline_basics/00_Introduction.html">Introduction</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="03_Drawing_a_triangle/02_Graphics_pipeline_basics/01_Shader_modules.html">Shader modules</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="03_Drawing_a_triangle/02_Graphics_pipeline_basics/02_Fixed_functions.html">Fixed functions</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="03_Drawing_a_triangle/02_Graphics_pipeline_basics/03_Render_passes.html">Render passes</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="03_Drawing_a_triangle/02_Graphics_pipeline_basics/04_Conclusion.html">Conclusion</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="03_Drawing_a_triangle/03_Drawing/00_Framebuffers.html">Drawing</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="03_Drawing_a_triangle/03_Drawing/00_Framebuffers.html">Framebuffers</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="03_Drawing_a_triangle/03_Drawing/01_Command_buffers.html">Command buffers</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="03_Drawing_a_triangle/03_Drawing/02_Rendering_and_presentation.html">Rendering and presentation</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="03_Drawing_a_triangle/03_Drawing/03_Frames_in_flight.html">Frames in flight</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="03_Drawing_a_triangle/04_Swap_chain_recreation.html">Swap chain recreation</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="04_Vertex_buffers/00_Vertex_input_description.html">Vertex buffers</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="04_Vertex_buffers/00_Vertex_input_description.html">Vertex input description</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="04_Vertex_buffers/01_Vertex_buffer_creation.html">Vertex buffer creation</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="04_Vertex_buffers/02_Staging_buffer.html">Staging buffer</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="04_Vertex_buffers/03_Index_buffer.html">Index buffer</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="05_Uniform_buffers/00_Descriptor_set_layout_and_buffer.html">Uniform buffers</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="05_Uniform_buffers/00_Descriptor_set_layout_and_buffer.html">Descriptor layout and buffer</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="05_Uniform_buffers/01_Descriptor_pool_and_sets.html">Descriptor pool and sets</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="06_Texture_mapping/00_Images.html">Texture mapping</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="06_Texture_mapping/00_Images.html">Images</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="06_Texture_mapping/01_Image_view_and_sampler.html">Image view and sampler</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="06_Texture_mapping/02_Combined_image_sampler.html">Combined image sampler</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="07_Depth_buffering.html">Depth buffering</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="08_Loading_models.html">Loading models</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="09_Generating_Mipmaps.html">Generating Mipmaps</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="10_Multisampling.html">Multisampling</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="11_Compute_Shader.html">Compute Shader</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="12_Ecosystem_Utilities_and_Compatibility.html">Ecosystem Utilities and GPU Compatibility</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="13_Vulkan_Profiles.html">Vulkan Profiles</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="14_Android.html">Android</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="15_GLTF_KTX2_Migration.html">Migrating to Modern Asset Formats: glTF and KTX2</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="16_Multiple_Objects.html">Rendering Multiple Objects</a>
  </li>
  <li class="nav-item is-current-page" data-depth="1">
    <a class="nav-link" href="17_Multithreading.html">Multithreading</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="courses/18_Ray_tracing/00_Overview.html">Ray Tracing</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="courses/18_Ray_tracing/00_Overview.html">Overview</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="courses/18_Ray_tracing/01_Dynamic_rendering.html">Dynamic rendering</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="courses/18_Ray_tracing/02_Acceleration_structures.html">Acceleration structures</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="courses/18_Ray_tracing/03_Ray_query_shadows.html">Ray query shadows</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="courses/18_Ray_tracing/04_TLAS_animation.html">TLAS animation</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="courses/18_Ray_tracing/05_Shadow_transparency.html">Shadow transparency</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="courses/18_Ray_tracing/06_Reflections.html">Reflections</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="courses/18_Ray_tracing/07_Conclusion.html">Conclusion</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="90_FAQ.html">FAQ</a>
  </li>
  <li class="nav-item" data-depth="1">
    <span class="nav-text"><a href="https://github.com/KhronosGroup/Vulkan-Tutorial" target="_blank" rel="noopener">GitHub Repository</a></span>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Khronos Vulkan Tutorial</span>
    <span class="version">latest</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <div class="title"><a href="00_Introduction.html">Khronos Vulkan Tutorial</a></div>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="00_Introduction.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../glsl/latest/index.html">OpenGL Shading Language Specification</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../glsl/latest/index.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../refpages/latest/refpages/index.html">Vulkan API Reference Pages</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../refpages/latest/refpages/index.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../features/latest/features/index.html">Vulkan Feature Descriptions</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../features/latest/features/index.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../guide/latest/index.html">Vulkan Guide</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../guide/latest/index.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../samples/latest/README.html">Vulkan Samples</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../samples/latest/README.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../spec/latest/index.html">Vulkan Specification</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../spec/latest/index.html">latest</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article" id="split-1">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../../spec/latest/index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="00_Introduction.html">Khronos Vulkan Tutorial</a></li>
    <li><a href="17_Multithreading.html">Multithreading</a></li>
  </ul>
</nav>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Multithreading with Vulkan</h1>
<div class="sect1">
<h2 id="_introduction"><a class="anchor" href="#_introduction"></a>Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In this chapter, we&#8217;ll explore how to leverage multithreading with Vulkan to improve performance in your applications. Modern CPUs have multiple cores, and efficiently utilizing these cores can significantly enhance your application&#8217;s performance, especially for computationally intensive tasks. Vulkan&#8217;s explicit design makes it well-suited for multithreaded architectures, allowing for fine-grained control over synchronization and resource access.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_overview"><a class="anchor" href="#_overview"></a>Overview</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Vulkan was designed with multithreading in mind, offering several advantages over older APIs:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Thread-safe command buffer recording</strong>: Multiple threads can record commands to different command buffers simultaneously.</p>
</li>
<li>
<p><strong>Explicit synchronization</strong>: Vulkan requires explicit synchronization, giving you precise control over resource access across threads.</p>
</li>
<li>
<p><strong>Queue-based architecture</strong>: Different operations can be submitted to different queues, potentially executing in parallel.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>However, multithreading in Vulkan requires careful consideration of:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Resource sharing</strong>: Ensuring safe access to shared resources across threads.</p>
</li>
<li>
<p><strong>Synchronization</strong>: Properly synchronizing operations between threads.</p>
</li>
<li>
<p><strong>Work distribution</strong>: Effectively distributing work to maximize parallelism.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>In this chapter, we&#8217;ll implement a multithreaded rendering system that builds upon our previous work with compute shaders. We&#8217;ll create a particle system where:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>One thread handles window events and presentation</p>
</li>
<li>
<p>Multiple worker threads record command buffers for different particle groups</p>
</li>
<li>
<p>A dedicated thread submits work to the GPU</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_implementation"><a class="anchor" href="#_implementation"></a>Implementation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Let&#8217;s walk through the key components needed to implement multithreading in our Vulkan application:</p>
</div>
<div class="sect2">
<h3 id="_thread_safe_resource_management"><a class="anchor" href="#_thread_safe_resource_management"></a>Thread-Safe Resource Management</h3>
<div class="paragraph">
<p>First, we need to ensure our resources are accessed safely across threads. We&#8217;ll use a combination of techniques:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c&#43;&#43; hljs" data-lang="c&#43;&#43;">// Thread-safe resource manager
class ThreadSafeResourceManager {
private:
    std::mutex resourceMutex;
    // Resources that need thread-safe access
    std::vector&lt;vk::raii::CommandPool&gt; commandPools;
    std::vector&lt;vk::raii::CommandBuffer&gt; commandBuffers;

public:
    // Create a command pool for each worker thread
    void createThreadCommandPools(vk::raii::Device&amp; device, uint32_t queueFamilyIndex, uint32_t threadCount) {
        std::lock_guard&lt;std::mutex&gt; lock(resourceMutex);

        commandPools.clear();
        for (uint32_t i = 0; i &lt; threadCount; i++) {
            vk::CommandPoolCreateInfo poolInfo{
                .flags = vk::CommandPoolCreateFlagBits::eResetCommandBuffer,
                .queueFamilyIndex = queueFamilyIndex
            };
            commandPools.emplace_back(device, poolInfo);
        }
    }

    // Get a command pool for a specific thread
    vk::raii::CommandPool&amp; getCommandPool(uint32_t threadIndex) {
        std::lock_guard&lt;std::mutex&gt; lock(resourceMutex);
        return commandPools[threadIndex];
    }

    // Allocate command buffers for each thread
    void allocateCommandBuffers(vk::raii::Device&amp; device, uint32_t threadCount, uint32_t buffersPerThread) {
        std::lock_guard&lt;std::mutex&gt; lock(resourceMutex);

        commandBuffers.clear();
        for (uint32_t i = 0; i &lt; threadCount; i++) {
            vk::CommandBufferAllocateInfo allocInfo{
                .commandPool = *commandPools[i],
                .level = vk::CommandBufferLevel::ePrimary,
                .commandBufferCount = buffersPerThread
            };
            auto threadBuffers = device.allocateCommandBuffers(allocInfo);
            for (auto&amp; buffer : threadBuffers) {
                commandBuffers.emplace_back(std::move(buffer));
            }
        }
    }

    // Get a command buffer
    vk::raii::CommandBuffer&amp; getCommandBuffer(uint32_t index) {
        std::lock_guard&lt;std::mutex&gt; lock(resourceMutex);
        return commandBuffers[index];
    }
};</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_worker_thread_implementation"><a class="anchor" href="#_worker_thread_implementation"></a>Worker Thread Implementation</h3>
<div class="paragraph">
<p>Next, we&#8217;ll implement worker threads that record command buffers for different particle groups:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c&#43;&#43; hljs" data-lang="c&#43;&#43;">class MultithreadedApplication {
private:
    // Thread-related members
    uint32_t threadCount;
    std::vector&lt;std::thread&gt; workerThreads;
    std::atomic&lt;bool&gt; shouldExit{false};
    std::vector&lt;std::atomic&lt;bool&gt;&gt; threadWorkReady;
    std::vector&lt;std::atomic&lt;bool&gt;&gt; threadWorkDone;

    // Synchronization primitives
    std::mutex queueSubmitMutex;
    std::condition_variable workCompleteCv;

    // Resource manager
    ThreadSafeResourceManager resourceManager;

    // Particle system data
    struct ParticleGroup {
        uint32_t startIndex;
        uint32_t count;
    };
    std::vector&lt;ParticleGroup&gt; particleGroups;

    // ... other Vulkan resources ...

public:
    void initThreads() {
        // Determine the number of threads to use (leave one core for the main thread)
        threadCount = std::max(1u, std::thread::hardware_concurrency() - 1);

        // Initialize synchronization primitives
        threadWorkReady.resize(threadCount);
        threadWorkDone.resize(threadCount);

        for (uint32_t i = 0; i &lt; threadCount; i++) {
            threadWorkReady[i] = false;
            threadWorkDone[i] = true;
        }

        // Create command pools for each thread
        resourceManager.createThreadCommandPools(device, graphicsQueueFamilyIndex, threadCount);

        // Divide particles into groups, one for each thread
        const uint32_t particlesPerThread = PARTICLE_COUNT / threadCount;
        particleGroups.resize(threadCount);

        for (uint32_t i = 0; i &lt; threadCount; i++) {
            particleGroups[i].startIndex = i * particlesPerThread;
            particleGroups[i].count = (i == threadCount - 1) ?
                (PARTICLE_COUNT - i * particlesPerThread) : particlesPerThread;
        }

        // Start worker threads
        for (uint32_t i = 0; i &lt; threadCount; i++) {
            workerThreads.emplace_back(&amp;MultithreadedApplication::workerThreadFunc, this, i);
        }
    }

    void workerThreadFunc(uint32_t threadIndex) {
        while (!shouldExit) {
            // Wait for work to be ready
            if (!threadWorkReady[threadIndex]) {
                std::this_thread::yield();
                continue;
            }

            // Get the particle group for this thread
            const ParticleGroup&amp; group = particleGroups[threadIndex];

            // Get the command buffer for this thread
            vk::raii::CommandBuffer&amp; cmdBuffer = resourceManager.getCommandBuffer(threadIndex);

            // Record commands for this particle group
            recordComputeCommandBuffer(cmdBuffer, group.startIndex, group.count);

            // Mark work as done
            threadWorkDone[threadIndex] = true;
            threadWorkReady[threadIndex] = false;

            // Notify main thread
            workCompleteCv.notify_one();
        }
    }

    void recordComputeCommandBuffer(vk::raii::CommandBuffer&amp; cmdBuffer, uint32_t startIndex, uint32_t count) {
        cmdBuffer.reset();
        cmdBuffer.begin({});

        // Bind compute pipeline and descriptor sets
        cmdBuffer.bindPipeline(vk::PipelineBindPoint::eCompute, *computePipeline);
        cmdBuffer.bindDescriptorSets(vk::PipelineBindPoint::eCompute, *computePipelineLayout, 0, {*computeDescriptorSets[currentFrame]}, {});

        // Add a push constant to specify the particle range for this thread
        struct PushConstants {
            uint32_t startIndex;
            uint32_t count;
        } pushConstants{startIndex, count};

        cmdBuffer.pushConstants&lt;PushConstants&gt;(*computePipelineLayout, vk::ShaderStageFlagBits::eCompute, 0, pushConstants);

        // Dispatch compute work
        uint32_t groupCount = (count + 255) / 256;
        cmdBuffer.dispatch(groupCount, 1, 1);

        cmdBuffer.end();
    }

    void signalThreadsToWork() {
        // Signal all threads to start working
        for (uint32_t i = 0; i &lt; threadCount; i++) {
            threadWorkDone[i] = false;
            threadWorkReady[i] = true;
        }
    }

    void waitForThreadsToComplete() {
        // Wait for all threads to complete their work
        std::unique_lock&lt;std::mutex&gt; lock(queueSubmitMutex);
        workCompleteCv.wait(lock, [this]() {
            for (uint32_t i = 0; i &lt; threadCount; i++) {
                if (!threadWorkDone[i]) {
                    return false;
                }
            }
            return true;
        });
    }

    void cleanup() {
        // Signal threads to exit and join them
        shouldExit = true;
        for (auto&amp; thread : workerThreads) {
            if (thread.joinable()) {
                thread.join();
            }
        }

        // ... cleanup other resources ...
    }
};</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_modifying_the_compute_shader"><a class="anchor" href="#_modifying_the_compute_shader"></a>Modifying the Compute Shader</h3>
<div class="paragraph">
<p>We need to modify our compute shader to work with particle ranges specified by push constants:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c&#43;&#43; hljs" data-lang="c&#43;&#43;">// In the compute shader (31_shader_compute.slang)
[[vk::push_constant]]
struct PushConstants {
    uint startIndex;
    uint count;
};

[[vk::binding(0, 0)]] ConstantBuffer&lt;UniformBufferObject&gt; ubo;
[[vk::binding(1, 0)]] RWStructuredBuffer&lt;Particle&gt; particlesIn;
[[vk::binding(2, 0)]] RWStructuredBuffer&lt;Particle&gt; particlesOut;
PushConstants pushConstants;

[numthreads(256,1,1)]
void compMain(uint3 threadId : SV_DispatchThreadID)
{
    uint index = threadId.x;

    // Only process particles within our assigned range
    if (index &gt;= pushConstants.count) {
        return;
    }

    // Adjust index to start from our assigned start index
    uint globalIndex = pushConstants.startIndex + index;

    // Process the particle
    Particle particle = particlesIn[globalIndex];

    // Update particle position based on velocity and delta time
    particle.position += particle.velocity * ubo.deltaTime;

    // Simple boundary check with velocity inversion
    if (abs(particle.position.x) &gt; 1.0) {
        particle.velocity.x *= -1.0;
    }
    if (abs(particle.position.y) &gt; 1.0) {
        particle.velocity.y *= -1.0;
    }

    // Write the updated particle to the output buffer
    particlesOut[globalIndex] = particle;
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_updating_the_main_loop"><a class="anchor" href="#_updating_the_main_loop"></a>Updating the Main Loop</h3>
<div class="paragraph">
<p>Finally, we&#8217;ll update our main loop to coordinate the worker threads:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c&#43;&#43; hljs" data-lang="c&#43;&#43;">void drawFrame() {
    // Wait for the previous frame to finish
    while (vk::Result::eTimeout == device.waitForFences(*inFlightFences[currentFrame], vk::True, UINT64_MAX));
    device.resetFences(*inFlightFences[currentFrame]);

    // Acquire the next image
    auto [result, imageIndex] = swapChain.acquireNextImage(UINT64_MAX, *imageAvailableSemaphores[currentFrame], nullptr);

    if (result == vk::Result::eErrorOutOfDateKHR || result == vk::Result::eSuboptimalKHR || framebufferResized) {
        framebufferResized = false;
        recreateSwapChain();
        return;
    }

    // Update uniform buffers
    updateUniformBuffer(currentFrame);

    // Signal worker threads to start recording compute command buffers
    signalThreadsToWork();

    // While worker threads are busy, record the graphics command buffer on the main thread
    recordGraphicsCommandBuffer(imageIndex);

    // Wait for all worker threads to complete
    waitForThreadsToComplete();

    // Collect command buffers from all threads
    std::vector&lt;vk::CommandBuffer&gt; computeCmdBuffers;
    for (uint32_t i = 0; i &lt; threadCount; i++) {
        computeCmdBuffers.push_back(*resourceManager.getCommandBuffer(i));
    }

    // Submit compute work
    vk::SubmitInfo computeSubmitInfo{
        .commandBufferCount = static_cast&lt;uint32_t&gt;(computeCmdBuffers.size()),
        .pCommandBuffers = computeCmdBuffers.data()
    };

    {
        std::lock_guard&lt;std::mutex&gt; lock(queueSubmitMutex);
        computeQueue.submit(computeSubmitInfo, nullptr);
    }

    // Wait for compute to finish before graphics
    vk::PipelineStageFlags waitStages[] = {vk::PipelineStageFlagBits::eVertexInput};

    // Submit graphics work
    vk::SubmitInfo graphicsSubmitInfo{
        .waitSemaphoreCount = 1,
        .pWaitSemaphores = &amp;*imageAvailableSemaphores[currentFrame],
        .pWaitDstStageMask = waitStages,
        .commandBufferCount = 1,
        .pCommandBuffers = &amp;*graphicsCommandBuffers[currentFrame],
        .signalSemaphoreCount = 1,
        .pSignalSemaphores = &amp;*renderFinishedSemaphores[currentFrame]
    };

    {
        std::lock_guard&lt;std::mutex&gt; lock(queueSubmitMutex);
        graphicsQueue.submit(graphicsSubmitInfo, *inFlightFences[currentFrame]);
    }

    // Present the image
    vk::PresentInfoKHR presentInfo{
        .waitSemaphoreCount = 1,
        .pWaitSemaphores = &amp;*renderFinishedSemaphores[currentFrame],
        .swapchainCount = 1,
        .pSwapchains = &amp;*swapChain,
        .pImageIndices = &amp;imageIndex
    };

    result = presentQueue.presentKHR(presentInfo);

    if (result == vk::Result::eErrorOutOfDateKHR || result == vk::Result::eSuboptimalKHR || framebufferResized) {
        framebufferResized = false;
        recreateSwapChain();
    } else if (result != vk::Result::eSuccess) {
        throw std::runtime_error("failed to present swap chain image!");
    }

    currentFrame = (currentFrame + 1) % MAX_FRAMES_IN_FLIGHT;
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_advanced_multithreading_techniques"><a class="anchor" href="#_advanced_multithreading_techniques"></a>Advanced Multithreading Techniques</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Beyond the basic implementation above, there are several advanced techniques you can use to further optimize your multithreaded Vulkan application:</p>
</div>
<div class="sect2">
<h3 id="_secondary_command_buffers"><a class="anchor" href="#_secondary_command_buffers"></a>Secondary Command Buffers</h3>
<div class="paragraph">
<p>Secondary command buffers can be recorded in parallel and then executed by a primary command buffer:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c&#43;&#43; hljs" data-lang="c&#43;&#43;">// In worker thread:
vk::CommandBufferInheritanceInfo inheritanceInfo{
    .renderPass = *renderPass,
    .subpass = 0,
    .framebuffer = *framebuffers[imageIndex]
};

vk::CommandBufferBeginInfo beginInfo{
    .flags = vk::CommandBufferUsageFlagBits::eRenderPassContinue,
    .pInheritanceInfo = &amp;inheritanceInfo
};

secondaryCommandBuffer.begin(beginInfo);
// Record rendering commands...
secondaryCommandBuffer.end();

// In main thread:
primaryCommandBuffer.begin({});
primaryCommandBuffer.beginRenderPass(...);
primaryCommandBuffer.executeCommands(secondaryCommandBuffers);
primaryCommandBuffer.endRenderPass();
primaryCommandBuffer.end();</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_thread_pool_for_dynamic_work_distribution"><a class="anchor" href="#_thread_pool_for_dynamic_work_distribution"></a>Thread Pool for Dynamic Work Distribution</h3>
<div class="paragraph">
<p>Instead of assigning fixed work to each thread, you can use a thread pool to dynamically distribute work:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c&#43;&#43; hljs" data-lang="c&#43;&#43;">class ThreadPool {
private:
    std::vector&lt;std::thread&gt; workers;
    std::queue&lt;std::function&lt;void()&gt;&gt; tasks;
    std::mutex queueMutex;
    std::condition_variable condition;
    bool stop;

public:
    ThreadPool(size_t threads) : stop(false) {
        for (size_t i = 0; i &lt; threads; ++i) {
            workers.emplace_back([this] {
                while (true) {
                    std::function&lt;void()&gt; task;
                    {
                        std::unique_lock&lt;std::mutex&gt; lock(queueMutex);
                        condition.wait(lock, [this] { return stop || !tasks.empty(); });
                        if (stop &amp;&amp; tasks.empty()) {
                            return;
                        }
                        task = std::move(tasks.front());
                        tasks.pop();
                    }
                    task();
                }
            });
        }
    }

    template&lt;class F&gt;
    void enqueue(F&amp;&amp; f) {
        {
            std::unique_lock&lt;std::mutex&gt; lock(queueMutex);
            tasks.emplace(std::forward&lt;F&gt;(f));
        }
        condition.notify_one();
    }

    ~ThreadPool() {
        {
            std::unique_lock&lt;std::mutex&gt; lock(queueMutex);
            stop = true;
        }
        condition.notify_all();
        for (std::thread&amp; worker : workers) {
            worker.join();
        }
    }
};</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_asynchronous_resource_loading"><a class="anchor" href="#_asynchronous_resource_loading"></a>Asynchronous Resource Loading</h3>
<div class="paragraph">
<p>You can use multithreading to load resources asynchronously:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c&#43;&#43; hljs" data-lang="c&#43;&#43;">std::future&lt;TextureData&gt; loadTextureAsync(const std::string&amp; filename) {
    return std::async(std::launch::async, [filename]() {
        TextureData data;
        // Load texture data from file
        return data;
    });
}

// Later in your code:
auto textureDataFuture = loadTextureAsync("texture.ktx");
// Do other work...
TextureData textureData = textureDataFuture.get(); // Wait for completion if needed
// Create Vulkan texture from the loaded data</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_performance_considerations"><a class="anchor" href="#_performance_considerations"></a>Performance Considerations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When implementing multithreading in Vulkan, keep these performance considerations in mind:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Thread Creation Overhead</strong>: Creating threads has overhead, so create them once at startup rather than per-frame.</p>
</li>
<li>
<p><strong>Work Granularity</strong>: Ensure each thread has enough work to justify the threading overhead.</p>
</li>
<li>
<p><strong>False Sharing</strong>: Be aware of cache line contention when multiple threads access adjacent memory.</p>
</li>
<li>
<p><strong>Queue Submissions</strong>: Queue submissions should be synchronized to avoid race conditions.</p>
</li>
<li>
<p><strong>Memory Barriers</strong>: Use memory barriers correctly to ensure visibility of memory operations across threads.</p>
</li>
<li>
<p><strong>Command Pool Per Thread</strong>: Each thread should have its own command pool to avoid synchronization overhead.</p>
</li>
<li>
<p><strong>Measure Performance</strong>: Always measure to ensure your multithreading actually improves performance.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_debugging_multithreaded_vulkan_applications"><a class="anchor" href="#_debugging_multithreaded_vulkan_applications"></a>Debugging Multithreaded Vulkan Applications</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Debugging multithreaded applications can be challenging. Here are some tips:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Validation Layers</strong>: Enable Vulkan validation layers to catch synchronization issues.</p>
</li>
<li>
<p><strong>Thread Sanitizers</strong>: Use tools like ThreadSanitizer to detect data races.</p>
</li>
<li>
<p><strong>Logging</strong>: Implement thread-safe logging to track execution flow.</p>
</li>
<li>
<p><strong>Simplify</strong>: Start with a simpler threading model and gradually add complexity.</p>
</li>
<li>
<p><strong>Atomic Operations</strong>: Use atomic operations for thread-safe counters and flags.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_conclusion"><a class="anchor" href="#_conclusion"></a>Conclusion</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In this chapter, we&#8217;ve explored how to leverage multithreading with Vulkan to improve performance. We&#8217;ve implemented a multithreaded particle system where:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Multiple worker threads record command buffers in parallel</p>
</li>
<li>
<p>The main thread coordinates work and handles presentation</p>
</li>
<li>
<p>Proper synchronization ensures thread safety</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>By distributing work across multiple CPU cores, we can significantly improve performance, especially for computationally intensive applications. Vulkan&#8217;s explicit design makes it well-suited for multithreaded architectures, allowing for fine-grained control over synchronization and resource access.</p>
</div>
<div class="paragraph">
<p>As you continue to develop your Vulkan applications, consider how multithreading can help you leverage the full power of modern CPUs, and remember to always measure performance to ensure your threading model is actually beneficial for your specific use case.</p>
</div>
<div class="paragraph">
<p><a href="_attachments/37_multithreading.cpp">C&#43;&#43; code</a></p>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<script id="site-script" src="../../_/js/site.js" data-ui-root-path="../../_"></script>
<script async src="../../_/js/vendor/highlight.js"></script>
<script src="../../_/js/vendor/split.js"></script>
<script>
    // Splitter should only be visible in non-mobile layouts (where a hamburger menu is used for nav)
    var width = (window.innerWidth > 0) ? window.innerWidth : screen.width;
    var mobileNav = (width < 1024);

    if (!mobileNav) {
        var sizes = localStorage.getItem('split-sizes')

        if (sizes) {
            sizes = JSON.parse(sizes)
        } else {
            sizes = [25, 75]
        }

        var split = Split(['#split-0', '#split-1'], {
            sizes: sizes,
            onDragEnd: function (sizes) {
                localStorage.setItem('split-sizes', JSON.stringify(sizes))
            },
        })
    }
</script>
<script src="../../_/js/vendor/lunr.js" defer></script>
<script src="https://cdn.jsdelivr.net/pako/1.0.3/pako.min.js" defer></script>
<script src="../../_/js/search-ui.js" id="search-ui-script" data-site-root-path="../.." data-snippet-length="100" data-stylesheet="../../_/css/search.css" defer></script>
<script>
window.addEventListener('DOMContentLoaded', function(){
  try {
    var script = document.getElementById('search-ui-script');
    var siteRoot = (script && script.getAttribute('data-site-root-path')) || '';
    var manifestUrl = siteRoot + '/search-index/manifest.json';
    fetch(manifestUrl)
      .then(function (r) { return r.ok ? r.json() : Promise.reject(new Error('manifest not found')) })
      .then(function (manifest) { antoraSearch.bootstrap(lunr, manifest, siteRoot); })
      .catch(function () {
        var s = document.createElement('script');
        s.async = true;
        s.src = siteRoot + '/search-index.js';
        document.head.appendChild(s);
      });
  } catch (e) {
    // Fallback to monolithic index if anything goes wrong
    var s = document.createElement('script');
    s.async = true;
    s.src = '../../search-index.js';
    document.head.appendChild(s);
  }
});
</script>
<script async src="../../_/js/vendor/tabs.js"></script>
  </body>
</html>

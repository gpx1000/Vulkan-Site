<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Window surface :: Vulkan Documentation Project</title>
    <meta name="generator" content="Antora 3.1.10">
    <link rel="stylesheet" href="../../../../_/css/site.css">
    <script>var uiRootPath = '../../../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="../../../..">Vulkan Documentation Project</a>
      <div class="navbar-item">
        <img alt="Vulkan White Label" src="../../../../_/Vulkan_White_Dec16.svg" height="100%" />
      </div>
      <div class="navbar-item search hide-for-print">
        <div id="search-field" class="field">
          <label for="search-input"></label><input id="search-input" type="text" placeholder="Search the docs">
        </div>
      </div>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <!-- <a class="navbar-item" href="#">Home</a> -->
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Specs</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="../../../../spec/latest/chapters/introduction.html">Vulkan 1.3</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Guides</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="../../../../guide/latest/index.html">Vulkan Guide</a>
          </div>
        </div>
            <!--
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Tools</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">TBD</a>
          </div>
        </div>
            -->
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Tutorial</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="../../../../tutorial/latest/index.html">Vulkan Tutorial</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Samples</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="../../../../samples/latest/README.html">Vulkan Samples</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Help</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="https://discord.gg/vulkan">Vulkan Discord</a>
            <a class="navbar-item" href="https://khr.io/khrdiscord">Khronos Discord</a>
          </div>
        </div>
            <!--
        <div class="navbar-item">
          <span class="control">
            <a class="button is-primary" href="#">Download</a>
          </span>
        </div>
            -->
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="tutorial" data-version="latest">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../../00_Introduction.html">Khronos Vulkan Tutorial</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../00_Introduction.html">Introduction</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../01_Overview.html">Overview</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../02_Development_environment.html">Development environment</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../00_Setup/00_Base_code.html">Drawing a triangle</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../00_Setup/00_Base_code.html">Setup</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../00_Setup/00_Base_code.html">Base Code</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../00_Setup/01_Instance.html">Instance</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../00_Setup/02_Validation_layers.html">Validation layers</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../00_Setup/03_Physical_devices_and_queue_families.html">Physical devices and queue families</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../00_Setup/04_Logical_device_and_queues.html">Logical device and queues</a>
  </li>
</ul>
  </li>
  <li class="nav-item is-current-page" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="00_Window_surface.html">Presentation</a>
<ul class="nav-list">
  <li class="nav-item is-current-page" data-depth="3">
    <a class="nav-link" href="00_Window_surface.html">Window surface</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="01_Swap_chain.html">Swap chain</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="02_Image_views.html">Image views</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../02_Graphics_pipeline_basics/00_Introduction.html">Graphics pipeline basics</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../02_Graphics_pipeline_basics/00_Introduction.html">Introduction</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../02_Graphics_pipeline_basics/01_Shader_modules.html">Shader modules</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../02_Graphics_pipeline_basics/02_Fixed_functions.html">Fixed functions</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../02_Graphics_pipeline_basics/03_Render_passes.html">Render passes</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../02_Graphics_pipeline_basics/04_Conclusion.html">Conclusion</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../03_Drawing/00_Framebuffers.html">Drawing</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../03_Drawing/00_Framebuffers.html">Framebuffers</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../03_Drawing/01_Command_buffers.html">Command buffers</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../03_Drawing/02_Rendering_and_presentation.html">Rendering and presentation</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../03_Drawing/03_Frames_in_flight.html">Frames in flight</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../04_Swap_chain_recreation.html">Swap chain recreation</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../04_Vertex_buffers/00_Vertex_input_description.html">Vertex buffers</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../04_Vertex_buffers/00_Vertex_input_description.html">Vertex input description</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../04_Vertex_buffers/01_Vertex_buffer_creation.html">Vertex buffer creation</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../04_Vertex_buffers/02_Staging_buffer.html">Staging buffer</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../04_Vertex_buffers/03_Index_buffer.html">Index buffer</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../05_Uniform_buffers/00_Descriptor_set_layout_and_buffer.html">Uniform buffers</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../05_Uniform_buffers/00_Descriptor_set_layout_and_buffer.html">Descriptor layout and buffer</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../05_Uniform_buffers/01_Descriptor_pool_and_sets.html">Descriptor pool and sets</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../06_Texture_mapping/00_Images.html">Texture mapping</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../06_Texture_mapping/00_Images.html">Images</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../06_Texture_mapping/01_Image_view_and_sampler.html">Image view and sampler</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../06_Texture_mapping/02_Combined_image_sampler.html">Combined image sampler</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../07_Depth_buffering.html">Depth buffering</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../08_Loading_models.html">Loading models</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../09_Generating_Mipmaps.html">Generating Mipmaps</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../10_Multisampling.html">Multisampling</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../11_Compute_Shader.html">Compute Shader</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../12_Ecosystem_Utilities_and_Compatibility.html">Ecosystem Utilities and GPU Compatibility</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../13_Vulkan_Profiles.html">Vulkan Profiles</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../14_Android.html">Android</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../15_GLTF_KTX2_Migration.html">Migrating to Modern Asset Formats: glTF and KTX2</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../16_Multiple_Objects.html">Rendering Multiple Objects</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../17_Multithreading.html">Multithreading</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../courses/18_Ray_tracing/00_Overview.html">Ray Tracing</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../courses/18_Ray_tracing/00_Overview.html">Overview</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../courses/18_Ray_tracing/01_Dynamic_rendering.html">Dynamic rendering</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../courses/18_Ray_tracing/02_Acceleration_structures.html">Acceleration structures</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../courses/18_Ray_tracing/03_Ray_query_shadows.html">Ray query shadows</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../courses/18_Ray_tracing/04_TLAS_animation.html">TLAS animation</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../courses/18_Ray_tracing/05_Shadow_transparency.html">Shadow transparency</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../courses/18_Ray_tracing/06_Reflections.html">Reflections</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../courses/18_Ray_tracing/07_Conclusion.html">Conclusion</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../90_FAQ.html">FAQ</a>
  </li>
  <li class="nav-item" data-depth="1">
    <span class="nav-text"><a href="https://github.com/KhronosGroup/Vulkan-Tutorial" target="_blank" rel="noopener">GitHub Repository</a></span>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Khronos Vulkan Tutorial</span>
    <span class="version">latest</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <a class="title" href="../../00_Introduction.html">Khronos Vulkan Tutorial</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../../00_Introduction.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../../../glsl/latest/index.html">OpenGL Shading Language Specification</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../glsl/latest/index.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../../../refpages/latest/refpages/index.html">Vulkan API Reference Pages</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../refpages/latest/refpages/index.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../../../features/latest/features/index.html">Vulkan Feature Descriptions</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../features/latest/features/index.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../../../guide/latest/index.html">Vulkan Guide</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../guide/latest/index.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../../../samples/latest/README.html">Vulkan Samples</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../samples/latest/README.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../../../spec/latest/index.html">Vulkan Specification</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../spec/latest/index.html">latest</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../../../../spec/latest/index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../../00_Introduction.html">Khronos Vulkan Tutorial</a></li>
    <li><a href="../00_Setup/00_Base_code.html">Drawing a triangle</a></li>
    <li><a href="00_Window_surface.html">Presentation</a></li>
  </ul>
</nav>
    <!--
    -->
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Window surface</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Since Vulkan is a platform-agnostic API, it is not designed to interface
directly with the window system on its own. To establish the connection
between Vulkan and the window system to present results to the screen, we
need to use the WSI (Window System Integration) extensions. In this chapter
we&#8217;ll discuss the first one, which is <code>VK_KHR_surface</code>. It exposes a
<code>VkSurfaceKHR</code> object that represents an abstract type of surface to
present rendered images to. The surface in our program will be backed by
the window that we&#8217;ve already opened with GLFW.</p>
</div>
<div class="paragraph">
<p>The <code>VK_KHR_surface</code> extension is an instance level extension, and we&#8217;ve actually
already enabled it, because it&#8217;s included in the list returned by
<code>glfwGetRequiredInstanceExtensions</code>. The list also includes some other WSI
extensions that we&#8217;ll use in the next couple of chapters.</p>
</div>
<div class="paragraph">
<p>The window surface needs to be created right after the instance creation,
because it can actually influence the physical device selection. The reason we
postponed this is that window surfaces are part of the larger topic of
render targets and presentation for which the explanation would have cluttered
the basic setup. It should also be noted that window surfaces are an entirely
optional component in Vulkan if you just need off-screen rendering. Vulkan
allows you to do that without hacks like creating an invisible window
(necessary for OpenGL).  Vulkan also allows you to remotely render from a
non-presenting GPU or remotely over the internet, or run compute
acceleration for AI without a render or presentation target.</p>
</div>
<div class="paragraph">
<p>While GLFW will be demonstrated here, the concept of Vulkan rendering to a
surface is repeated as a target for any other Windowing API. This concept
applies to mobile and to work with direct access to the windowing manager.
That said, let&#8217;s for now, concentrate on GLFW and see how it concretely
works in this tutorial.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_window_surface_creation"><a class="anchor" href="#_window_surface_creation"></a>Window surface creation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Start by adding a <code>surface</code> class member right below the debug callback.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">vk::raii::SurfaceKHR surface = nullptr;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Although the <code>VkSurfaceKHR</code> object and its usage is platform-agnostic, its
creation isn&#8217;t because it depends on window system details. For example, it
needs the <code>HWND</code> and <code>HMODULE</code> handles on Windows. Therefore, there is a
platform-specific addition to the extension, which on Windows is called
<code>VK_KHR_win32_surface</code> and is also automatically included in the list from
<code>glfwGetRequiredInstanceExtensions</code>.</p>
</div>
<div class="paragraph">
<p>I will demonstrate how this platform-specific extension can be used to create a
surface on Windows, but we won&#8217;t use it in this tutorial. It doesn&#8217;t
make any sense to use a library like GLFW and then proceed to use
platform-specific code anyway. GLFW actually has <code>glfwCreateWindowSurface</code> that
handles the platform differences for us. Still, it&#8217;s good to see what it does
behind the scenes before we start relying on it.</p>
</div>
<div class="paragraph">
<p>To access native platform functions, you need to update the includes at the top:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">#define VK_USE_PLATFORM_WIN32_KHR
#define GLFW_INCLUDE_VULKAN
#include &lt;GLFW/glfw3.h&gt;
#define GLFW_EXPOSE_NATIVE_WIN32
#include &lt;GLFW/glfw3native.h&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Because a window surface is a Vulkan object, it comes with a
<code>VkWin32SurfaceCreateInfoKHR</code> struct that needs to be filled in. It has two
important parameters: <code>hwnd</code> and <code>hinstance</code>. These are the handles to the
window and the process.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">VkWin32SurfaceCreateInfoKHR createInfo{};
createInfo.sType = VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR;
createInfo.hwnd = glfwGetWin32Window(window);
createInfo.hinstance = GetModuleHandle(nullptr);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>glfwGetWin32Window</code> function is used to get the raw <code>HWND</code> from the GLFW
window object. The <code>GetModuleHandle</code> call returns the <code>HINSTANCE</code> handle of the
current process.</p>
</div>
<div class="paragraph">
<p>After that the surface can be created with <code>vkCreateWin32SurfaceKHR</code>, which
includes a parameter for the instance, surface creation details, custom
allocators and the variable for the surface handle to be stored in.
Technically, this is a WSI extension function, but it is so commonly used
that the standard Vulkan loader includes it, so unlike other extensions, you
don&#8217;t need to explicitly load it.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">if (vkCreateWin32SurfaceKHR(instance, &amp;createInfo, nullptr, &amp;surface) != VK_SUCCESS) {
    throw std::runtime_error("failed to create window surface!");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The process is similar for other platforms like Linux, where
<code>vkCreateXcbSurfaceKHR</code> takes an XCB connection and window as creation details
with X11.</p>
</div>
<div class="paragraph">
<p>The <code>glfwCreateWindowSurface</code> function performs exactly this operation with a
different implementation for each platform. We&#8217;ll now integrate it into our
program. Add a function <code>createSurface</code> to be called from <code>initVulkan</code> right
after instance creation and <code>setupDebugMessenger</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void initVulkan() {
    createInstance();
    setupDebugMessenger();
    createSurface();
    pickPhysicalDevice();
    createLogicalDevice();
}

void createSurface() {

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The GLFW call takes simple parameters instead of a struct which makes the
implementation of the function very straightforward:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void createSurface() {
    VkSurfaceKHR       _surface;
    if (glfwCreateWindowSurface(*instance, window, nullptr, &amp;_surface) != 0) {
        throw std::runtime_error("failed to create window surface!");
    }
    surface = vk::raii::SurfaceKHR(instance, _surface);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>However, as you see in the above, GLFW only deals with the Vulkan C API.
The VkSurfaceKHR object is a C API object.  Thankfully, it can natively be
promoted to the C++ wrapper, and that&#8217;s what we do here.</p>
</div>
<div class="paragraph">
<p>The parameters are the <code>VkInstance</code>, GLFW window pointer, custom allocators and
pointer to <code>VkSurfaceKHR</code> variable. It simply passes through the <code>VkResult</code> from
the relevant platform call. GLFW doesn&#8217;t offer a special function for destroying
a surface, but wrapping it in our raii SurfaceKHR object will let Vulkan
RAII take care of that for us.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_querying_for_presentation_support"><a class="anchor" href="#_querying_for_presentation_support"></a>Querying for presentation support</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Although the Vulkan implementation may support window system integration, that
does not mean that every device in the system supports it. Therefore, we need to
extend <code>createLogicalDevice</code> to ensure that a device can present images to the
surface we created. Since the presentation is a queue-specific feature, the
problem is actually about finding a queue family that supports presenting to the
surface we created.</p>
</div>
<div class="paragraph">
<p>It&#8217;s actually possible that the queue families supporting drawing commands and
the queue families supporting presentation do not overlap. Therefore, we
have to take into account that there could be a distinct presentation queue.</p>
</div>
<div class="paragraph">
<p>Next, we&#8217;ll look for a queue family that has the capability of presenting
to our window surface. The function to check for that is
<code>vkGetPhysicalDeviceSurfaceSupportKHR</code>, which takes the  physical device,
queue family index and surface as parameters. Add a call to it
in the same loop as the <code>VK_QUEUE_GRAPHICS_BIT</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">VkBool32 presentSupport = physicalDevice.getSurfaceSupportKHR( graphicsIndex, *surface );</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then check the value of the boolean and store the presentation family
queue index:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">if (presentSupport) {
    indices.presentFamily = i;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that it&#8217;s very likely that these end up being the same queue family after
all, but throughout the program we will treat them as if they were separate
queues for a uniform approach. Nevertheless, you could add logic to explicitly
prefer a physical device that supports drawing and presentation in the same
queue for improved performance.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_creating_the_presentation_queue"><a class="anchor" href="#_creating_the_presentation_queue"></a>Creating the presentation queue</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The one thing that remains is modifying the logical device creation procedure to
create the presentation queue and retrieve the <code>VkQueue</code> handle. Add a member
variable for the handle:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">vk::raii::Queue presentQueue;

std::vector&lt;const char*&gt; deviceExtensions = {
    vk::KHRSwapchainExtensionName,
    vk::KHRSpirv14ExtensionName,
    vk::KHRSynchronization2ExtensionName,
    vk::KHRCreateRenderpass2ExtensionName
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Next, we need to modify the filtering logic to find the best queue families
to use as we detect them.  Here&#8217;s how we do it in one function at the device
creation functions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c++ hljs" data-lang="c++">void createLogicalDevice() {
    // find the index of the first queue family that supports graphics
    std::vector&lt;vk::QueueFamilyProperties&gt; queueFamilyProperties = physicalDevice.getQueueFamilyProperties();

    // get the first index into queueFamilyProperties which supports graphics
    auto graphicsQueueFamilyProperty = std::ranges::find_if( queueFamilyProperties, []( auto const &amp; qfp )
                    { return (qfp.queueFlags &amp; vk::QueueFlagBits::eGraphics) != static_cast&lt;vk::QueueFlags&gt;(0); } );

    auto graphicsIndex = static_cast&lt;uint32_t&gt;( std::distance( queueFamilyProperties.begin(), graphicsQueueFamilyProperty ) );

    // determine a queueFamilyIndex that supports present
    // first check if the graphicsIndex is good enough
    auto presentIndex = physicalDevice.getSurfaceSupportKHR( graphicsIndex, *surface )
                                       ? graphicsIndex
                                       : static_cast&lt;uint32_t&gt;( queueFamilyProperties.size() );
    if ( presentIndex == queueFamilyProperties.size() )
    {
        // the graphicsIndex doesn't support present -&gt; look for another family index that supports both
        // graphics and present
        for ( size_t i = 0; i &lt; queueFamilyProperties.size(); i++ )
        {
            if ( ( queueFamilyProperties[i].queueFlags &amp; vk::QueueFlagBits::eGraphics ) &amp;&amp;
                 physicalDevice.getSurfaceSupportKHR( static_cast&lt;uint32_t&gt;( i ), *surface ) )
            {
                graphicsIndex = static_cast&lt;uint32_t&gt;( i );
                presentIndex  = graphicsIndex;
                break;
            }
        }
        if ( presentIndex == queueFamilyProperties.size() )
        {
            // there's nothing like a single family index that supports both graphics and present -&gt; look for another
            // family index that supports present
            for ( size_t i = 0; i &lt; queueFamilyProperties.size(); i++ )
            {
                if ( physicalDevice.getSurfaceSupportKHR( static_cast&lt;uint32_t&gt;( i ), *surface ) )
                {
                    presentIndex = static_cast&lt;uint32_t&gt;( i );
                    break;
                }
            }
        }
    }
    if ( ( graphicsIndex == queueFamilyProperties.size() ) || ( presentIndex == queueFamilyProperties.size() ) )
    {
        throw std::runtime_error( "Could not find a queue for graphics or present -&gt; terminating" );
    }

    // query for Vulkan 1.3 features
    auto features = physicalDevice.getFeatures2();
    vk::PhysicalDeviceVulkan13Features vulkan13Features;
    vk::PhysicalDeviceExtendedDynamicStateFeaturesEXT extendedDynamicStateFeatures;
    vulkan13Features.dynamicRendering = vk::True;
    extendedDynamicStateFeatures.extendedDynamicState = vk::True;
    vulkan13Features.pNext = &amp;extendedDynamicStateFeatures;
    features.pNext = &amp;vulkan13Features;
    // create a Device
    float                     queuePriority = 0.5f;
    vk::DeviceQueueCreateInfo deviceQueueCreateInfo { .queueFamilyIndex = graphicsIndex, .queueCount = 1, .pQueuePriorities = &amp;queuePriority };
    vk::DeviceCreateInfo      deviceCreateInfo{ .pNext =  &amp;features, .queueCreateInfoCount = 1, .pQueueCreateInfos = &amp;deviceQueueCreateInfo };
    deviceCreateInfo.enabledExtensionCount = deviceExtensions.size();
    deviceCreateInfo.ppEnabledExtensionNames = deviceExtensions.data();

    device = vk::raii::Device( physicalDevice, deviceCreateInfo );
    graphicsQueue = vk::raii::Queue( device, graphicsIndex, 0 );
    presentQueue = vk::raii::Queue( device, presentIndex, 0 );
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In case the queue families are the same, the two handles will most likely have
the same value now. In the <a href="01_Swap_chain.html" class="xref page">next chapter</a>, we&#8217;re going to look at swap chains and
how they allow us to present images to the surface.</p>
</div>
<div class="paragraph">
<p><a href="../../_attachments/05_window_surface.cpp">C&#43;&#43; code</a></p>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer">
    <!--
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
    -->
</footer>
<script id="site-script" src="../../../../_/js/site.js" data-ui-root-path="../../../../_"></script>
<script async src="../../../../_/js/vendor/highlight.js"></script>
<script src="../../../../_/js/vendor/lunr.js" defer></script>
<script src="https://cdn.jsdelivr.net/pako/1.0.3/pako.min.js" defer></script>
<script src="../../../../_/js/search-ui.js" id="search-ui-script" data-site-root-path="../../../.." data-snippet-length="100" data-stylesheet="../../../../_/css/search.css" defer></script>
<script>
window.addEventListener('DOMContentLoaded', function(){
  try {
    var script = document.getElementById('search-ui-script');
    var siteRoot = (script && script.getAttribute('data-site-root-path')) || '';
    var manifestUrl = siteRoot + '/search-index/manifest.json';
    fetch(manifestUrl)
      .then(function (r) { return r.ok ? r.json() : Promise.reject(new Error('manifest not found')) })
      .then(function (manifest) { antoraSearch.bootstrap(lunr, manifest, siteRoot); })
      .catch(function () {
        var s = document.createElement('script');
        s.async = true;
        s.src = siteRoot + '/search-index.js';
        document.head.appendChild(s);
      });
  } catch (e) {
    // Fallback to monolithic index if anything goes wrong
    var s = document.createElement('script');
    s.async = true;
    s.src = '../../../../search-index.js';
    document.head.appendChild(s);
  }
});
</script>
  </body>
</html>

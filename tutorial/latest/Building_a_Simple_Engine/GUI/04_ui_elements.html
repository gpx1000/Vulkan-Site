<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>GUI: UI Elements and Integration Concepts :: Vulkan Documentation Project</title>
    <meta name="generator" content="Antora 3.1.10">
    <link rel="stylesheet" href="../../../../_/css/site.css">
    <script>var uiRootPath = '../../../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="../../../..">Vulkan Documentation Project</a>
      <div class="navbar-item">
        <img alt="Vulkan White Label" src="../../../../_/Vulkan_White_Dec16.svg" height="100%" />
      </div>
      <div class="navbar-item search hide-for-print">
        <div id="search-field" class="field">
          <label for="search-input"></label><input id="search-input" type="text" placeholder="Search the docs">
        </div>
      </div>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <!-- <a class="navbar-item" href="#">Home</a> -->
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Specs</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="../../../../spec/latest/chapters/introduction.html">Vulkan 1.3</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Guides</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="../../../../guide/latest/index.html">Vulkan Guide</a>
          </div>
        </div>
            <!--
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Tools</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">TBD</a>
          </div>
        </div>
            -->
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Tutorial</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="../../../../tutorial/latest/index.html">Vulkan Tutorial</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Samples</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="../../../../samples/latest/README.html">Vulkan Samples</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Help</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="https://discord.gg/vulkan">Vulkan Discord</a>
            <a class="navbar-item" href="https://khr.io/khrdiscord">Khronos Discord</a>
          </div>
        </div>
            <!--
        <div class="navbar-item">
          <span class="control">
            <a class="button is-primary" href="#">Download</a>
          </span>
        </div>
            -->
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="tutorial" data-version="latest">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../../00_Introduction.html">Khronos Vulkan Tutorial</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../00_Introduction.html">Introduction</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../01_Overview.html">Overview</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../02_Development_environment.html">Development environment</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../03_Drawing_a_triangle/00_Setup/00_Base_code.html">Drawing a triangle</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../03_Drawing_a_triangle/00_Setup/00_Base_code.html">Setup</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../03_Drawing_a_triangle/00_Setup/00_Base_code.html">Base Code</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../03_Drawing_a_triangle/00_Setup/01_Instance.html">Instance</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../03_Drawing_a_triangle/00_Setup/02_Validation_layers.html">Validation layers</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../03_Drawing_a_triangle/00_Setup/03_Physical_devices_and_queue_families.html">Physical devices and queue families</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../03_Drawing_a_triangle/00_Setup/04_Logical_device_and_queues.html">Logical device and queues</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../03_Drawing_a_triangle/01_Presentation/00_Window_surface.html">Presentation</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../03_Drawing_a_triangle/01_Presentation/00_Window_surface.html">Window surface</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../03_Drawing_a_triangle/01_Presentation/01_Swap_chain.html">Swap chain</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../03_Drawing_a_triangle/01_Presentation/02_Image_views.html">Image views</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../03_Drawing_a_triangle/02_Graphics_pipeline_basics/00_Introduction.html">Graphics pipeline basics</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../03_Drawing_a_triangle/02_Graphics_pipeline_basics/00_Introduction.html">Introduction</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../03_Drawing_a_triangle/02_Graphics_pipeline_basics/01_Shader_modules.html">Shader modules</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../03_Drawing_a_triangle/02_Graphics_pipeline_basics/02_Fixed_functions.html">Fixed functions</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../03_Drawing_a_triangle/02_Graphics_pipeline_basics/03_Render_passes.html">Render passes</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../03_Drawing_a_triangle/02_Graphics_pipeline_basics/04_Conclusion.html">Conclusion</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../03_Drawing_a_triangle/03_Drawing/00_Framebuffers.html">Drawing</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../03_Drawing_a_triangle/03_Drawing/00_Framebuffers.html">Framebuffers</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../03_Drawing_a_triangle/03_Drawing/01_Command_buffers.html">Command buffers</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../03_Drawing_a_triangle/03_Drawing/02_Rendering_and_presentation.html">Rendering and presentation</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../03_Drawing_a_triangle/03_Drawing/03_Frames_in_flight.html">Frames in flight</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../03_Drawing_a_triangle/04_Swap_chain_recreation.html">Swap chain recreation</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../04_Vertex_buffers/00_Vertex_input_description.html">Vertex buffers</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../04_Vertex_buffers/00_Vertex_input_description.html">Vertex input description</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../04_Vertex_buffers/01_Vertex_buffer_creation.html">Vertex buffer creation</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../04_Vertex_buffers/02_Staging_buffer.html">Staging buffer</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../04_Vertex_buffers/03_Index_buffer.html">Index buffer</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../05_Uniform_buffers/00_Descriptor_set_layout_and_buffer.html">Uniform buffers</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../05_Uniform_buffers/00_Descriptor_set_layout_and_buffer.html">Descriptor layout and buffer</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../05_Uniform_buffers/01_Descriptor_pool_and_sets.html">Descriptor pool and sets</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../06_Texture_mapping/00_Images.html">Texture mapping</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../06_Texture_mapping/00_Images.html">Images</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../06_Texture_mapping/01_Image_view_and_sampler.html">Image view and sampler</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../06_Texture_mapping/02_Combined_image_sampler.html">Combined image sampler</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../07_Depth_buffering.html">Depth buffering</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../08_Loading_models.html">Loading models</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../09_Generating_Mipmaps.html">Generating Mipmaps</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../10_Multisampling.html">Multisampling</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../11_Compute_Shader.html">Compute Shader</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../12_Ecosystem_Utilities_and_Compatibility.html">Ecosystem Utilities and GPU Compatibility</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../13_Vulkan_Profiles.html">Vulkan Profiles</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../14_Android.html">Android</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../15_GLTF_KTX2_Migration.html">Migrating to Modern Asset Formats: glTF and KTX2</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../16_Multiple_Objects.html">Rendering Multiple Objects</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../17_Multithreading.html">Multithreading</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../courses/18_Ray_tracing/00_Overview.html">Ray Tracing</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../courses/18_Ray_tracing/00_Overview.html">Overview</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../courses/18_Ray_tracing/01_Dynamic_rendering.html">Dynamic rendering</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../courses/18_Ray_tracing/02_Acceleration_structures.html">Acceleration structures</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../courses/18_Ray_tracing/03_Ray_query_shadows.html">Ray query shadows</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../courses/18_Ray_tracing/04_TLAS_animation.html">TLAS animation</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../courses/18_Ray_tracing/05_Shadow_transparency.html">Shadow transparency</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../courses/18_Ray_tracing/06_Reflections.html">Reflections</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../courses/18_Ray_tracing/07_Conclusion.html">Conclusion</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../90_FAQ.html">FAQ</a>
  </li>
  <li class="nav-item" data-depth="1">
    <span class="nav-text"><a href="https://github.com/KhronosGroup/Vulkan-Tutorial" target="_blank" rel="noopener">GitHub Repository</a></span>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Khronos Vulkan Tutorial</span>
    <span class="version">latest</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <a class="title" href="../../00_Introduction.html">Khronos Vulkan Tutorial</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../../00_Introduction.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../../../glsl/latest/index.html">OpenGL Shading Language Specification</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../glsl/latest/index.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../../../refpages/latest/refpages/index.html">Vulkan API Reference Pages</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../refpages/latest/refpages/index.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../../../features/latest/features/index.html">Vulkan Feature Descriptions</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../features/latest/features/index.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../../../guide/latest/index.html">Vulkan Guide</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../guide/latest/index.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../../../samples/latest/README.html">Vulkan Samples</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../samples/latest/README.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../../../spec/latest/index.html">Vulkan Specification</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../spec/latest/index.html">latest</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../../../../spec/latest/index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../../00_Introduction.html">Khronos Vulkan Tutorial</a></li>
    <li><a href="04_ui_elements.html">GUI: UI Elements and Integration Concepts</a></li>
  </ul>
</nav>
    <!--
    -->
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">GUI: UI Elements and Integration Concepts</h1>
<div class="sect1">
<h2 id="_ui_elements_and_integration_concepts"><a class="anchor" href="#_ui_elements_and_integration_concepts"></a>UI Elements and Integration Concepts</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Now that we have set up ImGui and implemented input handling, let&#8217;s explore the key concepts of integrating a GUI with your Vulkan application. We&#8217;ll focus on the integration aspects rather than exhaustive ImGui widget examples, as those are well-documented in the ImGui documentation.</p>
</div>
<div class="sect2">
<h3 id="_gui_integration_concepts"><a class="anchor" href="#_gui_integration_concepts"></a>GUI Integration Concepts</h3>
<div class="paragraph">
<p>When integrating a GUI into a 3D application, there are several important concepts to consider:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Separation of Concerns</strong>: Keep your GUI code separate from your rendering code to maintain clean architecture.</p>
</li>
<li>
<p><strong>Performance Impact</strong>: GUIs can impact performance, especially with complex layouts or frequent updates.</p>
</li>
<li>
<p><strong>Input Management</strong>: Properly handle input to ensure it&#8217;s routed to either the GUI or the 3D scene.</p>
</li>
<li>
<p><strong>Rendering Order</strong>: The GUI is typically rendered after the 3D scene, as an overlay.</p>
</li>
<li>
<p><strong>State Management</strong>: Use the GUI to modify application state in a controlled manner.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_basic_imgui_usage"><a class="anchor" href="#_basic_imgui_usage"></a>Basic ImGui Usage</h3>
<div class="paragraph">
<p>ImGui follows an immediate-mode paradigm, where the UI is recreated every frame. Here&#8217;s a simple example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">void drawGUI() {
    // Start a new ImGui frame
    ImGui::NewFrame();

    // Create a window
    ImGui::Begin("Settings");

    // Add UI elements here
    static bool enableFeature = false;
    if (ImGui::Checkbox("Enable Feature", &amp;enableFeature)) {
        // This code runs when the checkbox value changes
        updateFeatureState(enableFeature);
    }

    static float value = 0.5f;
    if (ImGui::SliderFloat("Parameter", &amp;value, 0.0f, 1.0f)) {
        // This code runs when the slider value changes
        updateParameter(value);
    }

    ImGui::End();

    // Render ImGui
    ImGui::Render();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>For a comprehensive guide to all available ImGui widgets and their options, please refer to the official ImGui documentation and demo:
<a href="https://github.com/ocornut/imgui/blob/master/imgui_demo.cpp" class="bare">https://github.com/ocornut/imgui/blob/master/imgui_demo.cpp</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_gui_design_considerations_for_vulkan_applications"><a class="anchor" href="#_gui_design_considerations_for_vulkan_applications"></a>GUI Design Considerations for Vulkan Applications</h3>
<div class="paragraph">
<p>When designing a GUI for your Vulkan application, consider these aspects:</p>
</div>
<div class="sect3">
<h4 id="_memory_management"><a class="anchor" href="#_memory_management"></a>Memory Management</h4>
<div class="paragraph">
<p>ImGui generates vertex and index buffers that need to be uploaded to the GPU. Ensure these resources are properly managed:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Buffer Sizing</strong>: Allocate buffers with sufficient size or implement resizing logic</p>
</li>
<li>
<p><strong>Memory Types</strong>: Use host-visible memory for frequent updates</p>
</li>
<li>
<p><strong>Synchronization</strong>: Ensure buffer updates are synchronized with rendering</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_command_buffer_integration"><a class="anchor" href="#_command_buffer_integration"></a>Command Buffer Integration</h4>
<div class="paragraph">
<p>Integrate ImGui rendering commands with your Vulkan command buffers:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">// Record commands for scene rendering
// ...

// Record ImGui rendering commands
imGuiUtil.drawFrame(commandBuffer);

// Submit command buffer
// ...</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_descriptor_resources"><a class="anchor" href="#_descriptor_resources"></a>Descriptor Resources</h4>
<div class="paragraph">
<p>ImGui requires descriptors for its font texture. Ensure your descriptor pool has sufficient capacity:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">// Create descriptor pool with enough capacity for ImGui
vk::DescriptorPoolSize poolSizes[] = {
    { vk::DescriptorType::eCombinedImageSampler, 50 },
    // Other descriptor types...
};

vk::DescriptorPoolCreateInfo poolInfo{};
poolInfo.flags = vk::DescriptorPoolCreateFlagBits::eFreeDescriptorSet;
poolInfo.maxSets = 50;
poolInfo.poolSizeCount = static_cast&lt;uint32_t&gt;(std::size(poolSizes));
poolInfo.pPoolSizes = poolSizes;

descriptorPool = device.createDescriptorPool(poolInfo);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_performance_considerations"><a class="anchor" href="#_performance_considerations"></a>Performance Considerations</h3>
<div class="paragraph">
<p>When integrating ImGui with Vulkan, consider these performance aspects:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Command Buffer Recording</strong>: Record ImGui commands efficiently, ideally once per frame</p>
</li>
<li>
<p><strong>Descriptor Management</strong>: Minimize descriptor set allocations and updates</p>
</li>
<li>
<p><strong>Buffer Updates</strong>: Optimize vertex and index buffer updates</p>
</li>
<li>
<p><strong>Pipeline State</strong>: Use a dedicated pipeline for ImGui to minimize state changes</p>
</li>
<li>
<p><strong>Render Pass Integration</strong>: Consider whether to use a separate render pass or subpass for the GUI</p>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="_frames_in_flight_duplicate_dynamic_buffers_per_frame"><a class="anchor" href="#_frames_in_flight_duplicate_dynamic_buffers_per_frame"></a>Frames-in-Flight: Duplicate Dynamic Buffers Per Frame</h4>
<div class="paragraph">
<p>If your renderer uses multiple frames in flight (e.g., double/triple buffering) without a device wait-idle between frames, ImGui&#8217;s dynamic vertex and index buffers must not be shared across frames. Otherwise, the CPU can overwrite data that the GPU from a previous frame is still reading.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Allocate one vertex buffer and one index buffer per frame-in-flight.</p>
</li>
<li>
<p>Update/bind the buffers for the current frame index only.</p>
</li>
<li>
<p>Size each buffer to the frame&#8217;s ImDrawData TotalVtxCount/TotalIdxCount, growing as needed.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Example sketch:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">class ImGuiSystem {
  // ...
  std::vector&lt;vk::raii::Buffer&gt; vertexBuffers;
  std::vector&lt;vk::raii::DeviceMemory&gt; vertexMemories;
  std::vector&lt;vk::raii::Buffer&gt; indexBuffers;
  std::vector&lt;vk::raii::DeviceMemory&gt; indexMemories;
  std::vector&lt;uint32_t&gt; vertexCounts;
  std::vector&lt;uint32_t&gt; indexCounts;

  bool Initialize(Renderer* renderer, uint32_t w, uint32_t h) {
    // ... create pipelines, font, descriptors ...
    const uint32_t frames = renderer-&gt;GetMaxFramesInFlight();
    vertexBuffers.resize(frames);
    vertexMemories.resize(frames);
    indexBuffers.resize(frames);
    indexMemories.resize(frames);
    vertexCounts.assign(frames, 0);
    indexCounts.assign(frames, 0);
    return true;
  }

  void Render(vk::raii::CommandBuffer&amp; cmd, uint32_t frameIndex) {
    ImGui::Render();
    updateBuffers(frameIndex);
    // bind per-frame buffers
    std::array vb = {*vertexBuffers[frameIndex]};
    std::array&lt;vk::DeviceSize,1&gt; offs{};
    cmd.bindVertexBuffers(0, vb, offs);
    cmd.bindIndexBuffer(*indexBuffers[frameIndex], 0, vk::IndexType::eUint16);
    // draw lists...
  }

  void updateBuffers(uint32_t frameIndex) {
    ImDrawData* dd = ImGui::GetDrawData();
    if (!dd || dd-&gt;CmdListsCount == 0) return;
    vk::DeviceSize vbytes = dd-&gt;TotalVtxCount * sizeof(ImDrawVert);
    vk::DeviceSize ibytes = dd-&gt;TotalIdxCount * sizeof(ImDrawIdx);
    // grow-per-frame if needed, then map/copy for this frame only
    // ...
  }
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>When integrating with your main renderer, pass the current frame index to the ImGui render call:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">// inside your frame loop after scene rendering
imguiSystem-&gt;Render(commandBuffers[currentFrame], currentFrame);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_organizing_your_gui_code"><a class="anchor" href="#_organizing_your_gui_code"></a>Organizing Your GUI Code</h3>
<div class="paragraph">
<p>For maintainable GUI code, consider these organizational patterns:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Component-Based Approach</strong>: Split your GUI into logical components</p>
</li>
<li>
<p><strong>State Management</strong>: Use a centralized state store that the GUI can modify</p>
</li>
<li>
<p><strong>Event System</strong>: Implement an event system for GUI-triggered actions</p>
</li>
<li>
<p><strong>Lazy Updates</strong>: Only update Vulkan resources when GUI settings actually change</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">// Component-based approach example
class VulkanGUI {
private:
    // GUI state
    struct {
        bool showRenderSettings = true;
        bool showPerformance = true;
        bool showSceneControls = true;
    } state;

    // Components
    void drawRenderSettingsPanel();
    void drawPerformancePanel();
    void drawSceneControlsPanel();

public:
    void draw() {
        // Start a new ImGui frame
        ImGui::NewFrame();

        // Draw components based on state
        if (state.showRenderSettings) drawRenderSettingsPanel();
        if (state.showPerformance) drawPerformancePanel();
        if (state.showSceneControls) drawSceneControlsPanel();

        // Main menu for toggling panels
        if (ImGui::BeginMainMenuBar()) {
            if (ImGui::BeginMenu("View")) {
                ImGui::MenuItem("Render Settings", nullptr, &amp;state.showRenderSettings);
                ImGui::MenuItem("Performance", nullptr, &amp;state.showPerformance);
                ImGui::MenuItem("Scene Controls", nullptr, &amp;state.showSceneControls);
                ImGui::EndMenu();
            }
            ImGui::EndMainMenuBar();
        }

        // Render ImGui
        ImGui::Render();
    }
};</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_displaying_textures_in_imgui"><a class="anchor" href="#_displaying_textures_in_imgui"></a>Displaying Textures in ImGui</h3>
<div class="paragraph">
<p>A common requirement in GUI systems is displaying textures, such as rendered scenes, material previews, or icons. ImGui provides the ability to display textures through its <code>ImGui::Image</code> and <code>ImGui::ImageButton</code> functions. To use these with Vulkan, you need to properly set up descriptor sets for your textures.</p>
</div>
<div class="sect3">
<h4 id="_setting_up_texture_descriptors"><a class="anchor" href="#_setting_up_texture_descriptors"></a>Setting Up Texture Descriptors</h4>
<div class="paragraph">
<p>To display a Vulkan texture in ImGui, you need to:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Create a descriptor set layout for the texture</p>
</li>
<li>
<p>Allocate a descriptor set</p>
</li>
<li>
<p>Update the descriptor set with your texture&#8217;s image view and sampler</p>
</li>
<li>
<p>Pass the descriptor set handle to ImGui</p>
</li>
</ol>
</div>
<div class="sect4">
<h5 id="_create_the_descriptor_set_layout"><a class="anchor" href="#_create_the_descriptor_set_layout"></a>Create the descriptor set layout</h5>
<div class="paragraph">
<p>This layout declares a single combined image sampler the shader can sample from when ImGui draws the quad.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">// Create a descriptor set layout for textures
vk::DescriptorSetLayoutBinding binding{};
binding.descriptorType = vk::DescriptorType::eCombinedImageSampler;
binding.descriptorCount = 1;
binding.stageFlags = vk::ShaderStageFlagBits::eFragment;
binding.binding = 0;

vk::DescriptorSetLayoutCreateInfo layoutInfo{};
layoutInfo.bindingCount = 1;
layoutInfo.pBindings = &amp;binding;

vk::raii::DescriptorSetLayout textureSetLayout = device.createDescriptorSetLayout(layoutInfo);</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_allocate_a_descriptor_set"><a class="anchor" href="#_allocate_a_descriptor_set"></a>Allocate a descriptor set</h5>
<div class="paragraph">
<p>Allocate one set per texture you want to show in ImGui.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">// Allocate a descriptor set for each texture
vk::DescriptorSetAllocateInfo allocInfo{};
allocInfo.descriptorPool = *descriptorPool;
allocInfo.descriptorSetCount = 1;
vk::DescriptorSetLayout layouts[] = {*textureSetLayout};
allocInfo.pSetLayouts = layouts;

vk::raii::DescriptorSet textureDescriptorSet = std::move(device.allocateDescriptorSets(allocInfo).front());</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_update_the_descriptor_set"><a class="anchor" href="#_update_the_descriptor_set"></a>Update the descriptor set</h5>
<div class="paragraph">
<p>Point the descriptor at your image view and sampler in shaderâ€‘read layout.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">// Update the descriptor set with your texture
vk::DescriptorImageInfo imageInfo{};
imageInfo.imageLayout = vk::ImageLayout::eShaderReadOnlyOptimal;
imageInfo.imageView = textureImageView.getHandle();
imageInfo.sampler = *textureSampler;

vk::WriteDescriptorSet writeSet{};
writeSet.dstSet = *textureDescriptorSet;
writeSet.descriptorCount = 1;
writeSet.descriptorType = vk::DescriptorType::eCombinedImageSampler;
writeSet.pImageInfo = &amp;imageInfo;
writeSet.dstBinding = 0;

device.updateDescriptorSets(1, &amp;writeSet, 0, nullptr);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_use_it_in_imgui"><a class="anchor" href="#_use_it_in_imgui"></a>Use it in ImGui</h4>
<div class="paragraph">
<p>Once you have set up the descriptor set, you can use it with ImGui&#8217;s image functions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">// Store the descriptor set as ImTextureID (which is just a void*)
ImTextureID textureId = (ImTextureID)(VkDescriptorSet)*textureDescriptorSet;

// Display the texture in ImGui
ImGui::Begin("Texture Viewer");

// Display as a simple image
ImGui::Image(textureId, ImVec2(width, height));

// Or as an image button
if (ImGui::ImageButton(textureId, ImVec2(width, height))) {
    // Handle button click
}

// You can also apply tinting and modify UV coordinates
ImGui::Image(textureId, ImVec2(width, height),
             ImVec2(0, 0), ImVec2(1, 1),  // UV coordinates (0,0) to (1,1) for the full texture
             ImVec4(1, 1, 1, 1),          // Tint color (white = no tint)
             ImVec4(1, 1, 1, 0.5));       // Border color

ImGui::End();</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_complete_example_texture_manager_for_imgui"><a class="anchor" href="#_complete_example_texture_manager_for_imgui"></a>Complete Example: Texture Manager for ImGui</h4>
<div class="paragraph">
<p>Here&#8217;s a more complete example of a texture manager class that handles multiple textures for ImGui:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">class ImGuiTextureManager {
private:
    vk::raii::Device* device = nullptr;
    vk::raii::DescriptorPool* descriptorPool = nullptr;
    vk::raii::DescriptorSetLayout descriptorSetLayout{nullptr};

    struct TextureInfo {
        vk::raii::DescriptorSet descriptorSet{nullptr};
        uint32_t width;
        uint32_t height;
    };

    std::unordered_map&lt;std::string, TextureInfo&gt; textures;

public:
    ImGuiTextureManager(vk::raii::Device&amp; device, vk::raii::DescriptorPool&amp; descriptorPool)
        : device(&amp;device), descriptorPool(&amp;descriptorPool) {

        // Create descriptor set layout for textures
        vk::DescriptorSetLayoutBinding binding{};
        binding.descriptorType = vk::DescriptorType::eCombinedImageSampler;
        binding.descriptorCount = 1;
        binding.stageFlags = vk::ShaderStageFlagBits::eFragment;
        binding.binding = 0;

        vk::DescriptorSetLayoutCreateInfo layoutInfo{};
        layoutInfo.bindingCount = 1;
        layoutInfo.pBindings = &amp;binding;

        descriptorSetLayout = device.createDescriptorSetLayout(layoutInfo);
    }

    // Register a texture for use with ImGui
    ImTextureID registerTexture(const std::string&amp; name, vk::ImageView imageView,
                               vk::Sampler sampler, uint32_t width, uint32_t height) {

        // Allocate descriptor set
        vk::DescriptorSetAllocateInfo allocInfo{};
        allocInfo.descriptorPool = **descriptorPool;
        allocInfo.descriptorSetCount = 1;
        vk::DescriptorSetLayout layouts[] = {*descriptorSetLayout};
        allocInfo.pSetLayouts = layouts;

        vk::raii::DescriptorSet descriptorSet = std::move(device-&gt;allocateDescriptorSets(allocInfo).front());

        // Update descriptor set
        vk::DescriptorImageInfo imageInfo{};
        imageInfo.imageLayout = vk::ImageLayout::eShaderReadOnlyOptimal;
        imageInfo.imageView = imageView;
        imageInfo.sampler = sampler;

        vk::WriteDescriptorSet writeSet{};
        writeSet.dstSet = *descriptorSet;
        writeSet.descriptorCount = 1;
        writeSet.descriptorType = vk::DescriptorType::eCombinedImageSampler;
        writeSet.pImageInfo = &amp;imageInfo;
        writeSet.dstBinding = 0;

        device-&gt;updateDescriptorSets(1, &amp;writeSet, 0, nullptr);

        // Store texture info
        textures[name] = {std::move(descriptorSet), width, height};

        // Return the descriptor set as ImTextureID
        return (ImTextureID)(VkDescriptorSet)*textures[name].descriptorSet;
    }

    // Get a previously registered texture
    ImTextureID getTexture(const std::string&amp; name) {
        if (textures.find(name) == textures.end()) {
            throw std::runtime_error("Texture not found: " + name);
        }

        return (ImTextureID)(VkDescriptorSet)*textures[name].descriptorSet;
    }

    // Get texture dimensions
    ImVec2 getTextureDimensions(const std::string&amp; name) {
        if (textures.find(name) == textures.end()) {
            throw std::runtime_error("Texture not found: " + name);
        }

        return ImVec2(static_cast&lt;float&gt;(textures[name].width),
                     static_cast&lt;float&gt;(textures[name].height));
    }
};</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_usage_example"><a class="anchor" href="#_usage_example"></a>Usage Example</h4>
<div class="paragraph">
<p>Here&#8217;s how you might use the texture manager in your application:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">// During initialization
ImGuiTextureManager textureManager(device, descriptorPool);

// Register textures (e.g., after loading a model or rendering to a texture)
ImTextureID albedoTexId = textureManager.registerTexture(
    "albedo",
    albedoImageView,
    textureSampler,
    albedoWidth,
    albedoHeight
);

ImTextureID normalMapId = textureManager.registerTexture(
    "normalMap",
    normalMapImageView,
    textureSampler,
    normalMapWidth,
    normalMapHeight
);

// In your GUI rendering code
void drawMaterialEditor() {
    ImGui::Begin("Material Editor");

    // Display textures
    ImGui::Text("Albedo Texture:");
    ImGui::Image(textureManager.getTexture("albedo"),
                ImVec2(200, 200));

    ImGui::Text("Normal Map:");
    ImGui::Image(textureManager.getTexture("normalMap"),
                ImVec2(200, 200));

    // Material properties
    static float roughness = 0.5f;
    if (ImGui::SliderFloat("Roughness", &amp;roughness, 0.0f, 1.0f)) {
        updateMaterialProperty("roughness", roughness);
    }

    static float metallic = 0.0f;
    if (ImGui::SliderFloat("Metallic", &amp;metallic, 0.0f, 1.0f)) {
        updateMaterialProperty("metallic", metallic);
    }

    ImGui::End();
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_performance_considerations_2"><a class="anchor" href="#_performance_considerations_2"></a>Performance Considerations</h4>
<div class="paragraph">
<p>When working with textures in ImGui, keep these performance considerations in mind:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Descriptor Management</strong>: Create descriptor sets for textures only when needed and reuse them</p>
</li>
<li>
<p><strong>Texture Size</strong>: Consider using smaller preview versions of textures for the UI</p>
</li>
<li>
<p><strong>Mipmap Selection</strong>: For large textures, ensure proper mipmap selection to avoid aliasing</p>
</li>
<li>
<p><strong>Texture Updates</strong>: If a texture changes frequently, use a staging buffer for updates</p>
</li>
<li>
<p><strong>Texture Atlas</strong>: For many small textures (like icons), consider using a texture atlas</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>By properly managing textures in your ImGui integration, you can create rich interfaces that display rendered content, material previews, and other visual elements directly in your GUI.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_object_picking_interacting_with_the_3d_scene"><a class="anchor" href="#_object_picking_interacting_with_the_3d_scene"></a>Object Picking: Interacting with the 3D Scene</h3>
<div class="paragraph">
<p>An important aspect of GUI integration is handling object picking - selecting 3D objects with the mouse. This requires coordination between ImGui and your 3D scene:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">void handleMouseInput(float mouseX, float mouseY) {
    // First, check if ImGui is using this input
    ImGuiIO&amp; io = ImGui::GetIO();
    if (io.WantCaptureMouse) {
        // ImGui is using the mouse, don't use it for 3D picking
        return;
    }

    // ImGui isn't using the mouse, so we can use it for 3D picking
    pickObject(mouseX, mouseY);
}

void pickObject(float mouseX, float mouseY) {
    // Convert screen coordinates to normalized device coordinates
    float ndcX = (2.0f * mouseX) / windowWidth - 1.0f;
    float ndcY = 1.0f - (2.0f * mouseY) / windowHeight;

    // Create a ray from the camera through the mouse position
    glm::vec4 clipCoords(ndcX, ndcY, -1.0f, 1.0f);
    glm::vec4 eyeCoords = glm::inverse(projectionMatrix) * clipCoords;
    eyeCoords = glm::vec4(eyeCoords.x, eyeCoords.y, -1.0f, 0.0f);

    glm::vec3 rayDirection = glm::normalize(glm::vec3(
        glm::inverse(viewMatrix) * eyeCoords
    ));

    glm::vec3 rayOrigin = camera.getPosition();

    // Test for intersections with scene objects
    float closestHit = std::numeric_limits&lt;float&gt;::max();
    int hitObjectId = -1;

    for (size_t i = 0; i &lt; sceneObjects.size(); i++) {
        float hitDistance;
        if (rayIntersectsObject(rayOrigin, rayDirection, sceneObjects[i], hitDistance)) {
            if (hitDistance &lt; closestHit) {
                closestHit = hitDistance;
                hitObjectId = static_cast&lt;int&gt;(i);
            }
        }
    }

    // If we hit an object, select it
    if (hitObjectId &gt;= 0) {
        selectObject(hitObjectId);
    }
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_implementing_ray_object_intersection"><a class="anchor" href="#_implementing_ray_object_intersection"></a>Implementing Ray-Object Intersection</h4>
<div class="paragraph">
<p>For object picking to work, you need to implement ray-object intersection tests. Here&#8217;s a simple example for sphere intersection:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">bool rayIntersectsSphere(
    const glm::vec3&amp; rayOrigin,
    const glm::vec3&amp; rayDirection,
    const glm::vec3&amp; sphereCenter,
    float sphereRadius,
    float&amp; outDistance
) {
    glm::vec3 oc = rayOrigin - sphereCenter;
    float a = glm::dot(rayDirection, rayDirection);
    float b = 2.0f * glm::dot(oc, rayDirection);
    float c = glm::dot(oc, oc) - sphereRadius * sphereRadius;
    float discriminant = b * b - 4 * a * c;

    if (discriminant &lt; 0) {
        return false; // No intersection
    }

    // Calculate the closest intersection point
    float t = (-b - sqrt(discriminant)) / (2.0f * a);
    if (t &lt; 0) {
        // Try the other intersection point
        t = (-b + sqrt(discriminant)) / (2.0f * a);
        if (t &lt; 0) {
            return false; // Both intersection points are behind the ray
        }
    }

    outDistance = t;
    return true;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_visualizing_selected_objects"><a class="anchor" href="#_visualizing_selected_objects"></a>Visualizing Selected Objects</h4>
<div class="paragraph">
<p>Once an object is selected, you can visualize the selection:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">void drawScene(vk::raii::CommandBuffer&amp; commandBuffer) {
    // Draw all objects
    for (size_t i = 0; i &lt; sceneObjects.size(); i++) {
        // If this object is selected, use a different pipeline
        if (static_cast&lt;int&gt;(i) == selectedObjectId) {
            commandBuffer.bindPipeline(vk::PipelineBindPoint::eGraphics, *highlightPipeline);
        } else {
            commandBuffer.bindPipeline(vk::PipelineBindPoint::eGraphics, *standardPipeline);
        }

        // Draw the object
        drawObject(commandBuffer, sceneObjects[i]);
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_integrating_picking_with_imgui"><a class="anchor" href="#_integrating_picking_with_imgui"></a>Integrating Picking with ImGui</h4>
<div class="paragraph">
<p>You can also display information about the selected object in the GUI:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">void drawObjectPropertiesPanel() {
    if (selectedObjectId &lt; 0) {
        return; // No object selected
    }

    ImGui::Begin("Object Properties");

    SceneObject&amp; obj = sceneObjects[selectedObjectId];

    // Display object properties
    ImGui::Text("Object ID: %d", selectedObjectId);
    ImGui::Text("Name: %s", obj.name.c_str());

    // Edit object properties
    glm::vec3 position = obj.position;
    if (ImGui::DragFloat3("Position", &amp;position[0], 0.1f)) {
        obj.position = position;
        updateObjectTransform(selectedObjectId);
    }

    glm::vec3 rotation = obj.rotation;
    if (ImGui::DragFloat3("Rotation", &amp;rotation[0], 1.0f, -180.0f, 180.0f)) {
        obj.rotation = rotation;
        updateObjectTransform(selectedObjectId);
    }

    glm::vec3 scale = obj.scale;
    if (ImGui::DragFloat3("Scale", &amp;scale[0], 0.1f, 0.1f, 10.0f)) {
        obj.scale = scale;
        updateObjectTransform(selectedObjectId);
    }

    ImGui::End();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Object picking creates a powerful interaction model where users can select and manipulate 3D objects directly, while using the GUI to fine-tune properties. This combination of direct manipulation and precise control provides an intuitive user experience.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_balancing_gui_and_3d_interaction"><a class="anchor" href="#_balancing_gui_and_3d_interaction"></a>Balancing GUI and 3D Interaction</h3>
<div class="paragraph">
<p>When designing your application, consider how to balance GUI-based controls with direct 3D interaction:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Use GUI for</strong>:</p>
<div class="ulist">
<ul>
<li>
<p>Precise numerical inputs</p>
</li>
<li>
<p>Complex settings with many options</p>
</li>
<li>
<p>Hierarchical data visualization</p>
</li>
<li>
<p>Application-wide controls</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Use 3D Interaction for</strong>:</p>
<div class="ulist">
<ul>
<li>
<p>Object placement and movement</p>
</li>
<li>
<p>Camera navigation</p>
</li>
<li>
<p>Direct manipulation of scene elements</p>
</li>
<li>
<p>Intuitive spatial operations</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Hybrid Approaches</strong>:</p>
<div class="ulist">
<ul>
<li>
<p>Gizmos for 3D transformation with precise control</p>
</li>
<li>
<p>Context menus that appear near selected objects</p>
</li>
<li>
<p>Property panels that update based on selection</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>By thoughtfully integrating ImGui with your Vulkan application and implementing object picking, you can create a powerful and intuitive user interface that combines the strengths of both 2D GUI controls and direct 3D interaction.</p>
</div>
<div class="paragraph">
<p>In the next section, we&#8217;ll explore more details about integrating the GUI rendering with the Vulkan rendering pipeline.</p>
</div>
<div class="paragraph">
<p><a href="03_input_handling.adoc">Previous: Input Handling</a> | <a href="05_vulkan_integration.adoc">Next: Vulkan Integration</a></p>
</div>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer">
    <!--
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
    -->
</footer>
<script id="site-script" src="../../../../_/js/site.js" data-ui-root-path="../../../../_"></script>
<script async src="../../../../_/js/vendor/highlight.js"></script>
<script src="../../../../_/js/vendor/lunr.js" defer></script>
<script src="https://cdn.jsdelivr.net/pako/1.0.3/pako.min.js" defer></script>
<script src="../../../../_/js/search-ui.js" id="search-ui-script" data-site-root-path="../../../.." data-snippet-length="100" data-stylesheet="../../../../_/css/search.css" defer></script>
<script>
window.addEventListener('DOMContentLoaded', function(){
  try {
    var script = document.getElementById('search-ui-script');
    var siteRoot = (script && script.getAttribute('data-site-root-path')) || '';
    var manifestUrl = siteRoot + '/search-index/manifest.json';
    fetch(manifestUrl)
      .then(function (r) { return r.ok ? r.json() : Promise.reject(new Error('manifest not found')) })
      .then(function (manifest) { antoraSearch.bootstrap(lunr, manifest, siteRoot); })
      .catch(function () {
        var s = document.createElement('script');
        s.async = true;
        s.src = siteRoot + '/search-index.js';
        document.head.appendChild(s);
      });
  } catch (e) {
    // Fallback to monolithic index if anything goes wrong
    var s = document.createElement('script');
    s.async = true;
    s.src = '../../../../search-index.js';
    document.head.appendChild(s);
  }
});
</script>
  </body>
</html>

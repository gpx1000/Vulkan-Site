<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>GUI: Vulkan Integration :: Vulkan Documentation Project</title>
    <meta name="generator" content="Antora 3.1.10">
    <script>
      !function (theme) {
        if (theme === 'dark') document.documentElement.classList.add('dark')
        else document.documentElement.classList.add('light')
      }(localStorage && localStorage.getItem('theme') || (matchMedia('(prefers-color-scheme: dark)')?.matches && 'dark'))
    </script>
    <link rel="stylesheet" href="../../../../_/css/site.css">
    <link rel="stylesheet" href="../../../../_/css/vendor/tabs.css">
    <link rel="apple-touch-icon" sizes="180x180" href="../../../../_/img/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../../../../_/img/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../../../../_/img/favicon-16x16.png">
    <link rel="manifest" href="../../../../_/site.webmanifest">
    <link rel="mask-icon" href="../../../../_/img/safari-pinned-tab.svg" color="#a41e22">
    <meta name="msapplication-TileColor" content="#ffc40d">
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="../../../.."><img class="navbar-item" alt="Vulkan White Label" src="../../../../_/Vulkan_Docs.svg" /></a>
      <div class="navbar-item search hide-for-print">
        <div id="search-field" class="field has-filter">
          <label for="search-input"></label>
          <input id="search-input" type="text" placeholder="Search the docs">
          <label class="filter checkbox">
            <input type="checkbox" data-facet-filter="component:tutorial" checked> In this component
          </label>
        </div>
      </div>
      <button class="navbar-burger" aria-controls="topbar-nav" aria-expanded="false" aria-label="Toggle main menu">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <!-- <a class="navbar-item" href="#">Home</a> -->
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Specs</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="../../../../spec/latest/chapters/introduction.html">Vulkan API</a>
            <a class="navbar-item" href="../../../../glsl/latest/index.html">GLSL</a>
            <a class="navbar-item" href="../../../../guide/latest/hlsl.html">HLSL</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Education</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="../../../../refpages/latest/refpages/index.html">Vulkan Reference Pages</a>
            <a class="navbar-item" href="../../../../features/latest/features/index.html">Vulkan Feature Descriptions</a>
            <a class="navbar-item" href="../../../../guide/latest/index.html">Vulkan Guide</a>
            <a class="navbar-item" href="../../../../samples/latest/README.html">Vulkan Samples</a>
            <a class="navbar-item" href="../../../../tutorial/latest/index.html">Vulkan Tutorial</a>
            <a class="navbar-item" href="https://www.youtube.com/c/vulkan">YouTube</a>
            <a class="navbar-item" href="https://vulkan.org">More Info at Vulkan.org</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Feedback</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="https://github.com/KhronosGroup/Vulkan-Site/issues/new/choose" target="_blank">Report a Problem</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Community</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="https://discord.gg/vulkan">Vulkan Discord</a>
            <a class="navbar-item" href="https://reddit.com/r/vulkan">Reddit</a>
            <a class="navbar-item" href="https://stackoverflow.com/questions/tagged/vulkan">Stack Overflow</a>
            <a class="navbar-item" href="https://fosstodon.org/@vulkan">Mastodon</a>
          </div>
        </div>
      </div>
    </div>
    <label class="theme-toggler">
      <input type="checkbox" id="switch-theme-checkbox" name="switch-theme-checkbox"/>
      <span class="icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="moon" class="svg-inline--fa fa-moon moon" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><path fill="currentColor" d="M223.5 32C100 32 0 132.3 0 256S100 480 223.5 480c60.6 0 115.5-24.2 155.8-63.4c5-4.9 6.3-12.5 3.1-18.7s-10.1-9.7-17-8.5c-9.8 1.7-19.8 2.6-30.1 2.6c-96.9 0-175.5-78.8-175.5-176c0-65.8 36-123.1 89.3-153.3c6.1-3.5 9.2-10.5 7.7-17.3s-7.3-11.9-14.3-12.5c-6.3-.5-12.6-.8-19-.8z"></path>
        </svg>
        <svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="sun" class="svg-inline--fa fa-sun sun" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M361.5 1.2c5 2.1 8.6 6.6 9.6 11.9L391 121l107.9 19.8c5.3 1 9.8 4.6 11.9 9.6s1.5 10.7-1.6 15.2L446.9 256l62.3 90.3c3.1 4.5 3.7 10.2 1.6 15.2s-6.6 8.6-11.9 9.6L391 391 371.1 498.9c-1 5.3-4.6 9.8-9.6 11.9s-10.7 1.5-15.2-1.6L256 446.9l-90.3 62.3c-4.5 3.1-10.2 3.7-15.2 1.6s-8.6-6.6-9.6-11.9L121 391 13.1 371.1c-5.3-1-9.8-4.6-11.9-9.6s-1.5-10.7 1.6-15.2L65.1 256 2.8 165.7c-3.1-4.5-3.7-10.2-1.6-15.2s6.6-8.6 11.9-9.6L121 121 140.9 13.1c1-5.3 4.6-9.8 9.6-11.9s10.7-1.5 15.2 1.6L256 65.1 346.3 2.8c4.5-3.1 10.2-3.7 15.2-1.6zM160 256a96 96 0 1 1 192 0 96 96 0 1 1 -192 0zm224 0a128 128 0 1 0 -256 0 128 128 0 1 0 256 0z"></path>
        </svg></span>
    </label>
  </nav>
</header>
<script>
  window.onload = function() {
    let e = document.getElementById("switch-theme-checkbox")
    e.checked = document.documentElement.classList.contains("dark");
    e.checked ? e.parentElement.classList.add("active") : e.parentElement.classList.remove("active")
  }
  !function() {
    let e = document.getElementById("switch-theme-checkbox")
    e.checked = document.documentElement.classList.contains("dark")
    e.addEventListener("change", function() {
      if (document.documentElement.classList.contains("light")) {
        document.documentElement.classList.remove("light")
        document.documentElement.classList.add("dark")
      } else if (document.documentElement.classList.contains("dark")) {
        document.documentElement.classList.remove("dark")
        document.documentElement.classList.add("light")
      } else {
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
          document.documentElement.classList.add("dark")
        } else {
          document.documentElement.classList.add("light")
        }
      }
      document.documentElement.setAttribute("data-theme", this.checked ? "dark" : "light"),
        function(e) {
          window.localStorage && window.localStorage.setItem("theme", e)
        }(this.checked ? "dark" : "light"), this.checked ? this.parentElement.classList.add("active") : this.parentElement.classList.remove("active")
    }.bind(e))
  }();
</script>
<div class="body">
<div class="nav-container" data-component="tutorial" data-version="latest" id="split-0">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <button class="nav-menu-toggle" aria-label="Toggle expand/collapse all" style="display: none"></button>
    <h3 class="title"><a href="../../00_Introduction.html">Khronos Vulkan Tutorial</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../00_Introduction.html">Introduction</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../01_Overview.html">Overview</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../02_Development_environment.html">Development environment</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../03_Drawing_a_triangle/00_Setup/00_Base_code.html">Drawing a triangle</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../03_Drawing_a_triangle/00_Setup/00_Base_code.html">Setup</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../03_Drawing_a_triangle/00_Setup/00_Base_code.html">Base Code</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../03_Drawing_a_triangle/00_Setup/01_Instance.html">Instance</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../03_Drawing_a_triangle/00_Setup/02_Validation_layers.html">Validation layers</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../03_Drawing_a_triangle/00_Setup/03_Physical_devices_and_queue_families.html">Physical devices and queue families</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../03_Drawing_a_triangle/00_Setup/04_Logical_device_and_queues.html">Logical device and queues</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../03_Drawing_a_triangle/01_Presentation/00_Window_surface.html">Presentation</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../03_Drawing_a_triangle/01_Presentation/00_Window_surface.html">Window surface</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../03_Drawing_a_triangle/01_Presentation/01_Swap_chain.html">Swap chain</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../03_Drawing_a_triangle/01_Presentation/02_Image_views.html">Image views</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../03_Drawing_a_triangle/02_Graphics_pipeline_basics/00_Introduction.html">Graphics pipeline basics</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../03_Drawing_a_triangle/02_Graphics_pipeline_basics/00_Introduction.html">Introduction</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../03_Drawing_a_triangle/02_Graphics_pipeline_basics/01_Shader_modules.html">Shader modules</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../03_Drawing_a_triangle/02_Graphics_pipeline_basics/02_Fixed_functions.html">Fixed functions</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../03_Drawing_a_triangle/02_Graphics_pipeline_basics/03_Render_passes.html">Render passes</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../03_Drawing_a_triangle/02_Graphics_pipeline_basics/04_Conclusion.html">Conclusion</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../03_Drawing_a_triangle/03_Drawing/00_Framebuffers.html">Drawing</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../03_Drawing_a_triangle/03_Drawing/00_Framebuffers.html">Framebuffers</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../03_Drawing_a_triangle/03_Drawing/01_Command_buffers.html">Command buffers</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../03_Drawing_a_triangle/03_Drawing/02_Rendering_and_presentation.html">Rendering and presentation</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../03_Drawing_a_triangle/03_Drawing/03_Frames_in_flight.html">Frames in flight</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../03_Drawing_a_triangle/04_Swap_chain_recreation.html">Swap chain recreation</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../04_Vertex_buffers/00_Vertex_input_description.html">Vertex buffers</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../04_Vertex_buffers/00_Vertex_input_description.html">Vertex input description</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../04_Vertex_buffers/01_Vertex_buffer_creation.html">Vertex buffer creation</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../04_Vertex_buffers/02_Staging_buffer.html">Staging buffer</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../04_Vertex_buffers/03_Index_buffer.html">Index buffer</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../05_Uniform_buffers/00_Descriptor_set_layout_and_buffer.html">Uniform buffers</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../05_Uniform_buffers/00_Descriptor_set_layout_and_buffer.html">Descriptor layout and buffer</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../05_Uniform_buffers/01_Descriptor_pool_and_sets.html">Descriptor pool and sets</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../06_Texture_mapping/00_Images.html">Texture mapping</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../06_Texture_mapping/00_Images.html">Images</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../06_Texture_mapping/01_Image_view_and_sampler.html">Image view and sampler</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../06_Texture_mapping/02_Combined_image_sampler.html">Combined image sampler</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../07_Depth_buffering.html">Depth buffering</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../08_Loading_models.html">Loading models</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../09_Generating_Mipmaps.html">Generating Mipmaps</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../10_Multisampling.html">Multisampling</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../11_Compute_Shader.html">Compute Shader</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../12_Ecosystem_Utilities_and_Compatibility.html">Ecosystem Utilities and GPU Compatibility</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../13_Vulkan_Profiles.html">Vulkan Profiles</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../14_Android.html">Android</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../15_GLTF_KTX2_Migration.html">Migrating to Modern Asset Formats: glTF and KTX2</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../16_Multiple_Objects.html">Rendering Multiple Objects</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../17_Multithreading.html">Multithreading</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../courses/18_Ray_tracing/00_Overview.html">Ray Tracing</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../courses/18_Ray_tracing/00_Overview.html">Overview</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../courses/18_Ray_tracing/01_Dynamic_rendering.html">Dynamic rendering</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../courses/18_Ray_tracing/02_Acceleration_structures.html">Acceleration structures</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../courses/18_Ray_tracing/03_Ray_query_shadows.html">Ray query shadows</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../courses/18_Ray_tracing/04_TLAS_animation.html">TLAS animation</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../courses/18_Ray_tracing/05_Shadow_transparency.html">Shadow transparency</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../courses/18_Ray_tracing/06_Reflections.html">Reflections</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../courses/18_Ray_tracing/07_Conclusion.html">Conclusion</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../90_FAQ.html">FAQ</a>
  </li>
  <li class="nav-item" data-depth="1">
    <span class="nav-text"><a href="https://github.com/KhronosGroup/Vulkan-Tutorial" target="_blank" rel="noopener">GitHub Repository</a></span>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Khronos Vulkan Tutorial</span>
    <span class="version">latest</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <div class="title"><a href="../../00_Introduction.html">Khronos Vulkan Tutorial</a></div>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../../00_Introduction.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../../../glsl/latest/index.html">OpenGL Shading Language Specification</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../glsl/latest/index.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../../../refpages/latest/refpages/index.html">Vulkan API Reference Pages</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../refpages/latest/refpages/index.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../../../features/latest/features/index.html">Vulkan Feature Descriptions</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../features/latest/features/index.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../../../guide/latest/index.html">Vulkan Guide</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../guide/latest/index.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../../../samples/latest/README.html">Vulkan Samples</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../samples/latest/README.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../../../spec/latest/index.html">Vulkan Specification</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../spec/latest/index.html">latest</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article" id="split-1">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../../../../spec/latest/index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../../00_Introduction.html">Khronos Vulkan Tutorial</a></li>
    <li><a href="05_vulkan_integration.html">GUI: Vulkan Integration</a></li>
  </ul>
</nav>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">GUI: Vulkan Integration</h1>
<div class="sect1">
<h2 id="_vulkan_integration"><a class="anchor" href="#_vulkan_integration"></a>Vulkan Integration</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In this section, we&#8217;ll explore how to properly integrate ImGui rendering with the Vulkan rendering pipeline. While we&#8217;ve already covered the basic setup in the "Setting Up Dear ImGui" section, here we&#8217;ll dive deeper into the technical details of how ImGui works with Vulkan and how to optimize the integration.</p>
</div>
<div class="sect2">
<h3 id="_understanding_the_rendering_flow"><a class="anchor" href="#_understanding_the_rendering_flow"></a>Understanding the Rendering Flow</h3>
<div class="paragraph">
<p>Before we dive into the implementation details, let&#8217;s understand how ImGui rendering fits into the Vulkan rendering pipeline:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Prepare Frame</strong>: Begin a new frame in ImGui and create UI elements</p>
</li>
<li>
<p><strong>Generate Draw Data</strong>: ImGui generates vertex and index buffers for the UI</p>
</li>
<li>
<p><strong>Record Commands</strong>: Record Vulkan commands to render the ImGui draw data</p>
</li>
<li>
<p><strong>Submit Commands</strong>: Submit the commands to the Vulkan queue</p>
</li>
<li>
<p><strong>Present</strong>: Present the rendered frame to the screen</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This flow needs to be integrated with your existing Vulkan rendering pipeline, which typically involves:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Acquiring the next swap chain image</p>
</li>
<li>
<p>Recording command buffers for scene rendering</p>
</li>
<li>
<p>Submitting command buffers</p>
</li>
<li>
<p>Presenting the rendered image</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_dynamic_rendering_configuration"><a class="anchor" href="#_dynamic_rendering_configuration"></a>Dynamic Rendering Configuration</h3>
<div class="paragraph">
<p>ImGui can be integrated with Vulkan&#8217;s dynamic rendering feature, which simplifies the rendering process by eliminating the need for explicit render passes and framebuffers:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">// When initializing ImGui, we set up our custom Vulkan renderer with dynamic rendering
ImGuiVulkanRenderer renderer;
// ... configure the renderer ...
renderer.initialize(*device, *physicalDevice);

// Set up dynamic rendering info
vk::PipelineRenderingCreateInfo renderingInfo{};
renderingInfo.colorAttachmentCount = 1;
vk::Format formats[] = { vk::Format::eB8G8R8A8Unorm };
renderingInfo.pColorAttachmentFormats = formats;
renderer.setDynamicRenderingInfo(renderingInfo);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Dynamic rendering simplifies the integration by removing the dependency on render passes and framebuffers, making the code more flexible and easier to maintain.</p>
</div>
</div>
<div class="sect2">
<h3 id="_command_buffer_integration"><a class="anchor" href="#_command_buffer_integration"></a>Command Buffer Integration</h3>
<div class="paragraph">
<p>There are two main approaches to integrating ImGui commands with your Vulkan command buffers:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Single Command Buffer</strong>: Record both scene and ImGui rendering commands in the same command buffer</p>
</li>
<li>
<p><strong>Multiple Command Buffers</strong>: Use separate command buffers for scene and ImGui rendering</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Let&#8217;s look at both approaches:</p>
</div>
<div class="sect3">
<h4 id="_single_command_buffer_approach"><a class="anchor" href="#_single_command_buffer_approach"></a>Single Command Buffer Approach</h4>
<div class="paragraph">
<p>This is the simplest approach and works well for most applications. With dynamic rendering, the code becomes even cleaner:</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_command_buffer_initialization"><a class="anchor" href="#_command_buffer_initialization"></a>Command Buffer Initialization</h3>
<div class="paragraph">
<p>The frame rendering process begins with command buffer preparation, where we set up the recording state and prepare for GPU command submission.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">void drawFrame() {
    // ... existing frame preparation code ...

    // Initialize command buffer recording
    // This tells Vulkan we're about to record a sequence of GPU commands
    vk::CommandBufferBeginInfo beginInfo{};
    commandBuffer.begin(beginInfo);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Command buffer recording represents the heart of Vulkan&#8217;s explicit GPU control model. Unlike older APIs where rendering commands are immediately submitted to the GPU, Vulkan allows us to build up a complete sequence of operations before submission. This approach enables powerful optimizations like command reordering, parallel command buffer construction, and efficient GPU scheduling.</p>
</div>
<div class="paragraph">
<p>The 'begin' operation transitions the command buffer from an initial state into a recording state, where subsequent API calls will be captured as GPU instructions rather than executed immediately. This explicit state management gives us precise control over when and how GPU work is submitted, enabling the fine-grained performance control that makes Vulkan so powerful for demanding applications.</p>
</div>
</div>
<div class="sect2">
<h3 id="_dynamic_rendering_attachment_setup"><a class="anchor" href="#_dynamic_rendering_attachment_setup"></a>Dynamic Rendering Attachment Setup</h3>
<div class="paragraph">
<p>Dynamic rendering requires us to explicitly describe our render targets and their properties, replacing the traditional render pass system with a more flexible approach.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">    // Configure color attachment for the main render target
    // This describes how the GPU should handle the color output
    vk::RenderingAttachmentInfo colorAttachment{};
    colorAttachment.imageView = *swapChainImageViews[imageIndex];       // Target swapchain image
    colorAttachment.imageLayout = vk::ImageLayout::eColorAttachmentOptimal;  // Optimal layout for color output
    colorAttachment.loadOp = vk::AttachmentLoadOp::eClear;              // Clear the image before rendering
    colorAttachment.storeOp = vk::AttachmentStoreOp::eStore;            // Preserve results after rendering
    colorAttachment.clearValue.color = std::array&lt;float, 4&gt;{0.0f, 0.0f, 0.0f, 1.0f};  // Clear to black

    // Configure depth attachment for 3D depth testing
    // This enables proper occlusion and depth sorting for 3D objects
    vk::RenderingAttachmentInfo depthAttachment{};
    depthAttachment.imageView = *depthImageView;                        // Depth buffer image
    depthAttachment.imageLayout = vk::ImageLayout::eDepthStencilAttachmentOptimal;  // Optimal for depth operations
    depthAttachment.loadOp = vk::AttachmentLoadOp::eClear;              // Clear depth buffer to far plane
    depthAttachment.storeOp = vk::AttachmentStoreOp::eDontCare;         // Don't preserve depth after rendering
    depthAttachment.clearValue.depthStencil = vk::ClearDepthStencilValue{1.0f, 0};  // Clear to maximum depth</code></pre>
</div>
</div>
<div class="paragraph">
<p>The attachment configuration system provides explicit control over how the GPU handles our render targets throughout the rendering process. By specifying load and store operations, we can optimize memory bandwidth by only preserving data that needs to carry forward to subsequent passes. The clear operations ensure we start with a known state, preventing visual artifacts from previous frame data.</p>
</div>
<div class="paragraph">
<p>Image layout transitions happen automatically based on our specifications, with the GPU driver handling the necessary memory barriers and cache flushes to ensure data coherency. The optimal layouts we specify here tell the driver to arrange the image data in whatever format provides the best performance for the intended usage, rather than forcing a specific memory organization.</p>
</div>
</div>
<div class="sect2">
<h3 id="_dynamic_rendering_pass_setup"><a class="anchor" href="#_dynamic_rendering_pass_setup"></a>Dynamic Rendering Pass Setup</h3>
<div class="paragraph">
<p>With our attachments configured, we now assemble them into a complete rendering pass that describes the full rendering operation to the GPU.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">    // Assemble the complete rendering operation description
    // This ties together all our attachments and rendering parameters
    vk::RenderingInfo renderingInfo{};
    renderingInfo.renderArea = vk::Rect2D{{0, 0}, swapChainExtent};     // Render to entire swapchain area
    renderingInfo.layerCount = 1;                                       // Single layer (not array rendering)
    renderingInfo.colorAttachmentCount = 1;                             // One color output
    renderingInfo.pColorAttachments = &amp;colorAttachment;                 // Our configured color attachment
    renderingInfo.pDepthAttachment = &amp;depthAttachment;                  // Our configured depth attachment

    // Begin the dynamic rendering pass
    // This establishes the rendering context for subsequent draw commands
    commandBuffer.beginRendering(renderingInfo);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Dynamic rendering represents a significant evolution from traditional Vulkan render passes, providing greater flexibility while maintaining the performance benefits of explicit GPU control. Instead of pre-defining render pass objects at initialization time, we can specify render targets and their properties at command recording time, enabling more dynamic and flexible rendering architectures.</p>
</div>
<div class="paragraph">
<p>The render area specification allows for partial-screen rendering, which can provide significant performance benefits when only portions of the screen need updating. For full-screen rendering like our case, we specify the entire swapchain extent to ensure complete coverage.</p>
</div>
</div>
<div class="sect2">
<h3 id="_3d_scene_rendering"><a class="anchor" href="#_3d_scene_rendering"></a>3D Scene Rendering</h3>
<div class="paragraph">
<p>The main scene rendering phase handles all 3D geometry, lighting, and material rendering within the established rendering context.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">    // Execute 3D scene rendering
    // All your existing 3D geometry, lighting, and material rendering happens here
    // ... your existing scene rendering code ...

    // Complete the 3D rendering pass
    // This finalizes all 3D rendering operations and prepares for UI overlay
    commandBuffer.endRendering();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The scene rendering phase operates within the rendering context we established, with the GPU automatically handling depth testing, color blending, and other rasterization operations according to our pipeline configurations. All draw commands issued between beginRendering and endRendering will target our configured attachments with the specified clear and store behaviors.</p>
</div>
<div class="paragraph">
<p>The explicit endRendering call ensures that all scene rendering operations are properly completed and that render targets are transitioned to appropriate states for subsequent operations. This explicit control allows the GPU driver to perform optimal scheduling and memory management for the rendering workload.</p>
</div>
</div>
<div class="sect2">
<h3 id="_ui_overlay_integration"><a class="anchor" href="#_ui_overlay_integration"></a>UI Overlay Integration</h3>
<div class="paragraph">
<p>The final rendering phase integrates ImGui UI elements as an overlay on top of the 3D scene, requiring careful coordination between the two rendering systems.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">    // Render ImGui UI overlay on top of the 3D scene
    // The custom renderer handles ImGui's own dynamic rendering setup internally
    // This includes vertex buffer uploads, pipeline binding, and draw command generation
    renderer.render(ImGui::GetDrawData(), commandBuffer);

    // Finalize command buffer recording
    // This transitions the command buffer to executable state for GPU submission
    commandBuffer.end();

    // Submit command buffer
    // ... your existing submission code ...
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_multiple_command_buffers_approach"><a class="anchor" href="#_multiple_command_buffers_approach"></a>Multiple Command Buffers Approach</h4>
<div class="paragraph">
<p>This approach gives you more flexibility and can be useful for more complex rendering pipelines. With dynamic rendering, it becomes even more straightforward:</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_multi_buffer_scene_command_buffer_recording"><a class="anchor" href="#_multi_buffer_scene_command_buffer_recording"></a>Multi-Buffer: Scene Command Buffer Recording</h3>
<div class="paragraph">
<p>The multiple command buffer approach begins by isolating 3D scene rendering into its own dedicated command buffer, providing greater flexibility for complex rendering pipelines.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">void drawFrame() {
    // ... existing frame preparation code ...

    // Initialize scene-specific command buffer recording
    // This dedicated buffer will contain only 3D geometry and lighting operations
    vk::CommandBufferBeginInfo beginInfo{};
    sceneCommandBuffer.begin(beginInfo);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Separating scene rendering into its own command buffer provides several architectural advantages. First, it enables parallel command buffer recording where different threads can simultaneously build scene and UI command sequences, improving CPU utilization on multi-core systems. Second, it allows for independent optimization of each rendering phase, where scene rendering can use different GPU queues or submission timing than UI rendering.</p>
</div>
<div class="paragraph">
<p>This separation also facilitates advanced rendering techniques like multi-frame latency optimization, where scene rendering can be decoupled from UI updates to maintain consistent frame timing even when one system experiences performance variations.</p>
</div>
</div>
<div class="sect2">
<h3 id="_multi_buffer_scene_attachment_configuration"><a class="anchor" href="#_multi_buffer_scene_attachment_configuration"></a>Multi-Buffer: Scene Attachment Configuration</h3>
<div class="paragraph">
<p>The scene rendering setup mirrors the single-buffer approach but with explicit ownership of the attachment configuration within the scene command buffer.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">    // Configure scene rendering attachments with explicit ownership
    // These configurations belong specifically to the scene rendering pass
    vk::RenderingAttachmentInfo colorAttachment{};
    colorAttachment.imageView = *swapChainImageViews[imageIndex];        // Target swapchain image
    colorAttachment.imageLayout = vk::ImageLayout::eColorAttachmentOptimal;  // Optimal for color rendering
    colorAttachment.loadOp = vk::AttachmentLoadOp::eClear;               // Clear for fresh scene start
    colorAttachment.storeOp = vk::AttachmentStoreOp::eStore;             // Preserve for UI overlay
    colorAttachment.clearValue.color = std::array&lt;float, 4&gt;{0.0f, 0.0f, 0.0f, 1.0f};  // Clear to black

    // Configure depth attachment for 3D scene depth testing
    // UI rendering won't need depth testing, so this is scene-specific
    vk::RenderingAttachmentInfo depthAttachment{};
    depthAttachment.imageView = *depthImageView;                         // Scene depth buffer
    depthAttachment.imageLayout = vk::ImageLayout::eDepthStencilAttachmentOptimal;  // Optimal for depth ops
    depthAttachment.loadOp = vk::AttachmentLoadOp::eClear;               // Clear depth for new frame
    depthAttachment.storeOp = vk::AttachmentStoreOp::eDontCare;          // UI doesn't need depth data
    depthAttachment.clearValue.depthStencil = vk::ClearDepthStencilValue{1.0f, 0};  // Clear to far plane</code></pre>
</div>
</div>
<div class="paragraph">
<p>The attachment configuration for scene rendering emphasizes the separation of concerns between 3D and UI rendering. The store operation for the color attachment ensures that scene rendering results are preserved for the subsequent UI overlay, while the depth attachment uses "don&#8217;t care" storage since UI elements typically render without depth testing.</p>
</div>
<div class="paragraph">
<p>This explicit configuration makes the rendering dependencies clear and helps optimize memory bandwidth by only preserving the data that subsequent passes actually need.</p>
</div>
</div>
<div class="sect2">
<h3 id="_multi_buffer_scene_rendering_execution"><a class="anchor" href="#_multi_buffer_scene_rendering_execution"></a>Multi-Buffer: Scene Rendering Execution</h3>
<div class="paragraph">
<p>The scene rendering execution occurs within its dedicated command buffer, providing isolated control over 3D rendering operations.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">    // Assemble scene rendering configuration
    // This defines the complete 3D rendering context
    vk::RenderingInfo renderingInfo{};
    renderingInfo.renderArea = vk::Rect2D{{0, 0}, swapChainExtent};      // Full screen rendering
    renderingInfo.layerCount = 1;                                        // Single rendering layer
    renderingInfo.colorAttachmentCount = 1;                              // One color output
    renderingInfo.pColorAttachments = &amp;colorAttachment;                  // Scene color configuration
    renderingInfo.pDepthAttachment = &amp;depthAttachment;                   // Scene depth configuration

    // Execute complete 3D scene rendering pass
    sceneCommandBuffer.beginRendering(renderingInfo);
    // All 3D geometry, lighting, materials, and effects render here
    // ... your existing scene rendering code ...
    sceneCommandBuffer.endRendering();

    // Finalize scene command buffer for submission
    sceneCommandBuffer.end();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The scene rendering execution benefits from having its own isolated command buffer context, where all GPU state changes and draw calls are contained within a clearly defined scope. This isolation makes debugging easier, as scene-specific rendering issues can be analyzed independently of UI rendering complexity.</p>
</div>
<div class="paragraph">
<p>Command buffer finalization with <code>end()</code> transitions the buffer to an executable state, ready for GPU submission, while maintaining clear boundaries between different rendering responsibilities.</p>
</div>
</div>
<div class="sect2">
<h3 id="_multi_buffer_ui_command_buffer_setup"><a class="anchor" href="#_multi_buffer_ui_command_buffer_setup"></a>Multi-Buffer: UI Command Buffer Setup</h3>
<div class="paragraph">
<p>The UI rendering phase begins with its own command buffer recording, configured specifically for overlay rendering requirements.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">    // Initialize UI-specific command buffer recording
    // This dedicated buffer handles only UI overlay operations
    imguiCommandBuffer.begin(beginInfo);

    // Configure UI attachment to preserve scene rendering results
    // This is the key difference from scene rendering - we load existing content
    colorAttachment.loadOp = vk::AttachmentLoadOp::eLoad;                // Preserve scene rendering

    // Ensure proper ordering/visibility between scene and UI when using multiple command buffers.
    // If you submit scene and UI command buffers separately, synchronize them either by:
    // - Submitting both on the same queue with a semaphore (scene signals, UI waits with stage = COLOR_ATTACHMENT_OUTPUT), or
    // - Recording a pipeline barrier in the UI command buffer before beginRendering() to make scene color writes visible.
    // Example barrier inserted in the UI command buffer:
    {
        vk::ImageMemoryBarrier2 barrier{
            .srcStageMask = vk::PipelineStageFlagBits2::eColorAttachmentOutput,
            .srcAccessMask = vk::AccessFlagBits2::eColorAttachmentWrite,
            .dstStageMask = vk::PipelineStageFlagBits2::eColorAttachmentOutput,
            .dstAccessMask = vk::AccessFlagBits2::eColorAttachmentRead | vk::AccessFlagBits2::eColorAttachmentWrite,
            .oldLayout = vk::ImageLayout::eColorAttachmentOptimal,
            .newLayout = vk::ImageLayout::eColorAttachmentOptimal,
            .image = *swapChainImages[imageIndex],
            .subresourceRange = { vk::ImageAspectFlagBits::eColor, 0, 1, 0, 1 }
        };
        vk::DependencyInfo depInfo{ .imageMemoryBarrierCount = 1, .pImageMemoryBarriers = &amp;barrier };
        imguiCommandBuffer.pipelineBarrier2(depInfo);
    }

    // UI rendering typically doesn't need depth testing
    // Remove depth attachment to optimize UI rendering performance
    renderingInfo.pDepthAttachment = nullptr;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The UI command buffer setup demonstrates the power of the multi-buffer approach through its different attachment configuration. By changing the load operation to <code>eLoad</code>, we preserve the scene rendering results as the foundation for UI overlay rendering. This approach is more explicit and controllable than relying on automatic render pass dependencies.</p>
</div>
<div class="paragraph">
<p>Removing the depth attachment for UI rendering eliminates unnecessary depth testing overhead, since UI elements typically render in screen space without complex occlusion relationships. This optimization can provide measurable performance improvements, especially on mobile GPUs where bandwidth is at a premium.</p>
</div>
</div>
<div class="sect2">
<h3 id="_multi_buffer_ui_rendering_and_submission_coordination"><a class="anchor" href="#_multi_buffer_ui_rendering_and_submission_coordination"></a>Multi-Buffer: UI Rendering and Submission Coordination</h3>
<div class="paragraph">
<p>The final phase handles UI rendering execution and coordinates the submission of both command buffers in the correct order.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">    // Execute UI overlay rendering
    // The custom renderer handles ImGui's dynamic rendering internally
    renderer.render(ImGui::GetDrawData(), imguiCommandBuffer);

    // Finalize UI command buffer
    imguiCommandBuffer.end();

    // Coordinate submission of both command buffers in dependency order
    // Scene must complete before UI to ensure proper overlay rendering
    std::array&lt;vk::CommandBuffer, 2&gt; submitCommandBuffers = {
        *sceneCommandBuffer,     // Execute scene rendering first
        *imguiCommandBuffer      // Then execute UI overlay
    };

    // Configure batch submission for optimal GPU utilization
    vk::SubmitInfo submitInfo{};
    submitInfo.commandBufferCount = static_cast&lt;uint32_t&gt;(submitCommandBuffers.size());
    submitInfo.pCommandBuffers = submitCommandBuffers.data();

    // Submit both command buffers as a cohesive frame
    // ... rest of your submission code ...
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_handling_multiple_viewports"><a class="anchor" href="#_handling_multiple_viewports"></a>Handling Multiple Viewports</h3>
<div class="paragraph">
<p>ImGui supports multiple viewports, which allows UI windows to be detached from the main window. To support this feature, we need to handle additional steps:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">// In your main loop, after rendering ImGui
if (ImGui::GetIO().ConfigFlags &amp; ImGuiConfigFlags_ViewportsEnable) {
    ImGui::UpdatePlatformWindows();
    ImGui::RenderPlatformWindowsDefault();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will render any detached ImGui windows. Note that this feature requires additional platform-specific code and may not be necessary for all applications.</p>
</div>
</div>
<div class="sect2">
<h3 id="_handling_window_resize"><a class="anchor" href="#_handling_window_resize"></a>Handling Window Resize</h3>
<div class="paragraph">
<p>When the window is resized, you need to recreate the swap chain and update ImGui:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">void recreateSwapChain() {
    // ... existing swap chain recreation code ...

    // Update ImGui display size
    ImGuiIO&amp; io = ImGui::GetIO();
    io.DisplaySize = ImVec2(static_cast&lt;float&gt;(swapChainExtent.width),
                           static_cast&lt;float&gt;(swapChainExtent.height));
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_performance_considerations"><a class="anchor" href="#_performance_considerations"></a>Performance Considerations</h3>
<div class="paragraph">
<p>Here are some tips to optimize ImGui rendering performance in Vulkan:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Minimize State Changes</strong>: Try to render all ImGui elements in a single pass to minimize state changes.</p>
</li>
<li>
<p><strong>Use Appropriate Descriptor Pool Sizes</strong>: Allocate enough descriptors for ImGui to avoid running out of descriptors.</p>
</li>
<li>
<p><strong>Consider Secondary Command Buffers</strong>: For complex UIs, consider using secondary command buffers to record ImGui commands in parallel.</p>
</li>
<li>
<p><strong>Optimize UI Updates</strong>: Only update UI elements that change, and consider using ImGui&#8217;s <code>Begin()</code> function with the <code>ImGuiWindowFlags_NoDecoration</code> flag for static UI elements.</p>
</li>
<li>
<p><strong>Use ImGui&#8217;s Memory Allocators</strong>: ImGui allows you to provide custom memory allocators, which can be useful for controlling memory usage.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_complete_integration_example"><a class="anchor" href="#_complete_integration_example"></a>Complete Integration Example</h3>
<div class="paragraph">
<p>Let&#8217;s put everything together in a complete example that integrates ImGui with a Vulkan application:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">class VulkanApplication {
private:
    // ... existing Vulkan members ...

    // ImGui-specific members
    vk::raii::DescriptorPool imguiPool = nullptr;
    bool showDemoWindow = true;
    bool showMetricsWindow = false;

public:
    void initVulkan() {
        // ... existing Vulkan initialization ...

        // Initialize ImGui
        createImGuiDescriptorPool();
        initImGui();
    }

    void createImGuiDescriptorPool() {
        // ImGui typically needs a handful of descriptors (font texture + user UI textures).
        // Adjust these values to your app's needs (e.g., expected number of UI textures, buffers).
        // As a starting point:
        vk::DescriptorPoolSize poolSizes[] =
        {
            { vk::DescriptorType::eSampler, 8 },
            { vk::DescriptorType::eCombinedImageSampler, 128 },   // font + user-provided textures
            { vk::DescriptorType::eSampledImage, 128 },
            { vk::DescriptorType::eStorageImage, 8 },
            { vk::DescriptorType::eUniformTexelBuffer, 8 },
            { vk::DescriptorType::eStorageTexelBuffer, 8 },
            { vk::DescriptorType::eUniformBuffer, 32 },
            { vk::DescriptorType::eStorageBuffer, 32 },
            { vk::DescriptorType::eUniformBufferDynamic, 16 },
            { vk::DescriptorType::eStorageBufferDynamic, 16 },
            { vk::DescriptorType::eInputAttachment, 8 }
        };

        // A conservative maxSets equals the sum of descriptor counts.
        uint32_t maxSets = 0;
        for (const auto&amp; ps : poolSizes) maxSets += ps.descriptorCount;

        vk::DescriptorPoolCreateInfo poolInfo{
            .flags = vk::DescriptorPoolCreateFlagBits::eFreeDescriptorSet,
            .maxSets = maxSets,
            .poolSizeCount = static_cast&lt;uint32_t&gt;(std::size(poolSizes)),
            .pPoolSizes = poolSizes
        };

        imguiPool = vk::raii::DescriptorPool(device, poolInfo);
    }

    void initImGui() {
        // Initialize ImGui context
        IMGUI_CHECKVERSION();
        ImGui::CreateContext();
        ImGuiIO&amp; io = ImGui::GetIO();
        io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;
        io.ConfigFlags |= ImGuiConfigFlags_DockingEnable;

        // Set up ImGui style
        ImGui::StyleColorsDark();

        // Initialize our custom backend
        int width = static_cast&lt;int&gt;(swapChainExtent.width);
        int height = static_cast&lt;int&gt;(swapChainExtent.height);
        ImGuiPlatform::Init(width, height);

        // Initialize our custom ImGui Vulkan renderer with dynamic rendering
        ImGuiVulkanRenderer renderer;
        renderer.initialize(
            *instance,
            *physicalDevice,
            *device,
            graphicsFamily,
            *graphicsQueue,
            *imguiPool,
            static_cast&lt;uint32_t&gt;(swapChainImages.size()),
            vk::SampleCountFlagBits::e1
        );

        // Set up dynamic rendering info
        vk::PipelineRenderingCreateInfo renderingInfo{};
        renderingInfo.colorAttachmentCount = 1;
        vk::Format formats[] = { swapChainImageFormat };
        renderingInfo.pColorAttachmentFormats = formats;
        renderer.setDynamicRenderingInfo(renderingInfo);

        // Upload ImGui fonts
        vk::raii::CommandBuffer commandBuffer = beginSingleTimeCommands();
        renderer.uploadFonts(commandBuffer);
        endSingleTimeCommands(commandBuffer);
    }

    void drawFrame() {
        // ... existing frame preparation code ...

        // Start the ImGui frame
        ImGui::NewFrame();

        // Create ImGui UI
        createImGuiUI();

        // Render ImGui
        ImGui::Render();

        // ... existing command buffer recording code ...

        // Begin dynamic rendering for scene
        vk::RenderingAttachmentInfo colorAttachment{};
        colorAttachment.imageView = *swapChainImageViews[imageIndex];
        colorAttachment.imageLayout = vk::ImageLayout::eColorAttachmentOptimal;
        colorAttachment.loadOp = vk::AttachmentLoadOp::eClear;
        colorAttachment.storeOp = vk::AttachmentStoreOp::eStore;
        colorAttachment.clearValue.color = std::array&lt;float, 4&gt;{0.0f, 0.0f, 0.0f, 1.0f};

        vk::RenderingAttachmentInfo depthAttachment{};
        depthAttachment.imageView = *depthImageView;
        depthAttachment.imageLayout = vk::ImageLayout::eDepthStencilAttachmentOptimal;
        depthAttachment.loadOp = vk::AttachmentLoadOp::eClear;
        depthAttachment.storeOp = vk::AttachmentStoreOp::eDontCare;
        depthAttachment.clearValue.depthStencil = vk::ClearDepthStencilValue{1.0f, 0};

        vk::RenderingInfo renderingInfo{};
        renderingInfo.renderArea = vk::Rect2D{{0, 0}, swapChainExtent};
        renderingInfo.layerCount = 1;
        renderingInfo.colorAttachmentCount = 1;
        renderingInfo.pColorAttachments = &amp;colorAttachment;
        renderingInfo.pDepthAttachment = &amp;depthAttachment;

        commandBuffer.beginRendering(renderingInfo);

        // Render 3D scene
        // ... your existing scene rendering code ...

        commandBuffer.endRendering();

        // Render ImGui using our custom renderer
        // ImGui will handle its own dynamic rendering internally
        renderer.render(ImGui::GetDrawData(), commandBuffer);

        // ... existing command buffer submission code ...
    }

    void createImGuiUI() {
        // Menu bar
        if (ImGui::BeginMainMenuBar()) {
            if (ImGui::BeginMenu("File")) {
                if (ImGui::MenuItem("Exit", "Alt+F4")) {
                    // Generic way to request application exit
                    requestApplicationExit();
                }
                ImGui::EndMenu();
            }

            if (ImGui::BeginMenu("View")) {
                ImGui::MenuItem("Demo Window", nullptr, &amp;showDemoWindow);
                ImGui::MenuItem("Metrics", nullptr, &amp;showMetricsWindow);
                ImGui::EndMenu();
            }

            ImGui::EndMainMenuBar();
        }

        // Demo window
        if (showDemoWindow) {
            ImGui::ShowDemoWindow(&amp;showDemoWindow);
        }

        // Metrics window
        if (showMetricsWindow) {
            ImGui::ShowMetricsWindow(&amp;showMetricsWindow);
        }

        // Custom windows
        ImGui::Begin("Settings");

        static float color[3] = { 0.5f, 0.5f, 0.5f };
        if (ImGui::ColorEdit3("Clear Color", color)) {
            // Update clear color
            clearColor = { color[0], color[1], color[2], 1.0f };
        }

        static int selectedModel = 0;
        const char* models[] = { "Cube", "Sphere", "Teapot", "Custom Model" };
        if (ImGui::Combo("Model", &amp;selectedModel, models, IM_ARRAYSIZE(models))) {
            // Change model
            loadModel(models[selectedModel]);
        }

        ImGui::End();
    }

    void cleanup() {
        // ... existing cleanup code ...

        // Cleanup ImGui
        renderer.cleanup();
        ImGuiPlatform::Shutdown();  // Our custom platform backend
        ImGui::DestroyContext();
    }
};</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_advanced_topics"><a class="anchor" href="#_advanced_topics"></a>Advanced Topics</h3>
<div class="sect3">
<h4 id="_custom_shaders_for_imgui"><a class="anchor" href="#_custom_shaders_for_imgui"></a>Custom Shaders for ImGui</h4>
<div class="paragraph">
<p>ImGui uses its own shaders for rendering, but you can customize them if needed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">// Create custom shader modules
vk::raii::ShaderModule customVertShaderModule = createShaderModule("custom_imgui_vert.spv");
vk::raii::ShaderModule customFragShaderModule = createShaderModule("custom_imgui_frag.spv");

// Initialize our custom renderer with custom shaders and dynamic rendering
ImGuiVulkanRenderer renderer;
renderer.initialize(
    *instance,
    *physicalDevice,
    *device,
    queueFamily,
    *queue,
    *descriptorPool,
    minImageCount,
    imageCount,
    vk::SampleCountFlagBits::e1
);

// Set up dynamic rendering info
vk::PipelineRenderingCreateInfo renderingInfo{};
renderingInfo.colorAttachmentCount = 1;
vk::Format formats[] = { swapChainImageFormat };
renderingInfo.pColorAttachmentFormats = formats;
renderer.setDynamicRenderingInfo(renderingInfo);

// Set custom shaders
renderer.setCustomShaders(
    customVertShaderModule,
    customFragShaderModule
);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_rendering_imgui_to_a_texture"><a class="anchor" href="#_rendering_imgui_to_a_texture"></a>Rendering ImGui to a Texture</h4>
<div class="paragraph">
<p>You can render ImGui to a texture instead of directly to the screen, which can be useful for creating in-game UI elements:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">// Create a texture to render ImGui to
vk::raii::Image imguiTargetImage = createImage(
    width, height,
    vk::Format::eR8G8B8A8Unorm,
    vk::ImageTiling::eOptimal,
    vk::ImageUsageFlagBits::eColorAttachment | vk::ImageUsageFlagBits::eSampled
);

// Create image view
vk::raii::ImageView imguiTargetImageView = createImageView(
    imguiTargetImage,
    vk::Format::eR8G8B8A8Unorm,
    vk::ImageAspectFlagBits::eColor
);

// Render ImGui to the texture using dynamic rendering
vk::RenderingAttachmentInfo colorAttachment{};
colorAttachment.imageView = *imguiTargetImageView;
colorAttachment.imageLayout = vk::ImageLayout::eColorAttachmentOptimal;
colorAttachment.loadOp = vk::AttachmentLoadOp::eClear;
colorAttachment.storeOp = vk::AttachmentStoreOp::eStore;
colorAttachment.clearValue.color = std::array&lt;float, 4&gt;{0.0f, 0.0f, 0.0f, 0.0f};

vk::RenderingInfo renderingInfo{};
renderingInfo.renderArea = vk::Rect2D{{0, 0}, {width, height}};
renderingInfo.layerCount = 1;
renderingInfo.colorAttachmentCount = 1;
renderingInfo.pColorAttachments = &amp;colorAttachment;

commandBuffer.beginRendering(renderingInfo);
renderer.render(ImGui::GetDrawData(), commandBuffer);
commandBuffer.endRendering();

// Later, use the texture in your 3D scene
// ...</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_handling_high_dpi_displays"><a class="anchor" href="#_handling_high_dpi_displays"></a>Handling High DPI Displays</h4>
<div class="paragraph">
<p>For high DPI displays, you need to handle scaling correctly across different platforms:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">// Cross-platform display scaling
void updateDisplayScale(int width, int height, float scaleX, float scaleY) {
    ImGuiIO&amp; io = ImGui::GetIO();
    io.DisplaySize = ImVec2(static_cast&lt;float&gt;(width), static_cast&lt;float&gt;(height));
    io.DisplayFramebufferScale = ImVec2(scaleX, scaleY);

    // Update our platform backend
    ImGuiPlatform::SetDisplaySize(width, height);
}

// Platform-specific implementations
// Here's an example using GLFW, but you can implement similar functions
// for any windowing library you choose to use

void updateDisplayScaleWithGLFW(GLFWwindow* window) {
    // Get the framebuffer size (which may differ from window size on high DPI displays)
    int width, height;
    glfwGetFramebufferSize(window, &amp;width, &amp;height);

    // Get the content scale (DPI scaling factor)
    float xscale, yscale;
    glfwGetWindowContentScale(window, &amp;xscale, &amp;yscale);

    // Update ImGui with the correct display size and scale
    updateDisplayScale(width, height, xscale, yscale);
}

// With other windowing libraries, you would use their equivalent APIs
// to get the framebuffer size and DPI scaling factor</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_imgui_utility_class"><a class="anchor" href="#_imgui_utility_class"></a>ImGui Utility Class</h3>
<div class="paragraph">
<p>To encapsulate all the ImGui functionality in a way that works across different platforms, let&#8217;s create a utility class similar to the one mentioned in the Vulkan-Samples repository:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">// ImGuiUtil.h
#pragma once

import vulkan_hpp;
#include &lt;imgui.h&gt;
#include &lt;functional&gt;
#include &lt;memory&gt;

class ImGuiUtil {
public:
    // Initialize ImGui with Vulkan using dynamic rendering
    static void Init(
        vk::raii::Instance&amp; instance,
        vk::raii::PhysicalDevice&amp; physicalDevice,
        vk::raii::Device&amp; device,
        uint32_t queueFamily,
        vk::raii::Queue&amp; queue,
        uint32_t minImageCount,
        uint32_t imageCount,
        vk::Format swapChainImageFormat,
        vk::SampleCountFlagBits msaaSamples = vk::SampleCountFlagBits::e1
    );

    // Shutdown ImGui
    static void Shutdown();

    // Start a new frame
    static void NewFrame();

    // Render ImGui draw data to a command buffer
    static void Render(vk::raii::CommandBuffer&amp; commandBuffer);

    // Update display size
    static void UpdateDisplaySize(int width, int height, float scaleX = 1.0f, float scaleY = 1.0f);

    // Process platform-specific input event
    static bool ProcessInputEvent(void* event);

    // Set input callback
    static void SetInputCallback(std::function&lt;void(ImGuiIO&amp;)&gt; callback);

private:
    // Create descriptor pool for ImGui
    static void createDescriptorPool();

    // Upload fonts
    static void uploadFonts();

    // Begin single-time commands
    static vk::raii::CommandBuffer beginSingleTimeCommands();

    // End single-time commands
    static void endSingleTimeCommands(vk::raii::CommandBuffer&amp; commandBuffer);

    // Vulkan objects
    static vk::raii::Instance* instance;
    static vk::raii::PhysicalDevice* physicalDevice;
    static vk::raii::Device* device;
    static uint32_t queueFamily;
    static vk::raii::Queue* queue;
    static vk::raii::DescriptorPool descriptorPool;
    static vk::raii::CommandPool commandPool;
    static vk::PipelineRenderingCreateInfo renderingInfo;

    // Input callback
    static std::function&lt;void(ImGuiIO&amp;)&gt; inputCallback;

    // Initialization state
    static bool initialized;
};

// ImGuiUtil.cpp
#include "ImGuiUtil.h"

// Static member initialization
vk::raii::Instance* ImGuiUtil::instance = nullptr;
vk::raii::PhysicalDevice* ImGuiUtil::physicalDevice = nullptr;
vk::raii::Device* ImGuiUtil::device = nullptr;
uint32_t ImGuiUtil::queueFamily = 0;
vk::raii::Queue* ImGuiUtil::queue = nullptr;
vk::raii::DescriptorPool ImGuiUtil::descriptorPool = nullptr;
vk::raii::CommandPool ImGuiUtil::commandPool = nullptr;
vk::PipelineRenderingCreateInfo ImGuiUtil::renderingInfo{};
std::function&lt;void(ImGuiIO&amp;)&gt; ImGuiUtil::inputCallback = nullptr;
bool ImGuiUtil::initialized = false;

void ImGuiUtil::Init(
    vk::raii::Instance&amp; instance,
    vk::raii::PhysicalDevice&amp; physicalDevice,
    vk::raii::Device&amp; device,
    uint32_t queueFamily,
    vk::raii::Queue&amp; queue,
    uint32_t minImageCount,
    uint32_t imageCount,
    vk::Format swapChainImageFormat,
    vk::SampleCountFlagBits msaaSamples
) {
    ImGuiUtil::instance = &amp;instance;
    ImGuiUtil::physicalDevice = &amp;physicalDevice;
    ImGuiUtil::device = &amp;device;
    ImGuiUtil::queueFamily = queueFamily;
    ImGuiUtil::queue = &amp;queue;

    // Set up dynamic rendering info
    renderingInfo.colorAttachmentCount = 1;
    vk::Format formats[] = { swapChainImageFormat };
    renderingInfo.pColorAttachmentFormats = formats;

    // Create command pool for font upload
    vk::CommandPoolCreateInfo poolInfo{
        .flags = vk::CommandPoolCreateFlagBits::eTransient,
        .queueFamilyIndex = queueFamily
    };
    commandPool = vk::raii::CommandPool(device, poolInfo);

    // Create descriptor pool
    createDescriptorPool();

    // Initialize ImGui context
    IMGUI_CHECKVERSION();
    ImGui::CreateContext();
    ImGuiIO&amp; io = ImGui::GetIO();
    io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;
    io.ConfigFlags |= ImGuiConfigFlags_DockingEnable;

    // Set up ImGui style
    ImGui::StyleColorsDark();

    // Initialize our custom Vulkan renderer with dynamic rendering
    renderer = ImGuiVulkanRenderer();
    renderer.initialize(
        *instance,
        *physicalDevice,
        *device,
        queueFamily,
        *queue,
        *descriptorPool,
        minImageCount,
        imageCount,
        msaaSamples
    );

    // Set dynamic rendering info
    renderer.setDynamicRenderingInfo(renderingInfo);

    // Upload fonts
    uploadFonts();

    initialized = true;
}

void ImGuiUtil::Shutdown() {
    if (!initialized) return;

    // Wait for device to finish operations
    device-&gt;waitIdle();

    // Cleanup ImGui
    renderer.cleanup();
    ImGui::DestroyContext();

    // Cleanup Vulkan resources
    commandPool = nullptr;
    descriptorPool = nullptr;

    // Reset pointers
    instance = nullptr;
    physicalDevice = nullptr;
    device = nullptr;
    queue = nullptr;

    initialized = false;
}

void ImGuiUtil::NewFrame() {
    if (!initialized) return;

    // Update ImGui IO with platform-specific input
    ImGuiIO&amp; io = ImGui::GetIO();

    // Call input callback if registered
    if (inputCallback) {
        inputCallback(io);
    }

    ImGui::NewFrame();
}

void ImGuiUtil::Render(vk::raii::CommandBuffer&amp; commandBuffer) {
    if (!initialized) return;

    ImGui::Render();
    renderer.render(ImGui::GetDrawData(), commandBuffer);
}

void ImGuiUtil::UpdateDisplaySize(int width, int height, float scaleX, float scaleY) {
    if (!initialized) return;

    ImGuiIO&amp; io = ImGui::GetIO();
    io.DisplaySize = ImVec2(static_cast&lt;float&gt;(width), static_cast&lt;float&gt;(height));
    io.DisplayFramebufferScale = ImVec2(scaleX, scaleY);
}

bool ImGuiUtil::ProcessInputEvent(void* event) {
    // Platform-specific event processing would go here
    // This is a placeholder for the actual implementation
    return false;
}

void ImGuiUtil::SetInputCallback(std::function&lt;void(ImGuiIO&amp;)&gt; callback) {
    inputCallback = callback;
}

void ImGuiUtil::createDescriptorPool() {
    // Tune these to match your expected number of UI textures and buffers.
    vk::DescriptorPoolSize poolSizes[] =
    {
        { vk::DescriptorType::eSampler, 8 },
        { vk::DescriptorType::eCombinedImageSampler, 128 },
        { vk::DescriptorType::eSampledImage, 128 },
        { vk::DescriptorType::eStorageImage, 8 },
        { vk::DescriptorType::eUniformTexelBuffer, 8 },
        { vk::DescriptorType::eStorageTexelBuffer, 8 },
        { vk::DescriptorType::eUniformBuffer, 32 },
        { vk::DescriptorType::eStorageBuffer, 32 },
        { vk::DescriptorType::eUniformBufferDynamic, 16 },
        { vk::DescriptorType::eStorageBufferDynamic, 16 },
        { vk::DescriptorType::eInputAttachment, 8 }
    };

    uint32_t maxSets = 0;
    for (const auto&amp; ps : poolSizes) maxSets += ps.descriptorCount;

    vk::DescriptorPoolCreateInfo poolInfo{
        .flags = vk::DescriptorPoolCreateFlagBits::eFreeDescriptorSet,
        .maxSets = maxSets,
        .poolSizeCount = static_cast&lt;uint32_t&gt;(std::size(poolSizes)),
        .pPoolSizes = poolSizes
    };

    descriptorPool = vk::raii::DescriptorPool(*device, poolInfo);
}

void ImGuiUtil::uploadFonts() {
    vk::raii::CommandBuffer commandBuffer = beginSingleTimeCommands();
    renderer.uploadFonts(commandBuffer);
    endSingleTimeCommands(commandBuffer);
}

vk::raii::CommandBuffer ImGuiUtil::beginSingleTimeCommands() {
    vk::CommandBufferAllocateInfo allocInfo{
        .commandPool = *commandPool,
        .level = vk::CommandBufferLevel::ePrimary,
        .commandBufferCount = 1
    };

    vk::raii::CommandBuffer commandBuffer = vk::raii::CommandBuffers(*device, allocInfo).front();

    vk::CommandBufferBeginInfo beginInfo{
        .flags = vk::CommandBufferUsageFlagBits::eOneTimeSubmit
    };

    commandBuffer.begin(beginInfo);

    return commandBuffer;
}

void ImGuiUtil::endSingleTimeCommands(vk::raii::CommandBuffer&amp; commandBuffer) {
    commandBuffer.end();

    vk::SubmitInfo submitInfo{
        .commandBufferCount = 1,
        .pCommandBuffers = &amp;*commandBuffer
    };

    queue-&gt;submit(submitInfo);
    queue-&gt;waitIdle();
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_conclusion"><a class="anchor" href="#_conclusion"></a>Conclusion</h3>
<div class="paragraph">
<p>In this section, we&#8217;ve explored how to integrate ImGui with Vulkan, including command buffer integration, render pass configuration, and performance considerations. By creating a flexible implementation, we&#8217;ve ensured that our GUI system works well with any windowing system you choose.</p>
</div>
<div class="paragraph">
<p>The key improvements we&#8217;ve made include:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Creating a platform-agnostic integration approach</p>
</li>
<li>
<p>Implementing a flexible input system that works with various windowing libraries</p>
</li>
<li>
<p>Developing a versatile ImGui utility class</p>
</li>
<li>
<p>Designing a window-system-independent integration</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>With this knowledge, you can create a robust GUI system for your Vulkan application that provides a smooth user experience regardless of which windowing system you use.</p>
</div>
<div class="paragraph">
<p>In the next section, we&#8217;ll wrap up with a conclusion and discuss potential improvements to our GUI system.</p>
</div>
<div class="paragraph">
<p><a href="04_ui_elements.adoc">Previous: UI Elements</a> | <a href="06_conclusion.adoc">Next: Conclusion</a></p>
</div>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<script id="site-script" src="../../../../_/js/site.js" data-ui-root-path="../../../../_"></script>
<script async src="../../../../_/js/vendor/highlight.js"></script>
<script src="../../../../_/js/vendor/split.js"></script>
<script>
    // Splitter should only be visible in non-mobile layouts (where a hamburger menu is used for nav)
    var width = (window.innerWidth > 0) ? window.innerWidth : screen.width;
    var mobileNav = (width < 1024);

    if (!mobileNav) {
        var sizes = localStorage.getItem('split-sizes')

        if (sizes) {
            sizes = JSON.parse(sizes)
        } else {
            sizes = [25, 75]
        }

        var split = Split(['#split-0', '#split-1'], {
            sizes: sizes,
            onDragEnd: function (sizes) {
                localStorage.setItem('split-sizes', JSON.stringify(sizes))
            },
        })
    }
</script>
<script src="../../../../_/js/vendor/lunr.js" defer></script>
<script src="https://cdn.jsdelivr.net/pako/1.0.3/pako.min.js" defer></script>
<script src="../../../../_/js/search-ui.js" id="search-ui-script" data-site-root-path="../../../.." data-snippet-length="100" data-stylesheet="../../../../_/css/search.css" defer></script>
<script>
window.addEventListener('DOMContentLoaded', function(){
  try {
    var script = document.getElementById('search-ui-script');
    var siteRoot = (script && script.getAttribute('data-site-root-path')) || '';
    var manifestUrl = siteRoot + '/search-index/manifest.json';
    fetch(manifestUrl)
      .then(function (r) { return r.ok ? r.json() : Promise.reject(new Error('manifest not found')) })
      .then(function (manifest) { antoraSearch.bootstrap(lunr, manifest, siteRoot); })
      .catch(function () {
        var s = document.createElement('script');
        s.async = true;
        s.src = siteRoot + '/search-index.js';
        document.head.appendChild(s);
      });
  } catch (e) {
    // Fallback to monolithic index if anything goes wrong
    var s = document.createElement('script');
    s.async = true;
    s.src = '../../../../search-index.js';
    document.head.appendChild(s);
  }
});
</script>
<script async src="../../../../_/js/vendor/tabs.js"></script>
  </body>
</html>

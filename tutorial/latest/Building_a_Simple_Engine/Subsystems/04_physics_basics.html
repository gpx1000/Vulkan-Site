<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Subsystems: Physics Basics :: Vulkan Documentation Project</title>
    <meta name="generator" content="Antora 3.1.10">
    <link rel="stylesheet" href="../../../../_/css/site.css">
    <script>var uiRootPath = '../../../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="../../../..">Vulkan Documentation Project</a>
      <div class="navbar-item">
        <img alt="Vulkan White Label" src="../../../../_/Vulkan_White_Dec16.svg" height="100%" />
      </div>
      <div class="navbar-item search hide-for-print">
        <div id="search-field" class="field">
          <label for="search-input"></label><input id="search-input" type="text" placeholder="Search the docs">
        </div>
      </div>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <!-- <a class="navbar-item" href="#">Home</a> -->
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Specs</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="../../../../spec/latest/chapters/introduction.html">Vulkan 1.3</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Guides</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="../../../../guide/latest/index.html">Vulkan Guide</a>
          </div>
        </div>
            <!--
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Tools</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">TBD</a>
          </div>
        </div>
            -->
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Tutorial</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="../../../../tutorial/latest/index.html">Vulkan Tutorial</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Samples</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="../../../../samples/latest/README.html">Vulkan Samples</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Help</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="https://discord.gg/vulkan">Vulkan Discord</a>
            <a class="navbar-item" href="https://khr.io/khrdiscord">Khronos Discord</a>
          </div>
        </div>
            <!--
        <div class="navbar-item">
          <span class="control">
            <a class="button is-primary" href="#">Download</a>
          </span>
        </div>
            -->
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="tutorial" data-version="latest">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../../00_Introduction.html">Khronos Vulkan Tutorial</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../00_Introduction.html">Introduction</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../01_Overview.html">Overview</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../02_Development_environment.html">Development environment</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../03_Drawing_a_triangle/00_Setup/00_Base_code.html">Drawing a triangle</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../03_Drawing_a_triangle/00_Setup/00_Base_code.html">Setup</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../03_Drawing_a_triangle/00_Setup/00_Base_code.html">Base Code</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../03_Drawing_a_triangle/00_Setup/01_Instance.html">Instance</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../03_Drawing_a_triangle/00_Setup/02_Validation_layers.html">Validation layers</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../03_Drawing_a_triangle/00_Setup/03_Physical_devices_and_queue_families.html">Physical devices and queue families</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../03_Drawing_a_triangle/00_Setup/04_Logical_device_and_queues.html">Logical device and queues</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../03_Drawing_a_triangle/01_Presentation/00_Window_surface.html">Presentation</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../03_Drawing_a_triangle/01_Presentation/00_Window_surface.html">Window surface</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../03_Drawing_a_triangle/01_Presentation/01_Swap_chain.html">Swap chain</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../03_Drawing_a_triangle/01_Presentation/02_Image_views.html">Image views</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../03_Drawing_a_triangle/02_Graphics_pipeline_basics/00_Introduction.html">Graphics pipeline basics</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../03_Drawing_a_triangle/02_Graphics_pipeline_basics/00_Introduction.html">Introduction</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../03_Drawing_a_triangle/02_Graphics_pipeline_basics/01_Shader_modules.html">Shader modules</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../03_Drawing_a_triangle/02_Graphics_pipeline_basics/02_Fixed_functions.html">Fixed functions</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../03_Drawing_a_triangle/02_Graphics_pipeline_basics/03_Render_passes.html">Render passes</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../03_Drawing_a_triangle/02_Graphics_pipeline_basics/04_Conclusion.html">Conclusion</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../03_Drawing_a_triangle/03_Drawing/00_Framebuffers.html">Drawing</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../03_Drawing_a_triangle/03_Drawing/00_Framebuffers.html">Framebuffers</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../03_Drawing_a_triangle/03_Drawing/01_Command_buffers.html">Command buffers</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../03_Drawing_a_triangle/03_Drawing/02_Rendering_and_presentation.html">Rendering and presentation</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../../03_Drawing_a_triangle/03_Drawing/03_Frames_in_flight.html">Frames in flight</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../03_Drawing_a_triangle/04_Swap_chain_recreation.html">Swap chain recreation</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../04_Vertex_buffers/00_Vertex_input_description.html">Vertex buffers</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../04_Vertex_buffers/00_Vertex_input_description.html">Vertex input description</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../04_Vertex_buffers/01_Vertex_buffer_creation.html">Vertex buffer creation</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../04_Vertex_buffers/02_Staging_buffer.html">Staging buffer</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../04_Vertex_buffers/03_Index_buffer.html">Index buffer</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../05_Uniform_buffers/00_Descriptor_set_layout_and_buffer.html">Uniform buffers</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../05_Uniform_buffers/00_Descriptor_set_layout_and_buffer.html">Descriptor layout and buffer</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../05_Uniform_buffers/01_Descriptor_pool_and_sets.html">Descriptor pool and sets</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../06_Texture_mapping/00_Images.html">Texture mapping</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../06_Texture_mapping/00_Images.html">Images</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../06_Texture_mapping/01_Image_view_and_sampler.html">Image view and sampler</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../06_Texture_mapping/02_Combined_image_sampler.html">Combined image sampler</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../07_Depth_buffering.html">Depth buffering</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../08_Loading_models.html">Loading models</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../09_Generating_Mipmaps.html">Generating Mipmaps</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../10_Multisampling.html">Multisampling</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../11_Compute_Shader.html">Compute Shader</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../12_Ecosystem_Utilities_and_Compatibility.html">Ecosystem Utilities and GPU Compatibility</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../13_Vulkan_Profiles.html">Vulkan Profiles</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../14_Android.html">Android</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../15_GLTF_KTX2_Migration.html">Migrating to Modern Asset Formats: glTF and KTX2</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../16_Multiple_Objects.html">Rendering Multiple Objects</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../17_Multithreading.html">Multithreading</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../courses/18_Ray_tracing/00_Overview.html">Ray Tracing</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../courses/18_Ray_tracing/00_Overview.html">Overview</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../courses/18_Ray_tracing/01_Dynamic_rendering.html">Dynamic rendering</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../courses/18_Ray_tracing/02_Acceleration_structures.html">Acceleration structures</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../courses/18_Ray_tracing/03_Ray_query_shadows.html">Ray query shadows</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../courses/18_Ray_tracing/04_TLAS_animation.html">TLAS animation</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../courses/18_Ray_tracing/05_Shadow_transparency.html">Shadow transparency</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../courses/18_Ray_tracing/06_Reflections.html">Reflections</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../courses/18_Ray_tracing/07_Conclusion.html">Conclusion</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../90_FAQ.html">FAQ</a>
  </li>
  <li class="nav-item" data-depth="1">
    <span class="nav-text"><a href="https://github.com/KhronosGroup/Vulkan-Tutorial" target="_blank" rel="noopener">GitHub Repository</a></span>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Khronos Vulkan Tutorial</span>
    <span class="version">latest</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <a class="title" href="../../00_Introduction.html">Khronos Vulkan Tutorial</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../../00_Introduction.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../../../glsl/latest/index.html">OpenGL Shading Language Specification</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../glsl/latest/index.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../../../refpages/latest/refpages/index.html">Vulkan API Reference Pages</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../refpages/latest/refpages/index.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../../../features/latest/features/index.html">Vulkan Feature Descriptions</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../features/latest/features/index.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../../../guide/latest/index.html">Vulkan Guide</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../guide/latest/index.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../../../samples/latest/README.html">Vulkan Samples</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../samples/latest/README.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../../../spec/latest/index.html">Vulkan Specification</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../spec/latest/index.html">latest</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../../../../spec/latest/index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../../00_Introduction.html">Khronos Vulkan Tutorial</a></li>
    <li><a href="04_physics_basics.html">Subsystems: Physics Basics</a></li>
  </ul>
</nav>
    <!--
    -->
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Subsystems: Physics Basics</h1>
<div class="sect1">
<h2 id="_physics_system_fundamentals"><a class="anchor" href="#_physics_system_fundamentals"></a>Physics System Fundamentals</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Before we explore how Vulkan can accelerate physics simulations, let&#8217;s establish a foundation by implementing a basic physics system for our engine. This will give us a framework that we can later enhance with Vulkan compute capabilities.</p>
</div>
<div class="sect2">
<h3 id="_physics_system_architecture"><a class="anchor" href="#_physics_system_architecture"></a>Physics System Architecture</h3>
<div class="paragraph">
<p>A typical game physics system consists of several key components:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Rigid Body Dynamics</strong>: Simulation of solid objects with mass, velocity, and rotational properties.</p>
</li>
<li>
<p><strong>Collision Detection</strong>: Determining when objects intersect or contact each other.</p>
</li>
<li>
<p><strong>Collision Response</strong>: Calculating how objects should react when they collide.</p>
</li>
<li>
<p><strong>Constraints</strong>: Limiting the movement of objects based on joints, hinges, or other connections.</p>
</li>
<li>
<p><strong>Continuous Collision Detection</strong>: Handling fast-moving objects that might pass through others between frames.</p>
</li>
<li>
<p><strong>Spatial Partitioning</strong>: Optimizing collision detection by dividing the world into regions.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Let&#8217;s implement a simple physics system that covers these basics, using a modern C++ approach consistent with our engine&#8217;s design.</p>
</div>
</div>
<div class="sect2">
<h3 id="_basic_physics_system_implementation"><a class="anchor" href="#_basic_physics_system_implementation"></a>Basic Physics System Implementation</h3>
<div class="paragraph">
<p>We&#8217;ll start by defining the core classes for our physics system:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">// Physics.h
#pragma once

#include &lt;vector&gt;
#include &lt;memory&gt;
#include &lt;unordered_map&gt;
#include &lt;string&gt;
#include &lt;glm/glm.hpp&gt;
#include &lt;glm/gtc/quaternion.hpp&gt;

namespace Engine {
namespace Physics {

enum class ColliderType {
    Box,
    Sphere,
    Capsule,
    Mesh
};

class Collider {
public:
    virtual ~Collider() = default;
    virtual ColliderType GetType() const = 0;

    void SetOffset(const glm::vec3&amp; offset) { m_Offset = offset; }
    const glm::vec3&amp; GetOffset() const { return m_Offset; }

protected:
    glm::vec3 m_Offset = glm::vec3(0.0f);
};

class BoxCollider : public Collider {
public:
    BoxCollider(const glm::vec3&amp; halfExtents) : m_HalfExtents(halfExtents) {}

    ColliderType GetType() const override { return ColliderType::Box; }

    const glm::vec3&amp; GetHalfExtents() const { return m_HalfExtents; }
    void SetHalfExtents(const glm::vec3&amp; halfExtents) { m_HalfExtents = halfExtents; }

private:
    glm::vec3 m_HalfExtents;
};

class SphereCollider : public Collider {
public:
    SphereCollider(float radius) : m_Radius(radius) {}

    ColliderType GetType() const override { return ColliderType::Sphere; }

    float GetRadius() const { return m_Radius; }
    void SetRadius(float radius) { m_Radius = radius; }

private:
    float m_Radius;
};

class RigidBody {
public:
    RigidBody();
    ~RigidBody();

    // Kinematic state
    void SetPosition(const glm::vec3&amp; position) { m_Position = position; }
    void SetRotation(const glm::quat&amp; rotation) { m_Rotation = rotation; }
    void SetLinearVelocity(const glm::vec3&amp; velocity) { m_LinearVelocity = velocity; }
    void SetAngularVelocity(const glm::vec3&amp; velocity) { m_AngularVelocity = velocity; }

    const glm::vec3&amp; GetPosition() const { return m_Position; }
    const glm::quat&amp; GetRotation() const { return m_Rotation; }
    const glm::vec3&amp; GetLinearVelocity() const { return m_LinearVelocity; }
    const glm::vec3&amp; GetAngularVelocity() const { return m_AngularVelocity; }

    // Physical properties
    void SetMass(float mass);
    float GetMass() const { return m_Mass; }
    float GetInverseMass() const { return m_InverseMass; }

    void SetRestitution(float restitution) { m_Restitution = restitution; }
    float GetRestitution() const { return m_Restitution; }

    void SetFriction(float friction) { m_Friction = friction; }
    float GetFriction() const { return m_Friction; }

    // Collider management
    void SetCollider(std::shared_ptr&lt;Collider&gt; collider) { m_Collider = collider; }
    std::shared_ptr&lt;Collider&gt; GetCollider() const { return m_Collider; }

    // Forces and impulses
    void ApplyForce(const glm::vec3&amp; force);
    void ApplyImpulse(const glm::vec3&amp; impulse);
    void ApplyTorque(const glm::vec3&amp; torque);
    void ApplyTorqueImpulse(const glm::vec3&amp; torqueImpulse);

    // Simulation flags
    void SetKinematic(bool kinematic) { m_IsKinematic = kinematic; }
    bool IsKinematic() const { return m_IsKinematic; }

    void SetGravityEnabled(bool enabled) { m_UseGravity = enabled; }
    bool IsGravityEnabled() const { return m_UseGravity; }

private:
    // Kinematic state
    glm::vec3 m_Position = glm::vec3(0.0f);
    glm::quat m_Rotation = glm::quat(1.0f, 0.0f, 0.0f, 0.0f);
    glm::vec3 m_LinearVelocity = glm::vec3(0.0f);
    glm::vec3 m_AngularVelocity = glm::vec3(0.0f);

    // Forces
    glm::vec3 m_AccumulatedForce = glm::vec3(0.0f);
    glm::vec3 m_AccumulatedTorque = glm::vec3(0.0f);

    // Physical properties
    float m_Mass = 1.0f;
    float m_InverseMass = 1.0f;
    glm::mat3 m_InertiaTensor = glm::mat3(1.0f);
    glm::mat3 m_InverseInertiaTensor = glm::mat3(1.0f);
    float m_Restitution = 0.5f;
    float m_Friction = 0.5f;

    // Collision
    std::shared_ptr&lt;Collider&gt; m_Collider;

    // Flags
    bool m_IsKinematic = false;
    bool m_UseGravity = true;

    // Update inertia tensor based on mass and collider
    void UpdateInertiaTensor();

    friend class PhysicsSystem;
};

struct CollisionInfo {
    std::shared_ptr&lt;RigidBody&gt; bodyA;
    std::shared_ptr&lt;RigidBody&gt; bodyB;
    glm::vec3 contactPoint;
    glm::vec3 normal;
    float penetrationDepth;
};

class PhysicsSystem {
public:
    PhysicsSystem();
    ~PhysicsSystem();

    void Initialize();
    void Shutdown();

    // Update physics simulation
    void Update(float deltaTime);

    // RigidBody management
    std::shared_ptr&lt;RigidBody&gt; CreateRigidBody();
    void DestroyRigidBody(std::shared_ptr&lt;RigidBody&gt; body);

    // World settings
    void SetGravity(const glm::vec3&amp; gravity) { m_Gravity = gravity; }
    const glm::vec3&amp; GetGravity() const { return m_Gravity; }

    // Collision detection
    bool Raycast(const glm::vec3&amp; origin, const glm::vec3&amp; direction, float maxDistance, RaycastHit&amp; hit);

private:
    std::vector&lt;std::shared_ptr&lt;RigidBody&gt;&gt; m_RigidBodies;
    glm::vec3 m_Gravity = glm::vec3(0.0f, -9.81f, 0.0f);

    // Simulation steps
    void IntegrateForces(RigidBody&amp; body, float deltaTime);
    void IntegrateVelocities(RigidBody&amp; body, float deltaTime);

    // Collision detection and response
    void DetectCollisions(std::vector&lt;CollisionInfo&gt;&amp; collisions);
    void ResolveCollisions(std::vector&lt;CollisionInfo&gt;&amp; collisions);

    // Helper functions for collision detection
    bool CheckCollision(const RigidBody&amp; bodyA, const RigidBody&amp; bodyB, CollisionInfo&amp; info);
    bool SphereVsSphere(const RigidBody&amp; bodyA, const RigidBody&amp; bodyB, CollisionInfo&amp; info);
    bool BoxVsBox(const RigidBody&amp; bodyA, const RigidBody&amp; bodyB, CollisionInfo&amp; info);
    bool SphereVsBox(const RigidBody&amp; bodyA, const RigidBody&amp; bodyB, CollisionInfo&amp; info);
};

struct RaycastHit {
    std::shared_ptr&lt;RigidBody&gt; body;
    glm::vec3 point;
    glm::vec3 normal;
    float distance;
};

} // namespace Physics
} // namespace Engine</code></pre>
</div>
</div>
<div class="paragraph">
<p>This basic structure provides a foundation for simulating rigid body physics with collision detection and response. In a real implementation, you would likely use a physics library like Bullet, PhysX, or Havok for more advanced features and optimizations.</p>
</div>
</div>
<div class="sect2">
<h3 id="_integrating_with_the_engine"><a class="anchor" href="#_integrating_with_the_engine"></a>Integrating with the Engine</h3>
<div class="paragraph">
<p>To integrate our physics system with the rest of our engine, we&#8217;ll add it to our engine&#8217;s main class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">// Engine.h
#include "Physics.h"

namespace Engine {

class Engine {
public:
    // ... existing engine code ...

    Physics::PhysicsSystem&amp; GetPhysicsSystem() { return m_PhysicsSystem; }

private:
    // ... existing engine members ...

    Physics::PhysicsSystem m_PhysicsSystem;
};

} // namespace Engine</code></pre>
</div>
</div>
<div class="paragraph">
<p>And we&#8217;ll initialize it during engine startup:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">// Engine.cpp
void Engine::Initialize() {
    // ... existing initialization code ...

    m_PhysicsSystem.Initialize();
}

void Engine::Shutdown() {
    m_PhysicsSystem.Shutdown();

    // ... existing shutdown code ...
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_basic_implementation_of_physics_simulation"><a class="anchor" href="#_basic_implementation_of_physics_simulation"></a>Basic Implementation of Physics Simulation</h3>
<div class="paragraph">
<p>To keep the update loop easy to follow, think of a fixed‑timestep frame as six steps:</p>
</div>
<div class="paragraph">
<p>1) Accumulate forces (e.g., gravity, user forces)
2) Integrate forces (update velocities with damping)
3) Detect collisions (broad/narrow checks per pair)
4) Resolve collisions (impulses + positional correction)
5) Integrate velocities (update positions and orientations)
6) Clear forces (prepare for next step)</p>
</div>
<div class="paragraph">
<p>Let&#8217;s implement the core physics simulation functions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">// Physics.cpp
#include "Physics.h"

namespace Engine {
namespace Physics {

void PhysicsSystem::Update(float deltaTime) {
    // Fixed timestep for stability
    const float fixedTimeStep = 1.0f / 60.0f;

    // Accumulate forces (e.g., gravity)
    for (auto&amp; body : m_RigidBodies) {
        if (!body-&gt;IsKinematic() &amp;&amp; body-&gt;IsGravityEnabled()) {
            body-&gt;m_AccumulatedForce += m_Gravity * body-&gt;m_Mass;
        }
    }

    // Integrate forces
    for (auto&amp; body : m_RigidBodies) {
        if (!body-&gt;IsKinematic()) {
            IntegrateForces(*body, fixedTimeStep);
        }
    }

    // Detect and resolve collisions
    std::vector&lt;CollisionInfo&gt; collisions;
    DetectCollisions(collisions);
    ResolveCollisions(collisions);

    // Integrate velocities
    for (auto&amp; body : m_RigidBodies) {
        if (!body-&gt;IsKinematic()) {
            IntegrateVelocities(*body, fixedTimeStep);
        }
    }

    // Clear accumulated forces
    for (auto&amp; body : m_RigidBodies) {
        body-&gt;m_AccumulatedForce = glm::vec3(0.0f);
        body-&gt;m_AccumulatedTorque = glm::vec3(0.0f);
    }
}

void PhysicsSystem::IntegrateForces(RigidBody&amp; body, float deltaTime) {
    // Update linear velocity
    body.m_LinearVelocity += (body.m_AccumulatedForce * body.m_InverseMass) * deltaTime;

    // Update angular velocity
    body.m_AngularVelocity += glm::vec3(body.m_InverseInertiaTensor * glm::vec4(body.m_AccumulatedTorque, 0.0f)) * deltaTime;

    // Apply damping
    const float linearDamping = 0.01f;
    const float angularDamping = 0.01f;
    body.m_LinearVelocity *= (1.0f - linearDamping);
    body.m_AngularVelocity *= (1.0f - angularDamping);
}

void PhysicsSystem::IntegrateVelocities(RigidBody&amp; body, float deltaTime) {
    // Update position
    body.m_Position += body.m_LinearVelocity * deltaTime;

    // Update rotation
    glm::quat angularVelocityQuat(0.0f, body.m_AngularVelocity.x, body.m_AngularVelocity.y, body.m_AngularVelocity.z);
    body.m_Rotation += (angularVelocityQuat * body.m_Rotation) * 0.5f * deltaTime;
    body.m_Rotation = glm::normalize(body.m_Rotation);
}

void PhysicsSystem::DetectCollisions(std::vector&lt;CollisionInfo&gt;&amp; collisions) {
    // Simple O(n²) collision detection
    for (size_t i = 0; i &lt; m_RigidBodies.size(); i++) {
        for (size_t j = i + 1; j &lt; m_RigidBodies.size(); j++) {
            auto&amp; bodyA = m_RigidBodies[i];
            auto&amp; bodyB = m_RigidBodies[j];

            // Skip if both bodies are kinematic
            if (bodyA-&gt;IsKinematic() &amp;&amp; bodyB-&gt;IsKinematic()) {
                continue;
            }

            // Skip if either body doesn't have a collider
            if (!bodyA-&gt;GetCollider() || !bodyB-&gt;GetCollider()) {
                continue;
            }

            CollisionInfo info;
            if (CheckCollision(*bodyA, *bodyB, info)) {
                info.bodyA = bodyA;
                info.bodyB = bodyB;
                collisions.push_back(info);
            }
        }
    }
}

void PhysicsSystem::ResolveCollisions(std::vector&lt;CollisionInfo&gt;&amp; collisions) {
    for (auto&amp; collision : collisions) {
        auto bodyA = collision.bodyA;
        auto bodyB = collision.bodyB;

        // Calculate relative velocity
        glm::vec3 relativeVelocity = bodyB-&gt;m_LinearVelocity - bodyA-&gt;m_LinearVelocity;

        // Calculate impulse magnitude
        float velocityAlongNormal = glm::dot(relativeVelocity, collision.normal);

        // Don't resolve if velocities are separating
        if (velocityAlongNormal &gt; 0) {
            continue;
        }

        // Calculate restitution (bounciness)
        float restitution = std::min(bodyA-&gt;m_Restitution, bodyB-&gt;m_Restitution);

        // Calculate impulse scalar
        float j = -(1.0f + restitution) * velocityAlongNormal;
        j /= bodyA-&gt;m_InverseMass + bodyB-&gt;m_InverseMass;

        // Apply impulse
        glm::vec3 impulse = collision.normal * j;

        if (!bodyA-&gt;IsKinematic()) {
            bodyA-&gt;m_LinearVelocity -= impulse * bodyA-&gt;m_InverseMass;
        }

        if (!bodyB-&gt;IsKinematic()) {
            bodyB-&gt;m_LinearVelocity += impulse * bodyB-&gt;m_InverseMass;
        }

        // Resolve penetration (position correction)
        const float percent = 0.2f; // usually 20% to 80%
        const float slop = 0.01f; // small penetration allowed
        glm::vec3 correction = std::max(collision.penetrationDepth - slop, 0.0f) * percent * collision.normal / (bodyA-&gt;m_InverseMass + bodyB-&gt;m_InverseMass);

        if (!bodyA-&gt;IsKinematic()) {
            bodyA-&gt;m_Position -= correction * bodyA-&gt;m_InverseMass;
        }

        if (!bodyB-&gt;IsKinematic()) {
            bodyB-&gt;m_Position += correction * bodyB-&gt;m_InverseMass;
        }
    }
}

bool PhysicsSystem::CheckCollision(const RigidBody&amp; bodyA, const RigidBody&amp; bodyB, CollisionInfo&amp; info) {
    auto colliderA = bodyA.GetCollider();
    auto colliderB = bodyB.GetCollider();

    if (colliderA-&gt;GetType() == ColliderType::Sphere &amp;&amp; colliderB-&gt;GetType() == ColliderType::Sphere) {
        return SphereVsSphere(bodyA, bodyB, info);
    }
    else if (colliderA-&gt;GetType() == ColliderType::Box &amp;&amp; colliderB-&gt;GetType() == ColliderType::Box) {
        return BoxVsBox(bodyA, bodyB, info);
    }
    else if (colliderA-&gt;GetType() == ColliderType::Sphere &amp;&amp; colliderB-&gt;GetType() == ColliderType::Box) {
        return SphereVsBox(bodyA, bodyB, info);
    }
    else if (colliderA-&gt;GetType() == ColliderType::Box &amp;&amp; colliderB-&gt;GetType() == ColliderType::Sphere) {
        bool result = SphereVsBox(bodyB, bodyA, info);
        if (result) {
            // Flip normal direction
            info.normal = -info.normal;
        }
        return result;
    }

    // Unsupported collision types
    return false;
}

bool PhysicsSystem::SphereVsSphere(const RigidBody&amp; bodyA, const RigidBody&amp; bodyB, CollisionInfo&amp; info) {
    auto sphereA = std::static_pointer_cast&lt;SphereCollider&gt;(bodyA.GetCollider());
    auto sphereB = std::static_pointer_cast&lt;SphereCollider&gt;(bodyB.GetCollider());

    glm::vec3 posA = bodyA.GetPosition() + sphereA-&gt;GetOffset();
    glm::vec3 posB = bodyB.GetPosition() + sphereB-&gt;GetOffset();

    float radiusA = sphereA-&gt;GetRadius();
    float radiusB = sphereB-&gt;GetRadius();

    glm::vec3 direction = posB - posA;
    float distance = glm::length(direction);
    float minDistance = radiusA + radiusB;

    if (distance &gt;= minDistance) {
        return false;
    }

    // Normalize direction
    direction = distance &gt; 0.0001f ? direction / distance : glm::vec3(0, 1, 0);

    info.contactPoint = posA + direction * radiusA;
    info.normal = direction;
    info.penetrationDepth = minDistance - distance;

    return true;
}

// Implementation of BoxVsBox and SphereVsBox collision detection would go here
// These are more complex and would require additional helper functions

} // namespace Physics
} // namespace Engine</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_basic_usage_example"><a class="anchor" href="#_basic_usage_example"></a>Basic Usage Example</h3>
<div class="paragraph">
<p>Here&#8217;s how you might use this physics system in a game:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">// Game code
void Game::Initialize() {
    // Create a ground plane
    auto ground = m_Engine.GetPhysicsSystem().CreateRigidBody();
    ground-&gt;SetPosition(glm::vec3(0.0f, -1.0f, 0.0f));
    ground-&gt;SetKinematic(true); // Static object
    auto groundCollider = std::make_shared&lt;Physics::BoxCollider&gt;(glm::vec3(50.0f, 1.0f, 50.0f));
    ground-&gt;SetCollider(groundCollider);

    // Create a dynamic box
    auto box = m_Engine.GetPhysicsSystem().CreateRigidBody();
    box-&gt;SetPosition(glm::vec3(0.0f, 5.0f, 0.0f));
    box-&gt;SetMass(1.0f);
    auto boxCollider = std::make_shared&lt;Physics::BoxCollider&gt;(glm::vec3(0.5f, 0.5f, 0.5f));
    box-&gt;SetCollider(boxCollider);

    // Create a dynamic sphere
    auto sphere = m_Engine.GetPhysicsSystem().CreateRigidBody();
    sphere-&gt;SetPosition(glm::vec3(1.0f, 10.0f, 0.0f));
    sphere-&gt;SetMass(2.0f);
    auto sphereCollider = std::make_shared&lt;Physics::SphereCollider&gt;(0.7f);
    sphere-&gt;SetCollider(sphereCollider);

    // Store references to our objects
    m_PhysicsObjects.push_back(ground);
    m_PhysicsObjects.push_back(box);
    m_PhysicsObjects.push_back(sphere);
}

void Game::Update(float deltaTime) {
    // Update physics
    m_Engine.GetPhysicsSystem().Update(deltaTime);

    // Update visual representations of physics objects
    for (auto&amp; physicsObject : m_PhysicsObjects) {
        auto visualObject = m_PhysicsToVisualMap[physicsObject];
        if (visualObject) {
            visualObject-&gt;SetPosition(physicsObject-&gt;GetPosition());
            visualObject-&gt;SetRotation(physicsObject-&gt;GetRotation());
        }
    }
}

void Game::OnExplosion(const glm::vec3&amp; position, float force) {
    // Apply radial impulse to nearby objects
    for (auto&amp; physicsObject : m_PhysicsObjects) {
        if (!physicsObject-&gt;IsKinematic()) {
            glm::vec3 direction = physicsObject-&gt;GetPosition() - position;
            float distance = glm::length(direction);

            if (distance &lt; 10.0f) {
                direction = glm::normalize(direction);
                float impulseMagnitude = force * (1.0f - distance / 10.0f);
                physicsObject-&gt;ApplyImpulse(direction * impulseMagnitude);
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_limitations_of_basic_physics_systems"><a class="anchor" href="#_limitations_of_basic_physics_systems"></a>Limitations of Basic Physics Systems</h3>
<div class="paragraph">
<p>While this basic physics system provides the essential functionality for simulating rigid bodies in a game, it has several limitations:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Performance</strong>: The O(n²) collision detection becomes a bottleneck with many objects.</p>
</li>
<li>
<p><strong>Limited Collision Shapes</strong>: We&#8217;ve only implemented basic shapes like boxes and spheres.</p>
</li>
<li>
<p><strong>Stability Issues</strong>: Simple integrators and collision resolution can lead to instability.</p>
</li>
<li>
<p><strong>No Continuous Collision Detection</strong>: Fast-moving objects might tunnel through thin obstacles.</p>
</li>
<li>
<p><strong>Limited Constraints</strong>: We haven&#8217;t implemented joints, springs, or other constraints.</p>
</li>
<li>
<p><strong>CPU-Bound Processing</strong>: All calculations are performed on the CPU, limiting scalability.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>In the next section, we&#8217;ll explore how Vulkan compute shaders can address these limitations by offloading physics calculations to the GPU, particularly for large-scale simulations with many objects.</p>
</div>
<div class="paragraph">
<p><a href="03_vulkan_audio.adoc">Previous: Vulkan for Audio Processing</a> | <a href="05_vulkan_physics.adoc">Next: Vulkan for Physics Simulation</a></p>
</div>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer">
    <!--
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
    -->
</footer>
<script id="site-script" src="../../../../_/js/site.js" data-ui-root-path="../../../../_"></script>
<script async src="../../../../_/js/vendor/highlight.js"></script>
<script src="../../../../_/js/vendor/lunr.js" defer></script>
<script src="https://cdn.jsdelivr.net/pako/1.0.3/pako.min.js" defer></script>
<script src="../../../../_/js/search-ui.js" id="search-ui-script" data-site-root-path="../../../.." data-snippet-length="100" data-stylesheet="../../../../_/css/search.css" defer></script>
<script>
window.addEventListener('DOMContentLoaded', function(){
  try {
    var script = document.getElementById('search-ui-script');
    var siteRoot = (script && script.getAttribute('data-site-root-path')) || '';
    var manifestUrl = siteRoot + '/search-index/manifest.json';
    fetch(manifestUrl)
      .then(function (r) { return r.ok ? r.json() : Promise.reject(new Error('manifest not found')) })
      .then(function (manifest) { antoraSearch.bootstrap(lunr, manifest, siteRoot); })
      .catch(function () {
        var s = document.createElement('script');
        s.async = true;
        s.src = siteRoot + '/search-index.js';
        document.head.appendChild(s);
      });
  } catch (e) {
    // Fallback to monolithic index if anything goes wrong
    var s = document.createElement('script');
    s.async = true;
    s.src = '../../../../search-index.js';
    document.head.appendChild(s);
  }
});
</script>
  </body>
</html>

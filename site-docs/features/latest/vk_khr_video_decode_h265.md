# VK_KHR_video_decode_h265

## Metadata

- **Component**: features
- **Version**: latest
- **URL**: /features/latest/features/proposals/VK_KHR_video_decode_h265.html

## Table of Contents

- [1. Problem Statement](#_problem_statement)
- [1._Problem_Statement](#_problem_statement)
- [2. Solution Space](#_solution_space)
- [2._Solution_Space](#_solution_space)
- [3. Proposal](#_proposal)
- [3.1. Video Std Headers](#_video_std_headers)
- [3.1._Video_Std_Headers](#_video_std_headers)
- [3.2. H.265 Decode Profiles](#_h_265_decode_profiles)
- [3.2._H.265_Decode_Profiles](#_h_265_decode_profiles)
- [3.3. H.265 Decode Capabilities](#_h_265_decode_capabilities)
- [3.3._H.265_Decode_Capabilities](#_h_265_decode_capabilities)
- [3.4. H.265 Decode Parameter Sets](#_h_265_decode_parameter_sets)
- [3.4._H.265_Decode_Parameter_Sets](#_h_265_decode_parameter_sets)
- [3.5. H.265 Decoding Parameters](#_h_265_decoding_parameters)
- [3.5._H.265_Decoding_Parameters](#_h_265_decoding_parameters)
- [4. Examples](#_examples)
- [4.1. Select queue family with H.265 decode support](#_select_queue_family_with_h_265_decode_support)
- [4.1._Select_queue_family_with_H.265_decode_support](#_select_queue_family_with_h_265_decode_support)
- [4.2. Check support and query the capabilities for an H.265 decode profile](#_check_support_and_query_the_capabilities_for_an_h_265_decode_profile)
- [4.2._Check_support_and_query_the_capabilities_for_an_H.265_decode_profile](#_check_support_and_query_the_capabilities_for_an_h_265_decode_profile)
- [4.3. Create and update H.265 video session parameters objects](#_create_and_update_h_265_video_session_parameters_objects)
- [4.3._Create_and_update_H.265_video_session_parameters_objects](#_create_and_update_h_265_video_session_parameters_objects)
- [4.4. Record H.265 decode operation (video session without DPB slots)](#_record_h_265_decode_operation_video_session_without_dpb_slots)
- [4.4._Record_H.265_decode_operation_(video_session_without_DPB_slots)](#_record_h_265_decode_operation_video_session_without_dpb_slots)
- [4.5. Record H.265 decode operation with optional reference picture setup](#_record_h_265_decode_operation_with_optional_reference_picture_setup)
- [4.5._Record_H.265_decode_operation_with_optional_reference_picture_setup](#_record_h_265_decode_operation_with_optional_reference_picture_setup)
- [4.6. Record H.265 decode operation with reference picture list](#_record_h_265_decode_operation_with_reference_picture_list)
- [4.6._Record_H.265_decode_operation_with_reference_picture_list](#_record_h_265_decode_operation_with_reference_picture_list)
- [5. Issues](#_issues)
- [5.1. RESOLVED: In what form should codec-specific parameters be provided?](#_resolved_in_what_form_should_codec_specific_parameters_be_provided)
- [5.1._RESOLVED:_In_what_form_should_codec-specific_parameters_be_provided?](#_resolved_in_what_form_should_codec_specific_parameters_be_provided)
- [5.2. RESOLVED: Why the vulkan_video_codec_h265std video std header does not have a version number?](#_resolved_why_the_vulkan_video_codec_h265std_video_std_header_does_not_have_a_version_number)
- [5.2._RESOLVED:_Why_the_vulkan_video_codec_h265std_video_std_header_does_not_have_a_version_number?](#_resolved_why_the_vulkan_video_codec_h265std_video_std_header_does_not_have_a_version_number)
- [5.3. RESOLVED: What are the requirements for the codec-specific input parameters and bitstream data?](#_resolved_what_are_the_requirements_for_the_codec_specific_input_parameters_and_bitstream_data)
- [5.3._RESOLVED:_What_are_the_requirements_for_the_codec-specific_input_parameters_and_bitstream_data?](#_resolved_what_are_the_requirements_for_the_codec_specific_input_parameters_and_bitstream_data)
- [5.4. RESOLVED: How should PPS entries be identified?](#_resolved_how_should_pps_entries_be_identified)
- [5.4._RESOLVED:_How_should_PPS_entries_be_identified?](#_resolved_how_should_pps_entries_be_identified)
- [5.5. RESOLVED: Why is there a need for the application to specify the offset of individual slice segments of the decoded pictures?](#_resolved_why_is_there_a_need_for_the_application_to_specify_the_offset_of_individual_slice_segments_of_the_decoded_pictures)
- [5.5._RESOLVED:_Why_is_there_a_need_for_the_application_to_specify_the_offset_of_individual_slice_segments_of_the_decoded_pictures?](#_resolved_why_is_there_a_need_for_the_application_to_specify_the_offset_of_individual_slice_segments_of_the_decoded_pictures)
- [5.6. RESOLVED: Is H.265 Multiview content supported?](#_resolved_is_h_265_multiview_content_supported)
- [5.6._RESOLVED:_Is_H.265_Multiview_content_supported?](#_resolved_is_h_265_multiview_content_supported)
- [5.7. RESOLVED: Is the worst case size of all input structures for H.265 VPS and SPS entries prohibitively large for embedded devices?](#_resolved_is_the_worst_case_size_of_all_input_structures_for_h_265_vps_and_sps_entries_prohibitively_large_for_embedded_devices)
- [5.7._RESOLVED:_Is_the_worst_case_size_of_all_input_structures_for_H.265_VPS_and_SPS_entries_prohibitively_large_for_embedded_devices?](#_resolved_is_the_worst_case_size_of_all_input_structures_for_h_265_vps_and_sps_entries_prohibitively_large_for_embedded_devices)
- [5.8. RESOLVED: Why are H.265 level indicator values specified differently than the way they are defined in the codec specification?](#_resolved_why_are_h_265_level_indicator_values_specified_differently_than_the_way_they_are_defined_in_the_codec_specification)
- [5.8._RESOLVED:_Why_are_H.265_level_indicator_values_specified_differently_than_the_way_they_are_defined_in_the_codec_specification?](#_resolved_why_are_h_265_level_indicator_values_specified_differently_than_the_way_they_are_defined_in_the_codec_specification)
- [5.9. RESOLVED: How is reference picture setup requested for H.265 decode operations?](#_resolved_how_is_reference_picture_setup_requested_for_h_265_decode_operations)
- [5.9._RESOLVED:_How_is_reference_picture_setup_requested_for_H.265_decode_operations?](#_resolved_how_is_reference_picture_setup_requested_for_h_265_decode_operations)
- [6. Further Functionality](#_further_functionality)
- [6._Further_Functionality](#_further_functionality)

## Content

Table of Contents 1. Problem Statement 2. Solution Space 3. Proposal 3.1. Video Std Headers 3.2. H.265 Decode Profiles 3.3. H.265 Decode Capabilities 3.4. H.265 Decode Parameter Sets 3.5. H.265 Decoding Parameters 4. Examples 4.1. Select queue family with H.265 decode support 4.2. Check support and query the capabilities for an H.265 decode profile 4.3. Create and update H.265 video session parameters objects 4.4. Record H.265 decode operation (video session without DPB slots) 4.5. Record H.265 decode operation with optional reference picture setup 4.6. Record H.265 decode operation with reference picture list 5. Issues 5.1. RESOLVED: In what form should codec-specific parameters be provided? 5.2. RESOLVED: Why the vulkan_video_codec_h265std video std header does not have a version number? 5.3. RESOLVED: What are the requirements for the codec-specific input parameters and bitstream data? 5.4. RESOLVED: How should PPS entries be identified? 5.5. RESOLVED: Why is there a need for the application to specify the offset of individual slice segments of the decoded pictures? 5.6. RESOLVED: Is H.265 Multiview content supported? 5.7. RESOLVED: Is the worst case size of all input structures for H.265 VPS and SPS entries prohibitively large for embedded devices? 5.8. RESOLVED: Why are H.265 level indicator values specified differently than the way they are defined in the codec specification? 5.9. RESOLVED: How is reference picture setup requested for H.265 decode operations? 6. Further Functionality This document outlines a proposal to enable performing H.265/HEVC video decode operations in Vulkan. The VK_KHR_video_queue extension introduces support for video coding operations and the VK_KHR_video_decode_queue extension further extends this with APIs specific to video decoding. The goal of this proposal is to build upon this infrastructure to introduce support for decoding elementary video stream sequences compliant with the H.265/HEVC video compression standard. As the VK_KHR_video_queue and VK_KHR_video_decode_queue extensions already laid down the architecture for how codec-specific video decode extensions need to be designed, this extension only needs to define the APIs to provide the necessary codec-specific parameters at various points during the use of the codec-independent APIs. In particular: APIs allowing to specify H.265 video, sequence, and picture parameter sets (VPS, SPS, PPS) to be stored in video session parameters objects APIs allowing to specify H.265 information specific to the decoded picture, including references to previously stored VPS, SPS, and PPS entries APIs allowing to specify H.265 reference picture information specific to the active reference pictures and optional reconstructed picture used in video decode operations The following options have been considered to choose the structure of these definitions: Allow specifying packed codec-specific data to the APIs in the form they appear in bitstreams Specify codec-specific parameters through custom type definitions that the application can populate after parsing the corresponding data elements in the bitstreams Option (1) would allow for a simpler API, but it requires implementations to include an appropriate parser for these data elements. As decoding applications typically parse these data elements for other reasons anyway, this proposal choses option (2) to enable the application to provide the needed parameters through custom definitions provided by a video std header dedicated to H.265 video decoding. The following additional options have been considered to choose the way this video std header is defined: Include all definitions in this H.265 video decode std header Add a separate video std header that includes H.265 parameter definitions that can be shared across video decoding and video encoding use cases that the H.265 video decode std header depends on, and only include decode-specific definitions in the H.265 video decode std header Both options are reasonable, however, as the H.265 video decoding and H.265 video encoding functionalities were designed in parallel, this extension uses option (2) and introduces the following new video std headers: vulkan_video_codec_h265std - containing common definitions for all H.265 video coding operations vulkan_video_codec_h265std_decode - containing definitions specific to H.265 video decoding operations These headers can be included as follows: #include #include This extension uses the new vulkan_video_codec_h265std_decode video std header. Implementations must always support at least version 1.0.0 of this video std header. This extension introduces the new video codec operation VK_VIDEO_CODEC_OPERATION_DECODE_H265_BIT_KHR. This flag can be used to check whether a particular queue family supports decoding H.265/HEVC content, as returned in VkQueueFamilyVideoPropertiesKHR. An H.265 decode profile can be defined through a VkVideoProfileInfoKHR structure using this new video codec operation and by including the following new codec-specific profile information structure in the pNext chain: typedef struct VkVideoDecodeH265ProfileInfoKHR { VkStructureType sType; const void* pNext; StdVideoH265ProfileIdc stdProfileIdc; } VkVideoDecodeH265ProfileInfoKHR; stdProfileIdc specifies the H.265 profile indicator. Applications need to include the following new structure in the pNext chain of VkVideoCapabilitiesKHR when calling the vkGetPhysicalDeviceVideoCapabilitiesKHR command to retrieve the capabilities specific to H.265 video decoding: typedef struct VkVideoDecodeH265CapabilitiesKHR { VkStructureType sType; void* pNext; StdVideoH265LevelIdc maxLevelIdc; } VkVideoDecodeH265CapabilitiesKHR; maxLevelIdc indicates the maximum supported H.265 level indicator. The use of video session parameters objects is mandatory when decoding H.265 video streams. Applications need to include the following new structure in the pNext chain of VkVideoSessionParametersCreateInfoKHR when creating video session parameters objects for H.265 decode use, to specify the parameter set capacity of the created objects: typedef struct VkVideoDecodeH265SessionParametersCreateInfoKHR { VkStructureType sType; const void* pNext; uint32_t maxStdVPSCount; uint32_t maxStdSPSCount; uint32_t maxStdPPSCount; const VkVideoDecodeH265SessionParametersAddInfoKHR* pParametersAddInfo; } VkVideoDecodeH265SessionParametersCreateInfoKHR; The optional pParametersAddInfo member also allows specifying an initial set of parameter sets to add to the created object: typedef struct VkVideoDecodeH265SessionParametersAddInfoKHR { VkStructureType sType; const void* pNext; uint32_t stdVPSCount; const StdVideoH265VideoParameterSet* pStdVPSs; uint32_t stdSPSCount; const StdVideoH265SequenceParameterSet* pStdSPSs; uint32_t stdPPSCount; const StdVideoH265PictureParameterSet* pStdPPSs; } VkVideoDecodeH265SessionParametersAddInfoKHR; This structure can also be included in the pNext chain of VkVideoSessionParametersUpdateInfoKHR used in video session parameters update operations to add further parameter sets to an object after its creation. Individual parameter sets are stored using parameter set IDs as their keys, specifically: H.265 VPS entries are identified using a vps_video_parameter_set_id value H.265 SPS entries are identified using a pair of sps_video_parameter_set_id and sps_seq_parameter_set_id values H.265 PPS entries are identified using a triplet of sps_video_parameter_set_id, pps_seq_parameter_set_id, and pps_pic_parameter_set_id values Please note the inclusion of the VPS ID in the PPS key. This is needed because a PPS is not uniquely identified by its ID and the ID of the parent SPS, as multiple SPS entries may exist with the same ID that have different parent VPS IDs. In order to ensure the uniqueness of keys, all APIs referring to a PPS in this proposal also take the parent VPS ID of the SPS the PPS in question belongs to, to specify the full hierarchy of IDs. The H.265/HEVC video compression standard always requires a VPS, SPS, and PPS, hence the application has to add an instance of each parameter set to the used parameters object before being able to record video decode operations. Furthermore, the H.265/HEVC video compression standard also allows modifying existing parameter sets, but as parameters already stored in video session parameters objects cannot be changed in Vulkan, the application has to create new parameters objects in such cases, as described in the proposal for VK_KHR_video_queue. Decode parameters specific to H.265 need to be provided by the application through the pNext chain of VkVideoDecodeInfoKHR, using the following new structure: typedef struct VkVideoDecodeH265PictureInfoKHR { VkStructureType sType; const void* pNext; const StdVideoDecodeH265PictureInfo* pStdPictureInfo; uint32_t sliceSegmentCount; const uint32_t* pSliceSegmentOffsets; } VkVideoDecodeH265PictureInfoKHR; pStdPictureInfo points to the codec-specific decode parameters defined in the vulkan_video_codec_h265std_decode video std header, while the pSliceSegmentOffsets array contains the relative offset of individual slice segments of the picture within the video bitstream range used by the video decode operation. The active VPS, SPS, and PPS (sourced from the bound video session parameters object) are identified by the sps_video_parameter_set_id, pps_seq_parameter_set_id, and pps_pic_parameter_set_id parameters. Picture information specific to H.265 for the active reference pictures and the optional reconstructed picture need to be provided by the application through the pNext chain of corresponding elements of VkVideoDecodeInfoKHR::pReferenceSlots and the pNext chain of VkVideoDecodeInfoKHR::pSetupReferenceSlot, respectively, using the following new structure: typedef struct VkVideoDecodeH265DpbSlotInfoKHR { VkStructureType sType; const void* pNext; const StdVideoDecodeH265ReferenceInfo* pStdReferenceInfo; } VkVideoDecodeH265DpbSlotInfoKHR; pStdReferenceInfo points to the codec-specific reference picture parameters defined in the vulkan_video_codec_h265std_decode video std header. It is the application’s responsibility to specify video bitstream buffer data and codec-specific parameters that are compliant with the rules defined by the H.265/HEVC video compression standard. While it is not illegal, from the API usage’s point of view, to specify non-compliant inputs, they may cause the video decode operation to complete unsuccessfully and will cause the output pictures (decode output and reconstructed pictures) to have undefined contents after the execution of the operation. For more information about how to parse individual H.265 bitstream syntax elements, calculate derived values, and, in general, how to interpret these parameters, please refer to the corresponding sections of the ITU-T H.265 Specification. uint32_t queueFamilyIndex; uint32_t queueFamilyCount; vkGetPhysicalDeviceQueueFamilyProperties2(physicalDevice, &queueFamilyCount, NULL); VkQueueFamilyProperties2* props = calloc(queueFamilyCount, sizeof(VkQueueFamilyProperties2)); VkQueueFamilyVideoPropertiesKHR* videoProps = calloc(queueFamilyCount, sizeof(VkQueueFamilyVideoPropertiesKHR)); for (queueFamilyIndex = 0; queueFamilyIndex ., not the decimal encoding used within raw H.265/HEVC bitstreams. As specifying a reconstructed picture DPB slot and resource is always required per the latest revision of the video extensions, additional codec syntax controls whether reference picture setup is requested and, in response, the DPB slot is activated with the reconstructed picture. For H.265 decode, reference picture setup is requested and the DPB slot specified for the reconstructed picture is activated with the picture if and only if the StdVideoDecodeH265PictureInfo::flags.IsReference flag is set. Future extensions can further extend the capabilities provided here, e.g. exposing support to decode H.265 Multiview content.

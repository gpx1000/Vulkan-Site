# VK_EXT_graphics_pipeline_library

## Metadata

- **Component**: features
- **Version**: latest
- **URL**: /features/latest/features/proposals/VK_EXT_graphics_pipeline_library.html

## Table of Contents

- [1. Problem Statement](#_problem_statement)
- [1._Problem_Statement](#_problem_statement)
- [2. Solution Space](#_solution_space)
- [2._Solution_Space](#_solution_space)
- [3. Proposal](#_proposal)
- [3.1. Prior Art: VK_EXT_pipeline_library](#_prior_art_vk_ext_pipeline_library)
- [3.1._Prior_Art:_VK_EXT_pipeline_library](#_prior_art_vk_ext_pipeline_library)
- [3.2. Features](#_features)
- [3.3. Properties](#_properties)
- [3.4. Dividing up the graphics state](#_dividing_up_the_graphics_state)
- [3.4._Dividing_up_the_graphics_state](#_dividing_up_the_graphics_state)
- [3.4.1. Vertex Input Interface](#_vertex_input_interface)
- [3.4.1._Vertex_Input_Interface](#_vertex_input_interface)
- [3.4.2. Pre-Rasterization Shaders](#_pre_rasterization_shaders)
- [3.4.2._Pre-Rasterization_Shaders](#_pre_rasterization_shaders)
- [3.4.3. Fragment Shader](#_fragment_shader)
- [3.4.3._Fragment_Shader](#_fragment_shader)
- [3.4.4. Fragment Output Interface](#_fragment_output_interface)
- [3.4.4._Fragment_Output_Interface](#_fragment_output_interface)
- [3.4.5. Interactions with extensions](#_interactions_with_extensions)
- [3.4.5._Interactions_with_extensions](#_interactions_with_extensions)
- [3.5. Pipeline Layouts](#_pipeline_layouts)
- [3.5._Pipeline_Layouts](#_pipeline_layouts)
- [3.6. Linking](#_linking)
- [3.7. Deprecating shader modules](#_deprecating_shader_modules)
- [3.7._Deprecating_shader_modules](#_deprecating_shader_modules)
- [4. Examples](#_examples)
- [4.1. Compilation](#_compilation)
- [4.2. Linking](#_linking_2)
- [5. Issues](#_issues)
- [5.1. RESOLVED: Should the pre-rasterization stages be separated?](#_resolved_should_the_pre_rasterization_stages_be_separated)
- [5.1._RESOLVED:_Should_the_pre-rasterization_stages_be_separated?](#_resolved_should_the_pre_rasterization_stages_be_separated)
- [5.2. RESOLVED: What is the expected usage model?](#_resolved_what_is_the_expected_usage_model)
- [5.2._RESOLVED:_What_is_the_expected_usage_model?](#_resolved_what_is_the_expected_usage_model)
- [5.3. RESOLVED: Why is there suggested behavior for the implementation of pipeline caches instead of letting the caching be driven by the application?](#_resolved_why_is_there_suggested_behavior_for_the_implementation_of_pipeline_caches_instead_of_letting_the_caching_be_driven_by_the_application)
- [5.3._RESOLVED:_Why_is_there_suggested_behavior_for_the_implementation_of_pipeline_caches_instead_of_letting_the_caching_be_driven_by_the_application?](#_resolved_why_is_there_suggested_behavior_for_the_implementation_of_pipeline_caches_instead_of_letting_the_caching_be_driven_by_the_application)
- [5.4. RESOLVED: What are the downsides to using unoptimized pipelines?](#_resolved_what_are_the_downsides_to_using_unoptimized_pipelines)
- [5.4._RESOLVED:_What_are_the_downsides_to_using_unoptimized_pipelines?](#_resolved_what_are_the_downsides_to_using_unoptimized_pipelines)
- [5.5. RESOLVED: Are there any interactions with specialization constants?](#_resolved_are_there_any_interactions_with_specialization_constants)
- [5.5._RESOLVED:_Are_there_any_interactions_with_specialization_constants?](#_resolved_are_there_any_interactions_with_specialization_constants)
- [5.6. RESOLVED: Are there any interface matching requirements that will need to change, like SSOs in OpenGL/ES?](#_resolved_are_there_any_interface_matching_requirements_that_will_need_to_change_like_ssos_in_opengles)
- [5.6._RESOLVED:_Are_there_any_interface_matching_requirements_that_will_need_to_change,_like_SSOs_in_OpenGL/ES?](#_resolved_are_there_any_interface_matching_requirements_that_will_need_to_change_like_ssos_in_opengles)
- [5.7. RESOLVED: Should we allow passing SPIR-V directly into pipeline creation?](#_resolved_should_we_allow_passing_spir_v_directly_into_pipeline_creation)
- [5.7._RESOLVED:_Should_we_allow_passing_SPIR-V_directly_into_pipeline_creation?](#_resolved_should_we_allow_passing_spir_v_directly_into_pipeline_creation)
- [5.8. RESOLVED: Should we advertise a property for “free link” vs. “fast link”?](#_resolved_should_we_advertise_a_property_for_free_link_vs_fast_link)
- [5.8._RESOLVED:_Should_we_advertise_a_property_for_“free_link”_vs._“fast_link”?](#_resolved_should_we_advertise_a_property_for_free_link_vs_fast_link)
- [5.9. RESOLVED: Does anyone need the depth/stencil format to be provided with the depth bias state?](#_resolved_does_anyone_need_the_depthstencil_format_to_be_provided_with_the_depth_bias_state)
- [5.9._RESOLVED:_Does_anyone_need_the_depth/stencil_format_to_be_provided_with_the_depth_bias_state?](#_resolved_does_anyone_need_the_depthstencil_format_to_be_provided_with_the_depth_bias_state)
- [5.10. RESOLVED: With the recommendation to create an optimized pipeline as well as a fast linked pipeline, will this lead to additional memory consumption?](#_resolved_with_the_recommendation_to_create_an_optimized_pipeline_as_well_as_a_fast_linked_pipeline_will_this_lead_to_additional_memory_consumption)
- [5.10._RESOLVED:_With_the_recommendation_to_create_an_optimized_pipeline_as_well_as_a_fast_linked_pipeline,_will_this_lead_to_additional_memory_consumption?](#_resolved_with_the_recommendation_to_create_an_optimized_pipeline_as_well_as_a_fast_linked_pipeline_will_this_lead_to_additional_memory_consumption)
- [5.11. RESOLVED: Should the link time optimization bits apply to other pipeline libraries (e.g. ray tracing)?](#_resolved_should_the_link_time_optimization_bits_apply_to_other_pipeline_libraries_e_g_ray_tracing)
- [5.11._RESOLVED:_Should_the_link_time_optimization_bits_apply_to_other_pipeline_libraries_(e.g._ray_tracing)?](#_resolved_should_the_link_time_optimization_bits_apply_to_other_pipeline_libraries_e_g_ray_tracing)
- [5.12. RESOLVED: Does the shader module deprecation apply to other pipelines?](#_resolved_does_the_shader_module_deprecation_apply_to_other_pipelines)
- [5.12._RESOLVED:_Does_the_shader_module_deprecation_apply_to_other_pipelines?](#_resolved_does_the_shader_module_deprecation_apply_to_other_pipelines)
- [5.13. RESOLVED: Should VkPipelineDepthStencilStateCreateInfo be part of the fragment shader state or fragment output interface state?](#_resolved_should_vkpipelinedepthstencilstatecreateinfo_be_part_of_the_fragment_shader_state_or_fragment_output_interface_state)
- [5.13._RESOLVED:_Should_VkPipelineDepthStencilStateCreateInfo_be_part_of_the_fragment_shader_state_or_fragment_output_interface_state?](#_resolved_should_vkpipelinedepthstencilstatecreateinfo_be_part_of_the_fragment_shader_state_or_fragment_output_interface_state)
- [5.14. RESOLVED: Should VkPipelineMultisampleStateCreateInfo be required, even when the fragment shader does not make use of multisampling shader features?](#_resolved_should_vkpipelinemultisamplestatecreateinfo_be_required_even_when_the_fragment_shader_does_not_make_use_of_multisampling_shader_features)
- [5.14._RESOLVED:_Should_VkPipelineMultisampleStateCreateInfo_be_required,_even_when_the_fragment_shader_does_not_make_use_of_multisampling_shader_features?](#_resolved_should_vkpipelinemultisamplestatecreateinfo_be_required_even_when_the_fragment_shader_does_not_make_use_of_multisampling_shader_features)
- [5.15. RESOLVED: Should VkPipelineMultisampleStateCreateInfo be part of the fragment output interface instead?](#_resolved_should_vkpipelinemultisamplestatecreateinfo_be_part_of_the_fragment_output_interface_instead)
- [5.15._RESOLVED:_Should_VkPipelineMultisampleStateCreateInfo_be_part_of_the_fragment_output_interface_instead?](#_resolved_should_vkpipelinemultisamplestatecreateinfo_be_part_of_the_fragment_output_interface_instead)
- [5.16. RESOLVED: Should we add an explicit result code to pipeline creation to indicate that a pipeline compiled with link time optimization has been returned?](#_resolved_should_we_add_an_explicit_result_code_to_pipeline_creation_to_indicate_that_a_pipeline_compiled_with_link_time_optimization_has_been_returned)
- [5.16._RESOLVED:_Should_we_add_an_explicit_result_code_to_pipeline_creation_to_indicate_that_a_pipeline_compiled_with_link_time_optimization_has_been_returned?](#_resolved_should_we_add_an_explicit_result_code_to_pipeline_creation_to_indicate_that_a_pipeline_compiled_with_link_time_optimization_has_been_returned)
- [5.17. RESOLVED: Can pipeline caches return optimized pipelines without the VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT set?](#_resolved_can_pipeline_caches_return_optimized_pipelines_without_the_vk_pipeline_layout_create_independent_sets_bit_ext_set)
- [5.17._RESOLVED:_Can_pipeline_caches_return_optimized_pipelines_without_the_VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT_set?](#_resolved_can_pipeline_caches_return_optimized_pipelines_without_the_vk_pipeline_layout_create_independent_sets_bit_ext_set)

## Content

Table of Contents

[1. Problem Statement](#_problem_statement)
[2. Solution Space](#_solution_space)
[3. Proposal](#_proposal)

[3.1. Prior Art: VK_EXT_pipeline_library](#_prior_art_vk_ext_pipeline_library)
[3.2. Features](#_features)
[3.3. Properties](#_properties)
[3.4. Dividing up the graphics state](#_dividing_up_the_graphics_state)
[3.5. Pipeline Layouts](#_pipeline_layouts)
[3.6. Linking](#_linking)
[3.7. Deprecating shader modules](#_deprecating_shader_modules)

[4. Examples](#_examples)

[4.1. Compilation](#_compilation)
[4.2. Linking](#_linking_2)

[5. Issues](#_issues)

[5.1. RESOLVED: Should the pre-rasterization stages be separated?](#_resolved_should_the_pre_rasterization_stages_be_separated)
[5.2. RESOLVED: What is the expected usage model?](#_resolved_what_is_the_expected_usage_model)
[5.3. RESOLVED: Why is there suggested behavior for the implementation of pipeline caches instead of letting the caching be driven by the application?](#_resolved_why_is_there_suggested_behavior_for_the_implementation_of_pipeline_caches_instead_of_letting_the_caching_be_driven_by_the_application)
[5.4. RESOLVED: What are the downsides to using unoptimized pipelines?](#_resolved_what_are_the_downsides_to_using_unoptimized_pipelines)
[5.5. RESOLVED: Are there any interactions with specialization constants?](#_resolved_are_there_any_interactions_with_specialization_constants)
[5.6. RESOLVED: Are there any interface matching requirements that will need to change, like SSOs in OpenGL/ES?](#_resolved_are_there_any_interface_matching_requirements_that_will_need_to_change_like_ssos_in_opengles)
[5.7. RESOLVED: Should we allow passing SPIR-V directly into pipeline creation?](#_resolved_should_we_allow_passing_spir_v_directly_into_pipeline_creation)
[5.8. RESOLVED: Should we advertise a property for “free link” vs. “fast link”?](#_resolved_should_we_advertise_a_property_for_free_link_vs_fast_link)
[5.9. RESOLVED: Does anyone need the depth/stencil format to be provided with the depth bias state?](#_resolved_does_anyone_need_the_depthstencil_format_to_be_provided_with_the_depth_bias_state)
[5.10. RESOLVED: With the recommendation to create an optimized pipeline as well as a fast linked pipeline, will this lead to additional memory consumption?](#_resolved_with_the_recommendation_to_create_an_optimized_pipeline_as_well_as_a_fast_linked_pipeline_will_this_lead_to_additional_memory_consumption)
[5.11. RESOLVED: Should the link time optimization bits apply to other pipeline libraries (e.g. ray tracing)?](#_resolved_should_the_link_time_optimization_bits_apply_to_other_pipeline_libraries_e_g_ray_tracing)
[5.12. RESOLVED: Does the shader module deprecation apply to other pipelines?](#_resolved_does_the_shader_module_deprecation_apply_to_other_pipelines)
[5.13. RESOLVED: Should `VkPipelineDepthStencilStateCreateInfo` be part of the fragment shader state or fragment output interface state?](#_resolved_should_vkpipelinedepthstencilstatecreateinfo_be_part_of_the_fragment_shader_state_or_fragment_output_interface_state)
[5.14. RESOLVED: Should `VkPipelineMultisampleStateCreateInfo` be required, even when the fragment shader does not make use of multisampling shader features?](#_resolved_should_vkpipelinemultisamplestatecreateinfo_be_required_even_when_the_fragment_shader_does_not_make_use_of_multisampling_shader_features)
[5.15. RESOLVED: Should `VkPipelineMultisampleStateCreateInfo` be part of the fragment output interface instead?](#_resolved_should_vkpipelinemultisamplestatecreateinfo_be_part_of_the_fragment_output_interface_instead)
[5.16. RESOLVED: Should we add an explicit result code to pipeline creation to indicate that a pipeline compiled with link time optimization has been returned?](#_resolved_should_we_add_an_explicit_result_code_to_pipeline_creation_to_indicate_that_a_pipeline_compiled_with_link_time_optimization_has_been_returned)
[5.17. RESOLVED: Can pipeline caches return optimized pipelines without the `VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT` set?](#_resolved_can_pipeline_caches_return_optimized_pipelines_without_the_vk_pipeline_layout_create_independent_sets_bit_ext_set)

This document outlines a proposal to allow partial compilation of portions
of pipelines, improving the performance of pipeline compilation for
applications that have large numbers of materials, large amounts of
dynamic state, or continuously stream in new material definitions.

The original promise of monolithic pipelines in Vulkan was to enable
developers to construct all their state up front, avoiding the driver doing
dynamic compilation and patching shaders implicitly when recording draw
calls, resulting in unexpected hitches.

The reality however is that for many game engines, requiring most of this state up front
either fails to eliminate hitching,
or requires precompiling so many state combinations that the size of the
pipeline cache is nearly unmanageable.

Games engines are typically still managing enormous sets of state and
shader combinations, and this is not a purely technical problem.
It is still expected and encouraged that developers will limit the number
of these, but it doesn’t change the fact that at least in the
short-to-mid-term, developers are having real problems that can’t be solved by
telling them to reduce the number of pipelines.

This proposal does not aim to fully solve these issues, but instead provides
a key piece of infrastructure required to solve it.
The main aim of this proposal is to reduce the cost of loading novel state
and shader combinations within the rendering loop, thus avoiding hitching.

An additional constraint to be aware of is that any solution should not
regress the intended wins from moving to pipeline objects – there should be
no need for late-compilation or patching that is performed **implicitly** by
the implementation.
An expectation of any solution here is that GPU performance may suffer
due to sub-optimal linking, and the solution should provide a way to mitigate this.
Explicit late compilation or patching may be acceptable, but it should be
simple to perform, and applications should have control over when and how
it is done.

The following options have been considered:

Handle this inside the implementation

Additional dynamic state

Separately compiled pipeline/state blobs

Handling this inside the implementation would potentially solve the problem
for the class of apps that have this issue.
However, it takes the choice of fast-linking vs. whole program optimization
away from the application.
It also means fighting with drivers and performance guidelines to hit the
right usage to trigger it on each implementation.

As for dynamic state, it is likely that the list of state that is fully dynamic
across implementations has been all but exhausted at this point.
While vendors can choose to expose additional dynamic state as they see
fit, solving this problem portably needs a different solution.
Vendors trying to implement state that isn’t dynamic as if it were dynamic
will end up doing implicit work at command recording time, leading
inevitably to implicit compilation or patching of shaders – which is
undesirable.

Separately compiling chunks of state (e.g. individual shaders, vertex
inputs, render passes) allows for applications to individually compile
these chunks as they show up.
Enough information should be given in this early step that linking these
chunks together later has significant cost savings and can be done at record time
if necessary.
Implementations could “cheat” at separate chunk compilation by exposing
this extension by keeping the create information until the final link
step and compiling everything at once then.
In general it is desirable for implementations to avoid late compilation, but this
does allow the extension to be implemented more widely (including via a software layer),
providing better consistency for developers.
Explicitly advertising this detail could allow developers to make better
choices about how and when these pipelines are compiled.

This proposal focuses on option 3 – providing applications with the ability
to separately compile state chunks and later link them together.

For [VK_KHR_ray_tracing_pipeline](https://docs.vulkan.org/spec/latest/appendices/extensions.html#VK_KHR_ray_tracing_pipeline), pipelines
contain a significant number of shaders - making monolithic compilation
very slow.
[VK_KHR_pipeline_library](https://docs.vulkan.org/spec/latest/appendices/extensions.html#VK_KHR_pipeline_library) allowed
applications to create partial pipelines (pipeline libraries) containing
only a subset of the final shaders.
These pipeline libraries can be linked together to form a final executable.
Ray pipelines were relatively straightforward as only shaders are linked,
and there’s no “state” for ray shaders beyond the shader groups.

Graphics pipelines by comparison contain a lot of static state that needs
to be separated carefully, retaining any “interface” information.
However, this extension reuses the same underlying mechanism.

The following feature is exposed by this extension:

typedef struct VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           graphicsPipelineLibrary;
} VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT;

`graphicsPipelineLibrary` is the core feature enabling this
functionality.

The following properties are exposed by this extension:

typedef struct VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT {
    VkStructure sType;
    void*       pNext;
    VkBool32    graphicsPipelineLibraryFastLinking;
    VkBool32    graphicsPipelineLibraryIndependentInterpolationDecoration;
} VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT;

`graphicsPipelineLibraryFastLinking` indicates whether the cost of
linking pipelines without `VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT`
is comparable to recording a command in a command buffer, such that
applications can link pipelines on demand while recording commands.
If this property is not supported, linking should still be cheaper than
a full pipeline compilation.

If `graphicsPipelineLibraryIndependentInterpolationDecoration` is not
supported, applications must provide matching interpolation decorations in
both the last geometry stage and the fragment stage; if it is supported,
any geometry stage decorations are ignored.

Four sets of state that have been identified as often recombined by
applications are:

* 
Vertex Input Interface

* 
Pre-rasterization

* 
Post-rasterization

* 
Fragment Output Interface (including blend state)

The intent is to allow each of those to be independently compiled as far as
possible, along with relevant pieces of state that may need to match for
the final linked pipeline.

typedef struct VkGraphicsPipelineLibraryCreateInfoEXT {
    VkStructureType                      sType;
    void*                                pNext;
    VkGraphicsPipelineLibraryFlagsEXT    flags;
} VkGraphicsPipelineLibraryCreateInfoEXT;

typedef enum VkGraphicsPipelineLibraryFlagBitsEXT {
    VK_GRAPHICS_PIPELINE_LIBRARY_VERTEX_INPUT_INTERFACE_BIT_EXT = 0x00000001,
    VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT = 0x00000002,
    VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT = 0x00000004,
    VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT = 0x00000008,
} VkGraphicsPipelineLibraryFlagBitsEXT;

typedef VkFlags VkGraphicsPipelineLibraryFlagsEXT;

Pipeline libraries are created for the parts specified, and any parameters
required to create a library with those parts must be provided.

For all pipeline libraries
[VkPipelineCache](https://docs.vulkan.org/spec/latest/chapters/pipelines.html#VkPipelineCache), `basePipelineHandle`,
`basePipelineIndex`,
[VkPipelineCreationFeedbackCreateInfo](https://docs.vulkan.org/spec/latest/chapters/pipelines.html#VkPipelineCreationFeedbackCreateInfo),
and
[VkPipelineCompilerControlCreateInfoAMD](https://docs.vulkan.org/spec/latest/chapters/pipelines.html#VkPipelineCompilerControlCreateInfoAMD)
parameters are independently consumed and do not need to match between
libraries or for any final pipeline.
[VkPipelineCreateFlags](https://docs.vulkan.org/spec/latest/chapters/pipelines.html#VkPipelineCreateFlags) are also
independent, though `VK_PIPELINE_CREATE_LIBRARY_BIT_KHR` is required for
all pipeline libraries.
Only dynamic states that affect state consumed by a library are used,
other dynamic states are ignored and play no part in linked pipelines.
Where multiple pipeline libraries are built with the same required piece of
state, those states must match exactly when linked together.

The subset of
[VkGraphicsPipelineCreateInfo](https://docs.vulkan.org/spec/latest/chapters/pipelines.html#VkGraphicsPipelineCreateInfo)
used to compile each kind of pipeline library is listed in the following
sections, along with any pitfalls, quirks, or interactions that need
calling out.
Any state not explicitly listed for a particular library part will be
ignored when compiling that part.

A vertex input interface library is defined by the following state:

* 
[VkPipelineVertexInputStateCreateInfo](https://docs.vulkan.org/spec/latest/chapters/fxvertex.html#VkPipelineVertexInputStateCreateInfo)

* 
[VkPipelineInputAssemblyStateCreateInfo](https://docs.vulkan.org/spec/latest/chapters/drawing.html#VkPipelineInputAssemblyStateCreateInfo)

A pre-rasterization shader library is defined by the following state:

* 
A valid [VkPipelineShaderStageCreateInfo](https://docs.vulkan.org/spec/latest/chapters/pipelines.html#VkPipelineShaderStageCreateInfo)
for each pre-rasterization shader stage used

* 
Within the [VkPipelineLayout](https://docs.vulkan.org/spec/latest/chapters/descriptorsets.html#VkPipelineLayout), all
descriptor sets with pre-rasterization shader bindings if
`VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT` was specified.

If `VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT` was not specified,
the full pipeline layout must be specified.

[VkPipelineViewportStateCreateInfo](https://docs.vulkan.org/spec/latest/chapters/vertexpostproc.html#VkPipelineViewportStateCreateInfo)

* 
However, all the functionality in that structure is dynamic other than
the flags, and this extension allows the structure to be omitted such
that it is as-if it was zero-initialized.

[VkPipelineRasterizationStateCreateInfo](https://docs.vulkan.org/spec/latest/chapters/primsrast.html#VkPipelineRasterizationStateCreateInfo)

[VkPipelineTessellationStateCreateInfo](https://docs.vulkan.org/spec/latest/chapters/tessellation.html#VkPipelineTessellationStateCreateInfo)
is required if tessellation stages are included.

[VkRenderPass](https://docs.vulkan.org/spec/latest/chapters/renderpass.html#VkRenderPass) and `subpass` parameter

[VkPipelineRenderingCreateInfo](https://docs.vulkan.org/spec/latest/chapters/pipelines.html#VkPipelineRenderingCreateInfo) for the `viewMask` parameter - formats are ignored.

[VkPipelineDiscardRectangleStateCreateInfoEXT](https://docs.vulkan.org/spec/latest/chapters/fragops.html#VkPipelineDiscardRectangleStateCreateInfoEXT)

[VkPipelineFragmentShadingRateStateCreateInfoKHR](https://docs.vulkan.org/spec/latest/chapters/primsrast.html#VkPipelineFragmentShadingRateStateCreateInfoKHR)

A fragment shader library is defined by the following state:

* 
A valid [VkPipelineShaderStageCreateInfo](https://docs.vulkan.org/spec/latest/chapters/pipelines.html#VkPipelineShaderStageCreateInfo)
for the fragment shader stage.

* 
Within the [VkPipelineLayout](https://docs.vulkan.org/spec/latest/chapters/descriptorsets.html#VkPipelineLayout), all
descriptor sets with fragment shader bindings if
`VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT` was specified.

If `VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT` was not specified,
the full pipeline layout must be specified.

[VkPipelineMultisampleStateCreateInfo](https://docs.vulkan.org/spec/latest/chapters/primsrast.html#VkPipelineMultisampleStateCreateInfo)
if sample shading is enabled or `renderpass` is not `VK_NULL_HANDLE`.

[VkPipelineDepthStencilStateCreateInfo](https://docs.vulkan.org/spec/latest/chapters/fragops.html#VkPipelineDepthStencilStateCreateInfo)

[VkRenderPass](https://docs.vulkan.org/spec/latest/chapters/renderpass.html#VkRenderPass) and `subpass` parameter

[VkPipelineRenderingCreateInfo](https://docs.vulkan.org/spec/latest/chapters/pipelines.html#VkPipelineRenderingCreateInfo) for the `viewMask` parameter - formats are ignored.

[VkPipelineFragmentShadingRateStateCreateInfoKHR](https://docs.vulkan.org/spec/latest/chapters/primsrast.html#VkPipelineFragmentShadingRateStateCreateInfoKHR)

[VkPipelineFragmentShadingRateEnumStateCreateInfoNV](https://docs.vulkan.org/spec/latest/chapters/primsrast.html#VkPipelineFragmentShadingRateEnumStateCreateInfoNV)

[VkPipelineRepresentativeFragmentTestStateCreateInfoNV](https://docs.vulkan.org/spec/latest/chapters/fragops.html#VkPipelineRepresentativeFragmentTestStateCreateInfoNV)

Inclusion/omission of the
`VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR`
flag

Inclusion/omission of the
`VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT`
flag

A fragment output interface library is defined by the following state:

* 
[VkPipelineColorBlendStateCreateInfo](https://docs.vulkan.org/spec/latest/chapters/framebuffer.html#VkPipelineColorBlendStateCreateInfo)

* 
[VkPipelineMultisampleStateCreateInfo](https://docs.vulkan.org/spec/latest/chapters/primsrast.html#VkPipelineMultisampleStateCreateInfo)

* 
[VkRenderPass](https://docs.vulkan.org/spec/latest/chapters/renderpass.html#VkRenderPass) and `subpass` parameter

* 
[VkPipelineRenderingCreateInfo](https://docs.vulkan.org/spec/latest/chapters/pipelines.html#VkPipelineRenderingCreateInfo)

* 
[VkAttachmentSampleCountInfoAMD/NV](https://docs.vulkan.org/spec/latest/chapters/cmdbuffers.html#VkAttachmentSampleCountInfoAMD)

The required structures for each pipeline subset include anything in the `pNext`
chains of the listed structures; any extensions to these structures are thus
implicitly accounted for unless otherwise stated.
includes anything in the `pNext` chains of those structures, so any
extensions that extend these structures will be automatically accounted for.
If any extension allows parts of
[VkGraphicsPipelineCreateInfo](https://docs.vulkan.org/spec/latest/chapters/pipelines.html#VkGraphicsPipelineCreateInfo)
to be ignored, by default that part of the state will also be ignored when
using graphics pipeline libraries.
Any extension that extends the base
[VkGraphicsPipelineCreateInfo](https://docs.vulkan.org/spec/latest/chapters/pipelines.html#VkGraphicsPipelineCreateInfo)
directly, or otherwise differs from the above implicit interactions, will
need an explicit interaction.

To allow descriptor sets to be independently specified for each of the two shader library types, a new pipeline layout create flag is added:

typedef enum VkPipelineLayoutCreateFlagBits {
    VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT = 0x00000002
} VkPipelineLayoutCreateFlagBits;

When specified, fragment and pre-rasterization shader pipeline libraries only need to specify the descriptor sets used by that library.
Descriptor set layouts unused by a library may be set to `VK_NULL_HANDLE`.

Linking is performed by including the existing
[VkPipelineLibraryCreateInfoKHR](https://docs.vulkan.org/spec/latest/chapters/pipelines.html#VkPipelineLibraryCreateInfoKHR) structure in the pNext chain of
[VkGraphicsPipelineCreateInfo](https://docs.vulkan.org/spec/latest/chapters/pipelines.html#VkGraphicsPipelineCreateInfo).

typedef struct VkPipelineLibraryCreateInfoKHR {
    VkStructureType      sType;
    const void*          pNext;
    uint32_t             libraryCount;
    const VkPipeline*    pLibraries;
} VkPipelineLibraryCreateInfoKHR;

Libraries can be linked into other libraries recursively while there are
still state blobs that can be linked together.
E.g an application could create a library for the vertex input interface
and pre-rasterization shaders separately, then link them into a new
library.

A newly created graphics pipeline consists of the parts defined by
linked libraries, plus those defined by
[VkGraphicsPipelineLibraryCreateInfoEXT](https://docs.vulkan.org/spec/latest/chapters/pipelines.html#VkGraphicsPipelineLibraryCreateInfoEXT).
Parts specified in the pipeline must not overlap those defined by
libraries, and similarly multiple libraries must not provide the same
parts.
Any state required by multiple parts must match.

Graphics pipelines that contain a full set of libraries are executable, may
not be used for further linking, and must not have the
`VK_PIPELINE_CREATE_LIBRARY_BIT_KHR` set.
Graphics pipelines that contain only a subset of stages are not executable,
may be used for further linking, and must have
`VK_PIPELINE_CREATE_LIBRARY_BIT_KHR` set.

If `rasterizerDiscardEnable` is enabled, the complete set of parts does
not include fragment shader or fragment output interface
libraries.

Two additional bits control how linking is performed:

* 
`VK_PIPELINE_CREATE_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT`

* 
`VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT`

`VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT` allows applications
to specify that linking should perform an optimization pass; when this bit
is specified, additional optimizations will be performed at link time, and
the resulting pipeline should perform equivalently to a pipeline created
monolithically.

To perform link time optimizations,
`VK_PIPELINE_CREATE_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT` must be
specified on all pipeline libraries that are being linked together.
Implementations should retain any additional information needed to perform
optimizations at the final link step when this bit is present.

If the application created the final linked pipeline with pipeline layouts
including the `VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT` flag,
the final linked pipeline layout is the union of the layouts provided for
shader stages.
However, in the specific case that a final link is being performed between
stages and `VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT` is specified,
the application can override the pipeline layout with one that is compatible
with that union but does not have the
`VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT` flag set, allowing a
more optimal pipeline layout to be used when generating the final pipeline.

To make single-shader compilation consistent, shader modules will be
deprecated by allowing [VkShaderModuleCreateInfo](https://docs.vulkan.org/spec/latest/chapters/shaders.html#VkShaderModuleCreateInfo) to be chained to
[VkPipelineShaderStageCreateInfo](https://docs.vulkan.org/spec/latest/chapters/pipelines.html#VkPipelineShaderStageCreateInfo), and allowing the
[VkShaderModule](https://docs.vulkan.org/spec/latest/chapters/shaders.html#VkShaderModule) to be [VK_NULL_HANDLE](https://docs.vulkan.org/spec/latest/appendices/boilerplate.html#VK_NULL_HANDLE) in this case.
Applications can continue to use shader modules as they are not
being removed; but it’s strongly recommended to not use them.
The primary reason for this would be to allow bypassing what is in many
cases a useless copy, along with potential wasted storage if they are
retained.
There have been previous efforts to allow shader modules to be precompiled
in some way, but this functionality is now being made available in a more
reliable and portably agreed way, negating the need to focus efforts in
this area moving forward.

Initial compilation can now be organized into separate chunks, allowing
consistent earlier compilation for applications that have this information
available separately, and potentially allows more multithreading
opportunities for applications that do not.

Below is an example of the information needed to compile a vertex shader:

VkPipeline createVertexShader(
    VkDevice device,
    const uint32_t* pShader,
    size_t shaderSize,
    VkPipelineCache vertexShaderCache,
    VkPipelineLayout layout)
{
    VkShaderModuleCreateInfo shaderModuleCreateInfo{};
    shaderModuleCreateInfo.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;
    shaderModuleCreateInfo.codeSize = shaderSize;
    shaderModuleCreateInfo.pCode = pShader;

    VkGraphicsPipelineLibraryCreateInfoEXT libraryInfo{};
    libraryInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT;
    libraryInfo.flags = VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT;

    VkPipelineShaderStageCreateInfo stageCreateInfo{};
    stageCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    stageCreateInfo.pNext = &shaderModuleCreateInfo;
    stageCreateInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;
    stageCreateInfo.pName = "main";

    VkDynamicState vertexDynamicStates[2] = {
        VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT_EXT,
        VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT_EXT };

    VkPipelineDynamicStateCreateInfo dynamicInfo{};
    dynamicInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
    dynamicInfo.dynamicStateCount = 2;
    dynamicInfo.pDynamicStates = vertexDynamicStates;

    VkGraphicsPipelineCreateInfo vertexShaderCreateInfo{};
    vertexShaderCreateInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    vertexShaderCreateInfo.pNext = &libraryInfo;
    vertexShaderCreateInfo.flags = VK_PIPELINE_CREATE_LIBRARY_BIT_KHR |
        VK_PIPELINE_CREATE_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT;
    vertexShaderCreateInfo.stageCount = 1;
    vertexShaderCreateInfo.pStages = &stageCreateInfo;
    vertexShaderCreateInfo.layout = layout;
    vertexShaderCreateInfo.pDynamicState = &dynamicInfo;

    VkPipeline vertexShader;
    vkCreateGraphicsPipelines(
        device, vertexShaderCache, 1, &vertexShaderCreateInfo, NULL, &vertexShader);

    return vertexShader;
}

Linking is relatively straightforward - pipeline libraries in, executable
pipeline out, with the option of optimizing the pipeline or not.

VkPipeline linkExecutable(
    VkDevice device,
    VkPipeline* pLibraries,
    size_t libraryCount,
    VkPipelineCache executableCache,
    bool optimized)
{
    VkPipelineLibraryCreateInfoKHR linkingInfo{};
    linkingInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR;
    linkingInfo.libraryCount = libraryCount;
    linkingInfo.pLibraries = pLibraries;

    VkGraphicsPipelineCreateInfo executablePipelineCreateInfo{};
    executablePipelineCreateInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    executablePipelineCreateInfo.pNext = &linkingInfo;
    executablePipelineCreateInfo.flags |= optimized ?
        VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT : 0;

    VkPipeline executable = VK_NULL_HANDLE;

    vkCreateGraphicsPipelines(
        device, executableCache, 1, & executablePipelineCreateInfo, NULL, &executable);

    return executable;
}

While splitting the geometry stages may be possible, it’s a significant
amount of additional work for many vendors, the advantage for most
developers is unclear, and it would be difficult to make some of the
guarantees in this extension.

When a novel shader/stage combination is seen that requires compilation, it
should be compiled into a separate pipeline library as early as possible;
this should be possible alongside usual material/object loading
(e.g. texture/mesh streaming).
If an application has its own material cache, the library should be cached
there.
Applications should still use pipeline caches to amortize compilation
across similar stage blobs but should avoid mixing different stage types in
the same [VkPipelineCache](https://docs.vulkan.org/spec/latest/chapters/pipelines.html#VkPipelineCache), to avoid unnecessary lookup overhead.

Basic linking should then be done as early as the application is able.
Applications should ideally store/cache this pipeline with relevant objects.
Using a [VkPipelineCache](https://docs.vulkan.org/spec/latest/chapters/pipelines.html#VkPipelineCache) for this suboptimal pipeline is recommended;
implementations where this would provide no benefit should ignore the cache
lookup request for fast linking.

Once a basic link is done, the application should schedule a task for a
separate thread to create an optimized pipeline.
This should use pipeline caches in the same manner as existing monolithic
compilation, sharing this cache with fast-linked pipelines.
Implementations should prefer returning optimized pipelines from these
caches.
Applications should switch to the optimized pipeline as soon as they are
available.

Work to change the way pipelines are cached is ongoing; to avoid scope creep
the minimum set of features required to ensure things worked were added.
A future extension may change how a lot of this works, so it was undesirable to
design something that would be thrown away later.

A fast-linked pipeline may have a significant device performance penalty
compared to the final pipeline on some implementations.
Some vendors may have a negligible performance penalty; others will have
performance penalties differing based on which shader stages are compiled
together.
A rough estimate given by vendors is that it could be as bad as a 50%
penalty in the general case, with outliers performing even worse.

As general advice, applications should be aiming to keep the amount of work
in each frame performed by unoptimized pipelines relatively low (

No. This extension doesn’t change how specialization constants work – they
work as they do for existing pipelines.
If they’re provided, implementations are free to specialize the pipeline or
not, and cache pipelines that are specialized, unspecialized, or both.
Specialization constants must be provided alongside the shader stages using
them and cannot be provided at link time.
This may be something we want to address in a future extension.

Some implementations require the interpolation decorations in the last
geometry shader stage if pipeline libraries are used, and this is
advertised by the
`graphicsPipelineLibraryIndependentInterpolationDecoration` property.
It is expected that these implementations are serving markets where OpenGL
ES is dominant, where this requirement was never dropped for separate
shader objects, unlike OpenGL.

Yes. This simplifies compilation, avoids an unnecessary copy, and brings developers and implementations onto the same page.

Yes, as developers may want to adjust the way they manage pipelines.
If linking is more or less free, the expectation is that applications may
link pipelines on demand when recording draw calls.
If linking is going to take more time, they may try to more aggressively
pre-cache pipelines.
This has been added as the `graphicsPipelineLibraryFastLinking`
property.

Implementation and developer guidance is that if this feature bit is
advertised, applications should be able to link on demand, so the cost of
linking should be comparable to recording commands in a command buffer.

The depth format affects how depth bias is applied, but these are currently provided in separate parts of the pipeline.
Nobody has claimed this to be a problem.

Caches containing pipeline libraries will necessarily increase the total memory consumption of compiled pipelines, as applications will generally try to keep these available while pipeline could be streamed in/out.
Implementations may be able to use data in the library caches for the final pipelines in some circumstances, which could help mitigate it - but this is not guaranteed and will vary by vendor.

Fast-linked pipelines should not contribute to the total memory consumption if applications destroy the fast-linked pipeline once an optimized version exists.

Improvements to pipeline caches allowing selective eviction of individual caches could help with memory management here, but as this intersects with other known pipeline cache problems, this should be dealt with in a separate extension.

Yes, but it will not necessarily be subject to the same quality guarantees. Ray tracing pipeline libraries were not designed with this directly in mind, so while implementations should make use of these bits as best they can, it is not possible to make the same quality guarantees as for graphics pipelines.

Any future extensions using the pipeline library interface should be aware of these interactions and try to follow the intent of these bits as much as possible.

Yes.

Some vendors will make use of this information if it is available and would rather not see it move - however notably all of this state can be made dynamic. Applications wanting to avoid setting this state with the fragment shader library should use this dynamic state.

The fragment shader library only needs this information when sample shading is enabled.

Moving it to the output interface removes the need to create multiple fragment shader libraries for different MSAA rates, which some applications do as a part of dynamic performance tuning.
This only works when used in conjunction with dynamic rendering; when render pass objects are used, the sample rate will effectively be sourced from any subpass attachments due to validation constraints.
This could be made to work with subpasses with no attachments, but the additional complexity of adding that path had no clear benefit, so is disallowed.

No, as the complexity of handling this does not clearly translate to significant application wins.

Not unconditionally - if an implementation does not do anything with that flag then yes, but there is a functional difference then it cannot. I.e. the same as other pipeline state.

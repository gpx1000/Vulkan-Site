# Devices and Queues

## Metadata

- **Component**: spec
- **Version**: latest
- **URL**: /spec/latest/chapters/devsandqueues.html

## Table of Contents

- [Physical Devices](#devsandqueues-physical-device-enumeration)
- [Devices](#devsandqueues-devices)
- [Device Creation](#devsandqueues-device-creation)
- [Device Use](#devsandqueues-use)
- [Lost Device](#devsandqueues-lost-device)
- [Device Destruction](#devsandqueues-destruction)
- [Queues](#devsandqueues-queues)
- [Queue Family Properties](#devsandqueues-queueprops)
- [Queue_Family_Properties](#devsandqueues-queueprops)
- [Queue Creation](#devsandqueues-queue-creation)
- [Queue Family Index](#devsandqueues-index)
- [Queue_Family_Index](#devsandqueues-index)
- [Queue Priority](#devsandqueues-priority)
- [Queue Submission](#devsandqueues-submission)
- [Sparse Memory Binding](#devsandqueues-sparsebinding)
- [Sparse_Memory_Binding](#devsandqueues-sparsebinding)
- [Queue Destruction](#devsandqueues-queuedestruction)

## Content

Once Vulkan is initialized, devices and queues are the primary objects used to interact with a Vulkan implementation. Vulkan separates the concept of physical and logical devices. A physical device usually represents a single complete implementation of Vulkan (excluding instance-level functionality) available to the host, of which there are a finite number. A logical device represents an instance of that implementation with its own state and resources independent of other logical devices. Physical devices cannot be independently destroyed, and are instead destroyed with the VkInstance that they were retrieved from. Physical devices are represented by VkPhysicalDevice handles: // Provided by VK_VERSION_1_0 VK_DEFINE_HANDLE(VkPhysicalDevice) To retrieve a list of physical device objects representing the physical devices installed in the system, call: // Provided by VK_VERSION_1_0 VkResult vkEnumeratePhysicalDevices( VkInstance instance, uint32_t* pPhysicalDeviceCount, VkPhysicalDevice* pPhysicalDevices); instance is a handle to a Vulkan instance previously created with vkCreateInstance. pPhysicalDeviceCount is a pointer to an integer related to the number of physical devices available or queried, as described below. pPhysicalDevices is either NULL or a pointer to an array of VkPhysicalDevice handles. If pPhysicalDevices is NULL, then the number of physical devices available is returned in pPhysicalDeviceCount. Otherwise, pPhysicalDeviceCount must point to a variable set by the application to the number of elements in the pPhysicalDevices array, and on return the variable is overwritten with the number of handles actually written to pPhysicalDevices. If pPhysicalDeviceCount is less than the number of physical devices available, at most pPhysicalDeviceCount structures will be written, and VK_INCOMPLETE will be returned instead of VK_SUCCESS, to indicate that not all the available physical devices were returned. Valid Usage (Implicit) VUID-vkEnumeratePhysicalDevices-instance-parameter instance must be a valid VkInstance handle VUID-vkEnumeratePhysicalDevices-pPhysicalDeviceCount-parameter pPhysicalDeviceCount must be a valid pointer to a uint32_t value VUID-vkEnumeratePhysicalDevices-pPhysicalDevices-parameter If the value referenced by pPhysicalDeviceCount is not 0, and pPhysicalDevices is not NULL, pPhysicalDevices must be a valid pointer to an array of pPhysicalDeviceCount VkPhysicalDevice handles Return Codes Success VK_SUCCESS VK_INCOMPLETE Failure VK_ERROR_OUT_OF_HOST_MEMORY VK_ERROR_OUT_OF_DEVICE_MEMORY VK_ERROR_INITIALIZATION_FAILED To query general properties of physical devices once enumerated, call: // Provided by VK_VERSION_1_0 void vkGetPhysicalDeviceProperties( VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties* pProperties); physicalDevice is the handle to the physical device whose properties will be queried. pProperties is a pointer to a VkPhysicalDeviceProperties structure in which properties are returned. Valid Usage (Implicit) VUID-vkGetPhysicalDeviceProperties-physicalDevice-parameter physicalDevice must be a valid VkPhysicalDevice handle VUID-vkGetPhysicalDeviceProperties-pProperties-parameter pProperties must be a valid pointer to a VkPhysicalDeviceProperties structure The VkPhysicalDeviceProperties structure is defined as: // Provided by VK_VERSION_1_0 typedef struct VkPhysicalDeviceProperties { uint32_t apiVersion; uint32_t driverVersion; uint32_t vendorID; uint32_t deviceID; VkPhysicalDeviceType deviceType; char deviceName[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE]; uint8_t pipelineCacheUUID[VK_UUID_SIZE]; VkPhysicalDeviceLimits limits; VkPhysicalDeviceSparseProperties sparseProperties; } VkPhysicalDeviceProperties; apiVersion is the version of Vulkan supported by the device, encoded as described in Version Numbers. driverVersion is the vendor-specified version of the driver. vendorID is a unique identifier for the vendor (see below) of the physical device. deviceID is a unique identifier for the physical device among devices available from the vendor. deviceType is a VkPhysicalDeviceType specifying the type of device. deviceName is an array of VK_MAX_PHYSICAL_DEVICE_NAME_SIZE char containing a null-terminated UTF-8 string which is the name of the device. pipelineCacheUUID is an array of VK_UUID_SIZE uint8_t values representing a universally unique identifier for the device. limits is the VkPhysicalDeviceLimits structure specifying device-specific limits of the physical device. See Limits for details. sparseProperties is the VkPhysicalDeviceSparseProperties structure specifying various sparse related properties of the physical device. See Sparse Properties for details. The value of apiVersion may be different than the version returned by vkEnumerateInstanceVersion; either higher or lower. In such cases, the application must not use functionality that exceeds the version of Vulkan associated with a given object. The pApiVersion parameter returned by vkEnumerateInstanceVersion is the version associated with a VkInstance and its children, except for a VkPhysicalDevice and its children. VkPhysicalDeviceProperties::apiVersion is the version associated with a VkPhysicalDevice and its children. The encoding of driverVersion is implementation-defined. It may not use the same encoding as apiVersion. Applications should follow information from the vendor on how to extract the version information from driverVersion. On implementations that claim support for the Roadmap 2022 profile, the major and minor version expressed by apiVersion must be at least Vulkan 1.3. The vendorID and deviceID fields are provided to allow applications to adapt to device characteristics that are not adequately exposed by other Vulkan queries. These may include performance profiles, hardware errata, or other characteristics. The vendor identified by vendorID is the entity responsible for the most salient characteristics of the underlying implementation of the VkPhysicalDevice being queried. For example, in the case of a discrete GPU implementation, this should be the GPU chipset vendor. In the case of a hardware accelerator integrated into a system-on-chip (SoC), this should be the supplier of the silicon IP used to create the accelerator. If the vendor has a PCI vendor ID, the low 16 bits of vendorID must contain that PCI vendor ID, and the remaining bits must be zero. Otherwise, the value returned must be a valid Khronos vendor ID, obtained as described in the Vulkan Documentation and Extensions: Procedures and Conventions document in the section “Registering a Vendor ID with Khronos”. Khronos vendor IDs are allocated starting at 0x10000, to distinguish them from the PCI vendor ID namespace. Khronos vendor IDs are symbolically defined in the VkVendorId type. The vendor is also responsible for the value returned in deviceID. If the implementation is driven primarily by a PCI device with a PCI device ID, the low 16 bits of deviceID must contain that PCI device ID, and the remaining bits must be zero. Otherwise, the choice of what values to return may be dictated by operating system or platform policies - but should uniquely identify both the device version and any major configuration options (for example, core count in the case of multicore devices). The same device ID should be used for all physical implementations of that device version and configuration. For example, all uses of a specific silicon IP GPU version and configuration should use the same device ID, even if those uses occur in different SoCs. Khronos vendor IDs which may be returned in VkPhysicalDeviceProperties::vendorID are: // Provided by VK_VERSION_1_0 typedef enum VkVendorId { VK_VENDOR_ID_KHRONOS = 0x10000, VK_VENDOR_ID_VIV = 0x10001, VK_VENDOR_ID_VSI = 0x10002, VK_VENDOR_ID_KAZAN = 0x10003, VK_VENDOR_ID_CODEPLAY = 0x10004, VK_VENDOR_ID_MESA = 0x10005, VK_VENDOR_ID_POCL = 0x10006, VK_VENDOR_ID_MOBILEYE = 0x10007, } VkVendorId; Khronos vendor IDs may be allocated by vendors at any time. Only the latest canonical versions of this Specification, of the corresponding vk.xml API Registry, and of the corresponding vulkan_core.h header file must contain all reserved Khronos vendor IDs. Only Khronos vendor IDs are given symbolic names at present. PCI vendor IDs returned by the implementation can be looked up in the PCI-SIG database. VK_MAX_PHYSICAL_DEVICE_NAME_SIZE is the length in char values of an array containing a physical device name string, as returned in VkPhysicalDeviceProperties::deviceName. #define VK_MAX_PHYSICAL_DEVICE_NAME_SIZE 256U The physical device types which may be returned in VkPhysicalDeviceProperties::deviceType are: // Provided by VK_VERSION_1_0 typedef enum VkPhysicalDeviceType { VK_PHYSICAL_DEVICE_TYPE_OTHER = 0, VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU = 1, VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU = 2, VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU = 3, VK_PHYSICAL_DEVICE_TYPE_CPU = 4, } VkPhysicalDeviceType; VK_PHYSICAL_DEVICE_TYPE_OTHER - the device does not match any other available types. VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU - the device is typically one embedded in or tightly coupled with the host. VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU - the device is typically a separate processor connected to the host via an interlink. VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU - the device is typically a virtual node in a virtualization environment. VK_PHYSICAL_DEVICE_TYPE_CPU - the device is typically running on the same processors as the host. The physical device type is advertised for informational purposes only, and does not directly affect the operation of the system. However, the device type may correlate with other advertised properties or capabilities of the system, such as how many memory heaps there are. To query general properties of physical devices once enumerated, call: // Provided by VK_VERSION_1_1 void vkGetPhysicalDeviceProperties2( VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties2* pProperties); or the equivalent command // Provided by VK_KHR_get_physical_device_properties2 void vkGetPhysicalDeviceProperties2KHR( VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties2* pProperties); physicalDevice is the handle to the physical device whose properties will be queried. pProperties is a pointer to a VkPhysicalDeviceProperties2 structure in which properties are returned. Each structure in pProperties and its pNext chain contains members corresponding to implementation-dependent properties, behaviors, or limits. vkGetPhysicalDeviceProperties2 fills in each member to specify the corresponding value for the implementation. Valid Usage (Implicit) VUID-vkGetPhysicalDeviceProperties2-physicalDevice-parameter physicalDevice must be a valid VkPhysicalDevice handle VUID-vkGetPhysicalDeviceProperties2-pProperties-parameter pProperties must be a valid pointer to a VkPhysicalDeviceProperties2 structure The VkPhysicalDeviceProperties2 structure is defined as: // Provided by VK_VERSION_1_1 typedef struct VkPhysicalDeviceProperties2 { VkStructureType sType; void* pNext; VkPhysicalDeviceProperties properties; } VkPhysicalDeviceProperties2; or the equivalent // Provided by VK_KHR_get_physical_device_properties2 typedef VkPhysicalDeviceProperties2 VkPhysicalDeviceProperties2KHR; sType is a VkStructureType value identifying this structure. pNext is NULL or a pointer to a structure extending this structure. properties is a VkPhysicalDeviceProperties structure describing properties of the physical device. This structure is written with the same values as if it were written by vkGetPhysicalDeviceProperties. The pNext chain of this structure is used to extend the structure with properties defined by extensions. Valid Usage (Implicit) VUID-VkPhysicalDeviceProperties2-sType-sType sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2 VUID-VkPhysicalDeviceProperties2-pNext-pNext Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkPhysicalDeviceAccelerationStructurePropertiesKHR, VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT, VkPhysicalDeviceClusterAccelerationStructurePropertiesNV, VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI, VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR, VkPhysicalDeviceConservativeRasterizationPropertiesEXT, VkPhysicalDeviceCooperativeMatrix2PropertiesNV, VkPhysicalDeviceCooperativeMatrixPropertiesKHR, VkPhysicalDeviceCooperativeMatrixPropertiesNV, VkPhysicalDeviceCooperativeVectorPropertiesNV, VkPhysicalDeviceCopyMemoryIndirectPropertiesNV, VkPhysicalDeviceCudaKernelLaunchPropertiesNV, VkPhysicalDeviceCustomBorderColorPropertiesEXT, VkPhysicalDeviceDepthStencilResolveProperties, VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT, VkPhysicalDeviceDescriptorBufferPropertiesEXT, VkPhysicalDeviceDescriptorIndexingProperties, VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT, VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV, VkPhysicalDeviceDiscardRectanglePropertiesEXT, VkPhysicalDeviceDisplacementMicromapPropertiesNV, VkPhysicalDeviceDriverProperties, VkPhysicalDeviceDrmPropertiesEXT, VkPhysicalDeviceExtendedDynamicState3PropertiesEXT, VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV, VkPhysicalDeviceExternalComputeQueuePropertiesNV, VkPhysicalDeviceExternalFormatResolvePropertiesANDROID, VkPhysicalDeviceExternalMemoryHostPropertiesEXT, VkPhysicalDeviceFloatControlsProperties, VkPhysicalDeviceFragmentDensityMap2PropertiesEXT, VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT, VkPhysicalDeviceFragmentDensityMapPropertiesEXT, VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR, VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV, VkPhysicalDeviceFragmentShadingRatePropertiesKHR, VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT, VkPhysicalDeviceHostImageCopyProperties, VkPhysicalDeviceIDProperties, VkPhysicalDeviceImageAlignmentControlPropertiesMESA, VkPhysicalDeviceImageProcessing2PropertiesQCOM, VkPhysicalDeviceImageProcessingPropertiesQCOM, VkPhysicalDeviceInlineUniformBlockProperties, VkPhysicalDeviceLayeredApiPropertiesListKHR, VkPhysicalDeviceLayeredDriverPropertiesMSFT, VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT, VkPhysicalDeviceLineRasterizationProperties, VkPhysicalDeviceMaintenance3Properties, VkPhysicalDeviceMaintenance4Properties, VkPhysicalDeviceMaintenance5Properties, VkPhysicalDeviceMaintenance6Properties, VkPhysicalDeviceMaintenance7PropertiesKHR, VkPhysicalDeviceMapMemoryPlacedPropertiesEXT, VkPhysicalDeviceMemoryDecompressionPropertiesNV, VkPhysicalDeviceMeshShaderPropertiesEXT, VkPhysicalDeviceMeshShaderPropertiesNV, VkPhysicalDeviceMultiDrawPropertiesEXT, VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX, VkPhysicalDeviceMultiviewProperties, VkPhysicalDeviceNestedCommandBufferPropertiesEXT, VkPhysicalDeviceOpacityMicromapPropertiesEXT, VkPhysicalDeviceOpticalFlowPropertiesNV, VkPhysicalDevicePCIBusInfoPropertiesEXT, VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV, VkPhysicalDevicePerformanceQueryPropertiesKHR, VkPhysicalDevicePipelineBinaryPropertiesKHR, VkPhysicalDevicePipelineRobustnessProperties, VkPhysicalDevicePointClippingProperties, VkPhysicalDevicePortabilitySubsetPropertiesKHR, VkPhysicalDeviceProtectedMemoryProperties, VkPhysicalDeviceProvokingVertexPropertiesEXT, VkPhysicalDevicePushDescriptorProperties, VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV, VkPhysicalDeviceRayTracingPipelinePropertiesKHR, VkPhysicalDeviceRayTracingPropertiesNV, VkPhysicalDeviceRenderPassStripedPropertiesARM, VkPhysicalDeviceRobustness2PropertiesKHR, VkPhysicalDeviceSampleLocationsPropertiesEXT, VkPhysicalDeviceSamplerFilterMinmaxProperties, VkPhysicalDeviceSchedulingControlsPropertiesARM, VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM, VkPhysicalDeviceShaderCoreProperties2AMD, VkPhysicalDeviceShaderCorePropertiesAMD, VkPhysicalDeviceShaderCorePropertiesARM, VkPhysicalDeviceShaderEnqueuePropertiesAMDX, VkPhysicalDeviceShaderIntegerDotProductProperties, VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT, VkPhysicalDeviceShaderObjectPropertiesEXT, VkPhysicalDeviceShaderSMBuiltinsPropertiesNV, VkPhysicalDeviceShaderTileImagePropertiesEXT, VkPhysicalDeviceShadingRateImagePropertiesNV, VkPhysicalDeviceSubgroupProperties, VkPhysicalDeviceSubgroupSizeControlProperties, VkPhysicalDeviceSubpassShadingPropertiesHUAWEI, VkPhysicalDeviceTexelBufferAlignmentProperties, VkPhysicalDeviceTileMemoryHeapPropertiesQCOM, VkPhysicalDeviceTileShadingPropertiesQCOM, VkPhysicalDeviceTimelineSemaphoreProperties, VkPhysicalDeviceTransformFeedbackPropertiesEXT, VkPhysicalDeviceVertexAttributeDivisorProperties, VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT, VkPhysicalDeviceVulkan11Properties, VkPhysicalDeviceVulkan12Properties, VkPhysicalDeviceVulkan13Properties, or VkPhysicalDeviceVulkan14Properties VUID-VkPhysicalDeviceProperties2-sType-unique The sType value of each structure in the pNext chain must be unique The VkPhysicalDeviceVulkan11Properties structure is defined as: // Provided by VK_VERSION_1_2 typedef struct VkPhysicalDeviceVulkan11Properties { VkStructureType sType; void* pNext; uint8_t deviceUUID[VK_UUID_SIZE]; uint8_t driverUUID[VK_UUID_SIZE]; uint8_t deviceLUID[VK_LUID_SIZE]; uint32_t deviceNodeMask; VkBool32 deviceLUIDValid; uint32_t subgroupSize; VkShaderStageFlags subgroupSupportedStages; VkSubgroupFeatureFlags subgroupSupportedOperations; VkBool32 subgroupQuadOperationsInAllStages; VkPointClippingBehavior pointClippingBehavior; uint32_t maxMultiviewViewCount; uint32_t maxMultiviewInstanceIndex; VkBool32 protectedNoFault; uint32_t maxPerSetDescriptors; VkDeviceSize maxMemoryAllocationSize; } VkPhysicalDeviceVulkan11Properties; sType is a VkStructureType value identifying this structure. pNext is NULL or a pointer to a structure extending this structure. deviceUUID is an array of VK_UUID_SIZE uint8_t values representing a universally unique identifier for the device. driverUUID is an array of VK_UUID_SIZE uint8_t values representing a universally unique identifier for the driver build in use by the device. deviceLUID is an array of VK_LUID_SIZE uint8_t values representing a locally unique identifier for the device. deviceNodeMask is a uint32_t bitfield identifying the node within a linked device adapter corresponding to the device. deviceLUIDValid is a boolean value that will be VK_TRUE if deviceLUID contains a valid LUID and deviceNodeMask contains a valid node mask, and VK_FALSE if they do not. subgroupSize is the default number of invocations in each subgroup. subgroupSize is at least 1 if any of the physical device’s queues support VK_QUEUE_GRAPHICS_BIT or VK_QUEUE_COMPUTE_BIT. subgroupSize is a power-of-two. subgroupSupportedStages is a bitfield of VkShaderStageFlagBits describing the shader stages that group operations with subgroup scope are supported in. subgroupSupportedStages will have the VK_SHADER_STAGE_COMPUTE_BIT bit set if any of the physical device’s queues support VK_QUEUE_COMPUTE_BIT. subgroupSupportedOperations is a bitmask of VkSubgroupFeatureFlagBits specifying the sets of group operations with subgroup scope supported on this device. subgroupSupportedOperations will have the VK_SUBGROUP_FEATURE_BASIC_BIT bit set if any of the physical device’s queues support VK_QUEUE_GRAPHICS_BIT or VK_QUEUE_COMPUTE_BIT. subgroupQuadOperationsInAllStages is a boolean specifying whether quad group operations are available in all stages, or are restricted to fragment and compute stages. pointClippingBehavior is a VkPointClippingBehavior value specifying the point clipping behavior supported by the implementation. maxMultiviewViewCount is one greater than the maximum view index that can be used in a subpass. maxMultiviewInstanceIndex is the maximum valid value of instance index allowed to be generated by a drawing command recorded within a subpass of a multiview render pass instance. protectedNoFault specifies how an implementation behaves when an application attempts to write to unprotected memory in a protected queue operation, read from protected memory in an unprotected queue operation, or perform a query in a protected queue operation. If this limit is VK_TRUE, such writes will be discarded or have undefined values written, reads and queries will return undefined values. If this limit is VK_FALSE, applications must not perform these operations. See Protected Memory Access Rules for more information. maxPerSetDescriptors is a maximum number of descriptors (summed over all descriptor types) in a single descriptor set that is guaranteed to satisfy any implementation-dependent constraints on the size of a descriptor set itself. Applications can query whether a descriptor set that goes beyond this limit is supported using vkGetDescriptorSetLayoutSupport. maxMemoryAllocationSize is the maximum size of a memory allocation that can be created, even if there is more space available in the heap. If VkMemoryAllocateInfo::allocationSize is larger the error VK_ERROR_OUT_OF_DEVICE_MEMORY may be returned. If the VkPhysicalDeviceVulkan11Properties structure is included in the pNext chain of the VkPhysicalDeviceProperties2 structure passed to vkGetPhysicalDeviceProperties2, it is filled in with each corresponding implementation-dependent property. These properties correspond to Vulkan 1.1 functionality. The members of VkPhysicalDeviceVulkan11Properties have the same values as the corresponding members of VkPhysicalDeviceIDProperties, VkPhysicalDeviceSubgroupProperties, VkPhysicalDevicePointClippingProperties, VkPhysicalDeviceMultiviewProperties, VkPhysicalDeviceProtectedMemoryProperties, and VkPhysicalDeviceMaintenance3Properties. The subgroupSupportedStages, subgroupSupportedOperations, and subgroupQuadOperationsInAllStages members of this structure correspond respectively to the VkPhysicalDeviceSubgroupProperties::supportedStages, VkPhysicalDeviceSubgroupProperties::supportedOperations, and VkPhysicalDeviceSubgroupProperties::quadOperationsInAllStages members, but add the subgroup prefix to the member name. Valid Usage (Implicit) VUID-VkPhysicalDeviceVulkan11Properties-sType-sType sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES The VkPhysicalDeviceVulkan12Properties structure is defined as: // Provided by VK_VERSION_1_2 typedef struct VkPhysicalDeviceVulkan12Properties { VkStructureType sType; void* pNext; VkDriverId driverID; char driverName[VK_MAX_DRIVER_NAME_SIZE]; char driverInfo[VK_MAX_DRIVER_INFO_SIZE]; VkConformanceVersion conformanceVersion; VkShaderFloatControlsIndependence denormBehaviorIndependence; VkShaderFloatControlsIndependence roundingModeIndependence; VkBool32 shaderSignedZeroInfNanPreserveFloat16; VkBool32 shaderSignedZeroInfNanPreserveFloat32; VkBool32 shaderSignedZeroInfNanPreserveFloat64; VkBool32 shaderDenormPreserveFloat16; VkBool32 shaderDenormPreserveFloat32; VkBool32 shaderDenormPreserveFloat64; VkBool32 shaderDenormFlushToZeroFloat16; VkBool32 shaderDenormFlushToZeroFloat32; VkBool32 shaderDenormFlushToZeroFloat64; VkBool32 shaderRoundingModeRTEFloat16; VkBool32 shaderRoundingModeRTEFloat32; VkBool32 shaderRoundingModeRTEFloat64; VkBool32 shaderRoundingModeRTZFloat16; VkBool32 shaderRoundingModeRTZFloat32; VkBool32 shaderRoundingModeRTZFloat64; uint32_t maxUpdateAfterBindDescriptorsInAllPools; VkBool32 shaderUniformBufferArrayNonUniformIndexingNative; VkBool32 shaderSampledImageArrayNonUniformIndexingNative; VkBool32 shaderStorageBufferArrayNonUniformIndexingNative; VkBool32 shaderStorageImageArrayNonUniformIndexingNative; VkBool32 shaderInputAttachmentArrayNonUniformIndexingNative; VkBool32 robustBufferAccessUpdateAfterBind; VkBool32 quadDivergentImplicitLod; uint32_t maxPerStageDescriptorUpdateAfterBindSamplers; uint32_t maxPerStageDescriptorUpdateAfterBindUniformBuffers; uint32_t maxPerStageDescriptorUpdateAfterBindStorageBuffers; uint32_t maxPerStageDescriptorUpdateAfterBindSampledImages; uint32_t maxPerStageDescriptorUpdateAfterBindStorageImages; uint32_t maxPerStageDescriptorUpdateAfterBindInputAttachments; uint32_t maxPerStageUpdateAfterBindResources; uint32_t maxDescriptorSetUpdateAfterBindSamplers; uint32_t maxDescriptorSetUpdateAfterBindUniformBuffers; uint32_t maxDescriptorSetUpdateAfterBindUniformBuffersDynamic; uint32_t maxDescriptorSetUpdateAfterBindStorageBuffers; uint32_t maxDescriptorSetUpdateAfterBindStorageBuffersDynamic; uint32_t maxDescriptorSetUpdateAfterBindSampledImages; uint32_t maxDescriptorSetUpdateAfterBindStorageImages; uint32_t maxDescriptorSetUpdateAfterBindInputAttachments; VkResolveModeFlags supportedDepthResolveModes; VkResolveModeFlags supportedStencilResolveModes; VkBool32 independentResolveNone; VkBool32 independentResolve; VkBool32 filterMinmaxSingleComponentFormats; VkBool32 filterMinmaxImageComponentMapping; uint64_t maxTimelineSemaphoreValueDifference; VkSampleCountFlags framebufferIntegerColorSampleCounts; } VkPhysicalDeviceVulkan12Properties; sType is a VkStructureType value identifying this structure. pNext is NULL or a pointer to a structure extending this structure. driverID is a unique identifier for the driver of the physical device. driverName is an array of VK_MAX_DRIVER_NAME_SIZE char containing a null-terminated UTF-8 string which is the name of the driver. driverInfo is an array of VK_MAX_DRIVER_INFO_SIZE char containing a null-terminated UTF-8 string with additional information about the driver. conformanceVersion is the latest version of the Vulkan conformance test that the implementor has successfully tested this driver against prior to release (see VkConformanceVersion). denormBehaviorIndependence is a VkShaderFloatControlsIndependence value indicating whether, and how, denorm behavior can be set independently for different bit widths. roundingModeIndependence is a VkShaderFloatControlsIndependence value indicating whether, and how, rounding modes can be set independently for different bit widths. shaderSignedZeroInfNanPreserveFloat16 is a boolean value indicating whether sign of a zero, Nans and can be preserved in 16-bit floating-point computations. It also indicates whether the SignedZeroInfNanPreserve execution mode can be used for 16-bit floating-point types. shaderSignedZeroInfNanPreserveFloat32 is a boolean value indicating whether sign of a zero, Nans and can be preserved in 32-bit floating-point computations. It also indicates whether the SignedZeroInfNanPreserve execution mode can be used for 32-bit floating-point types. shaderSignedZeroInfNanPreserveFloat64 is a boolean value indicating whether sign of a zero, Nans and can be preserved in 64-bit floating-point computations. It also indicates whether the SignedZeroInfNanPreserve execution mode can be used for 64-bit floating-point types. shaderDenormPreserveFloat16 is a boolean value indicating whether denormals can be preserved in 16-bit floating-point computations. It also indicates whether the DenormPreserve execution mode can be used for 16-bit floating-point types. shaderDenormPreserveFloat32 is a boolean value indicating whether denormals can be preserved in 32-bit floating-point computations. It also indicates whether the DenormPreserve execution mode can be used for 32-bit floating-point types. shaderDenormPreserveFloat64 is a boolean value indicating whether denormals can be preserved in 64-bit floating-point computations. It also indicates whether the DenormPreserve execution mode can be used for 64-bit floating-point types. shaderDenormFlushToZeroFloat16 is a boolean value indicating whether denormals can be flushed to zero in 16-bit floating-point computations. It also indicates whether the DenormFlushToZero execution mode can be used for 16-bit floating-point types. shaderDenormFlushToZeroFloat32 is a boolean value indicating whether denormals can be flushed to zero in 32-bit floating-point computations. It also indicates whether the DenormFlushToZero execution mode can be used for 32-bit floating-point types. shaderDenormFlushToZeroFloat64 is a boolean value indicating whether denormals can be flushed to zero in 64-bit floating-point computations. It also indicates whether the DenormFlushToZero execution mode can be used for 64-bit floating-point types. shaderRoundingModeRTEFloat16 is a boolean value indicating whether an implementation supports the round-to-nearest-even rounding mode for 16-bit floating-point arithmetic and conversion instructions. It also indicates whether the RoundingModeRTE execution mode can be used for 16-bit floating-point types. shaderRoundingModeRTEFloat32 is a boolean value indicating whether an implementation supports the round-to-nearest-even rounding mode for 32-bit floating-point arithmetic and conversion instructions. It also indicates whether the RoundingModeRTE execution mode can be used for 32-bit floating-point types. shaderRoundingModeRTEFloat64 is a boolean value indicating whether an implementation supports the round-to-nearest-even rounding mode for 64-bit floating-point arithmetic and conversion instructions. It also indicates whether the RoundingModeRTE execution mode can be used for 64-bit floating-point types. shaderRoundingModeRTZFloat16 is a boolean value indicating whether an implementation supports the round-towards-zero rounding mode for 16-bit floating-point arithmetic and conversion instructions. It also indicates whether the RoundingModeRTZ execution mode can be used for 16-bit floating-point types. shaderRoundingModeRTZFloat32 is a boolean value indicating whether an implementation supports the round-towards-zero rounding mode for 32-bit floating-point arithmetic and conversion instructions. It also indicates whether the RoundingModeRTZ execution mode can be used for 32-bit floating-point types. shaderRoundingModeRTZFloat64 is a boolean value indicating whether an implementation supports the round-towards-zero rounding mode for 64-bit floating-point arithmetic and conversion instructions. It also indicates whether the RoundingModeRTZ execution mode can be used for 64-bit floating-point types. maxUpdateAfterBindDescriptorsInAllPools is the maximum number of descriptors (summed over all descriptor types) that can be created across all pools that are created with the VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT bit set. Pool creation may fail when this limit is exceeded, or when the space this limit represents is unable to satisfy a pool creation due to fragmentation. shaderUniformBufferArrayNonUniformIndexingNative is a boolean value indicating whether uniform buffer descriptors natively support non-uniform indexing. If this is VK_FALSE, then a single dynamic instance of an instruction that non-uniformly indexes an array of uniform buffers may execute multiple times in order to access all the descriptors. shaderSampledImageArrayNonUniformIndexingNative is a boolean value indicating whether sampler and image descriptors natively support non-uniform indexing. If this is VK_FALSE, then a single dynamic instance of an instruction that non-uniformly indexes an array of samplers or images may execute multiple times in order to access all the descriptors. shaderStorageBufferArrayNonUniformIndexingNative is a boolean value indicating whether storage buffer descriptors natively support non-uniform indexing. If this is VK_FALSE, then a single dynamic instance of an instruction that non-uniformly indexes an array of storage buffers may execute multiple times in order to access all the descriptors. shaderStorageImageArrayNonUniformIndexingNative is a boolean value indicating whether storage image descriptors natively support non-uniform indexing. If this is VK_FALSE, then a single dynamic instance of an instruction that non-uniformly indexes an array of storage images may execute multiple times in order to access all the descriptors. shaderInputAttachmentArrayNonUniformIndexingNative is a boolean value indicating whether input attachment descriptors natively support non-uniform indexing. If this is VK_FALSE, then a single dynamic instance of an instruction that non-uniformly indexes an array of input attachments may execute multiple times in order to access all the descriptors. robustBufferAccessUpdateAfterBind is a boolean value indicating whether robustBufferAccess can be enabled on a device simultaneously with descriptorBindingUniformBufferUpdateAfterBind, descriptorBindingStorageBufferUpdateAfterBind, descriptorBindingUniformTexelBufferUpdateAfterBind, and/or descriptorBindingStorageTexelBufferUpdateAfterBind. If this is VK_FALSE, then either robustBufferAccess must be disabled or all of these update-after-bind features must be disabled. Similarly, if this property is VK_FALSE, robustness must not be enabled through the VkPipelineRobustnessCreateInfo mechanism. quadDivergentImplicitLod is a boolean value indicating whether implicit LOD calculations for image operations have well-defined results when the image and/or sampler objects used for the instruction are not uniform within a quad. See Derivative Image Operations. maxPerStageDescriptorUpdateAfterBindSamplers is similar to maxPerStageDescriptorSamplers but counts descriptors from descriptor sets created with or without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set. maxPerStageDescriptorUpdateAfterBindUniformBuffers is similar to maxPerStageDescriptorUniformBuffers but counts descriptors from descriptor sets created with or without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set. maxPerStageDescriptorUpdateAfterBindStorageBuffers is similar to maxPerStageDescriptorStorageBuffers but counts descriptors from descriptor sets created with or without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set. maxPerStageDescriptorUpdateAfterBindSampledImages is similar to maxPerStageDescriptorSampledImages but counts descriptors from descriptor sets created with or without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set. maxPerStageDescriptorUpdateAfterBindStorageImages is similar to maxPerStageDescriptorStorageImages but counts descriptors from descriptor sets created with or without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set. maxPerStageDescriptorUpdateAfterBindInputAttachments is similar to maxPerStageDescriptorInputAttachments but counts descriptors from descriptor sets created with or without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set. maxPerStageUpdateAfterBindResources is similar to maxPerStageResources but counts descriptors from descriptor sets created with or without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set. maxDescriptorSetUpdateAfterBindSamplers is similar to maxDescriptorSetSamplers but counts descriptors from descriptor sets created with or without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set. maxDescriptorSetUpdateAfterBindUniformBuffers is similar to maxDescriptorSetUniformBuffers but counts descriptors from descriptor sets created with or without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set. maxDescriptorSetUpdateAfterBindUniformBuffersDynamic is similar to maxDescriptorSetUniformBuffersDynamic but counts descriptors from descriptor sets created with or without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set. While an application can allocate dynamic uniform buffer descriptors from a pool created with the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT, bindings for these descriptors must not be present in any descriptor set layout that includes bindings created with VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT. maxDescriptorSetUpdateAfterBindStorageBuffers is similar to maxDescriptorSetStorageBuffers but counts descriptors from descriptor sets created with or without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set. maxDescriptorSetUpdateAfterBindStorageBuffersDynamic is similar to maxDescriptorSetStorageBuffersDynamic but counts descriptors from descriptor sets created with or without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set. While an application can allocate dynamic storage buffer descriptors from a pool created with the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT, bindings for these descriptors must not be present in any descriptor set layout that includes bindings created with VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT. maxDescriptorSetUpdateAfterBindSampledImages is similar to maxDescriptorSetSampledImages but counts descriptors from descriptor sets created with or without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set. maxDescriptorSetUpdateAfterBindStorageImages is similar to maxDescriptorSetStorageImages but counts descriptors from descriptor sets created with or without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set. maxDescriptorSetUpdateAfterBindInputAttachments is similar to maxDescriptorSetInputAttachments but counts descriptors from descriptor sets created with or without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set. supportedDepthResolveModes is a bitmask of VkResolveModeFlagBits indicating the set of supported depth resolve modes. VK_RESOLVE_MODE_SAMPLE_ZERO_BIT must be included in the set but implementations may support additional modes. supportedStencilResolveModes is a bitmask of VkResolveModeFlagBits indicating the set of supported stencil resolve modes. VK_RESOLVE_MODE_SAMPLE_ZERO_BIT must be included in the set but implementations may support additional modes. VK_RESOLVE_MODE_AVERAGE_BIT must not be included in the set. independentResolveNone is VK_TRUE if the implementation supports setting the depth and stencil resolve modes to different values when one of those modes is VK_RESOLVE_MODE_NONE. Otherwise the implementation only supports setting both modes to the same value. independentResolve is VK_TRUE if the implementation supports all combinations of the supported depth and stencil resolve modes, including setting either depth or stencil resolve mode to VK_RESOLVE_MODE_NONE. An implementation that supports independentResolve must also support independentResolveNone. filterMinmaxSingleComponentFormats is a boolean value indicating whether a minimum set of required formats support min/max filtering. filterMinmaxImageComponentMapping is a boolean value indicating whether the implementation supports non-identity component mapping of the image when doing min/max filtering. maxTimelineSemaphoreValueDifference indicates the maximum difference allowed by the implementation between the current value of a timeline semaphore and any pending signal or wait operations. framebufferIntegerColorSampleCounts is a bitmask of VkSampleCountFlagBits indicating the color sample counts that are supported for all framebuffer color attachments with integer formats. If the VkPhysicalDeviceVulkan12Properties structure is included in the pNext chain of the VkPhysicalDeviceProperties2 structure passed to vkGetPhysicalDeviceProperties2, it is filled in with each corresponding implementation-dependent property. These properties correspond to Vulkan 1.2 functionality. The members of VkPhysicalDeviceVulkan12Properties must have the same values as the corresponding members of VkPhysicalDeviceDriverProperties, VkPhysicalDeviceFloatControlsProperties, VkPhysicalDeviceDescriptorIndexingProperties, VkPhysicalDeviceDepthStencilResolveProperties, VkPhysicalDeviceSamplerFilterMinmaxProperties, and VkPhysicalDeviceTimelineSemaphoreProperties. Valid Usage (Implicit) VUID-VkPhysicalDeviceVulkan12Properties-sType-sType sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES The VkPhysicalDeviceVulkan13Properties structure is defined as: // Provided by VK_VERSION_1_3 typedef struct VkPhysicalDeviceVulkan13Properties { VkStructureType sType; void* pNext; uint32_t minSubgroupSize; uint32_t maxSubgroupSize; uint32_t maxComputeWorkgroupSubgroups; VkShaderStageFlags requiredSubgroupSizeStages; uint32_t maxInlineUniformBlockSize; uint32_t maxPerStageDescriptorInlineUniformBlocks; uint32_t maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks; uint32_t maxDescriptorSetInlineUniformBlocks; uint32_t maxDescriptorSetUpdateAfterBindInlineUniformBlocks; uint32_t maxInlineUniformTotalSize; VkBool32 integerDotProduct8BitUnsignedAccelerated; VkBool32 integerDotProduct8BitSignedAccelerated; VkBool32 integerDotProduct8BitMixedSignednessAccelerated; VkBool32 integerDotProduct4x8BitPackedUnsignedAccelerated; VkBool32 integerDotProduct4x8BitPackedSignedAccelerated; VkBool32 integerDotProduct4x8BitPackedMixedSignednessAccelerated; VkBool32 integerDotProduct16BitUnsignedAccelerated; VkBool32 integerDotProduct16BitSignedAccelerated; VkBool32 integerDotProduct16BitMixedSignednessAccelerated; VkBool32 integerDotProduct32BitUnsignedAccelerated; VkBool32 integerDotProduct32BitSignedAccelerated; VkBool32 integerDotProduct32BitMixedSignednessAccelerated; VkBool32 integerDotProduct64BitUnsignedAccelerated; VkBool32 integerDotProduct64BitSignedAccelerated; VkBool32 integerDotProduct64BitMixedSignednessAccelerated; VkBool32 integerDotProductAccumulatingSaturating8BitUnsignedAccelerated; VkBool32 integerDotProductAccumulatingSaturating8BitSignedAccelerated; VkBool32 integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated; VkBool32 integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated; VkBool32 integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated; VkBool32 integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated; VkBool32 integerDotProductAccumulatingSaturating16BitUnsignedAccelerated; VkBool32 integerDotProductAccumulatingSaturating16BitSignedAccelerated; VkBool32 integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated; VkBool32 integerDotProductAccumulatingSaturating32BitUnsignedAccelerated; VkBool32 integerDotProductAccumulatingSaturating32BitSignedAccelerated; VkBool32 integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated; VkBool32 integerDotProductAccumulatingSaturating64BitUnsignedAccelerated; VkBool32 integerDotProductAccumulatingSaturating64BitSignedAccelerated; VkBool32 integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated; VkDeviceSize storageTexelBufferOffsetAlignmentBytes; VkBool32 storageTexelBufferOffsetSingleTexelAlignment; VkDeviceSize uniformTexelBufferOffsetAlignmentBytes; VkBool32 uniformTexelBufferOffsetSingleTexelAlignment; VkDeviceSize maxBufferSize; } VkPhysicalDeviceVulkan13Properties; sType is a VkStructureType value identifying this structure. pNext is NULL or a pointer to a structure extending this structure. minSubgroupSize is the minimum subgroup size supported by this device. minSubgroupSize is at least one if any of the physical device’s queues support VK_QUEUE_GRAPHICS_BIT or VK_QUEUE_COMPUTE_BIT. minSubgroupSize is a power-of-two. minSubgroupSize is less than or equal to maxSubgroupSize. minSubgroupSize is less than or equal to subgroupSize. maxSubgroupSize is the maximum subgroup size supported by this device. maxSubgroupSize is at least one if any of the physical device’s queues support VK_QUEUE_GRAPHICS_BIT or VK_QUEUE_COMPUTE_BIT. maxSubgroupSize is a power-of-two. maxSubgroupSize is greater than or equal to minSubgroupSize. maxSubgroupSize is greater than or equal to subgroupSize. maxComputeWorkgroupSubgroups is the maximum number of subgroups supported by the implementation within a workgroup. requiredSubgroupSizeStages is a bitfield of what shader stages support having a required subgroup size specified. maxInlineUniformBlockSize is the maximum size in bytes of an inline uniform block binding. maxPerStageDescriptorInlineUniformBlocks is the maximum number of inline uniform block bindings that can be accessible to a single shader stage in a pipeline layout. Descriptor bindings with a descriptor type of VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK count against this limit. Only descriptor bindings in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set count against this limit. maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks is similar to maxPerStageDescriptorInlineUniformBlocks but counts descriptor bindings from descriptor sets created with or without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set. maxDescriptorSetInlineUniformBlocks is the maximum number of inline uniform block bindings that can be included in descriptor bindings in a pipeline layout across all pipeline shader stages and descriptor set numbers. Descriptor bindings with a descriptor type of VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK count against this limit. Only descriptor bindings in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set count against this limit. maxDescriptorSetUpdateAfterBindInlineUniformBlocks is similar to maxDescriptorSetInlineUniformBlocks but counts descriptor bindings from descriptor sets created with or without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set. maxInlineUniformTotalSize is the maximum total size in bytes of all inline uniform block bindings, across all pipeline shader stages and descriptor set numbers, that can be included in a pipeline layout. Descriptor bindings with a descriptor type of VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK count against this limit. integerDotProduct8BitUnsignedAccelerated is a boolean that will be VK_TRUE if the support for 8-bit unsigned dot product operations using the OpUDotKHR SPIR-V instruction is accelerated as defined below. integerDotProduct8BitSignedAccelerated is a boolean that will be VK_TRUE if the support for 8-bit signed dot product operations using the OpSDotKHR SPIR-V instruction is accelerated as defined below. integerDotProduct8BitMixedSignednessAccelerated is a boolean that will be VK_TRUE if the support for 8-bit mixed signedness dot product operations using the OpSUDotKHR SPIR-V instruction is accelerated as defined below. integerDotProduct4x8BitPackedUnsignedAccelerated is a boolean that will be VK_TRUE if the support for 8-bit unsigned dot product operations from operands packed into 32-bit integers using the OpUDotKHR SPIR-V instruction is accelerated as defined below. integerDotProduct4x8BitPackedSignedAccelerated is a boolean that will be VK_TRUE if the support for 8-bit signed dot product operations from operands packed into 32-bit integers using the OpSDotKHR SPIR-V instruction is accelerated as defined below. integerDotProduct4x8BitPackedMixedSignednessAccelerated is a boolean that will be VK_TRUE if the support for 8-bit mixed signedness dot product operations from operands packed into 32-bit integers using the OpSUDotKHR SPIR-V instruction is accelerated as defined below. integerDotProduct16BitUnsignedAccelerated is a boolean that will be VK_TRUE if the support for 16-bit unsigned dot product operations using the OpUDotKHR SPIR-V instruction is accelerated as defined below. integerDotProduct16BitSignedAccelerated is a boolean that will be VK_TRUE if the support for 16-bit signed dot product operations using the OpSDotKHR SPIR-V instruction is accelerated as defined below. integerDotProduct16BitMixedSignednessAccelerated is a boolean that will be VK_TRUE if the support for 16-bit mixed signedness dot product operations using the OpSUDotKHR SPIR-V instruction is accelerated as defined below. integerDotProduct32BitUnsignedAccelerated is a boolean that will be VK_TRUE if the support for 32-bit unsigned dot product operations using the OpUDotKHR SPIR-V instruction is accelerated as defined below. integerDotProduct32BitSignedAccelerated is a boolean that will be VK_TRUE if the support for 32-bit signed dot product operations using the OpSDotKHR SPIR-V instruction is accelerated as defined below. integerDotProduct32BitMixedSignednessAccelerated is a boolean that will be VK_TRUE if the support for 32-bit mixed signedness dot product operations using the OpSUDotKHR SPIR-V instruction is accelerated as defined below. integerDotProduct64BitUnsignedAccelerated is a boolean that will be VK_TRUE if the support for 64-bit unsigned dot product operations using the OpUDotKHR SPIR-V instruction is accelerated as defined below. integerDotProduct64BitSignedAccelerated is a boolean that will be VK_TRUE if the support for 64-bit signed dot product operations using the OpSDotKHR SPIR-V instruction is accelerated as defined below. integerDotProduct64BitMixedSignednessAccelerated is a boolean that will be VK_TRUE if the support for 64-bit mixed signedness dot product operations using the OpSUDotKHR SPIR-V instruction is accelerated as defined below. integerDotProductAccumulatingSaturating8BitUnsignedAccelerated is a boolean that will be VK_TRUE if the support for 8-bit unsigned accumulating saturating dot product operations using the OpUDotAccSatKHR SPIR-V instruction is accelerated as defined below. integerDotProductAccumulatingSaturating8BitSignedAccelerated is a boolean that will be VK_TRUE if the support for 8-bit signed accumulating saturating dot product operations using the OpSDotAccSatKHR SPIR-V instruction is accelerated as defined below. integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated is a boolean that will be VK_TRUE if the support for 8-bit mixed signedness accumulating saturating dot product operations using the OpSUDotAccSatKHR SPIR-V instruction is accelerated as defined below. integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated is a boolean that will be VK_TRUE if the support for 8-bit unsigned accumulating saturating dot product operations from operands packed into 32-bit integers using the OpUDotAccSatKHR SPIR-V instruction is accelerated as defined below. integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated is a boolean that will be VK_TRUE if the support for 8-bit signed accumulating saturating dot product operations from operands packed into 32-bit integers using the OpSDotAccSatKHR SPIR-V instruction is accelerated as defined below. integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated is a boolean that will be VK_TRUE if the support for 8-bit mixed signedness accumulating saturating dot product operations from operands packed into 32-bit integers using the OpSUDotAccSatKHR SPIR-V instruction is accelerated as defined below. integerDotProductAccumulatingSaturating16BitUnsignedAccelerated is a boolean that will be VK_TRUE if the support for 16-bit unsigned accumulating saturating dot product operations using the OpUDotAccSatKHR SPIR-V instruction is accelerated as defined below. integerDotProductAccumulatingSaturating16BitSignedAccelerated is a boolean that will be VK_TRUE if the support for 16-bit signed accumulating saturating dot product operations using the OpSDotAccSatKHR SPIR-V instruction is accelerated as defined below. integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated is a boolean that will be VK_TRUE if the support for 16-bit mixed signedness accumulating saturating dot product operations using the OpSUDotAccSatKHR SPIR-V instruction is accelerated as defined below. integerDotProductAccumulatingSaturating32BitUnsignedAccelerated is a boolean that will be VK_TRUE if the support for 32-bit unsigned accumulating saturating dot product operations using the OpUDotAccSatKHR SPIR-V instruction is accelerated as defined below. integerDotProductAccumulatingSaturating32BitSignedAccelerated is a boolean that will be VK_TRUE if the support for 32-bit signed accumulating saturating dot product operations using the OpSDotAccSatKHR SPIR-V instruction is accelerated as defined below. integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated is a boolean that will be VK_TRUE if the support for 32-bit mixed signedness accumulating saturating dot product operations using the OpSUDotAccSatKHR SPIR-V instruction is accelerated as defined below. integerDotProductAccumulatingSaturating64BitUnsignedAccelerated is a boolean that will be VK_TRUE if the support for 64-bit unsigned accumulating saturating dot product operations using the OpUDotAccSatKHR SPIR-V instruction is accelerated as defined below. integerDotProductAccumulatingSaturating64BitSignedAccelerated is a boolean that will be VK_TRUE if the support for 64-bit signed accumulating saturating dot product operations using the OpSDotAccSatKHR SPIR-V instruction is accelerated as defined below. integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated is a boolean that will be VK_TRUE if the support for 64-bit mixed signedness accumulating saturating dot product operations using the OpSUDotAccSatKHR SPIR-V instruction is accelerated as defined below. storageTexelBufferOffsetAlignmentBytes is a byte alignment that is sufficient for a storage texel buffer of any format. The value must be a power of two. storageTexelBufferOffsetSingleTexelAlignment indicates whether single texel alignment is sufficient for a storage texel buffer of any format. uniformTexelBufferOffsetAlignmentBytes is a byte alignment that is sufficient for a uniform texel buffer of any format. The value must be a power of two. uniformTexelBufferOffsetSingleTexelAlignment indicates whether single texel alignment is sufficient for a uniform texel buffer of any format. maxBufferSize is the maximum size VkBuffer that can be created. If the VkPhysicalDeviceVulkan13Properties structure is included in the pNext chain of the VkPhysicalDeviceProperties2 structure passed to vkGetPhysicalDeviceProperties2, it is filled in with each corresponding implementation-dependent property. These properties correspond to Vulkan 1.3 functionality. The members of VkPhysicalDeviceVulkan13Properties must have the same values as the corresponding members of VkPhysicalDeviceInlineUniformBlockProperties and VkPhysicalDeviceSubgroupSizeControlProperties. Valid Usage (Implicit) VUID-VkPhysicalDeviceVulkan13Properties-sType-sType sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES The VkPhysicalDeviceVulkan14Properties structure is defined as: // Provided by VK_VERSION_1_4 typedef struct VkPhysicalDeviceVulkan14Properties { VkStructureType sType; void* pNext; uint32_t lineSubPixelPrecisionBits; uint32_t maxVertexAttribDivisor; VkBool32 supportsNonZeroFirstInstance; uint32_t maxPushDescriptors; VkBool32 dynamicRenderingLocalReadDepthStencilAttachments; VkBool32 dynamicRenderingLocalReadMultisampledAttachments; VkBool32 earlyFragmentMultisampleCoverageAfterSampleCounting; VkBool32 earlyFragmentSampleMaskTestBeforeSampleCounting; VkBool32 depthStencilSwizzleOneSupport; VkBool32 polygonModePointSize; VkBool32 nonStrictSinglePixelWideLinesUseParallelogram; VkBool32 nonStrictWideLinesUseParallelogram; VkBool32 blockTexelViewCompatibleMultipleLayers; uint32_t maxCombinedImageSamplerDescriptorCount; VkBool32 fragmentShadingRateClampCombinerInputs; VkPipelineRobustnessBufferBehavior defaultRobustnessStorageBuffers; VkPipelineRobustnessBufferBehavior defaultRobustnessUniformBuffers; VkPipelineRobustnessBufferBehavior defaultRobustnessVertexInputs; VkPipelineRobustnessImageBehavior defaultRobustnessImages; uint32_t copySrcLayoutCount; VkImageLayout* pCopySrcLayouts; uint32_t copyDstLayoutCount; VkImageLayout* pCopyDstLayouts; uint8_t optimalTilingLayoutUUID[VK_UUID_SIZE]; VkBool32 identicalMemoryTypeRequirements; } VkPhysicalDeviceVulkan14Properties; sType is a VkStructureType value identifying this structure. pNext is NULL or a pointer to a structure extending this structure. lineSubPixelPrecisionBits is the number of bits of subpixel precision in framebuffer coordinates xf and yf when rasterizing line segments. maxVertexAttribDivisor is the maximum value of the number of instances that will repeat the value of vertex attribute data when instanced rendering is enabled. supportsNonZeroFirstInstance specifies whether a non-zero value for the firstInstance parameter of drawing commands is supported when VkVertexInputBindingDivisorDescription::divisor is not 1. maxPushDescriptors is the maximum number of descriptors that can be used in a descriptor set layout created with VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT set. dynamicRenderingLocalReadDepthStencilAttachments is VK_TRUE if the implementation supports local reads of depth/stencil attachments, VK_FALSE otherwise. dynamicRenderingLocalReadMultisampledAttachments is VK_TRUE if the implementation supports local reads of multisampled attachments, VK_FALSE otherwise. earlyFragmentMultisampleCoverageAfterSampleCounting is a boolean value indicating whether the fragment shading and multisample coverage operations are performed after sample counting for fragment shaders with EarlyFragmentTests execution mode. earlyFragmentSampleMaskTestBeforeSampleCounting is a boolean value indicating whether the sample mask test operation is performed before sample counting for fragment shaders using the EarlyFragmentTests execution mode. depthStencilSwizzleOneSupport is a boolean indicating that depth/stencil texturing operations with VK_COMPONENT_SWIZZLE_ONE have defined behavior. polygonModePointSize is a boolean value indicating whether the point size of the final rasterization of polygons with VK_POLYGON_MODE_POINT is controlled by PointSize. nonStrictSinglePixelWideLinesUseParallelogram is a boolean value indicating whether non-strict lines with a width of 1.0 are rasterized as parallelograms or using Bresenham’s algorithm. nonStrictWideLinesUseParallelogram is a boolean value indicating whether non-strict lines with a width greater than 1.0 are rasterized as parallelograms or using Bresenham’s algorithm. blockTexelViewCompatibleMultipleLayers is a boolean value indicating that an implementation supports creating image views with VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT where the layerCount member of subresourceRange is greater than 1. maxCombinedImageSamplerDescriptorCount is the maximum number of combined image sampler descriptors that the implementation uses to access any of the formats that require a sampler Y′CBCR conversion supported by the implementation. fragmentShadingRateClampCombinerInputs is a boolean value indicating that an implementation clamps the inputs to combiner operations. defaultRobustnessStorageBuffers describes the behavior of out of bounds accesses made to storage buffers when no robustness features are enabled defaultRobustnessUniformBuffers describes the behavior of out of bounds accesses made to uniform buffers when no robustness features are enabled defaultRobustnessVertexInputs describes the behavior of out of bounds accesses made to vertex input attributes when no robustness features are enabled defaultRobustnessImages describes the behavior of out of bounds accesses made to images when no robustness features are enabled copySrcLayoutCount is an integer related to the number of image layouts for host copies from images available or queried, as described below. pCopySrcLayouts is a pointer to an array of VkImageLayout in which supported image layouts for use with host copy operations from images are returned. copyDstLayoutCount is an integer related to the number of image layouts for host copies to images available or queried, as described below. pCopyDstLayouts is a pointer to an array of VkImageLayout in which supported image layouts for use with host copy operations to images are returned. optimalTilingLayoutUUID is an array of VK_UUID_SIZE uint8_t values representing a universally unique identifier for the implementation’s swizzling layout of images created with VK_IMAGE_TILING_OPTIMAL. identicalMemoryTypeRequirements indicates that specifying the VK_IMAGE_USAGE_HOST_TRANSFER_BIT flag in VkImageCreateInfo::usage does not affect the memory type requirements of the image. If the VkPhysicalDeviceVulkan14Properties structure is included in the pNext chain of the VkPhysicalDeviceProperties2 structure passed to vkGetPhysicalDeviceProperties2, it is filled in with each corresponding implementation-dependent property. These properties correspond to Vulkan 1.4 functionality. Valid Usage (Implicit) VUID-VkPhysicalDeviceVulkan14Properties-sType-sType sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_PROPERTIES The VkPhysicalDeviceIDProperties structure is defined as: // Provided by VK_VERSION_1_1 typedef struct VkPhysicalDeviceIDProperties { VkStructureType sType; void* pNext; uint8_t deviceUUID[VK_UUID_SIZE]; uint8_t driverUUID[VK_UUID_SIZE]; uint8_t deviceLUID[VK_LUID_SIZE]; uint32_t deviceNodeMask; VkBool32 deviceLUIDValid; } VkPhysicalDeviceIDProperties; or the equivalent // Provided by VK_KHR_external_fence_capabilities, VK_KHR_external_memory_capabilities, VK_KHR_external_semaphore_capabilities typedef VkPhysicalDeviceIDProperties VkPhysicalDeviceIDPropertiesKHR; sType is a VkStructureType value identifying this structure. pNext is NULL or a pointer to a structure extending this structure. deviceUUID is an array of VK_UUID_SIZE uint8_t values representing a universally unique identifier for the device. driverUUID is an array of VK_UUID_SIZE uint8_t values representing a universally unique identifier for the driver build in use by the device. deviceLUID is an array of VK_LUID_SIZE uint8_t values representing a locally unique identifier for the device. deviceNodeMask is a uint32_t bitfield identifying the node within a linked device adapter corresponding to the device. deviceLUIDValid is a boolean value that will be VK_TRUE if deviceLUID contains a valid LUID and deviceNodeMask contains a valid node mask, and VK_FALSE if they do not. If the VkPhysicalDeviceIDProperties structure is included in the pNext chain of the VkPhysicalDeviceProperties2 structure passed to vkGetPhysicalDeviceProperties2, it is filled in with each corresponding implementation-dependent property. deviceUUID must be immutable for a given device across instances, processes, driver APIs, driver versions, and system reboots. Applications can compare the driverUUID value across instance and process boundaries, and can make similar queries in external APIs to determine whether they are capable of sharing memory objects and resources using them with the device. deviceUUID and/or driverUUID must be used to determine whether a particular external object can be shared between driver components, where such a restriction exists as defined in the compatibility table for the particular object type: External memory handle types compatibility External semaphore handle types compatibility External fence handle types compatibility If deviceLUIDValid is VK_FALSE, the values of deviceLUID and deviceNodeMask are undefined. If deviceLUIDValid is VK_TRUE and Vulkan is running on the Windows operating system, the contents of deviceLUID can be cast to an LUID object and must be equal to the locally unique identifier of a IDXGIAdapter1 object that corresponds to physicalDevice. If deviceLUIDValid is VK_TRUE, deviceNodeMask must contain exactly one bit. If Vulkan is running on an operating system that supports the Direct3D 12 API and physicalDevice corresponds to an individual device in a linked device adapter, deviceNodeMask identifies the Direct3D 12 node corresponding to physicalDevice. Otherwise, deviceNodeMask must be 1. Although they have identical descriptions, VkPhysicalDeviceIDProperties::deviceUUID may differ from VkPhysicalDeviceProperties2::properties.pipelineCacheUUID. The former is intended to identify and correlate devices across API and driver boundaries, while the latter is used to identify a compatible device and driver combination to use when serializing and de-serializing pipeline state. Implementations should return deviceUUID values which are likely to be unique even in the presence of multiple Vulkan implementations (such as a GPU driver and a software renderer; two drivers for different GPUs; or the same Vulkan driver running on two logically different devices). Khronos' conformance testing is unable to guarantee that deviceUUID values are actually unique, so implementors should make their own best efforts to ensure this. In particular, hard-coded deviceUUID values, especially all-0 bits, should never be used. A combination of values unique to the vendor, the driver, and the hardware environment can be used to provide a deviceUUID which is unique to a high degree of certainty. Some possible inputs to such a computation are: Information reported by vkGetPhysicalDeviceProperties PCI device ID (if defined) PCI bus ID, or similar system configuration information. Driver binary checksums. While VkPhysicalDeviceIDProperties::deviceUUID is specified to remain consistent across driver versions and system reboots, it is not intended to be usable as a serializable persistent identifier for a device. It may change when a device is physically added to, removed from, or moved to a different connector in a system while that system is powered down. Further, there is no reasonable way to verify with conformance testing that a given device retains the same UUID in a given system across all driver versions supported in that system. While implementations should make every effort to report consistent device UUIDs across driver versions, applications should avoid relying on the persistence of this value for uses other than identifying compatible devices for external object sharing purposes. Valid Usage (Implicit) VUID-VkPhysicalDeviceIDProperties-sType-sType sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES VK_UUID_SIZE is the length in uint8_t values of an array containing a universally unique device or driver build identifier, as returned in VkPhysicalDeviceIDProperties::deviceUUID and VkPhysicalDeviceIDProperties::driverUUID. #define VK_UUID_SIZE 16U VK_LUID_SIZE is the length in uint8_t values of an array containing a locally unique device identifier, as returned in VkPhysicalDeviceIDProperties::deviceLUID. #define VK_LUID_SIZE 8U or the equivalent #define VK_LUID_SIZE_KHR VK_LUID_SIZE The VkPhysicalDeviceDriverProperties structure is defined as: // Provided by VK_VERSION_1_2 typedef struct VkPhysicalDeviceDriverProperties { VkStructureType sType; void* pNext; VkDriverId driverID; char driverName[VK_MAX_DRIVER_NAME_SIZE]; char driverInfo[VK_MAX_DRIVER_INFO_SIZE]; VkConformanceVersion conformanceVersion; } VkPhysicalDeviceDriverProperties; or the equivalent // Provided by VK_KHR_driver_properties typedef VkPhysicalDeviceDriverProperties VkPhysicalDeviceDriverPropertiesKHR; sType is a VkStructureType value identifying this structure. pNext is NULL or a pointer to a structure extending this structure. driverID is a unique identifier for the driver of the physical device. driverName is an array of VK_MAX_DRIVER_NAME_SIZE char containing a null-terminated UTF-8 string which is the name of the driver. driverInfo is an array of VK_MAX_DRIVER_INFO_SIZE char containing a null-terminated UTF-8 string with additional information about the driver. conformanceVersion is the latest version of the Vulkan conformance test that the implementor has successfully tested this driver against prior to release (see VkConformanceVersion). If the VkPhysicalDeviceDriverProperties structure is included in the pNext chain of the VkPhysicalDeviceProperties2 structure passed to vkGetPhysicalDeviceProperties2, it is filled in with each corresponding implementation-dependent property. These are properties of the driver corresponding to a physical device. driverID must be immutable for a given driver across instances, processes, driver versions, and system reboots. Valid Usage (Implicit) VUID-VkPhysicalDeviceDriverProperties-sType-sType sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES Khronos driver IDs which may be returned in VkPhysicalDeviceDriverProperties::driverID are: // Provided by VK_VERSION_1_2 typedef enum VkDriverId { VK_DRIVER_ID_AMD_PROPRIETARY = 1, VK_DRIVER_ID_AMD_OPEN_SOURCE = 2, VK_DRIVER_ID_MESA_RADV = 3, VK_DRIVER_ID_NVIDIA_PROPRIETARY = 4, VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS = 5, VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA = 6, VK_DRIVER_ID_IMAGINATION_PROPRIETARY = 7, VK_DRIVER_ID_QUALCOMM_PROPRIETARY = 8, VK_DRIVER_ID_ARM_PROPRIETARY = 9, VK_DRIVER_ID_GOOGLE_SWIFTSHADER = 10, VK_DRIVER_ID_GGP_PROPRIETARY = 11, VK_DRIVER_ID_BROADCOM_PROPRIETARY = 12, VK_DRIVER_ID_MESA_LLVMPIPE = 13, VK_DRIVER_ID_MOLTENVK = 14, VK_DRIVER_ID_COREAVI_PROPRIETARY = 15, VK_DRIVER_ID_JUICE_PROPRIETARY = 16, VK_DRIVER_ID_VERISILICON_PROPRIETARY = 17, VK_DRIVER_ID_MESA_TURNIP = 18, VK_DRIVER_ID_MESA_V3DV = 19, VK_DRIVER_ID_MESA_PANVK = 20, VK_DRIVER_ID_SAMSUNG_PROPRIETARY = 21, VK_DRIVER_ID_MESA_VENUS = 22, VK_DRIVER_ID_MESA_DOZEN = 23, VK_DRIVER_ID_MESA_NVK = 24, VK_DRIVER_ID_IMAGINATION_OPEN_SOURCE_MESA = 25, VK_DRIVER_ID_MESA_HONEYKRISP = 26, VK_DRIVER_ID_VULKAN_SC_EMULATION_ON_VULKAN = 27, // Provided by VK_KHR_driver_properties VK_DRIVER_ID_AMD_PROPRIETARY_KHR = VK_DRIVER_ID_AMD_PROPRIETARY, // Provided by VK_KHR_driver_properties VK_DRIVER_ID_AMD_OPEN_SOURCE_KHR = VK_DRIVER_ID_AMD_OPEN_SOURCE, // Provided by VK_KHR_driver_properties VK_DRIVER_ID_MESA_RADV_KHR = VK_DRIVER_ID_MESA_RADV, // Provided by VK_KHR_driver_properties VK_DRIVER_ID_NVIDIA_PROPRIETARY_KHR = VK_DRIVER_ID_NVIDIA_PROPRIETARY, // Provided by VK_KHR_driver_properties VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS_KHR = VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS, // Provided by VK_KHR_driver_properties VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA_KHR = VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA, // Provided by VK_KHR_driver_properties VK_DRIVER_ID_IMAGINATION_PROPRIETARY_KHR = VK_DRIVER_ID_IMAGINATION_PROPRIETARY, // Provided by VK_KHR_driver_properties VK_DRIVER_ID_QUALCOMM_PROPRIETARY_KHR = VK_DRIVER_ID_QUALCOMM_PROPRIETARY, // Provided by VK_KHR_driver_properties VK_DRIVER_ID_ARM_PROPRIETARY_KHR = VK_DRIVER_ID_ARM_PROPRIETARY, // Provided by VK_KHR_driver_properties VK_DRIVER_ID_GOOGLE_SWIFTSHADER_KHR = VK_DRIVER_ID_GOOGLE_SWIFTSHADER, // Provided by VK_KHR_driver_properties VK_DRIVER_ID_GGP_PROPRIETARY_KHR = VK_DRIVER_ID_GGP_PROPRIETARY, // Provided by VK_KHR_driver_properties VK_DRIVER_ID_BROADCOM_PROPRIETARY_KHR = VK_DRIVER_ID_BROADCOM_PROPRIETARY, } VkDriverId; or the equivalent // Provided by VK_KHR_driver_properties typedef VkDriverId VkDriverIdKHR; Khronos driver IDs may be allocated by vendors at any time. There may be multiple driver IDs for the same vendor, representing different drivers (for e.g. different platforms, proprietary or open source, etc.). Only the latest canonical versions of this Specification, of the corresponding vk.xml API Registry, and of the corresponding vulkan_core.h header file must contain all reserved Khronos driver IDs. Only driver IDs registered with Khronos are given symbolic names. There may be unregistered driver IDs returned. VK_MAX_DRIVER_NAME_SIZE is the length in char values of an array containing a driver name string, as returned in VkPhysicalDeviceDriverProperties::driverName. #define VK_MAX_DRIVER_NAME_SIZE 256U or the equivalent #define VK_MAX_DRIVER_NAME_SIZE_KHR VK_MAX_DRIVER_NAME_SIZE VK_MAX_DRIVER_INFO_SIZE is the length in char values of an array containing a driver information string, as returned in VkPhysicalDeviceDriverProperties::driverInfo. #define VK_MAX_DRIVER_INFO_SIZE 256U or the equivalent #define VK_MAX_DRIVER_INFO_SIZE_KHR VK_MAX_DRIVER_INFO_SIZE The conformance test suite version an implementation is compliant with is described with the VkConformanceVersion structure: // Provided by VK_VERSION_1_2 typedef struct VkConformanceVersion { uint8_t major; uint8_t minor; uint8_t subminor; uint8_t patch; } VkConformanceVersion; or the equivalent // Provided by VK_KHR_driver_properties typedef VkConformanceVersion VkConformanceVersionKHR; major is the major version number of the conformance test suite. minor is the minor version number of the conformance test suite. subminor is the subminor version number of the conformance test suite. patch is the patch version number of the conformance test suite. The VkPhysicalDevicePCIBusInfoPropertiesEXT structure is defined as: // Provided by VK_EXT_pci_bus_info typedef struct VkPhysicalDevicePCIBusInfoPropertiesEXT { VkStructureType sType; void* pNext; uint32_t pciDomain; uint32_t pciBus; uint32_t pciDevice; uint32_t pciFunction; } VkPhysicalDevicePCIBusInfoPropertiesEXT; sType is a VkStructureType value identifying this structure. pNext is NULL or a pointer to a structure extending this structure. pciDomain is the PCI bus domain. pciBus is the PCI bus identifier. pciDevice is the PCI device identifier. pciFunction is the PCI device function identifier. If the VkPhysicalDevicePCIBusInfoPropertiesEXT structure is included in the pNext chain of the VkPhysicalDeviceProperties2 structure passed to vkGetPhysicalDeviceProperties2, it is filled in with each corresponding implementation-dependent property. These are properties of the PCI bus information of a physical device. Valid Usage (Implicit) VUID-VkPhysicalDevicePCIBusInfoPropertiesEXT-sType-sType sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT The VkPhysicalDeviceDrmPropertiesEXT structure is defined as: // Provided by VK_EXT_physical_device_drm typedef struct VkPhysicalDeviceDrmPropertiesEXT { VkStructureType sType; void* pNext; VkBool32 hasPrimary; VkBool32 hasRender; int64_t primaryMajor; int64_t primaryMinor; int64_t renderMajor; int64_t renderMinor; } VkPhysicalDeviceDrmPropertiesEXT; sType is a VkStructureType value identifying this structure. pNext is NULL or a pointer to a structure extending this structure. hasPrimary is a boolean indicating whether the physical device has a DRM primary node. hasRender is a boolean indicating whether the physical device has a DRM render node. primaryMajor is the DRM primary node major number, if any. primaryMinor is the DRM primary node minor number, if any. renderMajor is the DRM render node major number, if any. renderMinor is the DRM render node minor number, if any. If the VkPhysicalDeviceDrmPropertiesEXT structure is included in the pNext chain of the VkPhysicalDeviceProperties2 structure passed to vkGetPhysicalDeviceProperties2, it is filled in with each corresponding implementation-dependent property. These are properties of the DRM information of a physical device. Valid Usage (Implicit) VUID-VkPhysicalDeviceDrmPropertiesEXT-sType-sType sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT The VkPhysicalDeviceShaderIntegerDotProductProperties structure is defined as: // Provided by VK_VERSION_1_3 typedef struct VkPhysicalDeviceShaderIntegerDotProductProperties { VkStructureType sType; void* pNext; VkBool32 integerDotProduct8BitUnsignedAccelerated; VkBool32 integerDotProduct8BitSignedAccelerated; VkBool32 integerDotProduct8BitMixedSignednessAccelerated; VkBool32 integerDotProduct4x8BitPackedUnsignedAccelerated; VkBool32 integerDotProduct4x8BitPackedSignedAccelerated; VkBool32 integerDotProduct4x8BitPackedMixedSignednessAccelerated; VkBool32 integerDotProduct16BitUnsignedAccelerated; VkBool32 integerDotProduct16BitSignedAccelerated; VkBool32 integerDotProduct16BitMixedSignednessAccelerated; VkBool32 integerDotProduct32BitUnsignedAccelerated; VkBool32 integerDotProduct32BitSignedAccelerated; VkBool32 integerDotProduct32BitMixedSignednessAccelerated; VkBool32 integerDotProduct64BitUnsignedAccelerated; VkBool32 integerDotProduct64BitSignedAccelerated; VkBool32 integerDotProduct64BitMixedSignednessAccelerated; VkBool32 integerDotProductAccumulatingSaturating8BitUnsignedAccelerated; VkBool32 integerDotProductAccumulatingSaturating8BitSignedAccelerated; VkBool32 integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated; VkBool32 integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated; VkBool32 integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated; VkBool32 integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated; VkBool32 integerDotProductAccumulatingSaturating16BitUnsignedAccelerated; VkBool32 integerDotProductAccumulatingSaturating16BitSignedAccelerated; VkBool32 integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated; VkBool32 integerDotProductAccumulatingSaturating32BitUnsignedAccelerated; VkBool32 integerDotProductAccumulatingSaturating32BitSignedAccelerated; VkBool32 integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated; VkBool32 integerDotProductAccumulatingSaturating64BitUnsignedAccelerated; VkBool32 integerDotProductAccumulatingSaturating64BitSignedAccelerated; VkBool32 integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated; } VkPhysicalDeviceShaderIntegerDotProductProperties; or the equivalent // Provided by VK_KHR_shader_integer_dot_product typedef VkPhysicalDeviceShaderIntegerDotProductProperties VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR; sType is a VkStructureType value identifying this structure. pNext is NULL or a pointer to a structure extending this structure. integerDotProduct8BitUnsignedAccelerated is a boolean that will be VK_TRUE if the support for 8-bit unsigned dot product operations using the OpUDotKHR SPIR-V instruction is accelerated as defined below. integerDotProduct8BitSignedAccelerated is a boolean that will be VK_TRUE if the support for 8-bit signed dot product operations using the OpSDotKHR SPIR-V instruction is accelerated as defined below. integerDotProduct8BitMixedSignednessAccelerated is a boolean that will be VK_TRUE if the support for 8-bit mixed signedness dot product operations using the OpSUDotKHR SPIR-V instruction is accelerated as defined below. integerDotProduct4x8BitPackedUnsignedAccelerated is a boolean that will be VK_TRUE if the support for 8-bit unsigned dot product operations from operands packed into 32-bit integers using the OpUDotKHR SPIR-V instruction is accelerated as defined below. integerDotProduct4x8BitPackedSignedAccelerated is a boolean that will be VK_TRUE if the support for 8-bit signed dot product operations from operands packed into 32-bit integers using the OpSDotKHR SPIR-V instruction is accelerated as defined below. integerDotProduct4x8BitPackedMixedSignednessAccelerated is a boolean that will be VK_TRUE if the support for 8-bit mixed signedness dot product operations from operands packed into 32-bit integers using the OpSUDotKHR SPIR-V instruction is accelerated as defined below. integerDotProduct16BitUnsignedAccelerated is a boolean that will be VK_TRUE if the support for 16-bit unsigned dot product operations using the OpUDotKHR SPIR-V instruction is accelerated as defined below. integerDotProduct16BitSignedAccelerated is a boolean that will be VK_TRUE if the support for 16-bit signed dot product operations using the OpSDotKHR SPIR-V instruction is accelerated as defined below. integerDotProduct16BitMixedSignednessAccelerated is a boolean that will be VK_TRUE if the support for 16-bit mixed signedness dot product operations using the OpSUDotKHR SPIR-V instruction is accelerated as defined below. integerDotProduct32BitUnsignedAccelerated is a boolean that will be VK_TRUE if the support for 32-bit unsigned dot product operations using the OpUDotKHR SPIR-V instruction is accelerated as defined below. integerDotProduct32BitSignedAccelerated is a boolean that will be VK_TRUE if the support for 32-bit signed dot product operations using the OpSDotKHR SPIR-V instruction is accelerated as defined below. integerDotProduct32BitMixedSignednessAccelerated is a boolean that will be VK_TRUE if the support for 32-bit mixed signedness dot product operations using the OpSUDotKHR SPIR-V instruction is accelerated as defined below. integerDotProduct64BitUnsignedAccelerated is a boolean that will be VK_TRUE if the support for 64-bit unsigned dot product operations using the OpUDotKHR SPIR-V instruction is accelerated as defined below. integerDotProduct64BitSignedAccelerated is a boolean that will be VK_TRUE if the support for 64-bit signed dot product operations using the OpSDotKHR SPIR-V instruction is accelerated as defined below. integerDotProduct64BitMixedSignednessAccelerated is a boolean that will be VK_TRUE if the support for 64-bit mixed signedness dot product operations using the OpSUDotKHR SPIR-V instruction is accelerated as defined below. integerDotProductAccumulatingSaturating8BitUnsignedAccelerated is a boolean that will be VK_TRUE if the support for 8-bit unsigned accumulating saturating dot product operations using the OpUDotAccSatKHR SPIR-V instruction is accelerated as defined below. integerDotProductAccumulatingSaturating8BitSignedAccelerated is a boolean that will be VK_TRUE if the support for 8-bit signed accumulating saturating dot product operations using the OpSDotAccSatKHR SPIR-V instruction is accelerated as defined below. integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated is a boolean that will be VK_TRUE if the support for 8-bit mixed signedness accumulating saturating dot product operations using the OpSUDotAccSatKHR SPIR-V instruction is accelerated as defined below. integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated is a boolean that will be VK_TRUE if the support for 8-bit unsigned accumulating saturating dot product operations from operands packed into 32-bit integers using the OpUDotAccSatKHR SPIR-V instruction is accelerated as defined below. integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated is a boolean that will be VK_TRUE if the support for 8-bit signed accumulating saturating dot product operations from operands packed into 32-bit integers using the OpSDotAccSatKHR SPIR-V instruction is accelerated as defined below. integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated is a boolean that will be VK_TRUE if the support for 8-bit mixed signedness accumulating saturating dot product operations from operands packed into 32-bit integers using the OpSUDotAccSatKHR SPIR-V instruction is accelerated as defined below. integerDotProductAccumulatingSaturating16BitUnsignedAccelerated is a boolean that will be VK_TRUE if the support for 16-bit unsigned accumulating saturating dot product operations using the OpUDotAccSatKHR SPIR-V instruction is accelerated as defined below. integerDotProductAccumulatingSaturating16BitSignedAccelerated is a boolean that will be VK_TRUE if the support for 16-bit signed accumulating saturating dot product operations using the OpSDotAccSatKHR SPIR-V instruction is accelerated as defined below. integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated is a boolean that will be VK_TRUE if the support for 16-bit mixed signedness accumulating saturating dot product operations using the OpSUDotAccSatKHR SPIR-V instruction is accelerated as defined below. integerDotProductAccumulatingSaturating32BitUnsignedAccelerated is a boolean that will be VK_TRUE if the support for 32-bit unsigned accumulating saturating dot product operations using the OpUDotAccSatKHR SPIR-V instruction is accelerated as defined below. integerDotProductAccumulatingSaturating32BitSignedAccelerated is a boolean that will be VK_TRUE if the support for 32-bit signed accumulating saturating dot product operations using the OpSDotAccSatKHR SPIR-V instruction is accelerated as defined below. integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated is a boolean that will be VK_TRUE if the support for 32-bit mixed signedness accumulating saturating dot product operations using the OpSUDotAccSatKHR SPIR-V instruction is accelerated as defined below. integerDotProductAccumulatingSaturating64BitUnsignedAccelerated is a boolean that will be VK_TRUE if the support for 64-bit unsigned accumulating saturating dot product operations using the OpUDotAccSatKHR SPIR-V instruction is accelerated as defined below. integerDotProductAccumulatingSaturating64BitSignedAccelerated is a boolean that will be VK_TRUE if the support for 64-bit signed accumulating saturating dot product operations using the OpSDotAccSatKHR SPIR-V instruction is accelerated as defined below. integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated is a boolean that will be VK_TRUE if the support for 64-bit mixed signedness accumulating saturating dot product operations using the OpSUDotAccSatKHR SPIR-V instruction is accelerated as defined below. If the VkPhysicalDeviceShaderIntegerDotProductProperties structure is included in the pNext chain of the VkPhysicalDeviceProperties2 structure passed to vkGetPhysicalDeviceProperties2, it is filled in with each corresponding implementation-dependent property. These are properties of the integer dot product acceleration information of a physical device. A dot product operation is deemed accelerated if its implementation provides a performance advantage over application-provided code composed from elementary instructions and/or other dot product instructions, either because the implementation uses optimized machine code sequences whose generation from application-provided code cannot be guaranteed or because it uses hardware features that cannot otherwise be targeted from application-provided code. Valid Usage (Implicit) VUID-VkPhysicalDeviceShaderIntegerDotProductProperties-sType-sType sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES The VkPhysicalDeviceImageProcessingPropertiesQCOM structure is defined as: // Provided by VK_QCOM_image_processing typedef struct VkPhysicalDeviceImageProcessingPropertiesQCOM { VkStructureType sType; void* pNext; uint32_t maxWeightFilterPhases; VkExtent2D maxWeightFilterDimension; VkExtent2D maxBlockMatchRegion; VkExtent2D maxBoxFilterBlockSize; } VkPhysicalDeviceImageProcessingPropertiesQCOM; sType is a VkStructureType value identifying this structure. pNext is NULL or a pointer to a structure extending this structure. maxWeightFilterPhases is the maximum value that can be specified for VkImageViewSampleWeightCreateInfoQCOM::numPhases in weight image sampling operations. maxWeightFilterDimension is a VkExtent2D describing the largest dimensions (width and height) that can be specified for VkImageViewSampleWeightCreateInfoQCOM::filterSize. maxBlockMatchRegion is a VkExtent2D describing the largest dimensions (width and height) that can be specified for blockSize in block matching operations. maxBoxFilterBlockSize is a VkExtent2D describing the maximum dimensions (width and height) that can be specified for blocksize in box filter sampling operations. If the VkPhysicalDeviceImageProcessingPropertiesQCOM structure is included in the pNext chain of the VkPhysicalDeviceProperties2 structure passed to vkGetPhysicalDeviceProperties2, it is filled in with each corresponding implementation-dependent property. These are properties of the image processing information of a physical device. Valid Usage (Implicit) VUID-VkPhysicalDeviceImageProcessingPropertiesQCOM-sType-sType sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM The VkPhysicalDeviceShaderTileImagePropertiesEXT structure is defined as: // Provided by VK_EXT_shader_tile_image typedef struct VkPhysicalDeviceShaderTileImagePropertiesEXT { VkStructureType sType; void* pNext; VkBool32 shaderTileImageCoherentReadAccelerated; VkBool32 shaderTileImageReadSampleFromPixelRateInvocation; VkBool32 shaderTileImageReadFromHelperInvocation; } VkPhysicalDeviceShaderTileImagePropertiesEXT; sType is a VkStructureType value identifying this structure. pNext is NULL or a pointer to a structure extending this structure. shaderTileImageCoherentReadAccelerated is a boolean that will be VK_TRUE if coherent reads of tile image data is accelerated. shaderTileImageReadSampleFromPixelRateInvocation is a boolean that will be VK_TRUE if reading from samples from a pixel rate fragment invocation is supported when VkPipelineMultisampleStateCreateInfo::rasterizationSamples > 1. shaderTileImageReadFromHelperInvocation is a boolean that will be VK_TRUE if reads of tile image data from helper fragment invocations result in valid values. If the VkPhysicalDeviceShaderTileImagePropertiesEXT structure is included in the pNext chain of the VkPhysicalDeviceProperties2 structure passed to vkGetPhysicalDeviceProperties2, it is filled in with each corresponding implementation-dependent property. These are properties of the tile image information of a physical device. Valid Usage (Implicit) VUID-VkPhysicalDeviceShaderTileImagePropertiesEXT-sType-sType sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT The VkPhysicalDeviceImageProcessing2PropertiesQCOM structure is defined as: // Provided by VK_QCOM_image_processing2 typedef struct VkPhysicalDeviceImageProcessing2PropertiesQCOM { VkStructureType sType; void* pNext; VkExtent2D maxBlockMatchWindow; } VkPhysicalDeviceImageProcessing2PropertiesQCOM; sType is a VkStructureType value identifying this structure. pNext is NULL or a pointer to a structure extending this structure. maxBlockMatchWindow is a VkExtent2D describing the largest dimensions (width and height) that can be specified for the block match window. If the VkPhysicalDeviceImageProcessing2PropertiesQCOM structure is included in the pNext chain of the VkPhysicalDeviceProperties2 structure passed to vkGetPhysicalDeviceProperties2, it is filled in with each corresponding implementation-dependent property. These are properties of the image processing2 information of a physical device. Valid Usage (Implicit) VUID-VkPhysicalDeviceImageProcessing2PropertiesQCOM-sType-sType sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM The VkPhysicalDeviceLayeredDriverPropertiesMSFT structure is defined as: // Provided by VK_MSFT_layered_driver typedef struct VkPhysicalDeviceLayeredDriverPropertiesMSFT { VkStructureType sType; void* pNext; VkLayeredDriverUnderlyingApiMSFT underlyingAPI; } VkPhysicalDeviceLayeredDriverPropertiesMSFT; sType is a VkStructureType value identifying this structure. pNext is NULL or a pointer to a structure extending this structure. underlyingAPI is a VkLayeredDriverUnderlyingApiMSFT value indicating which underlying API is used to implement the layered driver, or VK_LAYERED_DRIVER_UNDERLYING_API_NONE_MSFT if the driver is not layered. These are properties of the driver layering information of a physical device. Valid Usage (Implicit) VUID-VkPhysicalDeviceLayeredDriverPropertiesMSFT-sType-sType sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT Underlying APIs which may be returned in VkPhysicalDeviceLayeredDriverPropertiesMSFT::underlyingAPI are: // Provided by VK_MSFT_layered_driver typedef enum VkLayeredDriverUnderlyingApiMSFT { VK_LAYERED_DRIVER_UNDERLYING_API_NONE_MSFT = 0, VK_LAYERED_DRIVER_UNDERLYING_API_D3D12_MSFT = 1, } VkLayeredDriverUnderlyingApiMSFT; The VkPhysicalDeviceSchedulingControlsPropertiesARM structure is defined as: // Provided by VK_ARM_scheduling_controls typedef struct VkPhysicalDeviceSchedulingControlsPropertiesARM { VkStructureType sType; void* pNext; VkPhysicalDeviceSchedulingControlsFlagsARM schedulingControlsFlags; } VkPhysicalDeviceSchedulingControlsPropertiesARM; schedulingControlsFlags specifies the specific scheduling controls that a physical device supports. If the VkPhysicalDeviceSchedulingControlsPropertiesARM structure is included in the pNext chain of the VkPhysicalDeviceProperties2 structure passed to vkGetPhysicalDeviceProperties2, it is filled in with each corresponding implementation-dependent property. Valid Usage (Implicit) VUID-VkPhysicalDeviceSchedulingControlsPropertiesARM-sType-sType sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_PROPERTIES_ARM Bits which can be set in VkPhysicalDeviceSchedulingControlsPropertiesARM::schedulingControlsFlags, specifying supported scheduling controls, are: // Provided by VK_ARM_scheduling_controls // Flag bits for VkPhysicalDeviceSchedulingControlsFlagBitsARM typedef VkFlags64 VkPhysicalDeviceSchedulingControlsFlagBitsARM; static const VkPhysicalDeviceSchedulingControlsFlagBitsARM VK_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_SHADER_CORE_COUNT_ARM = 0x00000001ULL; VK_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_SHADER_CORE_COUNT_ARM specifies that a VkDeviceQueueShaderCoreControlCreateInfoARM structure may be included in the pNext chain of a VkDeviceQueueCreateInfo or VkDeviceCreateInfo structure. // Provided by VK_ARM_scheduling_controls typedef VkFlags64 VkPhysicalDeviceSchedulingControlsFlagsARM; VkPhysicalDeviceSchedulingControlsFlagsARM is a bitmask type for setting a mask of zero or more VkPhysicalDeviceSchedulingControlsFlagBitsARM. To query properties of queues available on a physical device, call: // Provided by VK_VERSION_1_0 void vkGetPhysicalDeviceQueueFamilyProperties( VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties* pQueueFamilyProperties); physicalDevice is the handle to the physical device whose properties will be queried. pQueueFamilyPropertyCount is a pointer to an integer related to the number of queue families available or queried, as described below. pQueueFamilyProperties is either NULL or a pointer to an array of VkQueueFamilyProperties structures. If pQueueFamilyProperties is NULL, then the number of queue families available is returned in pQueueFamilyPropertyCount. Implementations must support at least one queue family. Otherwise, pQueueFamilyPropertyCount must point to a variable set by the application to the number of elements in the pQueueFamilyProperties array, and on return the variable is overwritten with the number of structures actually written to pQueueFamilyProperties. If pQueueFamilyPropertyCount is less than the number of queue families available, at most pQueueFamilyPropertyCount structures will be written. Valid Usage (Implicit) VUID-vkGetPhysicalDeviceQueueFamilyProperties-physicalDevice-parameter physicalDevice must be a valid VkPhysicalDevice handle VUID-vkGetPhysicalDeviceQueueFamilyProperties-pQueueFamilyPropertyCount-parameter pQueueFamilyPropertyCount must be a valid pointer to a uint32_t value VUID-vkGetPhysicalDeviceQueueFamilyProperties-pQueueFamilyProperties-parameter If the value referenced by pQueueFamilyPropertyCount is not 0, and pQueueFamilyProperties is not NULL, pQueueFamilyProperties must be a valid pointer to an array of pQueueFamilyPropertyCount VkQueueFamilyProperties structures The VkQueueFamilyProperties structure is defined as: // Provided by VK_VERSION_1_0 typedef struct VkQueueFamilyProperties { VkQueueFlags queueFlags; uint32_t queueCount; uint32_t timestampValidBits; VkExtent3D minImageTransferGranularity; } VkQueueFamilyProperties; queueFlags is a bitmask of VkQueueFlagBits indicating capabilities of the queues in this queue family. queueCount is the unsigned integer count of queues in this queue family. Each queue family must support at least one queue. timestampValidBits is the unsigned integer count of meaningful bits in the timestamps written via vkCmdWriteTimestamp2 or vkCmdWriteTimestamp. The valid range for the count is 36 to 64 bits, or a value of 0, indicating no support for timestamps. Bits outside the valid range are guaranteed to be zeros. minImageTransferGranularity is the minimum granularity supported for image transfer operations on the queues in this queue family. The value returned in minImageTransferGranularity has a unit of compressed texel blocks for images having a block-compressed format, and a unit of texels otherwise. Possible values of minImageTransferGranularity are: (0,0,0) specifies that only whole mip levels must be transferred using the image transfer operations on the corresponding queues. In this case, the following restrictions apply to all offset and extent parameters of image transfer operations: The x, y, and z members of a VkOffset3D parameter must always be zero. The width, height, and depth members of a VkExtent3D parameter must always match the width, height, and depth of the image subresource corresponding to the parameter, respectively. (Ax, Ay, Az) where Ax, Ay, and Az are all integer powers of two. In this case the following restrictions apply to all image transfer operations: x, y, and z of a VkOffset3D parameter must be integer multiples of Ax, Ay, and Az, respectively. width of a VkExtent3D parameter must be an integer multiple of Ax, or else x + width must equal the width of the image subresource corresponding to the parameter. height of a VkExtent3D parameter must be an integer multiple of Ay, or else y + height must equal the height of the image subresource corresponding to the parameter. depth of a VkExtent3D parameter must be an integer multiple of Az, or else z + depth must equal the depth of the image subresource corresponding to the parameter. If the format of the image corresponding to the parameters is one of the block-compressed formats then for the purposes of the above calculations the granularity must be scaled up by the compressed texel block dimensions. Queues supporting graphics and/or compute operations must report (1,1,1) in minImageTransferGranularity, meaning that there are no additional restrictions on the granularity of image transfer operations for these queues. Other queues supporting image transfer operations are only required to support whole mip level transfers, thus minImageTransferGranularity for queues belonging to such queue families may be (0,0,0). The Device Memory section describes memory properties queried from the physical device. For physical device feature queries see the Features chapter. Bits which may be set in VkQueueFamilyProperties::queueFlags, indicating capabilities of queues in a queue family are: // Provided by VK_VERSION_1_0 typedef enum VkQueueFlagBits { VK_QUEUE_GRAPHICS_BIT = 0x00000001, VK_QUEUE_COMPUTE_BIT = 0x00000002, VK_QUEUE_TRANSFER_BIT = 0x00000004, VK_QUEUE_SPARSE_BINDING_BIT = 0x00000008, // Provided by VK_VERSION_1_1 VK_QUEUE_PROTECTED_BIT = 0x00000010, // Provided by VK_KHR_video_decode_queue VK_QUEUE_VIDEO_DECODE_BIT_KHR = 0x00000020, // Provided by VK_KHR_video_encode_queue VK_QUEUE_VIDEO_ENCODE_BIT_KHR = 0x00000040, // Provided by VK_NV_optical_flow VK_QUEUE_OPTICAL_FLOW_BIT_NV = 0x00000100, } VkQueueFlagBits; VK_QUEUE_GRAPHICS_BIT specifies that queues in this queue family support graphics operations. VK_QUEUE_COMPUTE_BIT specifies that queues in this queue family support compute operations. VK_QUEUE_TRANSFER_BIT specifies that queues in this queue family support transfer operations. VK_QUEUE_SPARSE_BINDING_BIT specifies that queues in this queue family support sparse memory management operations (see Sparse Resources). If any of the sparse resource features are enabled, then at least one queue family must support this bit. VK_QUEUE_VIDEO_DECODE_BIT_KHR specifies that queues in this queue family support video decode operations. VK_QUEUE_VIDEO_ENCODE_BIT_KHR specifies that queues in this queue family support video encode operations. VK_QUEUE_OPTICAL_FLOW_BIT_NV specifies that queues in this queue family support optical flow operations. VK_QUEUE_PROTECTED_BIT specifies that queues in this queue family support the VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT bit. (see Protected Memory). If the physical device supports the protectedMemory feature, at least one of its queue families must support this bit. If an implementation exposes any queue family that supports graphics operations, at least one queue family of at least one physical device exposed by the implementation must support both graphics and compute operations. Furthermore, if the protectedMemory physical device feature is supported, then at least one queue family of at least one physical device exposed by the implementation must support graphics operations, compute operations, and protected memory operations. All commands that are allowed on a queue that supports transfer operations are also allowed on a queue that supports either graphics or compute operations. Thus, if the capabilities of a queue family include VK_QUEUE_GRAPHICS_BIT or VK_QUEUE_COMPUTE_BIT, then reporting the VK_QUEUE_TRANSFER_BIT capability separately for that queue family is optional. For further details see Queues. // Provided by VK_VERSION_1_0 typedef VkFlags VkQueueFlags; VkQueueFlags is a bitmask type for setting a mask of zero or more VkQueueFlagBits. To query properties of queues available on a physical device, call: // Provided by VK_VERSION_1_1 void vkGetPhysicalDeviceQueueFamilyProperties2( VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties2* pQueueFamilyProperties); or the equivalent command // Provided by VK_KHR_get_physical_device_properties2 void vkGetPhysicalDeviceQueueFamilyProperties2KHR( VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties2* pQueueFamilyProperties); physicalDevice is the handle to the physical device whose properties will be queried. pQueueFamilyPropertyCount is a pointer to an integer related to the number of queue families available or queried, as described in vkGetPhysicalDeviceQueueFamilyProperties. pQueueFamilyProperties is either NULL or a pointer to an array of VkQueueFamilyProperties2 structures. vkGetPhysicalDeviceQueueFamilyProperties2 behaves similarly to vkGetPhysicalDeviceQueueFamilyProperties, with the ability to return extended information in a pNext chain of output structures. Valid Usage (Implicit) VUID-vkGetPhysicalDeviceQueueFamilyProperties2-physicalDevice-parameter physicalDevice must be a valid VkPhysicalDevice handle VUID-vkGetPhysicalDeviceQueueFamilyProperties2-pQueueFamilyPropertyCount-parameter pQueueFamilyPropertyCount must be a valid pointer to a uint32_t value VUID-vkGetPhysicalDeviceQueueFamilyProperties2-pQueueFamilyProperties-parameter If the value referenced by pQueueFamilyPropertyCount is not 0, and pQueueFamilyProperties is not NULL, pQueueFamilyProperties must be a valid pointer to an array of pQueueFamilyPropertyCount VkQueueFamilyProperties2 structures The VkQueueFamilyProperties2 structure is defined as: // Provided by VK_VERSION_1_1 typedef struct VkQueueFamilyProperties2 { VkStructureType sType; void* pNext; VkQueueFamilyProperties queueFamilyProperties; } VkQueueFamilyProperties2; or the equivalent // Provided by VK_KHR_get_physical_device_properties2 typedef VkQueueFamilyProperties2 VkQueueFamilyProperties2KHR; sType is a VkStructureType value identifying this structure. pNext is NULL or a pointer to a structure extending this structure. queueFamilyProperties is a VkQueueFamilyProperties structure which is populated with the same values as in vkGetPhysicalDeviceQueueFamilyProperties. Valid Usage (Implicit) VUID-VkQueueFamilyProperties2-sType-sType sType must be VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2 VUID-VkQueueFamilyProperties2-pNext-pNext Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkQueueFamilyCheckpointProperties2NV, VkQueueFamilyCheckpointPropertiesNV, VkQueueFamilyGlobalPriorityProperties, VkQueueFamilyQueryResultStatusPropertiesKHR, or VkQueueFamilyVideoPropertiesKHR VUID-VkQueueFamilyProperties2-sType-unique The sType value of each structure in the pNext chain must be unique The VkQueueFamilyGlobalPriorityProperties structure is defined as: // Provided by VK_VERSION_1_4 typedef struct VkQueueFamilyGlobalPriorityProperties { VkStructureType sType; void* pNext; uint32_t priorityCount; VkQueueGlobalPriority priorities[VK_MAX_GLOBAL_PRIORITY_SIZE]; } VkQueueFamilyGlobalPriorityProperties; or the equivalent // Provided by VK_KHR_global_priority typedef VkQueueFamilyGlobalPriorityProperties VkQueueFamilyGlobalPriorityPropertiesKHR; or the equivalent // Provided by VK_EXT_global_priority_query typedef VkQueueFamilyGlobalPriorityProperties VkQueueFamilyGlobalPriorityPropertiesEXT; sType is a VkStructureType value identifying this structure. pNext is NULL or a pointer to a structure extending this structure. priorityCount is the number of supported global queue priorities in this queue family, and it must be greater than 0. priorities is an array of VK_MAX_GLOBAL_PRIORITY_SIZE VkQueueGlobalPriority enums representing all supported global queue priorities in this queue family. The first priorityCount elements of the array will be valid. If the VkQueueFamilyGlobalPriorityProperties structure is included in the pNext chain of the VkQueueFamilyProperties2 structure passed to vkGetPhysicalDeviceQueueFamilyProperties2, it is filled in with the list of supported global queue priorities for the indicated family. The valid elements of priorities must not contain any duplicate values. The valid elements of priorities must be a continuous sequence of VkQueueGlobalPriority enums in the ascending order. For example, returning priorityCount as 3 with supported priorities as VK_QUEUE_GLOBAL_PRIORITY_LOW, VK_QUEUE_GLOBAL_PRIORITY_MEDIUM and VK_QUEUE_GLOBAL_PRIORITY_REALTIME is not allowed. Valid Usage (Implicit) VUID-VkQueueFamilyGlobalPriorityProperties-sType-sType sType must be VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES VK_MAX_GLOBAL_PRIORITY_SIZE is the length of an array of VkQueueGlobalPriority enumerants representing supported queue priorities, as returned in VkQueueFamilyGlobalPriorityProperties::priorities. #define VK_MAX_GLOBAL_PRIORITY_SIZE 16U or the equivalent #define VK_MAX_GLOBAL_PRIORITY_SIZE_KHR VK_MAX_GLOBAL_PRIORITY_SIZE or the equivalent #define VK_MAX_GLOBAL_PRIORITY_SIZE_EXT VK_MAX_GLOBAL_PRIORITY_SIZE The VkQueueFamilyCheckpointProperties2NV structure is defined as: // Provided by VK_NV_device_diagnostic_checkpoints with VK_VERSION_1_3 or VK_KHR_synchronization2 typedef struct VkQueueFamilyCheckpointProperties2NV { VkStructureType sType; void* pNext; VkPipelineStageFlags2 checkpointExecutionStageMask; } VkQueueFamilyCheckpointProperties2NV; sType is a VkStructureType value identifying this structure. pNext is NULL or a pointer to a structure extending this structure. checkpointExecutionStageMask is a mask indicating which pipeline stages the implementation can execute checkpoint markers in. Additional queue family information can be queried by setting VkQueueFamilyProperties2::pNext to point to a VkQueueFamilyCheckpointProperties2NV structure. Valid Usage (Implicit) VUID-VkQueueFamilyCheckpointProperties2NV-sType-sType sType must be VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV The VkQueueFamilyCheckpointPropertiesNV structure is defined as: // Provided by VK_NV_device_diagnostic_checkpoints typedef struct VkQueueFamilyCheckpointPropertiesNV { VkStructureType sType; void* pNext; VkPipelineStageFlags checkpointExecutionStageMask; } VkQueueFamilyCheckpointPropertiesNV; sType is a VkStructureType value identifying this structure. pNext is NULL or a pointer to a structure extending this structure. checkpointExecutionStageMask is a mask indicating which pipeline stages the implementation can execute checkpoint markers in. Additional queue family information can be queried by setting VkQueueFamilyProperties2::pNext to point to a VkQueueFamilyCheckpointPropertiesNV structure. Valid Usage (Implicit) VUID-VkQueueFamilyCheckpointPropertiesNV-sType-sType sType must be VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV The VkQueueFamilyVideoPropertiesKHR structure is defined as: // Provided by VK_KHR_video_queue typedef struct VkQueueFamilyVideoPropertiesKHR { VkStructureType sType; void* pNext; VkVideoCodecOperationFlagsKHR videoCodecOperations; } VkQueueFamilyVideoPropertiesKHR; sType is a VkStructureType value identifying this structure. pNext is NULL or a pointer to a structure extending this structure. videoCodecOperations is a bitmask of VkVideoCodecOperationFlagBitsKHR that indicates the set of video codec operations supported by the queue family. If this structure is included in the pNext chain of the VkQueueFamilyProperties2 structure passed to vkGetPhysicalDeviceQueueFamilyProperties2, then it is filled with the set of video codec operations supported by the specified queue family. Valid Usage (Implicit) VUID-VkQueueFamilyVideoPropertiesKHR-sType-sType sType must be VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR The VkQueueFamilyQueryResultStatusPropertiesKHR structure is defined as: // Provided by VK_KHR_video_queue typedef struct VkQueueFamilyQueryResultStatusPropertiesKHR { VkStructureType sType; void* pNext; VkBool32 queryResultStatusSupport; } VkQueueFamilyQueryResultStatusPropertiesKHR; sType is a VkStructureType value identifying this structure. pNext is NULL or a pointer to a structure extending this structure. queryResultStatusSupport reports VK_TRUE if query type VK_QUERY_TYPE_RESULT_STATUS_ONLY_KHR and use of VK_QUERY_RESULT_WITH_STATUS_BIT_KHR are supported. If this structure is included in the pNext chain of the VkQueueFamilyProperties2 structure passed to vkGetPhysicalDeviceQueueFamilyProperties2, then it is filled with information about whether result status queries are supported by the specified queue family. Valid Usage (Implicit) VUID-VkQueueFamilyQueryResultStatusPropertiesKHR-sType-sType sType must be VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR To enumerate the performance query counters available on a queue family of a physical device, call: // Provided by VK_KHR_performance_query VkResult vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR( VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, uint32_t* pCounterCount, VkPerformanceCounterKHR* pCounters, VkPerformanceCounterDescriptionKHR* pCounterDescriptions); physicalDevice is the handle to the physical device whose queue family performance query counter properties will be queried. queueFamilyIndex is the index into the queue family of the physical device we want to get properties for. pCounterCount is a pointer to an integer related to the number of counters available or queried, as described below. pCounters is either NULL or a pointer to an array of VkPerformanceCounterKHR structures. pCounterDescriptions is either NULL or a pointer to an array of VkPerformanceCounterDescriptionKHR structures. If pCounters is NULL and pCounterDescriptions is NULL, then the number of counters available is returned in pCounterCount. Otherwise, pCounterCount must point to a variable set by the application to the number of elements in the pCounters, pCounterDescriptions, or both arrays and on return the variable is overwritten with the number of structures actually written out. If pCounterCount is less than the number of counters available, at most pCounterCount structures will be written, and VK_INCOMPLETE will be returned instead of VK_SUCCESS, to indicate that not all the available counters were returned. Valid Usage (Implicit) VUID-vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR-physicalDevice-parameter physicalDevice must be a valid VkPhysicalDevice handle VUID-vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR-pCounterCount-parameter pCounterCount must be a valid pointer to a uint32_t value VUID-vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR-pCounters-parameter If the value referenced by pCounterCount is not 0, and pCounters is not NULL, pCounters must be a valid pointer to an array of pCounterCount VkPerformanceCounterKHR structures VUID-vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR-pCounterDescriptions-parameter If the value referenced by pCounterCount is not 0, and pCounterDescriptions is not NULL, pCounterDescriptions must be a valid pointer to an array of pCounterCount VkPerformanceCounterDescriptionKHR structures Return Codes Success VK_SUCCESS VK_INCOMPLETE Failure VK_ERROR_OUT_OF_HOST_MEMORY VK_ERROR_OUT_OF_DEVICE_MEMORY VK_ERROR_INITIALIZATION_FAILED The VkPerformanceCounterKHR structure is defined as: // Provided by VK_KHR_performance_query typedef struct VkPerformanceCounterKHR { VkStructureType sType; void* pNext; VkPerformanceCounterUnitKHR unit; VkPerformanceCounterScopeKHR scope; VkPerformanceCounterStorageKHR storage; uint8_t uuid[VK_UUID_SIZE]; } VkPerformanceCounterKHR; sType is a VkStructureType value identifying this structure. pNext is NULL or a pointer to a structure extending this structure. unit is a VkPerformanceCounterUnitKHR specifying the unit that the counter data will record. scope is a VkPerformanceCounterScopeKHR specifying the scope that the counter belongs to. storage is a VkPerformanceCounterStorageKHR specifying the storage type that the counter’s data uses. uuid is an array of size VK_UUID_SIZE, containing 8-bit values that represent a universally unique identifier for the counter of the physical device. Valid Usage (Implicit) VUID-VkPerformanceCounterKHR-sType-sType sType must be VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR VUID-VkPerformanceCounterKHR-pNext-pNext pNext must be NULL Performance counters have an associated unit. This unit describes how to interpret the performance counter result. The performance counter unit types which may be returned in VkPerformanceCounterKHR::unit are: // Provided by VK_KHR_performance_query typedef enum VkPerformanceCounterUnitKHR { VK_PERFORMANCE_COUNTER_UNIT_GENERIC_KHR = 0, VK_PERFORMANCE_COUNTER_UNIT_PERCENTAGE_KHR = 1, VK_PERFORMANCE_COUNTER_UNIT_NANOSECONDS_KHR = 2, VK_PERFORMANCE_COUNTER_UNIT_BYTES_KHR = 3, VK_PERFORMANCE_COUNTER_UNIT_BYTES_PER_SECOND_KHR = 4, VK_PERFORMANCE_COUNTER_UNIT_KELVIN_KHR = 5, VK_PERFORMANCE_COUNTER_UNIT_WATTS_KHR = 6, VK_PERFORMANCE_COUNTER_UNIT_VOLTS_KHR = 7, VK_PERFORMANCE_COUNTER_UNIT_AMPS_KHR = 8, VK_PERFORMANCE_COUNTER_UNIT_HERTZ_KHR = 9, VK_PERFORMANCE_COUNTER_UNIT_CYCLES_KHR = 10, } VkPerformanceCounterUnitKHR; VK_PERFORMANCE_COUNTER_UNIT_GENERIC_KHR - the performance counter unit is a generic data point. VK_PERFORMANCE_COUNTER_UNIT_PERCENTAGE_KHR - the performance counter unit is a percentage (%). VK_PERFORMANCE_COUNTER_UNIT_NANOSECONDS_KHR - the performance counter unit is a value of nanoseconds (ns). VK_PERFORMANCE_COUNTER_UNIT_BYTES_KHR - the performance counter unit is a value of bytes. VK_PERFORMANCE_COUNTER_UNIT_BYTES_PER_SECOND_KHR - the performance counter unit is a value of bytes/s. VK_PERFORMANCE_COUNTER_UNIT_KELVIN_KHR - the performance counter unit is a temperature reported in Kelvin. VK_PERFORMANCE_COUNTER_UNIT_WATTS_KHR - the performance counter unit is a value of watts (W). VK_PERFORMANCE_COUNTER_UNIT_VOLTS_KHR - the performance counter unit is a value of volts (V). VK_PERFORMANCE_COUNTER_UNIT_AMPS_KHR - the performance counter unit is a value of amps (A). VK_PERFORMANCE_COUNTER_UNIT_HERTZ_KHR - the performance counter unit is a value of hertz (Hz). VK_PERFORMANCE_COUNTER_UNIT_CYCLES_KHR - the performance counter unit is a value of cycles. Performance counters have an associated scope. This scope describes the granularity of a performance counter. The performance counter scope types which may be returned in VkPerformanceCounterKHR::scope are: // Provided by VK_KHR_performance_query typedef enum VkPerformanceCounterScopeKHR { VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR = 0, VK_PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR = 1, VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_KHR = 2, // VK_QUERY_SCOPE_COMMAND_BUFFER_KHR is a deprecated alias VK_QUERY_SCOPE_COMMAND_BUFFER_KHR = VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR, // VK_QUERY_SCOPE_RENDER_PASS_KHR is a deprecated alias VK_QUERY_SCOPE_RENDER_PASS_KHR = VK_PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR, // VK_QUERY_SCOPE_COMMAND_KHR is a deprecated alias VK_QUERY_SCOPE_COMMAND_KHR = VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_KHR, } VkPerformanceCounterScopeKHR; VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR - the performance counter scope is a single complete command buffer. VK_PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR - the performance counter scope is zero or more complete render passes. The performance query containing the performance counter must begin and end outside a render pass instance. VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_KHR - the performance counter scope is zero or more commands. Performance counters have an associated storage. This storage describes the payload of a counter result. The performance counter storage types which may be returned in VkPerformanceCounterKHR::storage are: // Provided by VK_KHR_performance_query typedef enum VkPerformanceCounterStorageKHR { VK_PERFORMANCE_COUNTER_STORAGE_INT32_KHR = 0, VK_PERFORMANCE_COUNTER_STORAGE_INT64_KHR = 1, VK_PERFORMANCE_COUNTER_STORAGE_UINT32_KHR = 2, VK_PERFORMANCE_COUNTER_STORAGE_UINT64_KHR = 3, VK_PERFORMANCE_COUNTER_STORAGE_FLOAT32_KHR = 4, VK_PERFORMANCE_COUNTER_STORAGE_FLOAT64_KHR = 5, } VkPerformanceCounterStorageKHR; VK_PERFORMANCE_COUNTER_STORAGE_INT32_KHR - the performance counter storage is a 32-bit signed integer. VK_PERFORMANCE_COUNTER_STORAGE_INT64_KHR - the performance counter storage is a 64-bit signed integer. VK_PERFORMANCE_COUNTER_STORAGE_UINT32_KHR - the performance counter storage is a 32-bit unsigned integer. VK_PERFORMANCE_COUNTER_STORAGE_UINT64_KHR - the performance counter storage is a 64-bit unsigned integer. VK_PERFORMANCE_COUNTER_STORAGE_FLOAT32_KHR - the performance counter storage is a 32-bit floating-point. VK_PERFORMANCE_COUNTER_STORAGE_FLOAT64_KHR - the performance counter storage is a 64-bit floating-point. The VkPerformanceCounterDescriptionKHR structure is defined as: // Provided by VK_KHR_performance_query typedef struct VkPerformanceCounterDescriptionKHR { VkStructureType sType; void* pNext; VkPerformanceCounterDescriptionFlagsKHR flags; char name[VK_MAX_DESCRIPTION_SIZE]; char category[VK_MAX_DESCRIPTION_SIZE]; char description[VK_MAX_DESCRIPTION_SIZE]; } VkPerformanceCounterDescriptionKHR; sType is a VkStructureType value identifying this structure. pNext is NULL or a pointer to a structure extending this structure. flags is a bitmask of VkPerformanceCounterDescriptionFlagBitsKHR indicating the usage behavior for the counter. name is an array of size VK_MAX_DESCRIPTION_SIZE, containing a null-terminated UTF-8 string specifying the name of the counter. category is an array of size VK_MAX_DESCRIPTION_SIZE, containing a null-terminated UTF-8 string specifying the category of the counter. description is an array of size VK_MAX_DESCRIPTION_SIZE, containing a null-terminated UTF-8 string specifying the description of the counter. Valid Usage (Implicit) VUID-VkPerformanceCounterDescriptionKHR-sType-sType sType must be VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR VUID-VkPerformanceCounterDescriptionKHR-pNext-pNext pNext must be NULL Bits which can be set in VkPerformanceCounterDescriptionKHR::flags, specifying usage behavior of a performance counter, are: // Provided by VK_KHR_performance_query typedef enum VkPerformanceCounterDescriptionFlagBitsKHR { VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_BIT_KHR = 0x00000001, VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_BIT_KHR = 0x00000002, // VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_KHR is a deprecated alias VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_KHR = VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_BIT_KHR, // VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_KHR is a deprecated alias VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_KHR = VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_BIT_KHR, } VkPerformanceCounterDescriptionFlagBitsKHR; VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_BIT_KHR specifies that recording the counter may have a noticeable performance impact. VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_BIT_KHR specifies that concurrently recording the counter while other submitted command buffers are running may impact the accuracy of the recording. // Provided by VK_KHR_performance_query typedef VkFlags VkPerformanceCounterDescriptionFlagsKHR; VkPerformanceCounterDescriptionFlagsKHR is a bitmask type for setting a mask of zero or more VkPerformanceCounterDescriptionFlagBitsKHR. Device objects represent logical connections to physical devices. Each device exposes a number of queue families each having one or more queues. All queues in a queue family support the same operations. As described in Physical Devices, a Vulkan application will first query for all physical devices in a system. Each physical device can then be queried for its capabilities, including its queue and queue family properties. Once an acceptable physical device is identified, an application will create a corresponding logical device. The created logical device is then the primary interface to the physical device. How to enumerate the physical devices in a system and query those physical devices for their queue family properties is described in the Physical Device Enumeration section above. A single logical device can be created from multiple physical devices, if those physical devices belong to the same device group. A device group is a set of physical devices that support accessing each other’s memory and recording a single command buffer that can be executed on all the physical devices. Device groups are enumerated by calling vkEnumeratePhysicalDeviceGroups, and a logical device is created from a subset of the physical devices in a device group by passing the physical devices through VkDeviceGroupDeviceCreateInfo. For two physical devices to be in the same device group, they must support identical extensions, features, and properties. Physical devices in the same device group must be so similar because there are no rules for how different features/properties would interact. They must return the same values for nearly every invariant vkGetPhysicalDevice* feature, property, capability, etc., but could potentially differ for certain queries based on things like having a different display connected, or a different compositor. The specification does not attempt to enumerate which state is in each category, because such a list would quickly become out of date. To retrieve a list of the device groups present in the system, call: // Provided by VK_VERSION_1_1 VkResult vkEnumeratePhysicalDeviceGroups( VkInstance instance, uint32_t* pPhysicalDeviceGroupCount, VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties); or the equivalent command // Provided by VK_KHR_device_group_creation VkResult vkEnumeratePhysicalDeviceGroupsKHR( VkInstance instance, uint32_t* pPhysicalDeviceGroupCount, VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties); instance is a handle to a Vulkan instance previously created with vkCreateInstance. pPhysicalDeviceGroupCount is a pointer to an integer related to the number of device groups available or queried, as described below. pPhysicalDeviceGroupProperties is either NULL or a pointer to an array of VkPhysicalDeviceGroupProperties structures. If pPhysicalDeviceGroupProperties is NULL, then the number of device groups available is returned in pPhysicalDeviceGroupCount. Otherwise, pPhysicalDeviceGroupCount must point to a variable set by the application to the number of elements in the pPhysicalDeviceGroupProperties array, and on return the variable is overwritten with the number of structures actually written to pPhysicalDeviceGroupProperties. If pPhysicalDeviceGroupCount is less than the number of device groups available, at most pPhysicalDeviceGroupCount structures will be written, and VK_INCOMPLETE will be returned instead of VK_SUCCESS, to indicate that not all the available device groups were returned. Every physical device must be in exactly one device group. Valid Usage (Implicit) VUID-vkEnumeratePhysicalDeviceGroups-instance-parameter instance must be a valid VkInstance handle VUID-vkEnumeratePhysicalDeviceGroups-pPhysicalDeviceGroupCount-parameter pPhysicalDeviceGroupCount must be a valid pointer to a uint32_t value VUID-vkEnumeratePhysicalDeviceGroups-pPhysicalDeviceGroupProperties-parameter If the value referenced by pPhysicalDeviceGroupCount is not 0, and pPhysicalDeviceGroupProperties is not NULL, pPhysicalDeviceGroupProperties must be a valid pointer to an array of pPhysicalDeviceGroupCount VkPhysicalDeviceGroupProperties structures Return Codes Success VK_SUCCESS VK_INCOMPLETE Failure VK_ERROR_OUT_OF_HOST_MEMORY VK_ERROR_OUT_OF_DEVICE_MEMORY VK_ERROR_INITIALIZATION_FAILED The VkPhysicalDeviceGroupProperties structure is defined as: // Provided by VK_VERSION_1_1 typedef struct VkPhysicalDeviceGroupProperties { VkStructureType sType; void* pNext; uint32_t physicalDeviceCount; VkPhysicalDevice physicalDevices[VK_MAX_DEVICE_GROUP_SIZE]; VkBool32 subsetAllocation; } VkPhysicalDeviceGroupProperties; or the equivalent // Provided by VK_KHR_device_group_creation typedef VkPhysicalDeviceGroupProperties VkPhysicalDeviceGroupPropertiesKHR; sType is a VkStructureType value identifying this structure. pNext is NULL or a pointer to a structure extending this structure. physicalDeviceCount is the number of physical devices in the group. physicalDevices is an array of VK_MAX_DEVICE_GROUP_SIZE VkPhysicalDevice handles representing all physical devices in the group. The first physicalDeviceCount elements of the array will be valid. subsetAllocation specifies whether logical devices created from the group support allocating device memory on a subset of devices, via the deviceMask member of the VkMemoryAllocateFlagsInfo. If this is VK_FALSE, then all device memory allocations are made across all physical devices in the group. If physicalDeviceCount is 1, then subsetAllocation must be VK_FALSE. Valid Usage (Implicit) VUID-VkPhysicalDeviceGroupProperties-sType-sType sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES VUID-VkPhysicalDeviceGroupProperties-pNext-pNext pNext must be NULL VK_MAX_DEVICE_GROUP_SIZE is the length of an array containing VkPhysicalDevice handle values representing all physical devices in a group, as returned in VkPhysicalDeviceGroupProperties::physicalDevices. #define VK_MAX_DEVICE_GROUP_SIZE 32U or the equivalent #define VK_MAX_DEVICE_GROUP_SIZE_KHR VK_MAX_DEVICE_GROUP_SIZE Logical devices are represented by VkDevice handles: // Provided by VK_VERSION_1_0 VK_DEFINE_HANDLE(VkDevice) A logical device is created as a connection to a physical device. To create a logical device, call: // Provided by VK_VERSION_1_0 VkResult vkCreateDevice( VkPhysicalDevice physicalDevice, const VkDeviceCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDevice* pDevice); physicalDevice must be one of the device handles returned from a call to vkEnumeratePhysicalDevices (see Physical Device Enumeration). pCreateInfo is a pointer to a VkDeviceCreateInfo structure containing information about how to create the device. pAllocator controls host memory allocation as described in the Memory Allocation chapter. pDevice is a pointer to a handle in which the created VkDevice is returned. vkCreateDevice verifies that extensions and features requested in the ppEnabledExtensionNames and pEnabledFeatures members of pCreateInfo, respectively, are supported by the implementation. If any requested extension is not supported, vkCreateDevice must return VK_ERROR_EXTENSION_NOT_PRESENT. If any requested feature is not supported, vkCreateDevice must return VK_ERROR_FEATURE_NOT_PRESENT. Support for extensions can be checked before creating a device by querying vkEnumerateDeviceExtensionProperties. Support for features can similarly be checked by querying vkGetPhysicalDeviceFeatures. After verifying and enabling the extensions the VkDevice object is created and returned to the application. Multiple logical devices can be created from the same physical device. Logical device creation may fail due to lack of device-specific resources (in addition to other errors). If that occurs, vkCreateDevice will return VK_ERROR_TOO_MANY_OBJECTS. Valid Usage VUID-vkCreateDevice-ppEnabledExtensionNames-01387 All required device extensions for each extension in the VkDeviceCreateInfo::ppEnabledExtensionNames list must also be present in that list Valid Usage (Implicit) VUID-vkCreateDevice-physicalDevice-parameter physicalDevice must be a valid VkPhysicalDevice handle VUID-vkCreateDevice-pCreateInfo-parameter pCreateInfo must be a valid pointer to a valid VkDeviceCreateInfo structure VUID-vkCreateDevice-pAllocator-parameter If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure VUID-vkCreateDevice-pDevice-parameter pDevice must be a valid pointer to a VkDevice handle Return Codes Success VK_SUCCESS Failure VK_ERROR_OUT_OF_HOST_MEMORY VK_ERROR_OUT_OF_DEVICE_MEMORY VK_ERROR_INITIALIZATION_FAILED VK_ERROR_EXTENSION_NOT_PRESENT VK_ERROR_FEATURE_NOT_PRESENT VK_ERROR_TOO_MANY_OBJECTS VK_ERROR_DEVICE_LOST The VkDeviceCreateInfo structure is defined as: // Provided by VK_VERSION_1_0 typedef struct VkDeviceCreateInfo { VkStructureType sType; const void* pNext; VkDeviceCreateFlags flags; uint32_t queueCreateInfoCount; const VkDeviceQueueCreateInfo* pQueueCreateInfos; // enabledLayerCount is deprecated and should not be used uint32_t enabledLayerCount; // ppEnabledLayerNames is deprecated and should not be used const char* const* ppEnabledLayerNames; uint32_t enabledExtensionCount; const char* const* ppEnabledExtensionNames; const VkPhysicalDeviceFeatures* pEnabledFeatures; } VkDeviceCreateInfo; sType is a VkStructureType value identifying this structure. pNext is NULL or a pointer to a structure extending this structure. flags is reserved for future use. queueCreateInfoCount is the unsigned integer size of the pQueueCreateInfos array. Refer to the Queue Creation section below for further details. pQueueCreateInfos is a pointer to an array of VkDeviceQueueCreateInfo structures describing the queues that are requested to be created along with the logical device. Refer to the Queue Creation section below for further details. enabledLayerCount is deprecated and ignored. ppEnabledLayerNames is deprecated and ignored. See Device Layer Deprecation. enabledExtensionCount is the number of device extensions to enable. ppEnabledExtensionNames is a pointer to an array of enabledExtensionCount null-terminated UTF-8 strings containing the names of extensions to enable for the created device. See the Extensions section for further details. pEnabledFeatures is NULL or a pointer to a VkPhysicalDeviceFeatures structure containing boolean indicators of all the features to be enabled. Refer to the Features section for further details. Valid Usage VUID-VkDeviceCreateInfo-queueFamilyIndex-02802 The queueFamilyIndex member of each element of pQueueCreateInfos must be unique within pQueueCreateInfos , except that two members can share the same queueFamilyIndex if one describes protected-capable queues and one describes queues that are not protected-capable VUID-VkDeviceCreateInfo-pQueueCreateInfos-06755 If multiple elements of pQueueCreateInfos share the same queueFamilyIndex, the sum of their queueCount members must be less than or equal to the queueCount member of the VkQueueFamilyProperties structure, as returned by vkGetPhysicalDeviceQueueFamilyProperties in the pQueueFamilyProperties[queueFamilyIndex] VUID-VkDeviceCreateInfo-pQueueCreateInfos-06654 If multiple elements of pQueueCreateInfos share the same queueFamilyIndex, then all of such elements must have the same global priority level, which can be specified explicitly by the including a VkDeviceQueueGlobalPriorityCreateInfo structure in the pNext chain, or by the implicit default value VUID-VkDeviceCreateInfo-pNext-00373 If the pNext chain includes a VkPhysicalDeviceFeatures2 structure, then pEnabledFeatures must be NULL VUID-VkDeviceCreateInfo-ppEnabledExtensionNames-01840 If VkPhysicalDeviceProperties::apiVersion advertises Vulkan 1.1 or later, ppEnabledExtensionNames must not contain VK_AMD_negative_viewport_height VUID-VkDeviceCreateInfo-ppEnabledExtensionNames-00374 ppEnabledExtensionNames must not contain both VK_KHR_maintenance1 and VK_AMD_negative_viewport_height VUID-VkDeviceCreateInfo-ppEnabledExtensionNames-03328 ppEnabledExtensionNames must not contain both VK_KHR_buffer_device_address and VK_EXT_buffer_device_address VUID-VkDeviceCreateInfo-pNext-04748 If the pNext chain includes a VkPhysicalDeviceVulkan12Features structure and VkPhysicalDeviceVulkan12Features::bufferDeviceAddress is VK_TRUE, ppEnabledExtensionNames must not contain VK_EXT_buffer_device_address VUID-VkDeviceCreateInfo-pNext-02829 If the pNext chain includes a VkPhysicalDeviceVulkan11Features structure, then it must not include a VkPhysicalDevice16BitStorageFeatures, VkPhysicalDeviceMultiviewFeatures, VkPhysicalDeviceVariablePointersFeatures, VkPhysicalDeviceProtectedMemoryFeatures, VkPhysicalDeviceSamplerYcbcrConversionFeatures, or VkPhysicalDeviceShaderDrawParametersFeatures structure VUID-VkDeviceCreateInfo-pNext-02830 If the pNext chain includes a VkPhysicalDeviceVulkan12Features structure, then it must not include a VkPhysicalDevice8BitStorageFeatures, VkPhysicalDeviceShaderAtomicInt64Features, VkPhysicalDeviceShaderFloat16Int8Features, VkPhysicalDeviceDescriptorIndexingFeatures, VkPhysicalDeviceScalarBlockLayoutFeatures, VkPhysicalDeviceImagelessFramebufferFeatures, VkPhysicalDeviceUniformBufferStandardLayoutFeatures, VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures, VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures, VkPhysicalDeviceHostQueryResetFeatures, VkPhysicalDeviceTimelineSemaphoreFeatures, VkPhysicalDeviceBufferDeviceAddressFeatures, or VkPhysicalDeviceVulkanMemoryModelFeatures structure VUID-VkDeviceCreateInfo-ppEnabledExtensionNames-04476 If ppEnabledExtensionNames contains "VK_KHR_shader_draw_parameters" and the pNext chain includes a VkPhysicalDeviceVulkan11Features structure, then VkPhysicalDeviceVulkan11Features::shaderDrawParameters must be VK_TRUE VUID-VkDeviceCreateInfo-ppEnabledExtensionNames-02831 If ppEnabledExtensionNames contains "VK_KHR_draw_indirect_count" and the pNext chain includes a VkPhysicalDeviceVulkan12Features structure, then VkPhysicalDeviceVulkan12Features::drawIndirectCount must be VK_TRUE VUID-VkDeviceCreateInfo-ppEnabledExtensionNames-02832 If ppEnabledExtensionNames contains "VK_KHR_sampler_mirror_clamp_to_edge" and the pNext chain includes a VkPhysicalDeviceVulkan12Features structure, then VkPhysicalDeviceVulkan12Features::samplerMirrorClampToEdge must be VK_TRUE VUID-VkDeviceCreateInfo-ppEnabledExtensionNames-02833 If ppEnabledExtensionNames contains "VK_EXT_descriptor_indexing" and the pNext chain includes a VkPhysicalDeviceVulkan12Features structure, then VkPhysicalDeviceVulkan12Features::descriptorIndexing must be VK_TRUE VUID-VkDeviceCreateInfo-ppEnabledExtensionNames-02834 If ppEnabledExtensionNames contains "VK_EXT_sampler_filter_minmax" and the pNext chain includes a VkPhysicalDeviceVulkan12Features structure, then VkPhysicalDeviceVulkan12Features::samplerFilterMinmax must be VK_TRUE VUID-VkDeviceCreateInfo-ppEnabledExtensionNames-02835 If ppEnabledExtensionNames contains "VK_EXT_shader_viewport_index_layer" and the pNext chain includes a VkPhysicalDeviceVulkan12Features structure, then VkPhysicalDeviceVulkan12Features::shaderOutputViewportIndex and VkPhysicalDeviceVulkan12Features::shaderOutputLayer must both be VK_TRUE VUID-VkDeviceCreateInfo-pNext-06532 If the pNext chain includes a VkPhysicalDeviceVulkan13Features structure, then it must not include a VkPhysicalDeviceDynamicRenderingFeatures, VkPhysicalDeviceImageRobustnessFeatures, VkPhysicalDeviceInlineUniformBlockFeatures, VkPhysicalDeviceMaintenance4Features, VkPhysicalDevicePipelineCreationCacheControlFeatures, VkPhysicalDevicePrivateDataFeatures, VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures, VkPhysicalDeviceShaderIntegerDotProductFeatures, VkPhysicalDeviceShaderTerminateInvocationFeatures, VkPhysicalDeviceSubgroupSizeControlFeatures, VkPhysicalDeviceSynchronization2Features, VkPhysicalDeviceTextureCompressionASTCHDRFeatures, or VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures structure VUID-VkDeviceCreateInfo-pNext-10360 If the pNext chain includes a VkPhysicalDeviceVulkan14Features structure, then it must not include a VkPhysicalDeviceGlobalPriorityQueryFeatures VkPhysicalDeviceShaderSubgroupRotateFeatures VkPhysicalDeviceShaderFloatControls2Features VkPhysicalDeviceShaderExpectAssumeFeatures VkPhysicalDeviceLineRasterizationFeatures VkPhysicalDeviceVertexAttributeDivisorFeatures VkPhysicalDeviceIndexTypeUint8Features VkPhysicalDeviceDynamicRenderingLocalReadFeatures VkPhysicalDeviceMaintenance5Features VkPhysicalDeviceMaintenance6Features VkPhysicalDevicePipelineProtectedAccessFeatures VkPhysicalDevicePipelineRobustnessFeatures, or VkPhysicalDeviceHostImageCopyFeatures structure VUID-VkDeviceCreateInfo-pProperties-04451 If the VK_KHR_portability_subset extension is included in pProperties of vkEnumerateDeviceExtensionProperties, ppEnabledExtensionNames must include "VK_KHR_portability_subset" VUID-VkDeviceCreateInfo-shadingRateImage-04478 If the shadingRateImage feature is enabled, the pipelineFragmentShadingRate feature must not be enabled VUID-VkDeviceCreateInfo-shadingRateImage-04479 If the shadingRateImage feature is enabled, the primitiveFragmentShadingRate feature must not be enabled VUID-VkDeviceCreateInfo-shadingRateImage-04480 If the shadingRateImage feature is enabled, the attachmentFragmentShadingRate feature must not be enabled VUID-VkDeviceCreateInfo-fragmentDensityMap-04481 If the fragmentDensityMap feature is enabled, the pipelineFragmentShadingRate feature must not be enabled VUID-VkDeviceCreateInfo-fragmentDensityMap-04482 If the fragmentDensityMap feature is enabled, the primitiveFragmentShadingRate feature must not be enabled VUID-VkDeviceCreateInfo-fragmentDensityMap-04483 If the fragmentDensityMap feature is enabled, the attachmentFragmentShadingRate feature must not be enabled VUID-VkDeviceCreateInfo-None-04896 If the sparseImageInt64Atomics feature is enabled, shaderImageInt64Atomics must be enabled VUID-VkDeviceCreateInfo-None-04897 If the sparseImageFloat32Atomics feature is enabled, shaderImageFloat32Atomics must be enabled VUID-VkDeviceCreateInfo-None-04898 If the sparseImageFloat32AtomicAdd feature is enabled, shaderImageFloat32AtomicAdd must be enabled VUID-VkDeviceCreateInfo-sparseImageFloat32AtomicMinMax-04975 If the sparseImageFloat32AtomicMinMax feature is enabled, shaderImageFloat32AtomicMinMax must be enabled VUID-VkDeviceCreateInfo-robustBufferAccess-10247 If the robustBufferAccess feature is enabled, and robustBufferAccessUpdateAfterBind is VK_FALSE, then descriptorBindingUniformBufferUpdateAfterBind, descriptorBindingStorageBufferUpdateAfterBind, descriptorBindingUniformTexelBufferUpdateAfterBind, and descriptorBindingStorageTexelBufferUpdateAfterBind must not be enabled VUID-VkDeviceCreateInfo-None-08095 If the descriptorBuffer feature is enabled, ppEnabledExtensionNames must not contain VK_AMD_shader_fragment_mask VUID-VkDeviceCreateInfo-pNext-09396 If the pNext chain includes a VkDeviceQueueShaderCoreControlCreateInfoARM structure, then it must not be included in the pNext chain of any of the VkDeviceQueueCreateInfo structures in pQueueCreateInfos VUID-VkDeviceCreateInfo-pNext-09397 If the pNext chain includes a VkDeviceQueueShaderCoreControlCreateInfoARM structure then VkPhysicalDeviceSchedulingControlsPropertiesARM::schedulingControlsFlags must contain VK_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_SHADER_CORE_COUNT_ARM Valid Usage (Implicit) VUID-VkDeviceCreateInfo-sType-sType sType must be VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO VUID-VkDeviceCreateInfo-pNext-pNext Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkDeviceDeviceMemoryReportCreateInfoEXT, VkDeviceDiagnosticsConfigCreateInfoNV, VkDeviceGroupDeviceCreateInfo, VkDeviceMemoryOverallocationCreateInfoAMD, VkDevicePipelineBinaryInternalCacheControlKHR, VkDevicePrivateDataCreateInfo, VkDeviceQueueShaderCoreControlCreateInfoARM, VkExternalComputeQueueDeviceCreateInfoNV, VkPhysicalDevice16BitStorageFeatures, VkPhysicalDevice4444FormatsFeaturesEXT, VkPhysicalDevice8BitStorageFeatures, VkPhysicalDeviceASTCDecodeFeaturesEXT, VkPhysicalDeviceAccelerationStructureFeaturesKHR, VkPhysicalDeviceAddressBindingReportFeaturesEXT, VkPhysicalDeviceAmigoProfilingFeaturesSEC, VkPhysicalDeviceAntiLagFeaturesAMD, VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT, VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT, VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT, VkPhysicalDeviceBorderColorSwizzleFeaturesEXT, VkPhysicalDeviceBufferDeviceAddressFeatures, VkPhysicalDeviceBufferDeviceAddressFeaturesEXT, VkPhysicalDeviceClusterAccelerationStructureFeaturesNV, VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI, VkPhysicalDeviceCoherentMemoryFeaturesAMD, VkPhysicalDeviceColorWriteEnableFeaturesEXT, VkPhysicalDeviceCommandBufferInheritanceFeaturesNV, VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR, VkPhysicalDeviceConditionalRenderingFeaturesEXT, VkPhysicalDeviceCooperativeMatrix2FeaturesNV, VkPhysicalDeviceCooperativeMatrixFeaturesKHR, VkPhysicalDeviceCooperativeMatrixFeaturesNV, VkPhysicalDeviceCooperativeVectorFeaturesNV, VkPhysicalDeviceCopyMemoryIndirectFeaturesNV, VkPhysicalDeviceCornerSampledImageFeaturesNV, VkPhysicalDeviceCoverageReductionModeFeaturesNV, VkPhysicalDeviceCubicClampFeaturesQCOM, VkPhysicalDeviceCubicWeightsFeaturesQCOM, VkPhysicalDeviceCudaKernelLaunchFeaturesNV, VkPhysicalDeviceCustomBorderColorFeaturesEXT, VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV, VkPhysicalDeviceDepthBiasControlFeaturesEXT, VkPhysicalDeviceDepthClampControlFeaturesEXT, VkPhysicalDeviceDepthClampZeroOneFeaturesKHR, VkPhysicalDeviceDepthClipControlFeaturesEXT, VkPhysicalDeviceDepthClipEnableFeaturesEXT, VkPhysicalDeviceDescriptorBufferFeaturesEXT, VkPhysicalDeviceDescriptorIndexingFeatures, VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV, VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE, VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV, VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT, VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV, VkPhysicalDeviceDeviceMemoryReportFeaturesEXT, VkPhysicalDeviceDiagnosticsConfigFeaturesNV, VkPhysicalDeviceDisplacementMicromapFeaturesNV, VkPhysicalDeviceDynamicRenderingFeatures, VkPhysicalDeviceDynamicRenderingLocalReadFeatures, VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT, VkPhysicalDeviceExclusiveScissorFeaturesNV, VkPhysicalDeviceExtendedDynamicState2FeaturesEXT, VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, VkPhysicalDeviceExtendedDynamicStateFeaturesEXT, VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV, VkPhysicalDeviceExternalFormatResolveFeaturesANDROID, VkPhysicalDeviceExternalMemoryRDMAFeaturesNV, VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX, VkPhysicalDeviceFaultFeaturesEXT, VkPhysicalDeviceFeatures2, VkPhysicalDeviceFragmentDensityMap2FeaturesEXT, VkPhysicalDeviceFragmentDensityMapFeaturesEXT, VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT, VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR, VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT, VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV, VkPhysicalDeviceFragmentShadingRateFeaturesKHR, VkPhysicalDeviceFrameBoundaryFeaturesEXT, VkPhysicalDeviceGlobalPriorityQueryFeatures, VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT, VkPhysicalDeviceHdrVividFeaturesHUAWEI, VkPhysicalDeviceHostImageCopyFeatures, VkPhysicalDeviceHostQueryResetFeatures, VkPhysicalDeviceImage2DViewOf3DFeaturesEXT, VkPhysicalDeviceImageAlignmentControlFeaturesMESA, VkPhysicalDeviceImageCompressionControlFeaturesEXT, VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT, VkPhysicalDeviceImageProcessing2FeaturesQCOM, VkPhysicalDeviceImageProcessingFeaturesQCOM, VkPhysicalDeviceImageRobustnessFeatures, VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT, VkPhysicalDeviceImageViewMinLodFeaturesEXT, VkPhysicalDeviceImagelessFramebufferFeatures, VkPhysicalDeviceIndexTypeUint8Features, VkPhysicalDeviceInheritedViewportScissorFeaturesNV, VkPhysicalDeviceInlineUniformBlockFeatures, VkPhysicalDeviceInvocationMaskFeaturesHUAWEI, VkPhysicalDeviceLegacyDitheringFeaturesEXT, VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT, VkPhysicalDeviceLineRasterizationFeatures, VkPhysicalDeviceLinearColorAttachmentFeaturesNV, VkPhysicalDeviceMaintenance4Features, VkPhysicalDeviceMaintenance5Features, VkPhysicalDeviceMaintenance6Features, VkPhysicalDeviceMaintenance7FeaturesKHR, VkPhysicalDeviceMaintenance8FeaturesKHR, VkPhysicalDeviceMapMemoryPlacedFeaturesEXT, VkPhysicalDeviceMemoryDecompressionFeaturesNV, VkPhysicalDeviceMemoryPriorityFeaturesEXT, VkPhysicalDeviceMeshShaderFeaturesEXT, VkPhysicalDeviceMeshShaderFeaturesNV, VkPhysicalDeviceMultiDrawFeaturesEXT, VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT, VkPhysicalDeviceMultiviewFeatures, VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM, VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM, VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT, VkPhysicalDeviceNestedCommandBufferFeaturesEXT, VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT, VkPhysicalDeviceOpacityMicromapFeaturesEXT, VkPhysicalDeviceOpticalFlowFeaturesNV, VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT, VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV, VkPhysicalDevicePerStageDescriptorSetFeaturesNV, VkPhysicalDevicePerformanceQueryFeaturesKHR, VkPhysicalDevicePipelineBinaryFeaturesKHR, VkPhysicalDevicePipelineCreationCacheControlFeatures, VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR, VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT, VkPhysicalDevicePipelineOpacityMicromapFeaturesARM, VkPhysicalDevicePipelinePropertiesFeaturesEXT, VkPhysicalDevicePipelineProtectedAccessFeatures, VkPhysicalDevicePipelineRobustnessFeatures, VkPhysicalDevicePortabilitySubsetFeaturesKHR, VkPhysicalDevicePresentBarrierFeaturesNV, VkPhysicalDevicePresentIdFeaturesKHR, VkPhysicalDevicePresentMeteringFeaturesNV, VkPhysicalDevicePresentModeFifoLatestReadyFeaturesEXT, VkPhysicalDevicePresentWaitFeaturesKHR, VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT, VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT, VkPhysicalDevicePrivateDataFeatures, VkPhysicalDeviceProtectedMemoryFeatures, VkPhysicalDeviceProvokingVertexFeaturesEXT, VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT, VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT, VkPhysicalDeviceRawAccessChainsFeaturesNV, VkPhysicalDeviceRayQueryFeaturesKHR, VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV, VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV, VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR, VkPhysicalDeviceRayTracingMotionBlurFeaturesNV, VkPhysicalDeviceRayTracingPipelineFeaturesKHR, VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR, VkPhysicalDeviceRayTracingValidationFeaturesNV, VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG, VkPhysicalDeviceRenderPassStripedFeaturesARM, VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV, VkPhysicalDeviceRobustness2FeaturesKHR, VkPhysicalDeviceSamplerYcbcrConversionFeatures, VkPhysicalDeviceScalarBlockLayoutFeatures, VkPhysicalDeviceSchedulingControlsFeaturesARM, VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures, VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV, VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT, VkPhysicalDeviceShaderAtomicFloatFeaturesEXT, VkPhysicalDeviceShaderAtomicInt64Features, VkPhysicalDeviceShaderBfloat16FeaturesKHR, VkPhysicalDeviceShaderClockFeaturesKHR, VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM, VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures, VkPhysicalDeviceShaderDrawParametersFeatures, VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD, VkPhysicalDeviceShaderEnqueueFeaturesAMDX, VkPhysicalDeviceShaderExpectAssumeFeatures, VkPhysicalDeviceShaderFloat16Int8Features, VkPhysicalDeviceShaderFloatControls2Features, VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT, VkPhysicalDeviceShaderImageFootprintFeaturesNV, VkPhysicalDeviceShaderIntegerDotProductFeatures, VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL, VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR, VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT, VkPhysicalDeviceShaderObjectFeaturesEXT, VkPhysicalDeviceShaderQuadControlFeaturesKHR, VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR, VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT, VkPhysicalDeviceShaderSMBuiltinsFeaturesNV, VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures, VkPhysicalDeviceShaderSubgroupRotateFeatures, VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR, VkPhysicalDeviceShaderTerminateInvocationFeatures, VkPhysicalDeviceShaderTileImageFeaturesEXT, VkPhysicalDeviceShadingRateImageFeaturesNV, VkPhysicalDeviceSubgroupSizeControlFeatures, VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT, VkPhysicalDeviceSubpassShadingFeaturesHUAWEI, VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT, VkPhysicalDeviceSynchronization2Features, VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT, VkPhysicalDeviceTextureCompressionASTCHDRFeatures, VkPhysicalDeviceTileMemoryHeapFeaturesQCOM, VkPhysicalDeviceTilePropertiesFeaturesQCOM, VkPhysicalDeviceTileShadingFeaturesQCOM, VkPhysicalDeviceTimelineSemaphoreFeatures, VkPhysicalDeviceTransformFeedbackFeaturesEXT, VkPhysicalDeviceUniformBufferStandardLayoutFeatures, VkPhysicalDeviceVariablePointersFeatures, VkPhysicalDeviceVertexAttributeDivisorFeatures, VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT, VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT, VkPhysicalDeviceVideoEncodeAV1FeaturesKHR, VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR, VkPhysicalDeviceVideoMaintenance1FeaturesKHR, VkPhysicalDeviceVideoMaintenance2FeaturesKHR, VkPhysicalDeviceVulkan11Features, VkPhysicalDeviceVulkan12Features, VkPhysicalDeviceVulkan13Features, VkPhysicalDeviceVulkan14Features, VkPhysicalDeviceVulkanMemoryModelFeatures, VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR, VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT, VkPhysicalDeviceYcbcrDegammaFeaturesQCOM, VkPhysicalDeviceYcbcrImageArraysFeaturesEXT, VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT, or VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures VUID-VkDeviceCreateInfo-sType-unique The sType value of each structure in the pNext chain must be unique, with the exception of structures of type VkDeviceDeviceMemoryReportCreateInfoEXT or VkDevicePrivateDataCreateInfo VUID-VkDeviceCreateInfo-flags-zerobitmask flags must be 0 VUID-VkDeviceCreateInfo-pQueueCreateInfos-parameter pQueueCreateInfos must be a valid pointer to an array of queueCreateInfoCount valid VkDeviceQueueCreateInfo structures VUID-VkDeviceCreateInfo-ppEnabledLayerNames-parameter If enabledLayerCount is not 0, ppEnabledLayerNames must be a valid pointer to an array of enabledLayerCount null-terminated UTF-8 strings VUID-VkDeviceCreateInfo-ppEnabledExtensionNames-parameter If enabledExtensionCount is not 0, ppEnabledExtensionNames must be a valid pointer to an array of enabledExtensionCount null-terminated UTF-8 strings VUID-VkDeviceCreateInfo-pEnabledFeatures-parameter If pEnabledFeatures is not NULL, pEnabledFeatures must be a valid pointer to a valid VkPhysicalDeviceFeatures structure VUID-VkDeviceCreateInfo-queueCreateInfoCount-arraylength queueCreateInfoCount must be greater than 0 // Provided by VK_VERSION_1_0 typedef VkFlags VkDeviceCreateFlags; VkDeviceCreateFlags is a bitmask type for setting a mask, but is currently reserved for future use. A logical device can be created that connects to one or more physical devices by adding a VkDeviceGroupDeviceCreateInfo structure to the pNext chain of VkDeviceCreateInfo. The VkDeviceGroupDeviceCreateInfo structure is defined as: // Provided by VK_VERSION_1_1 typedef struct VkDeviceGroupDeviceCreateInfo { VkStructureType sType; const void* pNext; uint32_t physicalDeviceCount; const VkPhysicalDevice* pPhysicalDevices; } VkDeviceGroupDeviceCreateInfo; or the equivalent // Provided by VK_KHR_device_group_creation typedef VkDeviceGroupDeviceCreateInfo VkDeviceGroupDeviceCreateInfoKHR; sType is a VkStructureType value identifying this structure. pNext is NULL or a pointer to a structure extending this structure. physicalDeviceCount is the number of elements in the pPhysicalDevices array. pPhysicalDevices is a pointer to an array of physical device handles belonging to the same device group. The elements of the pPhysicalDevices array are an ordered list of the physical devices that the logical device represents. These must be a subset of a single device group, and need not be in the same order as they were enumerated. The order of the physical devices in the pPhysicalDevices array determines the device index of each physical device, with element i being assigned a device index of i. Certain commands and structures refer to one or more physical devices by using device indices or device masks formed using device indices. A logical device created without using VkDeviceGroupDeviceCreateInfo, or with physicalDeviceCount equal to zero, is equivalent to a physicalDeviceCount of one and pPhysicalDevices pointing to the physicalDevice parameter to vkCreateDevice. In particular, the device index of that physical device is zero. Valid Usage VUID-VkDeviceGroupDeviceCreateInfo-pPhysicalDevices-00375 Each element of pPhysicalDevices must be unique VUID-VkDeviceGroupDeviceCreateInfo-pPhysicalDevices-00376 All elements of pPhysicalDevices must be in the same device group as enumerated by vkEnumeratePhysicalDeviceGroups VUID-VkDeviceGroupDeviceCreateInfo-physicalDeviceCount-00377 If physicalDeviceCount is not 0, the physicalDevice parameter of vkCreateDevice must be an element of pPhysicalDevices Valid Usage (Implicit) VUID-VkDeviceGroupDeviceCreateInfo-sType-sType sType must be VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO VUID-VkDeviceGroupDeviceCreateInfo-pPhysicalDevices-parameter If physicalDeviceCount is not 0, pPhysicalDevices must be a valid pointer to an array of physicalDeviceCount valid VkPhysicalDevice handles To specify whether device memory allocation is allowed beyond the size reported by VkPhysicalDeviceMemoryProperties, add a VkDeviceMemoryOverallocationCreateInfoAMD structure to the pNext chain of the VkDeviceCreateInfo structure. If this structure is not specified, it is as if the VK_MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD value is used. // Provided by VK_AMD_memory_overallocation_behavior typedef struct VkDeviceMemoryOverallocationCreateInfoAMD { VkStructureType sType; const void* pNext; VkMemoryOverallocationBehaviorAMD overallocationBehavior; } VkDeviceMemoryOverallocationCreateInfoAMD; sType is a VkStructureType value identifying this structure. pNext is NULL or a pointer to a structure extending this structure. overallocationBehavior is the desired overallocation behavior. Valid Usage (Implicit) VUID-VkDeviceMemoryOverallocationCreateInfoAMD-sType-sType sType must be VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD VUID-VkDeviceMemoryOverallocationCreateInfoAMD-overallocationBehavior-parameter overallocationBehavior must be a valid VkMemoryOverallocationBehaviorAMD value Possible values for VkDeviceMemoryOverallocationCreateInfoAMD::overallocationBehavior include: // Provided by VK_AMD_memory_overallocation_behavior typedef enum VkMemoryOverallocationBehaviorAMD { VK_MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD = 0, VK_MEMORY_OVERALLOCATION_BEHAVIOR_ALLOWED_AMD = 1, VK_MEMORY_OVERALLOCATION_BEHAVIOR_DISALLOWED_AMD = 2, } VkMemoryOverallocationBehaviorAMD; VK_MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD lets the implementation decide if overallocation is allowed. VK_MEMORY_OVERALLOCATION_BEHAVIOR_ALLOWED_AMD specifies overallocation is allowed if platform permits. VK_MEMORY_OVERALLOCATION_BEHAVIOR_DISALLOWED_AMD specifies the application is not allowed to allocate device memory beyond the heap sizes reported by VkPhysicalDeviceMemoryProperties. Allocations that are not explicitly made by the application within the scope of the Vulkan instance are not accounted for. When using the Nsight™ Aftermath SDK, to configure how device crash dumps are created, add a VkDeviceDiagnosticsConfigCreateInfoNV structure to the pNext chain of the VkDeviceCreateInfo structure. // Provided by VK_NV_device_diagnostics_config typedef struct VkDeviceDiagnosticsConfigCreateInfoNV { VkStructureType sType; const void* pNext; VkDeviceDiagnosticsConfigFlagsNV flags; } VkDeviceDiagnosticsConfigCreateInfoNV; sType is a VkStructureType value identifying this structure. pNext is NULL or a pointer to a structure extending this structure. flags is a bitmask of VkDeviceDiagnosticsConfigFlagBitsNV specifying additional parameters for configuring diagnostic tools. Valid Usage (Implicit) VUID-VkDeviceDiagnosticsConfigCreateInfoNV-sType-sType sType must be VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV VUID-VkDeviceDiagnosticsConfigCreateInfoNV-flags-parameter flags must be a valid combination of VkDeviceDiagnosticsConfigFlagBitsNV values Bits which can be set in VkDeviceDiagnosticsConfigCreateInfoNV::flags include: // Provided by VK_NV_device_diagnostics_config typedef enum VkDeviceDiagnosticsConfigFlagBitsNV { VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_DEBUG_INFO_BIT_NV = 0x00000001, VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_RESOURCE_TRACKING_BIT_NV = 0x00000002, VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_AUTOMATIC_CHECKPOINTS_BIT_NV = 0x00000004, VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_ERROR_REPORTING_BIT_NV = 0x00000008, } VkDeviceDiagnosticsConfigFlagBitsNV; VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_DEBUG_INFO_BIT_NV enables the generation of debug information for shaders. VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_RESOURCE_TRACKING_BIT_NV enables driver side tracking of resources (images, buffers, etc.) used to augment the device fault information. VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_AUTOMATIC_CHECKPOINTS_BIT_NV enables automatic insertion of diagnostic checkpoints for draw calls, dispatches, trace rays, and copies. The CPU call stack at the time of the command will be associated as the marker data for the automatically inserted checkpoints. VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_ERROR_REPORTING_BIT_NV enables shader error reporting. // Provided by VK_NV_device_diagnostics_config typedef VkFlags VkDeviceDiagnosticsConfigFlagsNV; VkDeviceDiagnosticsConfigFlagsNV is a bitmask type for setting a mask of zero or more VkDeviceDiagnosticsConfigFlagBitsNV. To register callbacks for underlying device memory events of type VkDeviceMemoryReportEventTypeEXT, add one or multiple VkDeviceDeviceMemoryReportCreateInfoEXT structures to the pNext chain of the VkDeviceCreateInfo structure. // Provided by VK_EXT_device_memory_report typedef struct VkDeviceDeviceMemoryReportCreateInfoEXT { VkStructureType sType; const void* pNext; VkDeviceMemoryReportFlagsEXT flags; PFN_vkDeviceMemoryReportCallbackEXT pfnUserCallback; void* pUserData; } VkDeviceDeviceMemoryReportCreateInfoEXT; sType is a VkStructureType value identifying this structure. pNext is NULL or a pointer to a structure extending this structure. flags is 0 and reserved for future use. pfnUserCallback is the application callback function to call. pUserData is user data to be passed to the callback. The callback may be called from multiple threads simultaneously. The callback must be called only once by the implementation when a VkDeviceMemoryReportEventTypeEXT event occurs. The callback could be called from a background thread other than the thread calling the Vulkan commands. Valid Usage (Implicit) VUID-VkDeviceDeviceMemoryReportCreateInfoEXT-sType-sType sType must be VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT VUID-VkDeviceDeviceMemoryReportCreateInfoEXT-flags-zerobitmask flags must be 0 VUID-VkDeviceDeviceMemoryReportCreateInfoEXT-pfnUserCallback-parameter pfnUserCallback must be a valid PFN_vkDeviceMemoryReportCallbackEXT value VUID-VkDeviceDeviceMemoryReportCreateInfoEXT-pUserData-parameter pUserData must be a pointer value The prototype for the VkDeviceDeviceMemoryReportCreateInfoEXT::pfnUserCallback function implemented by the application is: // Provided by VK_EXT_device_memory_report typedef void (VKAPI_PTR *PFN_vkDeviceMemoryReportCallbackEXT)( const VkDeviceMemoryReportCallbackDataEXT* pCallbackData, void* pUserData); pCallbackData contains all the callback related data in the VkDeviceMemoryReportCallbackDataEXT structure. pUserData is the user data provided when the VkDeviceDeviceMemoryReportCreateInfoEXT was created. The callback must not make calls to any Vulkan commands. The definition of VkDeviceMemoryReportCallbackDataEXT is: // Provided by VK_EXT_device_memory_report typedef struct VkDeviceMemoryReportCallbackDataEXT { VkStructureType sType; void* pNext; VkDeviceMemoryReportFlagsEXT flags; VkDeviceMemoryReportEventTypeEXT type; uint64_t memoryObjectId; VkDeviceSize size; VkObjectType objectType; uint64_t objectHandle; uint32_t heapIndex; } VkDeviceMemoryReportCallbackDataEXT; sType is a VkStructureType value identifying this structure. pNext is NULL or a pointer to a structure extending this structure. flags is 0 and reserved for future use. type is a VkDeviceMemoryReportEventTypeEXT type specifying the type of event reported in this VkDeviceMemoryReportCallbackDataEXT structure. memoryObjectId is the unique id for the underlying memory object as described below. size is the size of the memory object in bytes. If type is VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT, VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_IMPORT_EXT or VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATION_FAILED_EXT, size is a valid VkDeviceSize value. Otherwise, size is undefined. objectType is a VkObjectType value specifying the type of the object associated with this device memory report event. If type is VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT, VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_FREE_EXT, VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_IMPORT_EXT, VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_UNIMPORT_EXT or VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATION_FAILED_EXT, objectType is a valid VkObjectType enum. Otherwise, objectType is undefined. objectHandle is the object this device memory report event is attributed to. If type is VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT, VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_FREE_EXT, VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_IMPORT_EXT or VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_UNIMPORT_EXT, objectHandle is a valid Vulkan handle of the type associated with objectType as defined in the VkObjectType and Vulkan Handle Relationship table. Otherwise, objectHandle is undefined. heapIndex describes which memory heap this device memory allocation is made from. If type is VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT or VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATION_FAILED_EXT, heapIndex corresponds to one of the valid heaps from the VkPhysicalDeviceMemoryProperties structure. Otherwise, heapIndex is undefined. memoryObjectId is used to avoid double-counting on the same memory object. If an internally-allocated device memory object or a VkDeviceMemory cannot be exported, memoryObjectId must be unique in the VkDevice. If an internally-allocated device memory object or a VkDeviceMemory supports being exported, memoryObjectId must be unique system wide. If an internal device memory object or a VkDeviceMemory is backed by an imported external memory object, memoryObjectId must be unique system wide. This structure should only be considered valid during the lifetime of the triggered callback. For VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT and VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_IMPORT_EXT events, objectHandle usually will not yet exist when the application or tool receives the callback. objectHandle will only exist when the create or allocate call that triggered the event returns, and if the allocation or import ends up failing objectHandle will not ever exist. Valid Usage (Implicit) VUID-VkDeviceMemoryReportCallbackDataEXT-sType-sType sType must be VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT VUID-VkDeviceMemoryReportCallbackDataEXT-pNext-pNext pNext must be NULL // Provided by VK_EXT_device_memory_report typedef VkFlags VkDeviceMemoryReportFlagsEXT; VkDeviceMemoryReportFlagsEXT is a bitmask type for setting a mask, but is currently reserved for future use. Possible values of VkDeviceMemoryReportCallbackDataEXT::type, specifying event types which cause the device driver to call the callback, are: // Provided by VK_EXT_device_memory_report typedef enum VkDeviceMemoryReportEventTypeEXT { VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT = 0, VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_FREE_EXT = 1, VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_IMPORT_EXT = 2, VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_UNIMPORT_EXT = 3, VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATION_FAILED_EXT = 4, } VkDeviceMemoryReportEventTypeEXT; VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT specifies this event corresponds to the allocation of an internal device memory object or a VkDeviceMemory. VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_FREE_EXT specifies this event corresponds to the deallocation of an internally-allocated device memory object or a VkDeviceMemory. VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_IMPORT_EXT specifies this event corresponds to the import of an external memory object. VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_UNIMPORT_EXT specifies this event is the release of an imported external memory object. VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATION_FAILED_EXT specifies this event corresponds to the failed allocation of an internal device memory object or a VkDeviceMemory. To reserve private data storage slots, add a VkDevicePrivateDataCreateInfo structure to the pNext chain of the VkDeviceCreateInfo structure. Reserving slots in this manner is not strictly necessary, but doing so may improve performance. // Provided by VK_VERSION_1_3 typedef struct VkDevicePrivateDataCreateInfo { VkStructureType sType; const void* pNext; uint32_t privateDataSlotRequestCount; } VkDevicePrivateDataCreateInfo; or the equivalent // Provided by VK_EXT_private_data typedef VkDevicePrivateDataCreateInfo VkDevicePrivateDataCreateInfoEXT; sType is a VkStructureType value identifying this structure. pNext is NULL or a pointer to a structure extending this structure. privateDataSlotRequestCount is the amount of slots to reserve. Valid Usage (Implicit) VUID-VkDevicePrivateDataCreateInfo-sType-sType sType must be VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO To disable the implementation’s internal pipeline cache, add a VkDevicePipelineBinaryInternalCacheControlKHR structure to the pNext chain of the VkDeviceCreateInfo structure. // Provided by VK_KHR_pipeline_binary typedef struct VkDevicePipelineBinaryInternalCacheControlKHR { VkStructureType sType; const void* pNext; VkBool32 disableInternalCache; } VkDevicePipelineBinaryInternalCacheControlKHR; sType is a VkStructureType value identifying this structure. pNext is NULL or a pointer to a structure extending this structure. disableInternalCache specifies whether or not to disable the implementation’s internal pipeline cache. If the VkDeviceCreateInfo::pNext chain does not include this structure, then disableInternalCache defaults to VK_FALSE. Valid Usage VUID-VkDevicePipelineBinaryInternalCacheControlKHR-disableInternalCache-09602 If VkPhysicalDevicePipelineBinaryPropertiesKHR::pipelineBinaryInternalCacheControl is VK_FALSE, disableInternalCache must be VK_FALSE Valid Usage (Implicit) VUID-VkDevicePipelineBinaryInternalCacheControlKHR-sType-sType sType must be VK_STRUCTURE_TYPE_DEVICE_PIPELINE_BINARY_INTERNAL_CACHE_CONTROL_KHR The number of shader cores used by all the queues of a device can be controlled by adding a VkDeviceQueueShaderCoreControlCreateInfoARM structure to the pNext chain of the VkDeviceCreateInfo structure. The following is a high-level list of VkDevice uses along with references on where to find more information: Creation of queues. See the Queues section below for further details. Creation and tracking of various synchronization constructs. See Synchronization and Cache Control for further details. Allocating, freeing, and managing memory. See Memory Allocation and Resource Creation for further details. Creation and destruction of command buffers and command buffer pools. See Command Buffers for further details. Creation, destruction, and management of graphics state. See Pipelines and Resource Descriptors, among others, for further details. A logical device may become lost for a number of implementation-specific reasons, indicating that pending and future command execution may fail and cause resources and backing memory to become undefined. Typical reasons for device loss will include things like execution timing out (to prevent denial of service), power management events, platform resource management, implementation errors. Applications not adhering to valid usage may also result in device loss being reported, however this is not guaranteed. Even if device loss is reported, the system may be in an unrecoverable state, and further usage of the API is still considered invalid. When this happens, certain commands will return VK_ERROR_DEVICE_LOST. After any such event, the logical device is considered lost. It is not possible to reset the logical device to a non-lost state, however the lost state is specific to a logical device (VkDevice), and the corresponding physical device (VkPhysicalDevice) may be otherwise unaffected. In some cases, the physical device may also be lost, and attempting to create a new logical device will fail, returning VK_ERROR_DEVICE_LOST. This is usually indicative of a problem with the underlying implementation, or its connection to the host. If the physical device has not been lost, and a new logical device is successfully created from that physical device, it must be in the non-lost state. Whilst logical device loss may be recoverable, in the case of physical device loss, it is unlikely that an application will be able to recover unless additional, unaffected physical devices exist on the system. The error is largely informational and intended only to inform the application that a platform issue has occurred, and should be investigated further. For example, underlying hardware may have developed a fault or become physically disconnected from the rest of the system. In many cases, physical device loss may cause other more serious issues such as the operating system crashing; in which case it may not be reported via the Vulkan API. When a device is lost, its child objects are not implicitly destroyed and their handles are still valid. Those objects must still be destroyed before their parents or the device can be destroyed (see the Object Lifetime section). The host address space corresponding to device memory mapped using vkMapMemory is still valid, and host memory accesses to these mapped regions are still valid, but the contents are undefined. It is still legal to call any API command on the device and child objects. Once a device is lost, command execution may fail, and certain commands that return a VkResult may return VK_ERROR_DEVICE_LOST. These commands can be identified by the inclusion of VK_ERROR_DEVICE_LOST in the Return Codes section for each command. Commands that do not allow runtime errors must still operate correctly for valid usage and, if applicable, return valid data. Commands that wait indefinitely for device execution (namely vkDeviceWaitIdle, vkQueueWaitIdle, vkWaitForFences or vkAcquireNextImageKHR with a maximum timeout, and vkGetQueryPoolResults with the VK_QUERY_RESULT_WAIT_BIT bit set in flags) must return in finite time even in the case of a lost device, and return either VK_SUCCESS or VK_ERROR_DEVICE_LOST. For any command that may return VK_ERROR_DEVICE_LOST, for the purpose of determining whether a command buffer is in the pending state, or whether resources are considered in-use by the device, a return value of VK_ERROR_DEVICE_LOST is equivalent to VK_SUCCESS. If a device was created with the maintenance5 feature enabled, and any device command returns VK_ERROR_DEVICE_LOST, then all device commands for which VK_ERROR_DEVICE_LOST is a valid return value and which happen-after it on the same host thread must return VK_ERROR_DEVICE_LOST. Device commands executing on other threads must begin returning VK_ERROR_DEVICE_LOST within finite time. The content of any external memory objects that have been exported from or imported to a lost device become undefined. Objects on other logical devices or in other APIs which are associated with the same underlying memory resource as the external memory objects on the lost device are unaffected other than their content becoming undefined. The layout of subresources of images on other logical devices that are bound to VkDeviceMemory objects associated with the same underlying memory resources as external memory objects on the lost device becomes VK_IMAGE_LAYOUT_UNDEFINED. The state of VkSemaphore objects on other logical devices created by importing a semaphore payload with temporary permanence which was exported from the lost device is undefined. The state of VkSemaphore objects on other logical devices that permanently share a semaphore payload with a VkSemaphore object on the lost device is undefined, and remains undefined following any subsequent signal operations. Implementations must ensure pending and subsequently submitted wait operations on such semaphores behave as defined in Semaphore State Requirements For Wait Operations for external semaphores not in a valid state for a wait operation. To destroy a device, call: // Provided by VK_VERSION_1_0 void vkDestroyDevice( VkDevice device, const VkAllocationCallbacks* pAllocator); device is the logical device to destroy. pAllocator controls host memory allocation as described in the Memory Allocation chapter. To ensure that no work is active on the device, vkDeviceWaitIdle can be used to gate the destruction of the device. Prior to destroying a device, an application is responsible for destroying/freeing any Vulkan objects with explicit vkDestroy* or vkFree* commands that were created using that device as the first parameter of the corresponding vkCreate* or vkAllocate* command. The lifetime of each of these objects is bound by the lifetime of the VkDevice object. Therefore, to avoid resource leaks, it is critical that an application explicitly free all of these resources prior to calling vkDestroyDevice. Valid Usage VUID-vkDestroyDevice-device-05137 All child objects created on device that can be destroyed or freed must have been destroyed or freed prior to destroying device VUID-vkDestroyDevice-device-00379 If VkAllocationCallbacks were provided when device was created, a compatible set of callbacks must be provided here VUID-vkDestroyDevice-device-00380 If no VkAllocationCallbacks were provided when device was created, pAllocator must be NULL Valid Usage (Implicit) VUID-vkDestroyDevice-device-parameter If device is not NULL, device must be a valid VkDevice handle VUID-vkDestroyDevice-pAllocator-parameter If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure Host Synchronization Host access to device must be externally synchronized Host access to all VkQueue objects created from device must be externally synchronized As discussed in the Physical Device Enumeration section above, the vkGetPhysicalDeviceQueueFamilyProperties command is used to retrieve details about the queue families and queues supported by a device. Each index in the pQueueFamilyProperties array returned by vkGetPhysicalDeviceQueueFamilyProperties describes a unique queue family on that physical device. These indices are used when creating queues, and they correspond directly with the queueFamilyIndex that is passed to the vkCreateDevice command via the VkDeviceQueueCreateInfo structure as described in the Queue Creation section below. Grouping of queue families within a physical device is implementation-dependent. The general expectation is that a physical device groups all queues of matching capabilities into a single family. However, while implementations should do this, it is possible that a physical device may return two separate queue families with the same capabilities. Once an application has identified a physical device with the queue(s) that it desires to use, it will create those queues in conjunction with a logical device. This is described in the following section. Creating a logical device also creates the queues associated with that device. The queues to create are described by a set of VkDeviceQueueCreateInfo structures that are passed to vkCreateDevice in pQueueCreateInfos. Queues cannot be independently destroyed, and are instead destroyed with the VkDevice that they were created from. Queues are represented by VkQueue handles: // Provided by VK_VERSION_1_0 VK_DEFINE_HANDLE(VkQueue) The VkDeviceQueueCreateInfo structure is defined as: // Provided by VK_VERSION_1_0 typedef struct VkDeviceQueueCreateInfo { VkStructureType sType; const void* pNext; VkDeviceQueueCreateFlags flags; uint32_t queueFamilyIndex; uint32_t queueCount; const float* pQueuePriorities; } VkDeviceQueueCreateInfo; sType is a VkStructureType value identifying this structure. pNext is NULL or a pointer to a structure extending this structure. flags is a bitmask indicating behavior of the queues. queueFamilyIndex is an unsigned integer indicating the index of the queue family in which to create the queues on this device. This index corresponds to the index of an element of the pQueueFamilyProperties array that was returned by vkGetPhysicalDeviceQueueFamilyProperties. queueCount is an unsigned integer specifying the number of queues to create in the queue family indicated by queueFamilyIndex, and with the behavior specified by flags. pQueuePriorities is a pointer to an array of queueCount normalized floating-point values, specifying priorities of work that will be submitted to each created queue. See Queue Priority for more information. Valid Usage VUID-VkDeviceQueueCreateInfo-queueFamilyIndex-00381 queueFamilyIndex must be less than pQueueFamilyPropertyCount returned by vkGetPhysicalDeviceQueueFamilyProperties VUID-VkDeviceQueueCreateInfo-queueCount-00382 queueCount must be less than or equal to the queueCount member of the VkQueueFamilyProperties structure, as returned by vkGetPhysicalDeviceQueueFamilyProperties in the pQueueFamilyProperties[queueFamilyIndex] VUID-VkDeviceQueueCreateInfo-pQueuePriorities-00383 Each element of pQueuePriorities must be between 0.0 and 1.0 inclusive VUID-VkDeviceQueueCreateInfo-flags-02861 If the protectedMemory feature is not enabled, the VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT bit of flags must not be set VUID-VkDeviceQueueCreateInfo-flags-06449 If flags includes VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT, queueFamilyIndex must be the index of a queue family that includes the VK_QUEUE_PROTECTED_BIT capability VUID-VkDeviceQueueCreateInfo-pNext-09398 If the pNext chain includes a VkDeviceQueueShaderCoreControlCreateInfoARM structure then VkPhysicalDeviceSchedulingControlsPropertiesARM::schedulingControlsFlags must contain VK_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_SHADER_CORE_COUNT_ARM Valid Usage (Implicit) VUID-VkDeviceQueueCreateInfo-sType-sType sType must be VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO VUID-VkDeviceQueueCreateInfo-pNext-pNext Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkDeviceQueueGlobalPriorityCreateInfo or VkDeviceQueueShaderCoreControlCreateInfoARM VUID-VkDeviceQueueCreateInfo-sType-unique The sType value of each structure in the pNext chain must be unique VUID-VkDeviceQueueCreateInfo-flags-parameter flags must be a valid combination of VkDeviceQueueCreateFlagBits values VUID-VkDeviceQueueCreateInfo-pQueuePriorities-parameter pQueuePriorities must be a valid pointer to an array of queueCount float values VUID-VkDeviceQueueCreateInfo-queueCount-arraylength queueCount must be greater than 0 Bits which can be set in VkDeviceQueueCreateInfo::flags, specifying usage behavior of a queue, are: // Provided by VK_VERSION_1_1 typedef enum VkDeviceQueueCreateFlagBits { // Provided by VK_VERSION_1_1 VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT = 0x00000001, } VkDeviceQueueCreateFlagBits; VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT specifies that the device queue is a protected-capable queue. // Provided by VK_VERSION_1_0 typedef VkFlags VkDeviceQueueCreateFlags; VkDeviceQueueCreateFlags is a bitmask type for setting a mask of zero or more VkDeviceQueueCreateFlagBits. Queues can be created with a system-wide priority by adding a VkDeviceQueueGlobalPriorityCreateInfo structure to the pNext chain of VkDeviceQueueCreateInfo. The VkDeviceQueueGlobalPriorityCreateInfo structure is defined as: // Provided by VK_VERSION_1_4 typedef struct VkDeviceQueueGlobalPriorityCreateInfo { VkStructureType sType; const void* pNext; VkQueueGlobalPriority globalPriority; } VkDeviceQueueGlobalPriorityCreateInfo; or the equivalent // Provided by VK_KHR_global_priority typedef VkDeviceQueueGlobalPriorityCreateInfo VkDeviceQueueGlobalPriorityCreateInfoKHR; or the equivalent // Provided by VK_EXT_global_priority typedef VkDeviceQueueGlobalPriorityCreateInfo VkDeviceQueueGlobalPriorityCreateInfoEXT; sType is a VkStructureType value identifying this structure. pNext is NULL or a pointer to a structure extending this structure. globalPriority is the system-wide priority associated to these queues as specified by VkQueueGlobalPriority Queues created without specifying VkDeviceQueueGlobalPriorityCreateInfo will default to VK_QUEUE_GLOBAL_PRIORITY_MEDIUM. Valid Usage (Implicit) VUID-VkDeviceQueueGlobalPriorityCreateInfo-sType-sType sType must be VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO VUID-VkDeviceQueueGlobalPriorityCreateInfo-globalPriority-parameter globalPriority must be a valid VkQueueGlobalPriority value Possible values of VkDeviceQueueGlobalPriorityCreateInfo::globalPriority, specifying a system-wide priority level are: // Provided by VK_VERSION_1_4 typedef enum VkQueueGlobalPriority { VK_QUEUE_GLOBAL_PRIORITY_LOW = 128, VK_QUEUE_GLOBAL_PRIORITY_MEDIUM = 256, VK_QUEUE_GLOBAL_PRIORITY_HIGH = 512, VK_QUEUE_GLOBAL_PRIORITY_REALTIME = 1024, // Provided by VK_EXT_global_priority VK_QUEUE_GLOBAL_PRIORITY_LOW_EXT = VK_QUEUE_GLOBAL_PRIORITY_LOW, // Provided by VK_EXT_global_priority VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT = VK_QUEUE_GLOBAL_PRIORITY_MEDIUM, // Provided by VK_EXT_global_priority VK_QUEUE_GLOBAL_PRIORITY_HIGH_EXT = VK_QUEUE_GLOBAL_PRIORITY_HIGH, // Provided by VK_EXT_global_priority VK_QUEUE_GLOBAL_PRIORITY_REALTIME_EXT = VK_QUEUE_GLOBAL_PRIORITY_REALTIME, // Provided by VK_KHR_global_priority VK_QUEUE_GLOBAL_PRIORITY_LOW_KHR = VK_QUEUE_GLOBAL_PRIORITY_LOW, // Provided by VK_KHR_global_priority VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_KHR = VK_QUEUE_GLOBAL_PRIORITY_MEDIUM, // Provided by VK_KHR_global_priority VK_QUEUE_GLOBAL_PRIORITY_HIGH_KHR = VK_QUEUE_GLOBAL_PRIORITY_HIGH, // Provided by VK_KHR_global_priority VK_QUEUE_GLOBAL_PRIORITY_REALTIME_KHR = VK_QUEUE_GLOBAL_PRIORITY_REALTIME, } VkQueueGlobalPriority; or the equivalent // Provided by VK_KHR_global_priority typedef VkQueueGlobalPriority VkQueueGlobalPriorityKHR; or the equivalent // Provided by VK_EXT_global_priority typedef VkQueueGlobalPriority VkQueueGlobalPriorityEXT; Priority values are sorted in ascending order. A comparison operation on the enum values can be used to determine the priority order. VK_QUEUE_GLOBAL_PRIORITY_LOW is below the system default. Useful for non-interactive tasks. VK_QUEUE_GLOBAL_PRIORITY_MEDIUM is the system default priority. VK_QUEUE_GLOBAL_PRIORITY_HIGH is above the system default. VK_QUEUE_GLOBAL_PRIORITY_REALTIME is the highest priority. Useful for critical tasks. Queues with higher system priority may be allotted more processing time than queues with lower priority. An implementation may allow a higher-priority queue to starve a lower-priority queue until the higher-priority queue has no further commands to execute. Priorities imply no ordering or scheduling constraints. No specific guarantees are made about higher priority queues receiving more processing time or better quality of service than lower priority queues. The global priority level of a queue takes precedence over the per-process queue priority (VkDeviceQueueCreateInfo::pQueuePriorities). Abuse of this feature may result in starving the rest of the system of implementation resources. Therefore, the driver implementation may deny requests to acquire a priority above the default priority (VK_QUEUE_GLOBAL_PRIORITY_MEDIUM) if the caller does not have sufficient privileges. In this scenario VK_ERROR_NOT_PERMITTED is returned. The driver implementation may fail the queue allocation request if resources required to complete the operation have been exhausted (either by the same process or a different process). In this scenario VK_ERROR_INITIALIZATION_FAILED is returned. If the globalPriorityQuery feature is enabled and the requested global priority is not reported via VkQueueFamilyGlobalPriorityProperties, the driver implementation must fail the queue creation. In this scenario, VK_ERROR_INITIALIZATION_FAILED is returned. The number of shader cores used by a queue can be controlled by adding a VkDeviceQueueShaderCoreControlCreateInfoARM structure to the pNext chain of VkDeviceQueueCreateInfo structures. The VkDeviceQueueShaderCoreControlCreateInfoARM structure is defined as: // Provided by VK_ARM_scheduling_controls typedef struct VkDeviceQueueShaderCoreControlCreateInfoARM { VkStructureType sType; void* pNext; uint32_t shaderCoreCount; } VkDeviceQueueShaderCoreControlCreateInfoARM; sType is a VkStructureType value identifying this structure. pNext is NULL or a pointer to a structure extending this structure. shaderCoreCount is the number of shader cores this queue uses. Queues created without specifying VkDeviceQueueShaderCoreControlCreateInfoARM will default to using all the shader cores available. Valid Usage VUID-VkDeviceQueueShaderCoreControlCreateInfoARM-shaderCoreCount-09399 shaderCoreCount must be greater than 0 and less than or equal to the total number of shader cores as reported via VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM::shaderCoreCount Valid Usage (Implicit) VUID-VkDeviceQueueShaderCoreControlCreateInfoARM-sType-sType sType must be VK_STRUCTURE_TYPE_DEVICE_QUEUE_SHADER_CORE_CONTROL_CREATE_INFO_ARM To retrieve a handle to a VkQueue object, call: // Provided by VK_VERSION_1_0 void vkGetDeviceQueue( VkDevice device, uint32_t queueFamilyIndex, uint32_t queueIndex, VkQueue* pQueue); device is the logical device that owns the queue. queueFamilyIndex is the index of the queue family to which the queue belongs. queueIndex is the index within this queue family of the queue to retrieve. pQueue is a pointer to a VkQueue object that will be filled with the handle for the requested queue. vkGetDeviceQueue must only be used to get queues that were created with the flags parameter of VkDeviceQueueCreateInfo set to zero. To get queues that were created with a non-zero flags parameter use vkGetDeviceQueue2. Valid Usage VUID-vkGetDeviceQueue-queueFamilyIndex-00384 queueFamilyIndex must be one of the queue family indices specified when device was created, via the VkDeviceQueueCreateInfo structure VUID-vkGetDeviceQueue-queueIndex-00385 queueIndex must be less than the value of VkDeviceQueueCreateInfo::queueCount for the queue family indicated by queueFamilyIndex when device was created VUID-vkGetDeviceQueue-flags-01841 VkDeviceQueueCreateInfo::flags must have been zero when device was created Valid Usage (Implicit) VUID-vkGetDeviceQueue-device-parameter device must be a valid VkDevice handle VUID-vkGetDeviceQueue-pQueue-parameter pQueue must be a valid pointer to a VkQueue handle To retrieve a handle to a VkQueue object with specific VkDeviceQueueCreateFlags creation flags, call: // Provided by VK_VERSION_1_1 void vkGetDeviceQueue2( VkDevice device, const VkDeviceQueueInfo2* pQueueInfo, VkQueue* pQueue); device is the logical device that owns the queue. pQueueInfo is a pointer to a VkDeviceQueueInfo2 structure, describing parameters of the device queue to be retrieved. pQueue is a pointer to a VkQueue object that will be filled with the handle for the requested queue. Valid Usage (Implicit) VUID-vkGetDeviceQueue2-device-parameter device must be a valid VkDevice handle VUID-vkGetDeviceQueue2-pQueueInfo-parameter pQueueInfo must be a valid pointer to a valid VkDeviceQueueInfo2 structure VUID-vkGetDeviceQueue2-pQueue-parameter pQueue must be a valid pointer to a VkQueue handle The VkDeviceQueueInfo2 structure is defined as: // Provided by VK_VERSION_1_1 typedef struct VkDeviceQueueInfo2 { VkStructureType sType; const void* pNext; VkDeviceQueueCreateFlags flags; uint32_t queueFamilyIndex; uint32_t queueIndex; } VkDeviceQueueInfo2; sType is a VkStructureType value identifying this structure. pNext is NULL or a pointer to a structure extending this structure. The pNext chain of VkDeviceQueueInfo2 can be used to provide additional device queue parameters to vkGetDeviceQueue2. flags is a VkDeviceQueueCreateFlags value indicating the flags used to create the device queue. queueFamilyIndex is the index of the queue family to which the queue belongs. queueIndex is the index of the queue to retrieve from within the set of queues that share both the queue family and flags specified. The queue returned by vkGetDeviceQueue2 must have the same flags value from this structure as that used at device creation time in a VkDeviceQueueCreateInfo structure. Normally, if you create both protected-capable and non-protected-capable queues with the same family, they are treated as separate lists of queues and queueIndex is relative to the start of the list of queues specified by both queueFamilyIndex and flags. However, for historical reasons, some implementations may exhibit different behavior. These divergent implementations instead concatenate the lists of queues and treat queueIndex as relative to the start of the first list of queues with the given queueFamilyIndex. This only matters in cases where an application has created both protected-capable and non-protected-capable queues from the same queue family. For such divergent implementations, the maximum value of queueIndex is equal to the sum of VkDeviceQueueCreateInfo::queueCount minus one, for all VkDeviceQueueCreateInfo structures that share a common queueFamilyIndex. Such implementations will return NULL for either the protected or unprotected queues when calling vkGetDeviceQueue2 with queueIndex in the range zero to VkDeviceQueueCreateInfo::queueCount minus one. In cases where these implementations returned NULL, the corresponding queues are instead located in the extended range described in the preceding two paragraphs. This behavior will not be observed on any driver that has passed Vulkan conformance test suite version 1.3.3.0, or any subsequent version. This information can be found by querying VkPhysicalDeviceDriverProperties::conformanceVersion. Valid Usage VUID-VkDeviceQueueInfo2-queueFamilyIndex-01842 queueFamilyIndex must be one of the queue family indices specified when device was created, via the VkDeviceQueueCreateInfo structure VUID-VkDeviceQueueInfo2-flags-06225 flags must be equal to VkDeviceQueueCreateInfo::flags for a VkDeviceQueueCreateInfo structure for the queue family indicated by queueFamilyIndex when device was created VUID-VkDeviceQueueInfo2-queueIndex-01843 queueIndex must be less than VkDeviceQueueCreateInfo::queueCount for the corresponding queue family and flags indicated by queueFamilyIndex and flags when device was created Valid Usage (Implicit) VUID-VkDeviceQueueInfo2-sType-sType sType must be VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2 VUID-VkDeviceQueueInfo2-pNext-pNext pNext must be NULL VUID-VkDeviceQueueInfo2-flags-parameter flags must be a valid combination of VkDeviceQueueCreateFlagBits values The queue family index is used in multiple places in Vulkan in order to tie operations to a specific family of queues. When retrieving a handle to the queue via vkGetDeviceQueue, the queue family index is used to select which queue family to retrieve the VkQueue handle from as described in the previous section. When creating a VkCommandPool object (see Command Pools), a queue family index is specified in the VkCommandPoolCreateInfo structure. Command buffers from this pool can only be submitted on queues corresponding to this queue family. When creating VkImage (see Images) and VkBuffer (see Buffers) resources, a set of queue families is included in the VkImageCreateInfo and VkBufferCreateInfo structures to specify the queue families that can access the resource. When inserting a VkBufferMemoryBarrier or VkImageMemoryBarrier (see Pipeline Barriers), a source and destination queue family index is specified to allow the ownership of a buffer or image to be transferred from one queue family to another. See the Resource Sharing section for details. Each queue is assigned a priority, as set in the VkDeviceQueueCreateInfo structures when creating the device. The priority of each queue is a normalized floating-point value between 0.0 and 1.0, which is then translated to a discrete priority level by the implementation. Higher values indicate a higher priority, with 0.0 being the lowest priority and 1.0 being the highest. Within the same device, queues with higher priority may be allotted more processing time than queues with lower priority. The implementation makes no guarantees with regards to ordering or scheduling among queues with the same priority, other than the constraints defined by any explicit synchronization primitives. The implementation makes no guarantees with regards to queues across different devices. An implementation may allow a higher-priority queue to starve a lower-priority queue on the same VkDevice until the higher-priority queue has no further commands to execute. The relationship of queue priorities must not cause queues on one VkDevice to starve queues on another VkDevice. No specific guarantees are made about higher priority queues receiving more processing time or better quality of service than lower priority queues. Work is submitted to a queue via queue submission commands such as vkQueueSubmit2 or vkQueueSubmit. Queue submission commands define a set of queue operations to be executed by the underlying physical device, including synchronization with semaphores and fences. Submission commands take as parameters a target queue, zero or more batches of work, and an optional fence to signal upon completion. Each batch consists of three distinct parts: Zero or more semaphores to wait on before execution of the rest of the batch. If present, these describe a semaphore wait operation. Zero or more work items to execute. If present, these describe a queue operation matching the work described. Zero or more semaphores to signal upon completion of the work items. If present, these describe a semaphore signal operation. If a fence is present in a queue submission, it describes a fence signal operation. All work described by a queue submission command must be submitted to the queue before the command returns. In Vulkan it is possible to sparsely bind memory to buffers and images as described in the Sparse Resource chapter. Sparse memory binding is a queue operation. A queue whose flags include the VK_QUEUE_SPARSE_BINDING_BIT must be able to support the mapping of a virtual address to a physical address on the device. This causes an update to the page table mappings on the device. This update must be synchronized on a queue to avoid corrupting page table mappings during execution of graphics commands. By binding the sparse memory resources on queues, all commands that are dependent on the updated bindings are synchronized to only execute after the binding is updated. See the Synchronization and Cache Control chapter for how this synchronization is accomplished. Queues are created along with a logical device during vkCreateDevice. All queues associated with a logical device are destroyed when vkDestroyDevice is called on that device.

# Extending Vulkan

## Metadata

- **Component**: spec
- **Version**: latest
- **URL**: /spec/latest/chapters/extensions.html

## Table of Contents

- [Instance and Device Functionality](#extendingvulkan-instanceanddevicefunctionality)
- [Instance_and_Device_Functionality](#extendingvulkan-instanceanddevicefunctionality)
- [Core Versions](#extendingvulkan-coreversions)
- [Version Numbers](#extendingvulkan-coreversions-versionnumbers)
- [Querying Version Support](#extendingvulkan-coreversions-queryingversionsupport)
- [Querying_Version_Support](#extendingvulkan-coreversions-queryingversionsupport)
- [Layers](#extendingvulkan-layers)
- [Device Layer Deprecation](#extendingvulkan-layers-devicelayerdeprecation)
- [Device_Layer_Deprecation](#extendingvulkan-layers-devicelayerdeprecation)
- [Extensions](#extendingvulkan-extensions)
- [Instance Extensions](#extendingvulkan-instance-extensions)
- [Device Extensions](#extendingvulkan-device-extensions)
- [Accessing Device-Level Functionality From a VkPhysicalDevice](#extendingvulkan-accessing-device-physical-device)
- [Accessing_Device-Level_Functionality_From_a_VkPhysicalDevice](#extendingvulkan-accessing-device-physical-device)
- [Accessing Device-Level Functionality From a VkDevice](#extendingvulkan-accessing-device-logical-device)
- [Accessing_Device-Level_Functionality_From_a_VkDevice](#extendingvulkan-accessing-device-logical-device)
- [Extension Dependencies](#extendingvulkan-extensions-extensiondependencies)
- [Compatibility Guarantees (Informative)](#_compatibility_guarantees_informative)
- [Compatibility_Guarantees_(Informative)](#_compatibility_guarantees_informative)
- [Core Versions](#extendingvulkan-compatibility-coreversions)
- [Patch Versions](#_patch_versions)
- [Minor Versions](#_minor_versions)
- [Major Versions](#_major_versions)
- [Extensions](#extendingvulkan-compatibility-extensions)
- [Promotion](#extendingvulkan-compatibility-promotion)
- [Deprecation](#extendingvulkan-compatibility-deprecation)
- [Obsoletion](#extendingvulkan-compatibility-obsoletion)
- [Aliases](#extendingvulkan-compatibility-aliases)
- [Special Use Extensions](#extendingvulkan-compatibility-specialuse)
- [Special_Use_Extensions](#extendingvulkan-compatibility-specialuse)

## Content

New functionality may be added to Vulkan via either new extensions or new versions of the core, or new versions of an extension in some cases. This chapter describes how Vulkan is versioned, how compatibility is affected between different versions, and compatibility rules that are followed by the Vulkan Working Group. Commands that enumerate instance properties, or that accept a VkInstance object as a parameter, are considered instance-level functionality. Commands that dispatch from a VkDevice object or a child object of a VkDevice, or take any of them as a parameter, are considered device-level functionality. Types defined by a device extension are also considered device-level functionality. Commands that dispatch from VkPhysicalDevice, or accept a VkPhysicalDevice object as a parameter, are considered either instance-level or device-level functionality depending if the functionality is specified by an instance extension or device extension respectively. Additionally, commands that enumerate physical device properties are considered device-level functionality. Applications usually interface to Vulkan using a loader that implements only instance-level functionality, passing device-level functionality to implementations of the full Vulkan API on the system. In some circumstances, as these may be implemented independently, it is possible that the loader and device implementations on a given installation will support different versions. To allow for this and call out when it happens, the Vulkan specification enumerates device and instance level functionality separately - they have independent version queries. Vulkan 1.0 initially specified new physical device enumeration functionality as instance-level, requiring it to be included in an instance extension. As the capabilities of device-level functionality require discovery via physical device enumeration, this led to the situation where many device extensions required an instance extension as well. To alleviate this extra work, VK_KHR_get_physical_device_properties2 (and subsequently Vulkan 1.1) redefined device-level functionality to include physical device enumeration. The Vulkan Specification is regularly updated with bug fixes and clarifications. Occasionally new functionality is added to the core and at some point it is expected that there will be a desire to perform a large, breaking change to the API. In order to indicate to developers how and when these changes are made to the specification, and to provide a way to identify each set of changes, the Vulkan API maintains a version number. The Vulkan version number comprises four parts indicating the variant, major, minor and patch version of the Vulkan API Specification. The variant indicates the variant of the Vulkan API supported by the implementation. This is always 0 for the Vulkan API. A non-zero variant indicates the API is a variant of the Vulkan API and applications will typically need to be modified to run against it. The variant field was a later addition to the version number, added in version 1.2.175 of the Specification. As Vulkan uses variant 0, this change is fully backwards compatible with the previous version number format for Vulkan implementations. New version number macros have been added for this change and the old macros deprecated. For existing applications using the older format and macros, an implementation with non-zero variant will decode as a very high Vulkan version. The high version number should be detectable by applications performing suitable version checking. The major version indicates a significant change in the API, which will encompass a wholly new version of the specification. The minor version indicates the incorporation of new functionality into the core specification. The patch version indicates bug fixes, clarifications, and language improvements have been incorporated into the specification. Compatibility guarantees made about versions of the API sharing any of the same version numbers are documented in Core Versions The version number is used in several places in the API. In each such use, the version numbers are packed into a 32-bit integer as follows: The variant is a 3-bit integer packed into bits 31-29. The major version is a 7-bit integer packed into bits 28-22. The minor version number is a 10-bit integer packed into bits 21-12. The patch version number is a 12-bit integer packed into bits 11-0. VK_API_VERSION_VARIANT extracts the API variant number from a packed version number: // Provided by VK_VERSION_1_0 #define VK_API_VERSION_VARIANT(version) ((uint32_t)(version) >> 29U) VK_API_VERSION_MAJOR extracts the API major version number from a packed version number: // Provided by VK_VERSION_1_0 #define VK_API_VERSION_MAJOR(version) (((uint32_t)(version) >> 22U) & 0x7FU) VK_VERSION_MAJOR extracts the API major version number from a packed version number: // Provided by VK_VERSION_1_0 // VK_VERSION_MAJOR is deprecated, but no reason was given in the API XML // DEPRECATED: This define is deprecated. VK_API_VERSION_MAJOR should be used instead. #define VK_VERSION_MAJOR(version) ((uint32_t)(version) >> 22U) VK_API_VERSION_MINOR extracts the API minor version number from a packed version number: // Provided by VK_VERSION_1_0 #define VK_API_VERSION_MINOR(version) (((uint32_t)(version) >> 12U) & 0x3FFU) VK_VERSION_MINOR extracts the API minor version number from a packed version number: // Provided by VK_VERSION_1_0 // VK_VERSION_MINOR is deprecated, but no reason was given in the API XML // DEPRECATED: This define is deprecated. VK_API_VERSION_MINOR should be used instead. #define VK_VERSION_MINOR(version) (((uint32_t)(version) >> 12U) & 0x3FFU) VK_API_VERSION_PATCH extracts the API patch version number from a packed version number: // Provided by VK_VERSION_1_0 #define VK_API_VERSION_PATCH(version) ((uint32_t)(version) & 0xFFFU) VK_VERSION_PATCH extracts the API patch version number from a packed version number: // Provided by VK_VERSION_1_0 // VK_VERSION_PATCH is deprecated, but no reason was given in the API XML // DEPRECATED: This define is deprecated. VK_API_VERSION_PATCH should be used instead. #define VK_VERSION_PATCH(version) ((uint32_t)(version) & 0xFFFU) VK_MAKE_API_VERSION constructs an API version number. // Provided by VK_VERSION_1_0 #define VK_MAKE_API_VERSION(variant, major, minor, patch) \ ((((uint32_t)(variant)) tags. However, the metadata does not yet fully describe this scenario. In the future, we may extend the XML schema to describe the full set of extensions and versions satisfying a dependency. As discussed in more detail for Promotion below, when an extension is promoted it does not mean that a mechanical substitution of an extension API by the corresponding promoted API will work in exactly the same fashion; be supported at runtime; or even exist. This section is marked as informal as there is no binding responsibility on implementations of the Vulkan API - these guarantees are however a contract between the Vulkan Working Group and developers using this Specification. Each of the major, minor, and patch versions of the Vulkan specification provide different compatibility guarantees. A difference in the patch version indicates that a set of bug fixes or clarifications have been made to the Specification. Informative enums returned by Vulkan commands that will not affect the runtime behavior of a valid application may be added in a patch version (e.g. VkVendorId). The specification’s patch version is strictly increasing for a given major version of the specification; any change to a specification as described above will result in the patch version being increased by 1. Patch versions are applied to all minor versions, even if a given minor version is not affected by the provoking change. Specifications with different patch versions but the same major and minor version are fully compatible with each other - such that a valid application written against one will work with an implementation of another. If a patch version includes a bug fix or clarification that could have a significant impact on developer expectations, these will be highlighted in the change log. Generally the Vulkan Working Group tries to avoid these kinds of changes, instead fixing them in either an extension or core version. Changes in the minor version of the specification indicate that new functionality has been added to the core specification. This will usually include new interfaces in the header, and may also include behavior changes and bug fixes. Core functionality may be deprecated in a minor version, but will not be obsoleted or removed. The specification’s minor version is strictly increasing for a given major version of the specification; any change to a specification as described above will result in the minor version being increased by 1. Changes that can be accommodated in a patch version will not increase the minor version. Specifications with a lower minor version are backwards compatible with an implementation of a specification with a higher minor version for core functionality and extensions issued with the KHR vendor tag. Vendor and multi-vendor extensions are not guaranteed to remain functional across minor versions, though in general they are with few exceptions - see Obsoletion for more information. A difference in the major version of specifications indicates a large set of changes which will likely include interface changes, behavioral changes, removal of deprecated functionality, and the modification, addition, or replacement of other functionality. The specification’s major version is monotonically increasing; any change to the specification as described above will result in the major version being increased. Changes that can be accommodated in a patch or minor version will not increase the major version. The Vulkan Working Group intends to only issue a new major version of the Specification in order to realize significant improvements to the Vulkan API that will necessarily require breaking compatibility. A new major version will likely include a wholly new version of the specification to be issued - which could include an overhaul of the versioning semantics for the minor and patch versions. The patch and minor versions of a specification are therefore not meaningful across major versions. If a major version of the specification includes similar versioning semantics, it is expected that the patch and the minor version will be reset to 0 for that major version. A KHR extension must be able to be enabled alongside any other KHR extension, and for any minor or patch version of the core Specification beyond the minimum version it requires. A multi-vendor extension should be able to be enabled alongside any KHR extension or other multi-vendor extension, and for any minor or patch version of the core Specification beyond the minimum version it requires. A vendor extension should be able to be enabled alongside any KHR extension, multi-vendor extension, or other vendor extension from the same vendor, and for any minor or patch version of the core Specification beyond the minimum version it requires. A vendor extension may be able to be enabled alongside vendor extensions from another vendor. The one other exception to this is if a vendor or multi-vendor extension is made obsolete by either a core version or another extension, which will be highlighted in the extension appendix. Extensions, or features of an extension, may be promoted to a new core version of the API, or a newer extension which an equal or greater number of implementors are in favor of. Structure and enumerated types defined in extensions that were promoted to core in a later version of Vulkan are defined in terms of the equivalent Vulkan core interfaces in that version and its successors. This affects the Vulkan Specification, the Vulkan header files, and the corresponding XML Registry. When extension functionality is promoted, minor changes may be introduced, limited to the following: Naming Non-intrusive parameter changes Feature advertisement/enablement Combining structure parameters into larger structures Author ID suffixes changed or removed If extension functionality is promoted, there is no guarantee of direct compatibility, however it should require little effort to port code from the original feature to the promoted one. The Vulkan Working Group endeavors to ensure that larger changes are marked as either deprecated or obsoleted as appropriate, and can do so retroactively if necessary. Extensions that are promoted are listed as being promoted in their extension appendices, with reference to where they were promoted to. When an extension is promoted, any backwards compatibility aliases which exist in the extension will not be promoted. As a hypothetical example, if the VK_KHR_surface extension were promoted to part of a future core version, the VK_COLOR_SPACE_SRGB_NONLINEAR_KHR token defined by that extension would be promoted to VK_COLOR_SPACE_SRGB_NONLINEAR. However, the VK_COLORSPACE_SRGB_NONLINEAR_KHR token aliases VK_COLOR_SPACE_SRGB_NONLINEAR_KHR. The VK_COLORSPACE_SRGB_NONLINEAR_KHR would not be promoted, because it is a backwards compatibility alias that exists only due to a naming mistake when the extension was initially published. Extensions may be marked as deprecated when they are no longer intended to be used by applications under certain conditions. Generally, a new feature will become available to solve the use case in another extension or core version of the API, but it is not guaranteed. Features that are intended to replace deprecated functionality have no guarantees of compatibility, and applications may require drastic modification in order to make use of the new features. Extensions that are deprecated are listed as being deprecated in their extension appendices, with an explanation of the deprecation and any related features that are relevant. Occasionally, an extension will be marked as obsolete if a new version of the core API or a new extension is fundamentally incompatible with it. An obsoleted extension must not be used with the extension or core version that obsoleted it. Extensions that are obsoleted are listed as being obsoleted in their extension appendices, with reference to what they were obsoleted by. When an extension is promoted or deprecated by a newer feature, some or all of its functionality may be replicated into the newer feature. Rather than duplication of all the documentation and definitions, the specification instead identifies the identical commands and types as aliases of one another. Each alias is mentioned together with the definition it aliases, with the older aliases marked as “equivalents”. Each alias of the same command has identical behavior, and each alias of the same type has identical meaning - they can be used interchangeably in an application with no compatibility issues. For promoted types, the aliased extension type is semantically identical to the new core type. The C99 headers simply typedef the older aliases to the promoted types. For promoted command aliases, however, there are two separate command definitions, due to the fact that the C99 ABI has no way to alias command definitions without resorting to macros. Calling either command will produce identical behavior within the bounds of the specification, and should still invoke the same path in the implementation. Debug tools may use separate commands with different debug behavior; to write the appropriate command name to an output log, for instance. Some extensions exist only to support a specific purpose or specific class of application. These are referred to as “special use extensions”. Use of these extensions in applications not meeting the special use criteria is not recommended. Special use cases are restricted, and only those defined below are used to describe extensions: Table 1. Extension Special Use Cases Special Use XML Tag Full Description CAD support cadsupport Extension is intended to support specialized functionality used by CAD/CAM applications. D3D support d3demulation Extension is intended to support D3D emulation layers, and applications ported from D3D, by adding functionality specific to D3D. Developer tools devtools Extension is intended to support developer tools such as capture-replay libraries. Debugging tools debugging Extension is intended for use by applications when debugging. OpenGL / ES support glemulation Extension is intended to support OpenGL and/or OpenGL ES emulation layers, and applications ported from those APIs, by adding functionality specific to those APIs. Special use extensions are identified in the metadata for each such extension in the Layers & Extensions appendix, using the name in the “Special Use” column above. Special use extensions are also identified in vk.xml with the short name in “XML Tag” column above, as described in the “API Extensions (extension tag)” section of the registry schema documentation.

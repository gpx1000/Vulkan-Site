# Dispatching Commands

## Metadata

- **Component**: spec
- **Version**: latest
- **URL**: /spec/latest/chapters/dispatch.html

## Table of Contents

- [Dispatch Command for CUDA PTX Kernels](#cudadispatch)
- [Dispatch_Command_for_CUDA_PTX_Kernels](#cudadispatch)
- [Passing Dispatch Parameters and Arguments](#cudadispatch_info)
- [Passing_Dispatch_Parameters_and_Arguments](#cudadispatch_info)
- [Resource Sharing from Vulkan to the CUDA Kernel](#cudadispatch_sharing_resources)
- [Resource_Sharing_from_Vulkan_to_the_CUDA_Kernel](#cudadispatch_sharing_resources)

## Content

The dispatching commands described in this chapter provoke work in a compute pipeline. Dispatching commands are recorded into a command buffer and when executed by a queue, will produce work which executes according to the bound compute pipeline. A compute pipeline must be bound to a command buffer before any dispatching commands are recorded in that command buffer. To record a dispatch, call: // Provided by VK_VERSION_1_0 void vkCmdDispatch( VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ); commandBuffer is the command buffer into which the command will be recorded. groupCountX is the number of local workgroups to dispatch in the X dimension. groupCountY is the number of local workgroups to dispatch in the Y dimension. groupCountZ is the number of local workgroups to dispatch in the Z dimension. When the command is executed, a global workgroup consisting of groupCountX × groupCountY × groupCountZ local workgroups is assembled. Valid Usage VUID-vkCmdDispatch-magFilter-04553 If a VkSampler created with magFilter or minFilter equal to VK_FILTER_LINEAR, reductionMode equal to VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE, and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT VUID-vkCmdDispatch-magFilter-09598 If a VkSampler created with magFilter or minFilter equal to VK_FILTER_LINEAR and reductionMode equal to either VK_SAMPLER_REDUCTION_MODE_MIN or VK_SAMPLER_REDUCTION_MODE_MAX is used to sample a VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT VUID-vkCmdDispatch-mipmapMode-04770 If a VkSampler created with mipmapMode equal to VK_SAMPLER_MIPMAP_MODE_LINEAR, reductionMode equal to VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE, and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT VUID-vkCmdDispatch-mipmapMode-09599 If a VkSampler created with mipmapMode equal to VK_SAMPLER_MIPMAP_MODE_LINEAR and reductionMode equal to either VK_SAMPLER_REDUCTION_MODE_MIN or VK_SAMPLER_REDUCTION_MODE_MAX is used to sample a VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT VUID-vkCmdDispatch-unnormalizedCoordinates-09635 If a VkSampler created with unnormalizedCoordinates equal to VK_TRUE is used to sample a VkImageView as a result of this command, then the image view’s levelCount and layerCount must be 1 VUID-vkCmdDispatch-None-08609 If a VkSampler created with unnormalizedCoordinates equal to VK_TRUE is used to sample a VkImageView as a result of this command, then the image view’s viewType must be VK_IMAGE_VIEW_TYPE_1D or VK_IMAGE_VIEW_TYPE_2D VUID-vkCmdDispatch-None-08610 If a VkSampler created with unnormalizedCoordinates equal to VK_TRUE is used to sample a VkImageView as a result of this command, then the sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name VUID-vkCmdDispatch-None-08611 If a VkSampler created with unnormalizedCoordinates equal to VK_TRUE is used to sample a VkImageView as a result of this command, then the sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values VUID-vkCmdDispatch-None-06479 If a VkImageView is sampled with depth comparison, the image view’s format features must contain VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT VUID-vkCmdDispatch-None-02691 If a VkImageView is accessed using atomic operations as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT VUID-vkCmdDispatch-None-07888 If a VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER descriptor is accessed using atomic operations as a result of this command, then the storage texel buffer’s format features must contain VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT VUID-vkCmdDispatch-None-02692 If a VkImageView is sampled with VK_FILTER_CUBIC_EXT as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT VUID-vkCmdDispatch-None-02693 If the VK_EXT_filter_cubic extension is not enabled and any VkImageView is sampled with VK_FILTER_CUBIC_EXT as a result of this command, it must not have a VkImageViewType of VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY VUID-vkCmdDispatch-filterCubic-02694 Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic returned by vkGetPhysicalDeviceImageFormatProperties2 VUID-vkCmdDispatch-filterCubicMinmax-02695 Any VkImageView being sampled with VK_FILTER_CUBIC_EXT with a reduction mode of either VK_SAMPLER_REDUCTION_MODE_MIN or VK_SAMPLER_REDUCTION_MODE_MAX as a result of this command must have a VkImageViewType and format that supports cubic filtering together with minmax filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax returned by vkGetPhysicalDeviceImageFormatProperties2 VUID-vkCmdDispatch-cubicRangeClamp-09212 If the cubicRangeClamp feature is not enabled, then any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must not have a VkSamplerReductionModeCreateInfo::reductionMode equal to VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM VUID-vkCmdDispatch-reductionMode-09213 Any VkImageView being sampled with a VkSamplerReductionModeCreateInfo::reductionMode equal to VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM as a result of this command must sample with VK_FILTER_CUBIC_EXT VUID-vkCmdDispatch-selectableCubicWeights-09214 If the selectableCubicWeights feature is not enabled, then any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must have VkSamplerCubicWeightsCreateInfoQCOM::cubicWeights equal to VK_CUBIC_FILTER_WEIGHTS_CATMULL_ROM_QCOM VUID-vkCmdDispatch-flags-02696 Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE VUID-vkCmdDispatch-OpTypeImage-07027 For any VkImageView being written as a storage image where the image format field of the OpTypeImage is Unknown, the view’s format features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT VUID-vkCmdDispatch-OpTypeImage-07028 For any VkImageView being read as a storage image where the image format field of the OpTypeImage is Unknown, the view’s format features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT VUID-vkCmdDispatch-OpTypeImage-07029 For any VkBufferView being written as a storage texel buffer where the image format field of the OpTypeImage is Unknown, the view’s buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT VUID-vkCmdDispatch-OpTypeImage-07030 Any VkBufferView being read as a storage texel buffer where the image format field of the OpTypeImage is Unknown then the view’s buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT VUID-vkCmdDispatch-None-08600 For each set n that is statically used by a bound shader, a descriptor set must have been bound to n at the same pipeline bind point, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline or the VkDescriptorSetLayout array used to create the current VkShaderEXT , as described in Pipeline Layout Compatibility VUID-vkCmdDispatch-None-08601 For each push constant that is statically used by a bound shader, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline or the VkDescriptorSetLayout array used to create the current VkShaderEXT , as described in Pipeline Layout Compatibility VUID-vkCmdDispatch-None-10068 For each array of resources that is used by a bound shader, the indices used to access members of the array must be less than the descriptor count for the identified binding in the descriptor sets used by this command VUID-vkCmdDispatch-maintenance4-08602 If the maintenance4 feature is not enabled, then for each push constant that is statically used by a bound shader, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline or the VkDescriptorSetLayout and VkPushConstantRange arrays used to create the current VkShaderEXT , as described in Pipeline Layout Compatibility VUID-vkCmdDispatch-None-08114 Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid as described by descriptor validity if they are statically used by the VkPipeline bound to the pipeline bind point used by this command and the bound VkPipeline was not created with VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT VUID-vkCmdDispatch-None-08115 If the descriptors used by the VkPipeline bound to the pipeline bind point were specified via vkCmdBindDescriptorSets, the bound VkPipeline must have been created without VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT VUID-vkCmdDispatch-None-08116 Descriptors in bound descriptor buffers, specified via vkCmdSetDescriptorBufferOffsetsEXT, must be valid if they are dynamically used by the VkPipeline bound to the pipeline bind point used by this command and the bound VkPipeline was created with VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT VUID-vkCmdDispatch-None-08604 Descriptors in bound descriptor buffers, specified via vkCmdSetDescriptorBufferOffsetsEXT, must be valid if they are dynamically used by any VkShaderEXT bound to a stage corresponding to the pipeline bind point used by this command VUID-vkCmdDispatch-None-08117 If the descriptors used by the VkPipeline bound to the pipeline bind point were specified via vkCmdSetDescriptorBufferOffsetsEXT, the bound VkPipeline must have been created with VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT VUID-vkCmdDispatch-None-08119 If a descriptor is dynamically used with a VkPipeline created with VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT, the descriptor memory must be resident VUID-vkCmdDispatch-None-08605 If a descriptor is dynamically used with a VkShaderEXT created with a VkDescriptorSetLayout that was created with VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT, the descriptor memory must be resident VUID-vkCmdDispatch-None-08606 If the shaderObject feature is not enabled, a valid pipeline must be bound to the pipeline bind point used by this command VUID-vkCmdDispatch-None-08608 If a pipeline is bound to the pipeline bind point used by this command, there must not have been any calls to dynamic state setting commands for any state specified statically in the VkPipeline object bound to the pipeline bind point used by this command, since that pipeline was bound VUID-vkCmdDispatch-uniformBuffers-06935 If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a uniform buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2 for uniformBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point VUID-vkCmdDispatch-None-08612 If the robustBufferAccess feature is not enabled, and any VkShaderEXT bound to a stage corresponding to the pipeline bind point used by this command accesses a uniform buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point VUID-vkCmdDispatch-storageBuffers-06936 If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a storage buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2 for storageBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point VUID-vkCmdDispatch-None-08613 If the robustBufferAccess feature is not enabled, and any VkShaderEXT bound to a stage corresponding to the pipeline bind point used by this command accesses a storage buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point VUID-vkCmdDispatch-commandBuffer-02707 If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, any resource accessed by bound shaders must not be a protected resource VUID-vkCmdDispatch-viewType-07752 If a VkImageView is accessed as a result of this command, then the image view’s viewType must match the Dim operand of the OpTypeImage as described in Compatibility Between SPIR-V Image Dimensions and Vulkan ImageView Types VUID-vkCmdDispatch-format-07753 If a VkImageView or VkBufferView is accessed as a result of this command, then the numeric type of the view’s format and the Sampled Type operand of the OpTypeImage must match VUID-vkCmdDispatch-OpImageWrite-08795 If a VkImageView created with a format other than VK_FORMAT_A8_UNORM is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the image view’s format VUID-vkCmdDispatch-OpImageWrite-08796 If a VkImageView created with the format VK_FORMAT_A8_UNORM is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have four components VUID-vkCmdDispatch-OpImageWrite-04469 If a VkBufferView is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the buffer view’s format VUID-vkCmdDispatch-SampledType-04470 If a VkImageView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64 VUID-vkCmdDispatch-SampledType-04471 If a VkImageView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32 VUID-vkCmdDispatch-SampledType-04472 If a VkBufferView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64 VUID-vkCmdDispatch-SampledType-04473 If a VkBufferView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32 VUID-vkCmdDispatch-sparseImageInt64Atomics-04474 If the sparseImageInt64Atomics feature is not enabled, VkImage objects created with the VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command VUID-vkCmdDispatch-sparseImageInt64Atomics-04475 If the sparseImageInt64Atomics feature is not enabled, VkBuffer objects created with the VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command VUID-vkCmdDispatch-OpImageWeightedSampleQCOM-06971 If OpImageWeightedSampleQCOM is used to sample a VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM VUID-vkCmdDispatch-OpImageWeightedSampleQCOM-06972 If OpImageWeightedSampleQCOM uses a VkImageView as a sample weight image as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM VUID-vkCmdDispatch-OpImageBoxFilterQCOM-06973 If OpImageBoxFilterQCOM is used to sample a VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM VUID-vkCmdDispatch-OpImageBlockMatchSSDQCOM-06974 If OpImageBlockMatchSSDQCOM is used to read from an VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM VUID-vkCmdDispatch-OpImageBlockMatchSADQCOM-06975 If OpImageBlockMatchSADQCOM is used to read from an VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM VUID-vkCmdDispatch-OpImageBlockMatchSADQCOM-06976 If OpImageBlockMatchSADQCOM or OpImageBlockMatchSSDQCOM is used to read from a reference image as result of this command, then the specified reference coordinates must not fail integer texel coordinate validation VUID-vkCmdDispatch-OpImageWeightedSampleQCOM-06977 If OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchWindowSSDQCOM, OpImageBlockMatchWindowSADQCOM, OpImageBlockMatchGatherSSDQCOM, OpImageBlockMatchGatherSADQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM VUID-vkCmdDispatch-OpImageWeightedSampleQCOM-06978 If any command other than OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchWindowSSDQCOM, OpImageBlockMatchWindowSADQCOM, OpImageBlockMatchGatherSSDQCOM, OpImageBlockMatchGatherSADQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must not have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM VUID-vkCmdDispatch-OpImageBlockMatchWindow-09215 If a OpImageBlockMatchWindow*QCOM or OpImageBlockMatchGather*QCOM instruction is used to read from an VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM VUID-vkCmdDispatch-OpImageBlockMatchWindow-09216 If a OpImageBlockMatchWindow*QCOM or OpImageBlockMatchGather*QCOM instruction is used to read from an VkImageView as a result of this command, then the image view’s format must be a single-component format VUID-vkCmdDispatch-OpImageBlockMatchWindow-09217 If a OpImageBlockMatchWindow*QCOM or OpImageBlockMatchGather*QCOM read from a reference image as result of this command, then the specified reference coordinates must not fail integer texel coordinate validation VUID-vkCmdDispatch-None-07288 Any shader invocation executed by this command must terminate VUID-vkCmdDispatch-None-09600 If a descriptor with type equal to any of VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM, VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, or VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT is accessed as a result of this command, all image subresources identified by that descriptor must be in the image layout identified when the descriptor was written VUID-vkCmdDispatch-commandBuffer-10746 The VkDeviceMemory object allocated from a VkMemoryHeap with the VK_MEMORY_HEAP_TILE_MEMORY_BIT_QCOM property that is bound to a resource accessed as a result of this command must be the active bound bound tile memory object in commandBuffer VUID-vkCmdDispatch-None-10678 If this command is recorded inside a tile shading render pass instance, the stages corresponding to the pipeline bind point used by this command must only include VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_FRAGMENT_BIT, and/or VK_SHADER_STAGE_COMPUTE_BIT VUID-vkCmdDispatch-None-10679 If this command is recorded where per-tile execution model is enabled, there must be no access to any image while the image was be transitioned to the VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT layout VUID-vkCmdDispatch-None-10672 If the per-tile execution model is not enabled, this command must be called outside of a render pass instance VUID-vkCmdDispatch-aspectMask-10673 If this command is recorded where per-tile execution model is enabled, and if the VkPipeline object bound to the pipeline bind point used by this command writes to a variable of storage class Storage Class TileAttachmentQCOM, the corresponding VkImageView using must not have been created with an aspectMask that contains VK_IMAGE_ASPECT_DEPTH_BIT or VK_IMAGE_ASPECT_STENCIL_BIT VUID-vkCmdDispatch-None-10674 If the per-tile execution model is enabled, the tileShadingPerTileDispatch feature must be enabled VUID-vkCmdDispatch-None-10675 Memory backing image subresources used as tile attachments in the current render pass must not be written in any way other than as a tile attachment by this command VUID-vkCmdDispatch-None-10676 If any recorded command in the current subpass will write to an image subresource as a tile attachment, this command must not read from the memory backing that image subresource in any other way than as a tile attachment VUID-vkCmdDispatch-None-10743 If there is no bound compute pipeline, a valid VkShaderEXT must be bound to the VK_SHADER_STAGE_COMPUTE_BIT stage VUID-vkCmdDispatch-commandBuffer-02712 If commandBuffer is a protected command buffer and protectedNoFault is not supported, any resource written to by the VkPipeline object bound to the pipeline bind point used by this command must not be an unprotected resource VUID-vkCmdDispatch-commandBuffer-02713 If commandBuffer is a protected command buffer and protectedNoFault is not supported, pipeline stages other than the framebuffer-space and compute stages in the VkPipeline object bound to the pipeline bind point used by this command must not write to any resource VUID-vkCmdDispatch-commandBuffer-04617 If any of the shader stages of the VkPipeline bound to the pipeline bind point used by this command uses the RayQueryKHR capability, then commandBuffer must not be a protected command buffer VUID-vkCmdDispatch-groupCountX-00386 groupCountX must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[0] VUID-vkCmdDispatch-groupCountY-00387 groupCountY must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[1] VUID-vkCmdDispatch-groupCountZ-00388 groupCountZ must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[2] Valid Usage (Implicit) VUID-vkCmdDispatch-commandBuffer-parameter commandBuffer must be a valid VkCommandBuffer handle VUID-vkCmdDispatch-commandBuffer-recording commandBuffer must be in the recording state VUID-vkCmdDispatch-commandBuffer-cmdpool The VkCommandPool that commandBuffer was allocated from must support compute operations VUID-vkCmdDispatch-videocoding This command must only be called outside of a video coding scope Host Synchronization Host access to commandBuffer must be externally synchronized Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized Command Properties Command Buffer Levels Render Pass Scope Video Coding Scope Supported Queue Types Command Type Primary Secondary Both Outside Compute Action To record an indirect dispatching command, call: // Provided by VK_VERSION_1_0 void vkCmdDispatchIndirect( VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset); commandBuffer is the command buffer into which the command will be recorded. buffer is the buffer containing dispatch parameters. offset is the byte offset into buffer where parameters begin. vkCmdDispatchIndirect behaves similarly to vkCmdDispatch except that the parameters are read by the device from a buffer during execution. The parameters of the dispatch are encoded in a VkDispatchIndirectCommand structure taken from buffer starting at offset. Valid Usage VUID-vkCmdDispatchIndirect-magFilter-04553 If a VkSampler created with magFilter or minFilter equal to VK_FILTER_LINEAR, reductionMode equal to VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE, and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT VUID-vkCmdDispatchIndirect-magFilter-09598 If a VkSampler created with magFilter or minFilter equal to VK_FILTER_LINEAR and reductionMode equal to either VK_SAMPLER_REDUCTION_MODE_MIN or VK_SAMPLER_REDUCTION_MODE_MAX is used to sample a VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT VUID-vkCmdDispatchIndirect-mipmapMode-04770 If a VkSampler created with mipmapMode equal to VK_SAMPLER_MIPMAP_MODE_LINEAR, reductionMode equal to VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE, and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT VUID-vkCmdDispatchIndirect-mipmapMode-09599 If a VkSampler created with mipmapMode equal to VK_SAMPLER_MIPMAP_MODE_LINEAR and reductionMode equal to either VK_SAMPLER_REDUCTION_MODE_MIN or VK_SAMPLER_REDUCTION_MODE_MAX is used to sample a VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT VUID-vkCmdDispatchIndirect-unnormalizedCoordinates-09635 If a VkSampler created with unnormalizedCoordinates equal to VK_TRUE is used to sample a VkImageView as a result of this command, then the image view’s levelCount and layerCount must be 1 VUID-vkCmdDispatchIndirect-None-08609 If a VkSampler created with unnormalizedCoordinates equal to VK_TRUE is used to sample a VkImageView as a result of this command, then the image view’s viewType must be VK_IMAGE_VIEW_TYPE_1D or VK_IMAGE_VIEW_TYPE_2D VUID-vkCmdDispatchIndirect-None-08610 If a VkSampler created with unnormalizedCoordinates equal to VK_TRUE is used to sample a VkImageView as a result of this command, then the sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name VUID-vkCmdDispatchIndirect-None-08611 If a VkSampler created with unnormalizedCoordinates equal to VK_TRUE is used to sample a VkImageView as a result of this command, then the sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values VUID-vkCmdDispatchIndirect-None-06479 If a VkImageView is sampled with depth comparison, the image view’s format features must contain VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT VUID-vkCmdDispatchIndirect-None-02691 If a VkImageView is accessed using atomic operations as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT VUID-vkCmdDispatchIndirect-None-07888 If a VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER descriptor is accessed using atomic operations as a result of this command, then the storage texel buffer’s format features must contain VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT VUID-vkCmdDispatchIndirect-None-02692 If a VkImageView is sampled with VK_FILTER_CUBIC_EXT as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT VUID-vkCmdDispatchIndirect-None-02693 If the VK_EXT_filter_cubic extension is not enabled and any VkImageView is sampled with VK_FILTER_CUBIC_EXT as a result of this command, it must not have a VkImageViewType of VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY VUID-vkCmdDispatchIndirect-filterCubic-02694 Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic returned by vkGetPhysicalDeviceImageFormatProperties2 VUID-vkCmdDispatchIndirect-filterCubicMinmax-02695 Any VkImageView being sampled with VK_FILTER_CUBIC_EXT with a reduction mode of either VK_SAMPLER_REDUCTION_MODE_MIN or VK_SAMPLER_REDUCTION_MODE_MAX as a result of this command must have a VkImageViewType and format that supports cubic filtering together with minmax filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax returned by vkGetPhysicalDeviceImageFormatProperties2 VUID-vkCmdDispatchIndirect-cubicRangeClamp-09212 If the cubicRangeClamp feature is not enabled, then any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must not have a VkSamplerReductionModeCreateInfo::reductionMode equal to VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM VUID-vkCmdDispatchIndirect-reductionMode-09213 Any VkImageView being sampled with a VkSamplerReductionModeCreateInfo::reductionMode equal to VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM as a result of this command must sample with VK_FILTER_CUBIC_EXT VUID-vkCmdDispatchIndirect-selectableCubicWeights-09214 If the selectableCubicWeights feature is not enabled, then any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must have VkSamplerCubicWeightsCreateInfoQCOM::cubicWeights equal to VK_CUBIC_FILTER_WEIGHTS_CATMULL_ROM_QCOM VUID-vkCmdDispatchIndirect-flags-02696 Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE VUID-vkCmdDispatchIndirect-OpTypeImage-07027 For any VkImageView being written as a storage image where the image format field of the OpTypeImage is Unknown, the view’s format features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT VUID-vkCmdDispatchIndirect-OpTypeImage-07028 For any VkImageView being read as a storage image where the image format field of the OpTypeImage is Unknown, the view’s format features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT VUID-vkCmdDispatchIndirect-OpTypeImage-07029 For any VkBufferView being written as a storage texel buffer where the image format field of the OpTypeImage is Unknown, the view’s buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT VUID-vkCmdDispatchIndirect-OpTypeImage-07030 Any VkBufferView being read as a storage texel buffer where the image format field of the OpTypeImage is Unknown then the view’s buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT VUID-vkCmdDispatchIndirect-None-08600 For each set n that is statically used by a bound shader, a descriptor set must have been bound to n at the same pipeline bind point, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline or the VkDescriptorSetLayout array used to create the current VkShaderEXT , as described in Pipeline Layout Compatibility VUID-vkCmdDispatchIndirect-None-08601 For each push constant that is statically used by a bound shader, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline or the VkDescriptorSetLayout array used to create the current VkShaderEXT , as described in Pipeline Layout Compatibility VUID-vkCmdDispatchIndirect-None-10068 For each array of resources that is used by a bound shader, the indices used to access members of the array must be less than the descriptor count for the identified binding in the descriptor sets used by this command VUID-vkCmdDispatchIndirect-maintenance4-08602 If the maintenance4 feature is not enabled, then for each push constant that is statically used by a bound shader, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline or the VkDescriptorSetLayout and VkPushConstantRange arrays used to create the current VkShaderEXT , as described in Pipeline Layout Compatibility VUID-vkCmdDispatchIndirect-None-08114 Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid as described by descriptor validity if they are statically used by the VkPipeline bound to the pipeline bind point used by this command and the bound VkPipeline was not created with VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT VUID-vkCmdDispatchIndirect-None-08115 If the descriptors used by the VkPipeline bound to the pipeline bind point were specified via vkCmdBindDescriptorSets, the bound VkPipeline must have been created without VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT VUID-vkCmdDispatchIndirect-None-08116 Descriptors in bound descriptor buffers, specified via vkCmdSetDescriptorBufferOffsetsEXT, must be valid if they are dynamically used by the VkPipeline bound to the pipeline bind point used by this command and the bound VkPipeline was created with VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT VUID-vkCmdDispatchIndirect-None-08604 Descriptors in bound descriptor buffers, specified via vkCmdSetDescriptorBufferOffsetsEXT, must be valid if they are dynamically used by any VkShaderEXT bound to a stage corresponding to the pipeline bind point used by this command VUID-vkCmdDispatchIndirect-None-08117 If the descriptors used by the VkPipeline bound to the pipeline bind point were specified via vkCmdSetDescriptorBufferOffsetsEXT, the bound VkPipeline must have been created with VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT VUID-vkCmdDispatchIndirect-None-08119 If a descriptor is dynamically used with a VkPipeline created with VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT, the descriptor memory must be resident VUID-vkCmdDispatchIndirect-None-08605 If a descriptor is dynamically used with a VkShaderEXT created with a VkDescriptorSetLayout that was created with VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT, the descriptor memory must be resident VUID-vkCmdDispatchIndirect-None-08606 If the shaderObject feature is not enabled, a valid pipeline must be bound to the pipeline bind point used by this command VUID-vkCmdDispatchIndirect-None-08608 If a pipeline is bound to the pipeline bind point used by this command, there must not have been any calls to dynamic state setting commands for any state specified statically in the VkPipeline object bound to the pipeline bind point used by this command, since that pipeline was bound VUID-vkCmdDispatchIndirect-uniformBuffers-06935 If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a uniform buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2 for uniformBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point VUID-vkCmdDispatchIndirect-None-08612 If the robustBufferAccess feature is not enabled, and any VkShaderEXT bound to a stage corresponding to the pipeline bind point used by this command accesses a uniform buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point VUID-vkCmdDispatchIndirect-storageBuffers-06936 If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a storage buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2 for storageBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point VUID-vkCmdDispatchIndirect-None-08613 If the robustBufferAccess feature is not enabled, and any VkShaderEXT bound to a stage corresponding to the pipeline bind point used by this command accesses a storage buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point VUID-vkCmdDispatchIndirect-commandBuffer-02707 If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, any resource accessed by bound shaders must not be a protected resource VUID-vkCmdDispatchIndirect-viewType-07752 If a VkImageView is accessed as a result of this command, then the image view’s viewType must match the Dim operand of the OpTypeImage as described in Compatibility Between SPIR-V Image Dimensions and Vulkan ImageView Types VUID-vkCmdDispatchIndirect-format-07753 If a VkImageView or VkBufferView is accessed as a result of this command, then the numeric type of the view’s format and the Sampled Type operand of the OpTypeImage must match VUID-vkCmdDispatchIndirect-OpImageWrite-08795 If a VkImageView created with a format other than VK_FORMAT_A8_UNORM is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the image view’s format VUID-vkCmdDispatchIndirect-OpImageWrite-08796 If a VkImageView created with the format VK_FORMAT_A8_UNORM is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have four components VUID-vkCmdDispatchIndirect-OpImageWrite-04469 If a VkBufferView is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the buffer view’s format VUID-vkCmdDispatchIndirect-SampledType-04470 If a VkImageView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64 VUID-vkCmdDispatchIndirect-SampledType-04471 If a VkImageView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32 VUID-vkCmdDispatchIndirect-SampledType-04472 If a VkBufferView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64 VUID-vkCmdDispatchIndirect-SampledType-04473 If a VkBufferView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32 VUID-vkCmdDispatchIndirect-sparseImageInt64Atomics-04474 If the sparseImageInt64Atomics feature is not enabled, VkImage objects created with the VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command VUID-vkCmdDispatchIndirect-sparseImageInt64Atomics-04475 If the sparseImageInt64Atomics feature is not enabled, VkBuffer objects created with the VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command VUID-vkCmdDispatchIndirect-OpImageWeightedSampleQCOM-06971 If OpImageWeightedSampleQCOM is used to sample a VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM VUID-vkCmdDispatchIndirect-OpImageWeightedSampleQCOM-06972 If OpImageWeightedSampleQCOM uses a VkImageView as a sample weight image as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM VUID-vkCmdDispatchIndirect-OpImageBoxFilterQCOM-06973 If OpImageBoxFilterQCOM is used to sample a VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM VUID-vkCmdDispatchIndirect-OpImageBlockMatchSSDQCOM-06974 If OpImageBlockMatchSSDQCOM is used to read from an VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM VUID-vkCmdDispatchIndirect-OpImageBlockMatchSADQCOM-06975 If OpImageBlockMatchSADQCOM is used to read from an VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM VUID-vkCmdDispatchIndirect-OpImageBlockMatchSADQCOM-06976 If OpImageBlockMatchSADQCOM or OpImageBlockMatchSSDQCOM is used to read from a reference image as result of this command, then the specified reference coordinates must not fail integer texel coordinate validation VUID-vkCmdDispatchIndirect-OpImageWeightedSampleQCOM-06977 If OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchWindowSSDQCOM, OpImageBlockMatchWindowSADQCOM, OpImageBlockMatchGatherSSDQCOM, OpImageBlockMatchGatherSADQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM VUID-vkCmdDispatchIndirect-OpImageWeightedSampleQCOM-06978 If any command other than OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchWindowSSDQCOM, OpImageBlockMatchWindowSADQCOM, OpImageBlockMatchGatherSSDQCOM, OpImageBlockMatchGatherSADQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must not have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM VUID-vkCmdDispatchIndirect-OpImageBlockMatchWindow-09215 If a OpImageBlockMatchWindow*QCOM or OpImageBlockMatchGather*QCOM instruction is used to read from an VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM VUID-vkCmdDispatchIndirect-OpImageBlockMatchWindow-09216 If a OpImageBlockMatchWindow*QCOM or OpImageBlockMatchGather*QCOM instruction is used to read from an VkImageView as a result of this command, then the image view’s format must be a single-component format VUID-vkCmdDispatchIndirect-OpImageBlockMatchWindow-09217 If a OpImageBlockMatchWindow*QCOM or OpImageBlockMatchGather*QCOM read from a reference image as result of this command, then the specified reference coordinates must not fail integer texel coordinate validation VUID-vkCmdDispatchIndirect-None-07288 Any shader invocation executed by this command must terminate VUID-vkCmdDispatchIndirect-None-09600 If a descriptor with type equal to any of VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM, VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, or VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT is accessed as a result of this command, all image subresources identified by that descriptor must be in the image layout identified when the descriptor was written VUID-vkCmdDispatchIndirect-commandBuffer-10746 The VkDeviceMemory object allocated from a VkMemoryHeap with the VK_MEMORY_HEAP_TILE_MEMORY_BIT_QCOM property that is bound to a resource accessed as a result of this command must be the active bound bound tile memory object in commandBuffer VUID-vkCmdDispatchIndirect-None-10678 If this command is recorded inside a tile shading render pass instance, the stages corresponding to the pipeline bind point used by this command must only include VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_FRAGMENT_BIT, and/or VK_SHADER_STAGE_COMPUTE_BIT VUID-vkCmdDispatchIndirect-None-10679 If this command is recorded where per-tile execution model is enabled, there must be no access to any image while the image was be transitioned to the VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT layout VUID-vkCmdDispatchIndirect-None-10672 If the per-tile execution model is not enabled, this command must be called outside of a render pass instance VUID-vkCmdDispatchIndirect-aspectMask-10673 If this command is recorded where per-tile execution model is enabled, and if the VkPipeline object bound to the pipeline bind point used by this command writes to a variable of storage class Storage Class TileAttachmentQCOM, the corresponding VkImageView using must not have been created with an aspectMask that contains VK_IMAGE_ASPECT_DEPTH_BIT or VK_IMAGE_ASPECT_STENCIL_BIT VUID-vkCmdDispatchIndirect-None-10674 If the per-tile execution model is enabled, the tileShadingPerTileDispatch feature must be enabled VUID-vkCmdDispatchIndirect-None-10675 Memory backing image subresources used as tile attachments in the current render pass must not be written in any way other than as a tile attachment by this command VUID-vkCmdDispatchIndirect-None-10676 If any recorded command in the current subpass will write to an image subresource as a tile attachment, this command must not read from the memory backing that image subresource in any other way than as a tile attachment VUID-vkCmdDispatchIndirect-None-10743 If there is no bound compute pipeline, a valid VkShaderEXT must be bound to the VK_SHADER_STAGE_COMPUTE_BIT stage VUID-vkCmdDispatchIndirect-buffer-02708 If buffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object VUID-vkCmdDispatchIndirect-buffer-02709 buffer must have been created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set VUID-vkCmdDispatchIndirect-offset-02710 offset must be a multiple of 4 VUID-vkCmdDispatchIndirect-commandBuffer-02711 commandBuffer must not be a protected command buffer VUID-vkCmdDispatchIndirect-offset-00407 The sum of offset and the size of VkDispatchIndirectCommand must be less than or equal to the size of buffer Valid Usage (Implicit) VUID-vkCmdDispatchIndirect-commandBuffer-parameter commandBuffer must be a valid VkCommandBuffer handle VUID-vkCmdDispatchIndirect-buffer-parameter buffer must be a valid VkBuffer handle VUID-vkCmdDispatchIndirect-commandBuffer-recording commandBuffer must be in the recording state VUID-vkCmdDispatchIndirect-commandBuffer-cmdpool The VkCommandPool that commandBuffer was allocated from must support compute operations VUID-vkCmdDispatchIndirect-videocoding This command must only be called outside of a video coding scope VUID-vkCmdDispatchIndirect-commonparent Both of buffer, and commandBuffer must have been created, allocated, or retrieved from the same VkDevice Host Synchronization Host access to commandBuffer must be externally synchronized Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized Command Properties Command Buffer Levels Render Pass Scope Video Coding Scope Supported Queue Types Command Type Primary Secondary Both Outside Compute Action The VkDispatchIndirectCommand structure is defined as: // Provided by VK_VERSION_1_0 typedef struct VkDispatchIndirectCommand { uint32_t x; uint32_t y; uint32_t z; } VkDispatchIndirectCommand; x is the number of local workgroups to dispatch in the X dimension. y is the number of local workgroups to dispatch in the Y dimension. z is the number of local workgroups to dispatch in the Z dimension. The members of VkDispatchIndirectCommand have the same meaning as the corresponding parameters of vkCmdDispatch. Valid Usage VUID-VkDispatchIndirectCommand-x-00417 x must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[0] VUID-VkDispatchIndirectCommand-y-00418 y must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[1] VUID-VkDispatchIndirectCommand-z-00419 z must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[2] To record a dispatch using non-zero base values for the components of WorkgroupId, call: // Provided by VK_VERSION_1_1 void vkCmdDispatchBase( VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ); or the equivalent command // Provided by VK_KHR_device_group void vkCmdDispatchBaseKHR( VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ); commandBuffer is the command buffer into which the command will be recorded. baseGroupX is the start value for the X component of WorkgroupId. baseGroupY is the start value for the Y component of WorkgroupId. baseGroupZ is the start value for the Z component of WorkgroupId. groupCountX is the number of local workgroups to dispatch in the X dimension. groupCountY is the number of local workgroups to dispatch in the Y dimension. groupCountZ is the number of local workgroups to dispatch in the Z dimension. When the command is executed, a global workgroup consisting of groupCountX × groupCountY × groupCountZ local workgroups is assembled, with WorkgroupId values ranging from [baseGroup*, baseGroup* + groupCount*) in each component. vkCmdDispatch is equivalent to vkCmdDispatchBase(0,0,0,groupCountX,groupCountY,groupCountZ). Valid Usage VUID-vkCmdDispatchBase-magFilter-04553 If a VkSampler created with magFilter or minFilter equal to VK_FILTER_LINEAR, reductionMode equal to VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE, and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT VUID-vkCmdDispatchBase-magFilter-09598 If a VkSampler created with magFilter or minFilter equal to VK_FILTER_LINEAR and reductionMode equal to either VK_SAMPLER_REDUCTION_MODE_MIN or VK_SAMPLER_REDUCTION_MODE_MAX is used to sample a VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT VUID-vkCmdDispatchBase-mipmapMode-04770 If a VkSampler created with mipmapMode equal to VK_SAMPLER_MIPMAP_MODE_LINEAR, reductionMode equal to VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE, and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT VUID-vkCmdDispatchBase-mipmapMode-09599 If a VkSampler created with mipmapMode equal to VK_SAMPLER_MIPMAP_MODE_LINEAR and reductionMode equal to either VK_SAMPLER_REDUCTION_MODE_MIN or VK_SAMPLER_REDUCTION_MODE_MAX is used to sample a VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT VUID-vkCmdDispatchBase-unnormalizedCoordinates-09635 If a VkSampler created with unnormalizedCoordinates equal to VK_TRUE is used to sample a VkImageView as a result of this command, then the image view’s levelCount and layerCount must be 1 VUID-vkCmdDispatchBase-None-08609 If a VkSampler created with unnormalizedCoordinates equal to VK_TRUE is used to sample a VkImageView as a result of this command, then the image view’s viewType must be VK_IMAGE_VIEW_TYPE_1D or VK_IMAGE_VIEW_TYPE_2D VUID-vkCmdDispatchBase-None-08610 If a VkSampler created with unnormalizedCoordinates equal to VK_TRUE is used to sample a VkImageView as a result of this command, then the sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name VUID-vkCmdDispatchBase-None-08611 If a VkSampler created with unnormalizedCoordinates equal to VK_TRUE is used to sample a VkImageView as a result of this command, then the sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values VUID-vkCmdDispatchBase-None-06479 If a VkImageView is sampled with depth comparison, the image view’s format features must contain VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT VUID-vkCmdDispatchBase-None-02691 If a VkImageView is accessed using atomic operations as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT VUID-vkCmdDispatchBase-None-07888 If a VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER descriptor is accessed using atomic operations as a result of this command, then the storage texel buffer’s format features must contain VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT VUID-vkCmdDispatchBase-None-02692 If a VkImageView is sampled with VK_FILTER_CUBIC_EXT as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT VUID-vkCmdDispatchBase-None-02693 If the VK_EXT_filter_cubic extension is not enabled and any VkImageView is sampled with VK_FILTER_CUBIC_EXT as a result of this command, it must not have a VkImageViewType of VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY VUID-vkCmdDispatchBase-filterCubic-02694 Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic returned by vkGetPhysicalDeviceImageFormatProperties2 VUID-vkCmdDispatchBase-filterCubicMinmax-02695 Any VkImageView being sampled with VK_FILTER_CUBIC_EXT with a reduction mode of either VK_SAMPLER_REDUCTION_MODE_MIN or VK_SAMPLER_REDUCTION_MODE_MAX as a result of this command must have a VkImageViewType and format that supports cubic filtering together with minmax filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax returned by vkGetPhysicalDeviceImageFormatProperties2 VUID-vkCmdDispatchBase-cubicRangeClamp-09212 If the cubicRangeClamp feature is not enabled, then any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must not have a VkSamplerReductionModeCreateInfo::reductionMode equal to VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM VUID-vkCmdDispatchBase-reductionMode-09213 Any VkImageView being sampled with a VkSamplerReductionModeCreateInfo::reductionMode equal to VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM as a result of this command must sample with VK_FILTER_CUBIC_EXT VUID-vkCmdDispatchBase-selectableCubicWeights-09214 If the selectableCubicWeights feature is not enabled, then any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must have VkSamplerCubicWeightsCreateInfoQCOM::cubicWeights equal to VK_CUBIC_FILTER_WEIGHTS_CATMULL_ROM_QCOM VUID-vkCmdDispatchBase-flags-02696 Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE VUID-vkCmdDispatchBase-OpTypeImage-07027 For any VkImageView being written as a storage image where the image format field of the OpTypeImage is Unknown, the view’s format features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT VUID-vkCmdDispatchBase-OpTypeImage-07028 For any VkImageView being read as a storage image where the image format field of the OpTypeImage is Unknown, the view’s format features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT VUID-vkCmdDispatchBase-OpTypeImage-07029 For any VkBufferView being written as a storage texel buffer where the image format field of the OpTypeImage is Unknown, the view’s buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT VUID-vkCmdDispatchBase-OpTypeImage-07030 Any VkBufferView being read as a storage texel buffer where the image format field of the OpTypeImage is Unknown then the view’s buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT VUID-vkCmdDispatchBase-None-08600 For each set n that is statically used by a bound shader, a descriptor set must have been bound to n at the same pipeline bind point, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline or the VkDescriptorSetLayout array used to create the current VkShaderEXT , as described in Pipeline Layout Compatibility VUID-vkCmdDispatchBase-None-08601 For each push constant that is statically used by a bound shader, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline or the VkDescriptorSetLayout array used to create the current VkShaderEXT , as described in Pipeline Layout Compatibility VUID-vkCmdDispatchBase-None-10068 For each array of resources that is used by a bound shader, the indices used to access members of the array must be less than the descriptor count for the identified binding in the descriptor sets used by this command VUID-vkCmdDispatchBase-maintenance4-08602 If the maintenance4 feature is not enabled, then for each push constant that is statically used by a bound shader, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline or the VkDescriptorSetLayout and VkPushConstantRange arrays used to create the current VkShaderEXT , as described in Pipeline Layout Compatibility VUID-vkCmdDispatchBase-None-08114 Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid as described by descriptor validity if they are statically used by the VkPipeline bound to the pipeline bind point used by this command and the bound VkPipeline was not created with VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT VUID-vkCmdDispatchBase-None-08115 If the descriptors used by the VkPipeline bound to the pipeline bind point were specified via vkCmdBindDescriptorSets, the bound VkPipeline must have been created without VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT VUID-vkCmdDispatchBase-None-08116 Descriptors in bound descriptor buffers, specified via vkCmdSetDescriptorBufferOffsetsEXT, must be valid if they are dynamically used by the VkPipeline bound to the pipeline bind point used by this command and the bound VkPipeline was created with VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT VUID-vkCmdDispatchBase-None-08604 Descriptors in bound descriptor buffers, specified via vkCmdSetDescriptorBufferOffsetsEXT, must be valid if they are dynamically used by any VkShaderEXT bound to a stage corresponding to the pipeline bind point used by this command VUID-vkCmdDispatchBase-None-08117 If the descriptors used by the VkPipeline bound to the pipeline bind point were specified via vkCmdSetDescriptorBufferOffsetsEXT, the bound VkPipeline must have been created with VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT VUID-vkCmdDispatchBase-None-08119 If a descriptor is dynamically used with a VkPipeline created with VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT, the descriptor memory must be resident VUID-vkCmdDispatchBase-None-08605 If a descriptor is dynamically used with a VkShaderEXT created with a VkDescriptorSetLayout that was created with VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT, the descriptor memory must be resident VUID-vkCmdDispatchBase-None-08606 If the shaderObject feature is not enabled, a valid pipeline must be bound to the pipeline bind point used by this command VUID-vkCmdDispatchBase-None-08608 If a pipeline is bound to the pipeline bind point used by this command, there must not have been any calls to dynamic state setting commands for any state specified statically in the VkPipeline object bound to the pipeline bind point used by this command, since that pipeline was bound VUID-vkCmdDispatchBase-uniformBuffers-06935 If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a uniform buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2 for uniformBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point VUID-vkCmdDispatchBase-None-08612 If the robustBufferAccess feature is not enabled, and any VkShaderEXT bound to a stage corresponding to the pipeline bind point used by this command accesses a uniform buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point VUID-vkCmdDispatchBase-storageBuffers-06936 If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a storage buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2 for storageBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point VUID-vkCmdDispatchBase-None-08613 If the robustBufferAccess feature is not enabled, and any VkShaderEXT bound to a stage corresponding to the pipeline bind point used by this command accesses a storage buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point VUID-vkCmdDispatchBase-commandBuffer-02707 If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, any resource accessed by bound shaders must not be a protected resource VUID-vkCmdDispatchBase-viewType-07752 If a VkImageView is accessed as a result of this command, then the image view’s viewType must match the Dim operand of the OpTypeImage as described in Compatibility Between SPIR-V Image Dimensions and Vulkan ImageView Types VUID-vkCmdDispatchBase-format-07753 If a VkImageView or VkBufferView is accessed as a result of this command, then the numeric type of the view’s format and the Sampled Type operand of the OpTypeImage must match VUID-vkCmdDispatchBase-OpImageWrite-08795 If a VkImageView created with a format other than VK_FORMAT_A8_UNORM is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the image view’s format VUID-vkCmdDispatchBase-OpImageWrite-08796 If a VkImageView created with the format VK_FORMAT_A8_UNORM is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have four components VUID-vkCmdDispatchBase-OpImageWrite-04469 If a VkBufferView is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the buffer view’s format VUID-vkCmdDispatchBase-SampledType-04470 If a VkImageView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64 VUID-vkCmdDispatchBase-SampledType-04471 If a VkImageView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32 VUID-vkCmdDispatchBase-SampledType-04472 If a VkBufferView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64 VUID-vkCmdDispatchBase-SampledType-04473 If a VkBufferView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32 VUID-vkCmdDispatchBase-sparseImageInt64Atomics-04474 If the sparseImageInt64Atomics feature is not enabled, VkImage objects created with the VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command VUID-vkCmdDispatchBase-sparseImageInt64Atomics-04475 If the sparseImageInt64Atomics feature is not enabled, VkBuffer objects created with the VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command VUID-vkCmdDispatchBase-OpImageWeightedSampleQCOM-06971 If OpImageWeightedSampleQCOM is used to sample a VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM VUID-vkCmdDispatchBase-OpImageWeightedSampleQCOM-06972 If OpImageWeightedSampleQCOM uses a VkImageView as a sample weight image as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM VUID-vkCmdDispatchBase-OpImageBoxFilterQCOM-06973 If OpImageBoxFilterQCOM is used to sample a VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM VUID-vkCmdDispatchBase-OpImageBlockMatchSSDQCOM-06974 If OpImageBlockMatchSSDQCOM is used to read from an VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM VUID-vkCmdDispatchBase-OpImageBlockMatchSADQCOM-06975 If OpImageBlockMatchSADQCOM is used to read from an VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM VUID-vkCmdDispatchBase-OpImageBlockMatchSADQCOM-06976 If OpImageBlockMatchSADQCOM or OpImageBlockMatchSSDQCOM is used to read from a reference image as result of this command, then the specified reference coordinates must not fail integer texel coordinate validation VUID-vkCmdDispatchBase-OpImageWeightedSampleQCOM-06977 If OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchWindowSSDQCOM, OpImageBlockMatchWindowSADQCOM, OpImageBlockMatchGatherSSDQCOM, OpImageBlockMatchGatherSADQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM VUID-vkCmdDispatchBase-OpImageWeightedSampleQCOM-06978 If any command other than OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchWindowSSDQCOM, OpImageBlockMatchWindowSADQCOM, OpImageBlockMatchGatherSSDQCOM, OpImageBlockMatchGatherSADQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must not have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM VUID-vkCmdDispatchBase-OpImageBlockMatchWindow-09215 If a OpImageBlockMatchWindow*QCOM or OpImageBlockMatchGather*QCOM instruction is used to read from an VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM VUID-vkCmdDispatchBase-OpImageBlockMatchWindow-09216 If a OpImageBlockMatchWindow*QCOM or OpImageBlockMatchGather*QCOM instruction is used to read from an VkImageView as a result of this command, then the image view’s format must be a single-component format VUID-vkCmdDispatchBase-OpImageBlockMatchWindow-09217 If a OpImageBlockMatchWindow*QCOM or OpImageBlockMatchGather*QCOM read from a reference image as result of this command, then the specified reference coordinates must not fail integer texel coordinate validation VUID-vkCmdDispatchBase-None-07288 Any shader invocation executed by this command must terminate VUID-vkCmdDispatchBase-None-09600 If a descriptor with type equal to any of VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM, VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, or VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT is accessed as a result of this command, all image subresources identified by that descriptor must be in the image layout identified when the descriptor was written VUID-vkCmdDispatchBase-commandBuffer-10746 The VkDeviceMemory object allocated from a VkMemoryHeap with the VK_MEMORY_HEAP_TILE_MEMORY_BIT_QCOM property that is bound to a resource accessed as a result of this command must be the active bound bound tile memory object in commandBuffer VUID-vkCmdDispatchBase-None-10678 If this command is recorded inside a tile shading render pass instance, the stages corresponding to the pipeline bind point used by this command must only include VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_FRAGMENT_BIT, and/or VK_SHADER_STAGE_COMPUTE_BIT VUID-vkCmdDispatchBase-None-10679 If this command is recorded where per-tile execution model is enabled, there must be no access to any image while the image was be transitioned to the VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT layout VUID-vkCmdDispatchBase-None-10672 If the per-tile execution model is not enabled, this command must be called outside of a render pass instance VUID-vkCmdDispatchBase-aspectMask-10673 If this command is recorded where per-tile execution model is enabled, and if the VkPipeline object bound to the pipeline bind point used by this command writes to a variable of storage class Storage Class TileAttachmentQCOM, the corresponding VkImageView using must not have been created with an aspectMask that contains VK_IMAGE_ASPECT_DEPTH_BIT or VK_IMAGE_ASPECT_STENCIL_BIT VUID-vkCmdDispatchBase-None-10674 If the per-tile execution model is enabled, the tileShadingPerTileDispatch feature must be enabled VUID-vkCmdDispatchBase-None-10675 Memory backing image subresources used as tile attachments in the current render pass must not be written in any way other than as a tile attachment by this command VUID-vkCmdDispatchBase-None-10676 If any recorded command in the current subpass will write to an image subresource as a tile attachment, this command must not read from the memory backing that image subresource in any other way than as a tile attachment VUID-vkCmdDispatchBase-None-10743 If there is no bound compute pipeline, a valid VkShaderEXT must be bound to the VK_SHADER_STAGE_COMPUTE_BIT stage VUID-vkCmdDispatchBase-commandBuffer-02712 If commandBuffer is a protected command buffer and protectedNoFault is not supported, any resource written to by the VkPipeline object bound to the pipeline bind point used by this command must not be an unprotected resource VUID-vkCmdDispatchBase-commandBuffer-02713 If commandBuffer is a protected command buffer and protectedNoFault is not supported, pipeline stages other than the framebuffer-space and compute stages in the VkPipeline object bound to the pipeline bind point used by this command must not write to any resource VUID-vkCmdDispatchBase-commandBuffer-04617 If any of the shader stages of the VkPipeline bound to the pipeline bind point used by this command uses the RayQueryKHR capability, then commandBuffer must not be a protected command buffer VUID-vkCmdDispatchBase-baseGroupX-00421 baseGroupX must be less than VkPhysicalDeviceLimits::maxComputeWorkGroupCount[0] VUID-vkCmdDispatchBase-baseGroupX-00422 baseGroupY must be less than VkPhysicalDeviceLimits::maxComputeWorkGroupCount[1] VUID-vkCmdDispatchBase-baseGroupZ-00423 baseGroupZ must be less than VkPhysicalDeviceLimits::maxComputeWorkGroupCount[2] VUID-vkCmdDispatchBase-groupCountX-00424 groupCountX must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[0] minus baseGroupX VUID-vkCmdDispatchBase-groupCountY-00425 groupCountY must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[1] minus baseGroupY VUID-vkCmdDispatchBase-groupCountZ-00426 groupCountZ must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[2] minus baseGroupZ VUID-vkCmdDispatchBase-baseGroupX-00427 If any of baseGroupX, baseGroupY, or baseGroupZ are not zero, then the bound compute pipeline must have been created with the VK_PIPELINE_CREATE_DISPATCH_BASE flag or the bound compute shader object must have been created with the VK_SHADER_CREATE_DISPATCH_BASE_BIT_EXT flag Valid Usage (Implicit) VUID-vkCmdDispatchBase-commandBuffer-parameter commandBuffer must be a valid VkCommandBuffer handle VUID-vkCmdDispatchBase-commandBuffer-recording commandBuffer must be in the recording state VUID-vkCmdDispatchBase-commandBuffer-cmdpool The VkCommandPool that commandBuffer was allocated from must support compute operations VUID-vkCmdDispatchBase-videocoding This command must only be called outside of a video coding scope Host Synchronization Host access to commandBuffer must be externally synchronized Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized Command Properties Command Buffer Levels Render Pass Scope Video Coding Scope Supported Queue Types Command Type Primary Secondary Both Outside Compute Action To record an area-based dispatch, call: // Provided by VK_QCOM_tile_shading void vkCmdDispatchTileQCOM( VkCommandBuffer commandBuffer); commandBuffer is the command buffer into which the command will be recorded. pDispatchTileInfo is a pointer to a VkDispatchTileInfoQCOM structure containing information about the area-based dispatch. This command operates in the per-tile execution model, invoking a separate dispatch for each covered tile. The global workgroup count and local workgroup size of each dispatch are defined by the implementation to efficiently iterate over a uniform grid of pixel blocks within the area of its active tile. Each shader invocation operates on a single pixel block and its size is determined by the shader’s tiling rate, which must be defined by shaders executed by this command. The TileShadingRateQCOM execution mode operand defines the shader’s tiling rate. Its x and y must be a power of two and less than or equal to the maxTileShadingRate limit. Its z must be less than or equal to the active tile’s depth as reported by VK_QCOM_tile_properties, and VkTilePropertiesQCOM::tileSize::z % TileShadingRateQCOM::z must equal 0. The start location of the shader invocation’s pixel block is vec3(TileOffsetQCOM, 0) + (GlobalInvocationId * TileShadingRateQCOM) Shader invocations can perform tile attachment load/store operations at any location within the active tile, but the most efficient access may be limited to fragment locations within and local to the shader invocation’s pixel block. Valid Usage VUID-vkCmdDispatchTileQCOM-magFilter-04553 If a VkSampler created with magFilter or minFilter equal to VK_FILTER_LINEAR, reductionMode equal to VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE, and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT VUID-vkCmdDispatchTileQCOM-magFilter-09598 If a VkSampler created with magFilter or minFilter equal to VK_FILTER_LINEAR and reductionMode equal to either VK_SAMPLER_REDUCTION_MODE_MIN or VK_SAMPLER_REDUCTION_MODE_MAX is used to sample a VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT VUID-vkCmdDispatchTileQCOM-mipmapMode-04770 If a VkSampler created with mipmapMode equal to VK_SAMPLER_MIPMAP_MODE_LINEAR, reductionMode equal to VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE, and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT VUID-vkCmdDispatchTileQCOM-mipmapMode-09599 If a VkSampler created with mipmapMode equal to VK_SAMPLER_MIPMAP_MODE_LINEAR and reductionMode equal to either VK_SAMPLER_REDUCTION_MODE_MIN or VK_SAMPLER_REDUCTION_MODE_MAX is used to sample a VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT VUID-vkCmdDispatchTileQCOM-unnormalizedCoordinates-09635 If a VkSampler created with unnormalizedCoordinates equal to VK_TRUE is used to sample a VkImageView as a result of this command, then the image view’s levelCount and layerCount must be 1 VUID-vkCmdDispatchTileQCOM-None-08609 If a VkSampler created with unnormalizedCoordinates equal to VK_TRUE is used to sample a VkImageView as a result of this command, then the image view’s viewType must be VK_IMAGE_VIEW_TYPE_1D or VK_IMAGE_VIEW_TYPE_2D VUID-vkCmdDispatchTileQCOM-None-08610 If a VkSampler created with unnormalizedCoordinates equal to VK_TRUE is used to sample a VkImageView as a result of this command, then the sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name VUID-vkCmdDispatchTileQCOM-None-08611 If a VkSampler created with unnormalizedCoordinates equal to VK_TRUE is used to sample a VkImageView as a result of this command, then the sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values VUID-vkCmdDispatchTileQCOM-None-06479 If a VkImageView is sampled with depth comparison, the image view’s format features must contain VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT VUID-vkCmdDispatchTileQCOM-None-02691 If a VkImageView is accessed using atomic operations as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT VUID-vkCmdDispatchTileQCOM-None-07888 If a VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER descriptor is accessed using atomic operations as a result of this command, then the storage texel buffer’s format features must contain VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT VUID-vkCmdDispatchTileQCOM-None-02692 If a VkImageView is sampled with VK_FILTER_CUBIC_EXT as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT VUID-vkCmdDispatchTileQCOM-None-02693 If the VK_EXT_filter_cubic extension is not enabled and any VkImageView is sampled with VK_FILTER_CUBIC_EXT as a result of this command, it must not have a VkImageViewType of VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY VUID-vkCmdDispatchTileQCOM-filterCubic-02694 Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic returned by vkGetPhysicalDeviceImageFormatProperties2 VUID-vkCmdDispatchTileQCOM-filterCubicMinmax-02695 Any VkImageView being sampled with VK_FILTER_CUBIC_EXT with a reduction mode of either VK_SAMPLER_REDUCTION_MODE_MIN or VK_SAMPLER_REDUCTION_MODE_MAX as a result of this command must have a VkImageViewType and format that supports cubic filtering together with minmax filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax returned by vkGetPhysicalDeviceImageFormatProperties2 VUID-vkCmdDispatchTileQCOM-cubicRangeClamp-09212 If the cubicRangeClamp feature is not enabled, then any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must not have a VkSamplerReductionModeCreateInfo::reductionMode equal to VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM VUID-vkCmdDispatchTileQCOM-reductionMode-09213 Any VkImageView being sampled with a VkSamplerReductionModeCreateInfo::reductionMode equal to VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM as a result of this command must sample with VK_FILTER_CUBIC_EXT VUID-vkCmdDispatchTileQCOM-selectableCubicWeights-09214 If the selectableCubicWeights feature is not enabled, then any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must have VkSamplerCubicWeightsCreateInfoQCOM::cubicWeights equal to VK_CUBIC_FILTER_WEIGHTS_CATMULL_ROM_QCOM VUID-vkCmdDispatchTileQCOM-flags-02696 Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE VUID-vkCmdDispatchTileQCOM-OpTypeImage-07027 For any VkImageView being written as a storage image where the image format field of the OpTypeImage is Unknown, the view’s format features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT VUID-vkCmdDispatchTileQCOM-OpTypeImage-07028 For any VkImageView being read as a storage image where the image format field of the OpTypeImage is Unknown, the view’s format features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT VUID-vkCmdDispatchTileQCOM-OpTypeImage-07029 For any VkBufferView being written as a storage texel buffer where the image format field of the OpTypeImage is Unknown, the view’s buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT VUID-vkCmdDispatchTileQCOM-OpTypeImage-07030 Any VkBufferView being read as a storage texel buffer where the image format field of the OpTypeImage is Unknown then the view’s buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT VUID-vkCmdDispatchTileQCOM-None-08600 For each set n that is statically used by a bound shader, a descriptor set must have been bound to n at the same pipeline bind point, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline or the VkDescriptorSetLayout array used to create the current VkShaderEXT , as described in Pipeline Layout Compatibility VUID-vkCmdDispatchTileQCOM-None-08601 For each push constant that is statically used by a bound shader, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline or the VkDescriptorSetLayout array used to create the current VkShaderEXT , as described in Pipeline Layout Compatibility VUID-vkCmdDispatchTileQCOM-None-10068 For each array of resources that is used by a bound shader, the indices used to access members of the array must be less than the descriptor count for the identified binding in the descriptor sets used by this command VUID-vkCmdDispatchTileQCOM-maintenance4-08602 If the maintenance4 feature is not enabled, then for each push constant that is statically used by a bound shader, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline or the VkDescriptorSetLayout and VkPushConstantRange arrays used to create the current VkShaderEXT , as described in Pipeline Layout Compatibility VUID-vkCmdDispatchTileQCOM-None-08114 Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid as described by descriptor validity if they are statically used by the VkPipeline bound to the pipeline bind point used by this command and the bound VkPipeline was not created with VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT VUID-vkCmdDispatchTileQCOM-None-08115 If the descriptors used by the VkPipeline bound to the pipeline bind point were specified via vkCmdBindDescriptorSets, the bound VkPipeline must have been created without VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT VUID-vkCmdDispatchTileQCOM-None-08116 Descriptors in bound descriptor buffers, specified via vkCmdSetDescriptorBufferOffsetsEXT, must be valid if they are dynamically used by the VkPipeline bound to the pipeline bind point used by this command and the bound VkPipeline was created with VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT VUID-vkCmdDispatchTileQCOM-None-08604 Descriptors in bound descriptor buffers, specified via vkCmdSetDescriptorBufferOffsetsEXT, must be valid if they are dynamically used by any VkShaderEXT bound to a stage corresponding to the pipeline bind point used by this command VUID-vkCmdDispatchTileQCOM-None-08117 If the descriptors used by the VkPipeline bound to the pipeline bind point were specified via vkCmdSetDescriptorBufferOffsetsEXT, the bound VkPipeline must have been created with VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT VUID-vkCmdDispatchTileQCOM-None-08119 If a descriptor is dynamically used with a VkPipeline created with VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT, the descriptor memory must be resident VUID-vkCmdDispatchTileQCOM-None-08605 If a descriptor is dynamically used with a VkShaderEXT created with a VkDescriptorSetLayout that was created with VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT, the descriptor memory must be resident VUID-vkCmdDispatchTileQCOM-None-08606 If the shaderObject feature is not enabled, a valid pipeline must be bound to the pipeline bind point used by this command VUID-vkCmdDispatchTileQCOM-None-08608 If a pipeline is bound to the pipeline bind point used by this command, there must not have been any calls to dynamic state setting commands for any state specified statically in the VkPipeline object bound to the pipeline bind point used by this command, since that pipeline was bound VUID-vkCmdDispatchTileQCOM-uniformBuffers-06935 If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a uniform buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2 for uniformBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point VUID-vkCmdDispatchTileQCOM-None-08612 If the robustBufferAccess feature is not enabled, and any VkShaderEXT bound to a stage corresponding to the pipeline bind point used by this command accesses a uniform buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point VUID-vkCmdDispatchTileQCOM-storageBuffers-06936 If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a storage buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2 for storageBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point VUID-vkCmdDispatchTileQCOM-None-08613 If the robustBufferAccess feature is not enabled, and any VkShaderEXT bound to a stage corresponding to the pipeline bind point used by this command accesses a storage buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point VUID-vkCmdDispatchTileQCOM-commandBuffer-02707 If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, any resource accessed by bound shaders must not be a protected resource VUID-vkCmdDispatchTileQCOM-viewType-07752 If a VkImageView is accessed as a result of this command, then the image view’s viewType must match the Dim operand of the OpTypeImage as described in Compatibility Between SPIR-V Image Dimensions and Vulkan ImageView Types VUID-vkCmdDispatchTileQCOM-format-07753 If a VkImageView or VkBufferView is accessed as a result of this command, then the numeric type of the view’s format and the Sampled Type operand of the OpTypeImage must match VUID-vkCmdDispatchTileQCOM-OpImageWrite-08795 If a VkImageView created with a format other than VK_FORMAT_A8_UNORM is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the image view’s format VUID-vkCmdDispatchTileQCOM-OpImageWrite-08796 If a VkImageView created with the format VK_FORMAT_A8_UNORM is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have four components VUID-vkCmdDispatchTileQCOM-OpImageWrite-04469 If a VkBufferView is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the buffer view’s format VUID-vkCmdDispatchTileQCOM-SampledType-04470 If a VkImageView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64 VUID-vkCmdDispatchTileQCOM-SampledType-04471 If a VkImageView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32 VUID-vkCmdDispatchTileQCOM-SampledType-04472 If a VkBufferView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64 VUID-vkCmdDispatchTileQCOM-SampledType-04473 If a VkBufferView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32 VUID-vkCmdDispatchTileQCOM-sparseImageInt64Atomics-04474 If the sparseImageInt64Atomics feature is not enabled, VkImage objects created with the VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command VUID-vkCmdDispatchTileQCOM-sparseImageInt64Atomics-04475 If the sparseImageInt64Atomics feature is not enabled, VkBuffer objects created with the VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command VUID-vkCmdDispatchTileQCOM-OpImageWeightedSampleQCOM-06971 If OpImageWeightedSampleQCOM is used to sample a VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM VUID-vkCmdDispatchTileQCOM-OpImageWeightedSampleQCOM-06972 If OpImageWeightedSampleQCOM uses a VkImageView as a sample weight image as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM VUID-vkCmdDispatchTileQCOM-OpImageBoxFilterQCOM-06973 If OpImageBoxFilterQCOM is used to sample a VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM VUID-vkCmdDispatchTileQCOM-OpImageBlockMatchSSDQCOM-06974 If OpImageBlockMatchSSDQCOM is used to read from an VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM VUID-vkCmdDispatchTileQCOM-OpImageBlockMatchSADQCOM-06975 If OpImageBlockMatchSADQCOM is used to read from an VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM VUID-vkCmdDispatchTileQCOM-OpImageBlockMatchSADQCOM-06976 If OpImageBlockMatchSADQCOM or OpImageBlockMatchSSDQCOM is used to read from a reference image as result of this command, then the specified reference coordinates must not fail integer texel coordinate validation VUID-vkCmdDispatchTileQCOM-OpImageWeightedSampleQCOM-06977 If OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchWindowSSDQCOM, OpImageBlockMatchWindowSADQCOM, OpImageBlockMatchGatherSSDQCOM, OpImageBlockMatchGatherSADQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM VUID-vkCmdDispatchTileQCOM-OpImageWeightedSampleQCOM-06978 If any command other than OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchWindowSSDQCOM, OpImageBlockMatchWindowSADQCOM, OpImageBlockMatchGatherSSDQCOM, OpImageBlockMatchGatherSADQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must not have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM VUID-vkCmdDispatchTileQCOM-OpImageBlockMatchWindow-09215 If a OpImageBlockMatchWindow*QCOM or OpImageBlockMatchGather*QCOM instruction is used to read from an VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM VUID-vkCmdDispatchTileQCOM-OpImageBlockMatchWindow-09216 If a OpImageBlockMatchWindow*QCOM or OpImageBlockMatchGather*QCOM instruction is used to read from an VkImageView as a result of this command, then the image view’s format must be a single-component format VUID-vkCmdDispatchTileQCOM-OpImageBlockMatchWindow-09217 If a OpImageBlockMatchWindow*QCOM or OpImageBlockMatchGather*QCOM read from a reference image as result of this command, then the specified reference coordinates must not fail integer texel coordinate validation VUID-vkCmdDispatchTileQCOM-None-07288 Any shader invocation executed by this command must terminate VUID-vkCmdDispatchTileQCOM-None-09600 If a descriptor with type equal to any of VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM, VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, or VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT is accessed as a result of this command, all image subresources identified by that descriptor must be in the image layout identified when the descriptor was written VUID-vkCmdDispatchTileQCOM-commandBuffer-10746 The VkDeviceMemory object allocated from a VkMemoryHeap with the VK_MEMORY_HEAP_TILE_MEMORY_BIT_QCOM property that is bound to a resource accessed as a result of this command must be the active bound bound tile memory object in commandBuffer VUID-vkCmdDispatchTileQCOM-None-10678 If this command is recorded inside a tile shading render pass instance, the stages corresponding to the pipeline bind point used by this command must only include VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_FRAGMENT_BIT, and/or VK_SHADER_STAGE_COMPUTE_BIT VUID-vkCmdDispatchTileQCOM-None-10679 If this command is recorded where per-tile execution model is enabled, there must be no access to any image while the image was be transitioned to the VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT layout VUID-vkCmdDispatchTileQCOM-None-10672 If the per-tile execution model is not enabled, this command must be called outside of a render pass instance VUID-vkCmdDispatchTileQCOM-aspectMask-10673 If this command is recorded where per-tile execution model is enabled, and if the VkPipeline object bound to the pipeline bind point used by this command writes to a variable of storage class Storage Class TileAttachmentQCOM, the corresponding VkImageView using must not have been created with an aspectMask that contains VK_IMAGE_ASPECT_DEPTH_BIT or VK_IMAGE_ASPECT_STENCIL_BIT VUID-vkCmdDispatchTileQCOM-None-10674 If the per-tile execution model is enabled, the tileShadingPerTileDispatch feature must be enabled VUID-vkCmdDispatchTileQCOM-None-10675 Memory backing image subresources used as tile attachments in the current render pass must not be written in any way other than as a tile attachment by this command VUID-vkCmdDispatchTileQCOM-None-10676 If any recorded command in the current subpass will write to an image subresource as a tile attachment, this command must not read from the memory backing that image subresource in any other way than as a tile attachment VUID-vkCmdDispatchTileQCOM-None-10743 If there is no bound compute pipeline, a valid VkShaderEXT must be bound to the VK_SHADER_STAGE_COMPUTE_BIT stage VUID-vkCmdDispatchTileQCOM-commandBuffer-02712 If commandBuffer is a protected command buffer and protectedNoFault is not supported, any resource written to by the VkPipeline object bound to the pipeline bind point used by this command must not be an unprotected resource VUID-vkCmdDispatchTileQCOM-commandBuffer-02713 If commandBuffer is a protected command buffer and protectedNoFault is not supported, pipeline stages other than the framebuffer-space and compute stages in the VkPipeline object bound to the pipeline bind point used by this command must not write to any resource VUID-vkCmdDispatchTileQCOM-commandBuffer-04617 If any of the shader stages of the VkPipeline bound to the pipeline bind point used by this command uses the RayQueryKHR capability, then commandBuffer must not be a protected command buffer VUID-vkCmdDispatchTileQCOM-None-10668 When this command is recorded per-tile execution model must be enabled VUID-vkCmdDispatchTileQCOM-None-10669 The tileShadingDispatchTile must enabled Valid Usage (Implicit) VUID-vkCmdDispatchTileQCOM-commandBuffer-parameter commandBuffer must be a valid VkCommandBuffer handle VUID-vkCmdDispatchTileQCOM-commandBuffer-recording commandBuffer must be in the recording state VUID-vkCmdDispatchTileQCOM-commandBuffer-cmdpool The VkCommandPool that commandBuffer was allocated from must support compute operations VUID-vkCmdDispatchTileQCOM-renderpass This command must only be called inside of a render pass instance VUID-vkCmdDispatchTileQCOM-videocoding This command must only be called outside of a video coding scope Host Synchronization Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized Command Properties Command Buffer Levels Render Pass Scope Video Coding Scope Supported Queue Types Command Type Primary Secondary Inside Outside Compute Action The VkDispatchTileInfoQCOM structure is defined as: // Provided by VK_QCOM_tile_shading typedef struct VkDispatchTileInfoQCOM { VkStructureType sType; const void* pNext; } VkDispatchTileInfoQCOM; sType is a VkStructureType value identifying this structure. pNext is NULL or a pointer to a structure extending this structure. Valid Usage (Implicit) VUID-VkDispatchTileInfoQCOM-sType-sType sType must be VK_STRUCTURE_TYPE_DISPATCH_TILE_INFO_QCOM VUID-VkDispatchTileInfoQCOM-pNext-pNext pNext must be NULL A subpass shading dispatches a compute pipeline work with the work dimension of render area of the calling subpass and work groups are partitioned by specified work group size. Subpass operations like subpassLoad are allowed to be used. To record a subpass shading, call: // Provided by VK_HUAWEI_subpass_shading void vkCmdSubpassShadingHUAWEI( VkCommandBuffer commandBuffer); commandBuffer is the command buffer into which the command will be recorded. When the command is executed, a global workgroup consisting of ceil (render area size / local workgroup size) local workgroups is assembled. Valid Usage VUID-vkCmdSubpassShadingHUAWEI-magFilter-04553 If a VkSampler created with magFilter or minFilter equal to VK_FILTER_LINEAR, reductionMode equal to VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE, and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT VUID-vkCmdSubpassShadingHUAWEI-magFilter-09598 If a VkSampler created with magFilter or minFilter equal to VK_FILTER_LINEAR and reductionMode equal to either VK_SAMPLER_REDUCTION_MODE_MIN or VK_SAMPLER_REDUCTION_MODE_MAX is used to sample a VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT VUID-vkCmdSubpassShadingHUAWEI-mipmapMode-04770 If a VkSampler created with mipmapMode equal to VK_SAMPLER_MIPMAP_MODE_LINEAR, reductionMode equal to VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE, and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT VUID-vkCmdSubpassShadingHUAWEI-mipmapMode-09599 If a VkSampler created with mipmapMode equal to VK_SAMPLER_MIPMAP_MODE_LINEAR and reductionMode equal to either VK_SAMPLER_REDUCTION_MODE_MIN or VK_SAMPLER_REDUCTION_MODE_MAX is used to sample a VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT VUID-vkCmdSubpassShadingHUAWEI-unnormalizedCoordinates-09635 If a VkSampler created with unnormalizedCoordinates equal to VK_TRUE is used to sample a VkImageView as a result of this command, then the image view’s levelCount and layerCount must be 1 VUID-vkCmdSubpassShadingHUAWEI-None-08609 If a VkSampler created with unnormalizedCoordinates equal to VK_TRUE is used to sample a VkImageView as a result of this command, then the image view’s viewType must be VK_IMAGE_VIEW_TYPE_1D or VK_IMAGE_VIEW_TYPE_2D VUID-vkCmdSubpassShadingHUAWEI-None-08610 If a VkSampler created with unnormalizedCoordinates equal to VK_TRUE is used to sample a VkImageView as a result of this command, then the sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name VUID-vkCmdSubpassShadingHUAWEI-None-08611 If a VkSampler created with unnormalizedCoordinates equal to VK_TRUE is used to sample a VkImageView as a result of this command, then the sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values VUID-vkCmdSubpassShadingHUAWEI-None-06479 If a VkImageView is sampled with depth comparison, the image view’s format features must contain VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT VUID-vkCmdSubpassShadingHUAWEI-None-02691 If a VkImageView is accessed using atomic operations as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT VUID-vkCmdSubpassShadingHUAWEI-None-07888 If a VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER descriptor is accessed using atomic operations as a result of this command, then the storage texel buffer’s format features must contain VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT VUID-vkCmdSubpassShadingHUAWEI-None-02692 If a VkImageView is sampled with VK_FILTER_CUBIC_EXT as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT VUID-vkCmdSubpassShadingHUAWEI-None-02693 If the VK_EXT_filter_cubic extension is not enabled and any VkImageView is sampled with VK_FILTER_CUBIC_EXT as a result of this command, it must not have a VkImageViewType of VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY VUID-vkCmdSubpassShadingHUAWEI-filterCubic-02694 Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic returned by vkGetPhysicalDeviceImageFormatProperties2 VUID-vkCmdSubpassShadingHUAWEI-filterCubicMinmax-02695 Any VkImageView being sampled with VK_FILTER_CUBIC_EXT with a reduction mode of either VK_SAMPLER_REDUCTION_MODE_MIN or VK_SAMPLER_REDUCTION_MODE_MAX as a result of this command must have a VkImageViewType and format that supports cubic filtering together with minmax filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax returned by vkGetPhysicalDeviceImageFormatProperties2 VUID-vkCmdSubpassShadingHUAWEI-cubicRangeClamp-09212 If the cubicRangeClamp feature is not enabled, then any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must not have a VkSamplerReductionModeCreateInfo::reductionMode equal to VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM VUID-vkCmdSubpassShadingHUAWEI-reductionMode-09213 Any VkImageView being sampled with a VkSamplerReductionModeCreateInfo::reductionMode equal to VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM as a result of this command must sample with VK_FILTER_CUBIC_EXT VUID-vkCmdSubpassShadingHUAWEI-selectableCubicWeights-09214 If the selectableCubicWeights feature is not enabled, then any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must have VkSamplerCubicWeightsCreateInfoQCOM::cubicWeights equal to VK_CUBIC_FILTER_WEIGHTS_CATMULL_ROM_QCOM VUID-vkCmdSubpassShadingHUAWEI-flags-02696 Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE VUID-vkCmdSubpassShadingHUAWEI-OpTypeImage-07027 For any VkImageView being written as a storage image where the image format field of the OpTypeImage is Unknown, the view’s format features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT VUID-vkCmdSubpassShadingHUAWEI-OpTypeImage-07028 For any VkImageView being read as a storage image where the image format field of the OpTypeImage is Unknown, the view’s format features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT VUID-vkCmdSubpassShadingHUAWEI-OpTypeImage-07029 For any VkBufferView being written as a storage texel buffer where the image format field of the OpTypeImage is Unknown, the view’s buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT VUID-vkCmdSubpassShadingHUAWEI-OpTypeImage-07030 Any VkBufferView being read as a storage texel buffer where the image format field of the OpTypeImage is Unknown then the view’s buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT VUID-vkCmdSubpassShadingHUAWEI-None-08600 For each set n that is statically used by a bound shader, a descriptor set must have been bound to n at the same pipeline bind point, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline or the VkDescriptorSetLayout array used to create the current VkShaderEXT , as described in Pipeline Layout Compatibility VUID-vkCmdSubpassShadingHUAWEI-None-08601 For each push constant that is statically used by a bound shader, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline or the VkDescriptorSetLayout array used to create the current VkShaderEXT , as described in Pipeline Layout Compatibility VUID-vkCmdSubpassShadingHUAWEI-None-10068 For each array of resources that is used by a bound shader, the indices used to access members of the array must be less than the descriptor count for the identified binding in the descriptor sets used by this command VUID-vkCmdSubpassShadingHUAWEI-maintenance4-08602 If the maintenance4 feature is not enabled, then for each push constant that is statically used by a bound shader, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline or the VkDescriptorSetLayout and VkPushConstantRange arrays used to create the current VkShaderEXT , as described in Pipeline Layout Compatibility VUID-vkCmdSubpassShadingHUAWEI-None-08114 Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid as described by descriptor validity if they are statically used by the VkPipeline bound to the pipeline bind point used by this command and the bound VkPipeline was not created with VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT VUID-vkCmdSubpassShadingHUAWEI-None-08115 If the descriptors used by the VkPipeline bound to the pipeline bind point were specified via vkCmdBindDescriptorSets, the bound VkPipeline must have been created without VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT VUID-vkCmdSubpassShadingHUAWEI-None-08116 Descriptors in bound descriptor buffers, specified via vkCmdSetDescriptorBufferOffsetsEXT, must be valid if they are dynamically used by the VkPipeline bound to the pipeline bind point used by this command and the bound VkPipeline was created with VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT VUID-vkCmdSubpassShadingHUAWEI-None-08604 Descriptors in bound descriptor buffers, specified via vkCmdSetDescriptorBufferOffsetsEXT, must be valid if they are dynamically used by any VkShaderEXT bound to a stage corresponding to the pipeline bind point used by this command VUID-vkCmdSubpassShadingHUAWEI-None-08117 If the descriptors used by the VkPipeline bound to the pipeline bind point were specified via vkCmdSetDescriptorBufferOffsetsEXT, the bound VkPipeline must have been created with VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT VUID-vkCmdSubpassShadingHUAWEI-None-08119 If a descriptor is dynamically used with a VkPipeline created with VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT, the descriptor memory must be resident VUID-vkCmdSubpassShadingHUAWEI-None-08605 If a descriptor is dynamically used with a VkShaderEXT created with a VkDescriptorSetLayout that was created with VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT, the descriptor memory must be resident VUID-vkCmdSubpassShadingHUAWEI-None-08606 If the shaderObject feature is not enabled, a valid pipeline must be bound to the pipeline bind point used by this command VUID-vkCmdSubpassShadingHUAWEI-None-08608 If a pipeline is bound to the pipeline bind point used by this command, there must not have been any calls to dynamic state setting commands for any state specified statically in the VkPipeline object bound to the pipeline bind point used by this command, since that pipeline was bound VUID-vkCmdSubpassShadingHUAWEI-uniformBuffers-06935 If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a uniform buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2 for uniformBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point VUID-vkCmdSubpassShadingHUAWEI-None-08612 If the robustBufferAccess feature is not enabled, and any VkShaderEXT bound to a stage corresponding to the pipeline bind point used by this command accesses a uniform buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point VUID-vkCmdSubpassShadingHUAWEI-storageBuffers-06936 If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a storage buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2 for storageBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point VUID-vkCmdSubpassShadingHUAWEI-None-08613 If the robustBufferAccess feature is not enabled, and any VkShaderEXT bound to a stage corresponding to the pipeline bind point used by this command accesses a storage buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point VUID-vkCmdSubpassShadingHUAWEI-commandBuffer-02707 If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, any resource accessed by bound shaders must not be a protected resource VUID-vkCmdSubpassShadingHUAWEI-viewType-07752 If a VkImageView is accessed as a result of this command, then the image view’s viewType must match the Dim operand of the OpTypeImage as described in Compatibility Between SPIR-V Image Dimensions and Vulkan ImageView Types VUID-vkCmdSubpassShadingHUAWEI-format-07753 If a VkImageView or VkBufferView is accessed as a result of this command, then the numeric type of the view’s format and the Sampled Type operand of the OpTypeImage must match VUID-vkCmdSubpassShadingHUAWEI-OpImageWrite-08795 If a VkImageView created with a format other than VK_FORMAT_A8_UNORM is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the image view’s format VUID-vkCmdSubpassShadingHUAWEI-OpImageWrite-08796 If a VkImageView created with the format VK_FORMAT_A8_UNORM is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have four components VUID-vkCmdSubpassShadingHUAWEI-OpImageWrite-04469 If a VkBufferView is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the buffer view’s format VUID-vkCmdSubpassShadingHUAWEI-SampledType-04470 If a VkImageView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64 VUID-vkCmdSubpassShadingHUAWEI-SampledType-04471 If a VkImageView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32 VUID-vkCmdSubpassShadingHUAWEI-SampledType-04472 If a VkBufferView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64 VUID-vkCmdSubpassShadingHUAWEI-SampledType-04473 If a VkBufferView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32 VUID-vkCmdSubpassShadingHUAWEI-sparseImageInt64Atomics-04474 If the sparseImageInt64Atomics feature is not enabled, VkImage objects created with the VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command VUID-vkCmdSubpassShadingHUAWEI-sparseImageInt64Atomics-04475 If the sparseImageInt64Atomics feature is not enabled, VkBuffer objects created with the VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command VUID-vkCmdSubpassShadingHUAWEI-OpImageWeightedSampleQCOM-06971 If OpImageWeightedSampleQCOM is used to sample a VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM VUID-vkCmdSubpassShadingHUAWEI-OpImageWeightedSampleQCOM-06972 If OpImageWeightedSampleQCOM uses a VkImageView as a sample weight image as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM VUID-vkCmdSubpassShadingHUAWEI-OpImageBoxFilterQCOM-06973 If OpImageBoxFilterQCOM is used to sample a VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM VUID-vkCmdSubpassShadingHUAWEI-OpImageBlockMatchSSDQCOM-06974 If OpImageBlockMatchSSDQCOM is used to read from an VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM VUID-vkCmdSubpassShadingHUAWEI-OpImageBlockMatchSADQCOM-06975 If OpImageBlockMatchSADQCOM is used to read from an VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM VUID-vkCmdSubpassShadingHUAWEI-OpImageBlockMatchSADQCOM-06976 If OpImageBlockMatchSADQCOM or OpImageBlockMatchSSDQCOM is used to read from a reference image as result of this command, then the specified reference coordinates must not fail integer texel coordinate validation VUID-vkCmdSubpassShadingHUAWEI-OpImageWeightedSampleQCOM-06977 If OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchWindowSSDQCOM, OpImageBlockMatchWindowSADQCOM, OpImageBlockMatchGatherSSDQCOM, OpImageBlockMatchGatherSADQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM VUID-vkCmdSubpassShadingHUAWEI-OpImageWeightedSampleQCOM-06978 If any command other than OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchWindowSSDQCOM, OpImageBlockMatchWindowSADQCOM, OpImageBlockMatchGatherSSDQCOM, OpImageBlockMatchGatherSADQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must not have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM VUID-vkCmdSubpassShadingHUAWEI-OpImageBlockMatchWindow-09215 If a OpImageBlockMatchWindow*QCOM or OpImageBlockMatchGather*QCOM instruction is used to read from an VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM VUID-vkCmdSubpassShadingHUAWEI-OpImageBlockMatchWindow-09216 If a OpImageBlockMatchWindow*QCOM or OpImageBlockMatchGather*QCOM instruction is used to read from an VkImageView as a result of this command, then the image view’s format must be a single-component format VUID-vkCmdSubpassShadingHUAWEI-OpImageBlockMatchWindow-09217 If a OpImageBlockMatchWindow*QCOM or OpImageBlockMatchGather*QCOM read from a reference image as result of this command, then the specified reference coordinates must not fail integer texel coordinate validation VUID-vkCmdSubpassShadingHUAWEI-None-07288 Any shader invocation executed by this command must terminate VUID-vkCmdSubpassShadingHUAWEI-None-09600 If a descriptor with type equal to any of VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM, VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, or VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT is accessed as a result of this command, all image subresources identified by that descriptor must be in the image layout identified when the descriptor was written VUID-vkCmdSubpassShadingHUAWEI-commandBuffer-10746 The VkDeviceMemory object allocated from a VkMemoryHeap with the VK_MEMORY_HEAP_TILE_MEMORY_BIT_QCOM property that is bound to a resource accessed as a result of this command must be the active bound bound tile memory object in commandBuffer VUID-vkCmdSubpassShadingHUAWEI-None-10678 If this command is recorded inside a tile shading render pass instance, the stages corresponding to the pipeline bind point used by this command must only include VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_FRAGMENT_BIT, and/or VK_SHADER_STAGE_COMPUTE_BIT VUID-vkCmdSubpassShadingHUAWEI-None-10679 If this command is recorded where per-tile execution model is enabled, there must be no access to any image while the image was be transitioned to the VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT layout VUID-vkCmdSubpassShadingHUAWEI-None-04931 This command must be called in a subpass with bind point VK_PIPELINE_BIND_POINT_SUBPASS_SHADING_HUAWEI. No draw commands can be called in the same subpass. Only one vkCmdSubpassShadingHUAWEI command can be called in a subpass Valid Usage (Implicit) VUID-vkCmdSubpassShadingHUAWEI-commandBuffer-parameter commandBuffer must be a valid VkCommandBuffer handle VUID-vkCmdSubpassShadingHUAWEI-commandBuffer-recording commandBuffer must be in the recording state VUID-vkCmdSubpassShadingHUAWEI-commandBuffer-cmdpool The VkCommandPool that commandBuffer was allocated from must support graphics operations VUID-vkCmdSubpassShadingHUAWEI-renderpass This command must only be called inside of a render pass instance VUID-vkCmdSubpassShadingHUAWEI-videocoding This command must only be called outside of a video coding scope Host Synchronization Host access to commandBuffer must be externally synchronized Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized Command Properties Command Buffer Levels Render Pass Scope Video Coding Scope Supported Queue Types Command Type Primary Secondary Inside Outside Graphics Action Compute kernels can be provided in SPIR-V or PTX code. When using PTX kernels the dispatch mechanism is different than with regular compute pipelines. The way to create a PTX assembly file is beyond the scope of this documentation. For mode information, please refer to the CUDA toolkit documentation at https://docs.nvidia.com/cuda/. Prior to using this command, you must initialize a CUDA module, and create a function handle that will serve as the entry point of the kernel to dispatch. See CUDA Modules. The dispatching of a CUDA kernel is recorded into a command buffer, and when executed by a queue submit, will produce work which executes according to the bound compute pipeline. To record a CUDA kernel launch, call: // Provided by VK_NV_cuda_kernel_launch void vkCmdCudaLaunchKernelNV( VkCommandBuffer commandBuffer, const VkCudaLaunchInfoNV* pLaunchInfo); commandBuffer is the command buffer into which the command will be recorded. pLaunchInfo is a pointer to a VkCudaLaunchInfoNV structure in which the grid (similar to workgroup) dimension, function handle and related arguments are defined. When the command is executed, a global workgroup consisting of gridDimX × gridDimY × gridDimZ local workgroups is assembled. Valid Usage (Implicit) VUID-vkCmdCudaLaunchKernelNV-commandBuffer-parameter commandBuffer must be a valid VkCommandBuffer handle VUID-vkCmdCudaLaunchKernelNV-pLaunchInfo-parameter pLaunchInfo must be a valid pointer to a valid VkCudaLaunchInfoNV structure VUID-vkCmdCudaLaunchKernelNV-commandBuffer-recording commandBuffer must be in the recording state VUID-vkCmdCudaLaunchKernelNV-commandBuffer-cmdpool The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations VUID-vkCmdCudaLaunchKernelNV-videocoding This command must only be called outside of a video coding scope Host Synchronization Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized Command Properties Command Buffer Levels Render Pass Scope Video Coding Scope Supported Queue Types Command Type Primary Secondary Both Outside Graphics Compute Action The VkCudaLaunchInfoNV structure is very close to the parameters of the CUDA-Driver function cuLaunchKernel documented in section 6.19 Execution Control of CUDA Driver API. The structure is defined as: // Provided by VK_NV_cuda_kernel_launch typedef struct VkCudaLaunchInfoNV { VkStructureType sType; const void* pNext; VkCudaFunctionNV function; uint32_t gridDimX; uint32_t gridDimY; uint32_t gridDimZ; uint32_t blockDimX; uint32_t blockDimY; uint32_t blockDimZ; uint32_t sharedMemBytes; size_t paramCount; const void* const * pParams; size_t extraCount; const void* const * pExtras; } VkCudaLaunchInfoNV; sType is a VkStructureType value identifying this structure. pNext is NULL or a pointer to a structure extending this structure. function is the CUDA-Driver handle to the function being launched. gridDimX is the number of local workgroups to dispatch in the X dimension. It must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[0] gridDimY is the number of local workgroups to dispatch in the Y dimension. It must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[1] gridDimZ is the number of local workgroups to dispatch in the Z dimension. It must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[2] blockDimX is block size in the X dimension. blockDimY is block size in the Y dimension. blockDimZ is block size in the Z dimension. sharedMemBytes is the dynamic shared-memory size per thread block in bytes. paramCount is the length of the pParams table. pParams is a pointer to an array of paramCount pointers, corresponding to the arguments of function. extraCount is reserved for future use. pExtras is reserved for future use. Kernel parameters of function are specified via pParams, very much the same way as described in cuLaunchKernel If function has N parameters, then pParams must be an array of N pointers and paramCount must be N. Each of kernelParams[0] through kernelParams[N-1] must point to a region of memory from which the actual kernel parameter will be copied. The number of kernel parameters and their offsets and sizes are not specified here as that information is stored in the VkCudaFunctionNV object. The application-owned memory pointed to by pParams and kernelParams[0] through kernelParams[N-1] are consumed immediately, and may be altered or freed after vkCmdCudaLaunchKernelNV has returned. Valid Usage VUID-VkCudaLaunchInfoNV-gridDimX-09406 gridDimX must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[0] VUID-VkCudaLaunchInfoNV-gridDimY-09407 gridDimY must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[1] VUID-VkCudaLaunchInfoNV-gridDimZ-09408 gridDimZ must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[2] VUID-VkCudaLaunchInfoNV-paramCount-09409 paramCount must be the total amount of parameters listed in the pParams table VUID-VkCudaLaunchInfoNV-pParams-09410 pParams must be a pointer to a table of paramCount parameters, corresponding to the arguments of function VUID-VkCudaLaunchInfoNV-extraCount-09411 extraCount must be 0 VUID-VkCudaLaunchInfoNV-pExtras-09412 pExtras must be NULL Valid Usage (Implicit) VUID-VkCudaLaunchInfoNV-sType-sType sType must be VK_STRUCTURE_TYPE_CUDA_LAUNCH_INFO_NV VUID-VkCudaLaunchInfoNV-pNext-pNext pNext must be NULL VUID-VkCudaLaunchInfoNV-function-parameter function must be a valid VkCudaFunctionNV handle Given that one key limitation of this extension is that Vulkan cannot access, nor bind any global resource of CUDA modules, the only way to exchange data with the kernel must be to pass resources via the arguments of the function. You can use VK_KHR_buffer_device_address to write/read to/from a VkBuffer object. VK_KHR_buffer_device_address allows you to get the device address of the buffer to pass it as an argument into pParams. Application-side pointer arithmetic on the device address is legal, but will not be bounds-checked on the device. The corresponding argument of the CUDA function should be declared as a pointer of the same type as the referenced buffer. CUDA code may simply read or write to this buffer in the typical C way. You may also use VK_NVX_image_view_handle as another convenient way to read/write from/to a VkImage. The corresponding argument of the CUDA function must be typed as cudaSurfaceObject_t. You may read from it by using CUDA surface-read functions such as surf3Dread, surf2Dread, and surf1Dread You may write to it by using CUDA surface-write functions such as surf3Dwrite, surf2Dwrite, and surf1Dwrite Please refer to CUDA surface object documentation for more details On Vulkan side, here is an example on how to setup VkImageViewHandleInfoNVX to query the handle for cudaSurfaceObject_t: VkImageViewHandleInfoNVX imageViewHandleInfo = {VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX}; imageViewHandleInfo.sampler = VK_NULL_HANDLE; imageViewHandleInfo.descriptorType = VK_DESCRIPTOR_TYPE_STORAGE_IMAGE; imageViewHandleInfo.imageView = imageViewIn; // the VkImageView we want to access uint32_t myViewHandleIn = vkGetImageViewHandleNVX(m_device, &imageViewHandleInfo); imageViewHandleInfo.imageView = imageViewOut; // the VkImageView we want to access uint32_t myViewHandleOut = vkGetImageViewHandleNVX(m_device, &imageViewHandleInfo); Here is an example of how to declare parameters for pParams VkCudaLaunchInfoNV launchInfo = { VK_STRUCTURE_TYPE_CUDA_LAUNCH_INFO_NV }; int block_size = 8; float dt = 1.0f / 60.0f; const void* params[] = { &dt, &uint32_t myViewHandleIn, &uint32_t myViewHandleOut }; launchInfo.function = cudaFunction; // CUDA function previously created launchInfo.gridDimX = (volumeTexDimensionNonBoundary / block_size); launchInfo.gridDimY = (volumeTexDimensionNonBoundary / block_size); launchInfo.gridDimZ = (volumeTexDimensionNonBoundary / block_size); launchInfo.blockDimX = block_size; launchInfo.blockDimY = block_size; launchInfo.blockDimZ = block_size; launchInfo.sharedMemBytes = 0; launchInfo.paramCount = 3; launchInfo.pParams = ¶ms[0]; launchInfo.extraCount = 0; launchInfo.pExtras = nullptr; vkCmdCudaLaunchKernelNV(commandBuffer, &launchInfo); In the CUDA kernel source code, here is an example on how arguments match pParams and how we can use Surface object: extern "C" __global__ void cudaFunction( float dt, cudaSurfaceObject_t volumeTexIn, cudaSurfaceObject_t volumeTexOut ) { int i = 1 + blockIdx.x * blockDim.x + threadIdx.x; int j = 1 + blockIdx.y * blockDim.y + threadIdx.y; int k = 1 + blockIdx.z * blockDim.z + threadIdx.z; float val; surf3Dread(&val, volumeTexIn, i * sizeof(float), j, k); ... float result = ...; // write result surf3Dwrite(result, volumeTexOut, i * sizeof(float), j, k); }

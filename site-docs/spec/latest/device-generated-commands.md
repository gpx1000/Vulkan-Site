# Device-Generated Commands

## Metadata

- **Component**: spec
- **Version**: latest
- **URL**: /spec/latest/chapters/device_generated_commands/generatedcommands.html

## Table of Contents

- [Indirect Commands Layout](#indirectmdslayout)
- [Indirect_Commands_Layout](#indirectmdslayout)
- [Creation and Deletion](#_creation_and_deletion)
- [Creation_and_Deletion](#_creation_and_deletion)
- [Token Input Streams](#_token_input_streams)
- [Token_Input_Streams](#_token_input_streams)
- [Tokenized Command Processing](#_tokenized_command_processing)
- [Tokenized_Command_Processing](#_tokenized_command_processing)
- [Indirect Commands Generation and Execution](#_indirect_commands_generation_and_execution)
- [Indirect_Commands_Generation_and_Execution](#_indirect_commands_generation_and_execution)
- [Indirect Execution Sets](#device-generated-indirect-execution-sets)
- [Indirect_Execution_Sets](#device-generated-indirect-execution-sets)

## Content

This chapter discusses the generation of command buffer content on the device, for which these principle steps are to be taken: Define a layout describing the sequence of commands which should be generated. Optionally set up device-bindable shaders. Retrieve device addresses by vkGetBufferDeviceAddressEXT for setting buffers on the device. Fill one or more VkBuffer with the appropriate content that gets interpreted by the command layout. Create a preprocess VkBuffer using the device-queried allocation information. Optionally preprocess the input data in a separate action. Generate and execute the actual commands. The preprocessing step executes in a separate logical pipeline from either graphics or compute. When preprocessing commands in a separate step they must be explicitly synchronized against the command execution. When not preprocessing in a separate step, the preprocessing is automatically synchronized against the command execution. The device-side command generation happens through an iterative processing of an atomic sequence comprised of command tokens, which are represented by: // Provided by VK_EXT_device_generated_commands VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkIndirectCommandsLayoutEXT) or: // Provided by VK_NV_device_generated_commands VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkIndirectCommandsLayoutNV) Each indirect command layout must have exactly one action command token and it must be the last token in the sequence. If the indirect commands layout contains only 1 token, it will be an action command token, and the contents of the indirect buffer will be a sequence of indirect command structures, similar to the ones used for indirect draws and dispatches. On some implementations, using indirect draws and dispatches for these cases will result in increased performance compared to using device-generated commands, due to the overhead that results from using the latter. Indirect command layouts for VK_EXT_device_generated_commands are created by: // Provided by VK_EXT_device_generated_commands VkResult vkCreateIndirectCommandsLayoutEXT( VkDevice device, const VkIndirectCommandsLayoutCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkIndirectCommandsLayoutEXT* pIndirectCommandsLayout); device is the logical device that creates the indirect command layout. pCreateInfo is a pointer to a VkIndirectCommandsLayoutCreateInfoEXT structure containing parameters affecting creation of the indirect command layout. pAllocator controls host memory allocation as described in the Memory Allocation chapter. pIndirectCommandsLayout is a pointer to a VkIndirectCommandsLayoutEXT handle in which the resulting indirect command layout is returned. Valid Usage VUID-vkCreateIndirectCommandsLayoutEXT-deviceGeneratedCommands-11089 The VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT::deviceGeneratedCommands feature must be enabled Valid Usage (Implicit) VUID-vkCreateIndirectCommandsLayoutEXT-device-parameter device must be a valid VkDevice handle VUID-vkCreateIndirectCommandsLayoutEXT-pCreateInfo-parameter pCreateInfo must be a valid pointer to a valid VkIndirectCommandsLayoutCreateInfoEXT structure VUID-vkCreateIndirectCommandsLayoutEXT-pAllocator-parameter If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure VUID-vkCreateIndirectCommandsLayoutEXT-pIndirectCommandsLayout-parameter pIndirectCommandsLayout must be a valid pointer to a VkIndirectCommandsLayoutEXT handle Return Codes Success VK_SUCCESS Failure VK_ERROR_OUT_OF_HOST_MEMORY VK_ERROR_OUT_OF_DEVICE_MEMORY The VkIndirectCommandsLayoutCreateInfoEXT structure is defined as: // Provided by VK_EXT_device_generated_commands typedef struct VkIndirectCommandsLayoutCreateInfoEXT { VkStructureType sType; const void* pNext; VkIndirectCommandsLayoutUsageFlagsEXT flags; VkShaderStageFlags shaderStages; uint32_t indirectStride; VkPipelineLayout pipelineLayout; uint32_t tokenCount; const VkIndirectCommandsLayoutTokenEXT* pTokens; } VkIndirectCommandsLayoutCreateInfoEXT; sType is a VkStructureType value identifying this structure. pNext is NULL or a pointer to a structure extending this structure. flags is a bitmask of VkIndirectCommandsLayoutUsageFlagBitsEXT specifying usage rules for this layout. shaderStages is the VkShaderStageFlags that this layout supports. indirectStride is the distance in bytes between sequences in the indirect buffer pipelineLayout is the optional VkPipelineLayout that tokens in this layout use. If the dynamicGeneratedPipelineLayout feature is enabled, pipelineLayout can be VK_NULL_HANDLE and the layout must be specified by chaining the VkPipelineLayoutCreateInfo structure off the pNext tokenCount is the length of the individual command sequence. pTokens is a pointer to an array of VkIndirectCommandsLayoutTokenEXT describing each command token in detail. The following code illustrates some of the flags: void cmdProcessAllSequences(cmd, indirectExecutionSet, indirectCommandsLayout, indirectAddress, sequencesCount) { for (s = 0; s offset; uint32_t stride = indirectCommandsLayout.indirectStride; VkDeviceAddress streamData = indirectAddress; const void* input = streamData + stride * s + offset; switch (token->tokenType) { case VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXECUTION_SET_EXT: uint32_t *bind = input; VkIndirectCommandsExecutionSetTokenEXT *info = token->data.pExecutionSet; if (info->type == VK_INDIRECT_EXECUTION_SET_INFO_TYPE_PIPELINES_EXT) { vkCmdBindPipeline(cmd, indirectExecutionSet.pipelineBindPoint, indirectExecutionSet.pipelines[*bind]); } else { VkShaderStageFlagBits stages[]; VkShaderEXT shaders[]; uint32_t i = 0; IterateBitmaskLSBToMSB(iter, info->shaderStages) { stages[i] = iter; shaders[i] = indirectExecutionSet.shaders[bind[i]].shaderObject; i++; } vkCmdBindShadersEXT(cmd, i, stages, shaders); } break; case VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_EXT: uint32_t* data = input; VkPushConstantsInfoKHR info = { VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO_KHR, // this can also use `dynamicGeneratedPipelineLayout' to pass a VkPipelineLayoutCreateInfo from pNext indirectCommandsLayout.pipelineLayout, token->token.pushConstant.updateRange.shaderStages, token->token.pushConstant.updateRange.offset, token->token.pushConstant.updateRange.size, data }; vkCmdPushConstants2KHR(cmd, &info); break; case VK_INDIRECT_COMMANDS_TOKEN_TYPE_SEQUENCE_INDEX_EXT: VkPushConstantsInfoKHR info = { VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO_KHR, // this can also use `dynamicGeneratedPipelineLayout' to pass a VkPipelineLayoutCreateInfo from pNext indirectCommandsLayout.pipelineLayout, token->token.pushConstant.updateRange.shaderStages, token->token.pushConstant.updateRange.offset, // this must be 4 token->token.pushConstant.updateRange.size, // this just updates the sequence index &s }; vkCmdPushConstants2KHR(cmd, &info); break; case VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_EXT: VkBindIndexBufferIndirectCommandEXT* data = input; vkCmdBindIndexBuffer(cmd, deriveBuffer(data->bufferAddress), deriveOffset(data->bufferAddress), data->indexType); break; case VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_EXT: VkBindVertexBufferIndirectCommandEXT* data = input; vkCmdBindVertexBuffers2(cmd, token->token.vertexBuffer->vertexBindingUnit, 1, &deriveBuffer(data->bufferAddress), &deriveOffset(data->bufferAddress), data->size, data->stride); break; case VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_EXT: VkDrawIndexedIndirectCommand *data = input; vkCmdDrawIndexed(cmd, data->indexCount, data->instanceCount, data->firstIndex, data->vertexOffset, data->firstInstance); break; case VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_COUNT_EXT: VkDrawIndirectCountIndirectCommandEXT* data = input; vkCmdDrawIndexedIndirect(cmd, deriveBuffer(data->bufferAddress), deriveoffset(data->bufferAddress), min(data->commandCount, indirectCommandsLayout.maxDrawCount), data->stride); break; case VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_EXT: VkDrawIndirectCommand* data = input; vkCmdDraw(cmd, data->vertex_count, data->instanceCount, data->firstVertex, data->firstIndex); break; case VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_COUNT_EXT: VkDrawIndirectCountIndirectCommandEXT* data = input; vkCmdDrawIndirect(cmd, deriveBuffer(data->bufferAddress), deriveoffset(data->bufferAddress), min(data->commandCount, indirectCommandsLayout.maxDrawCount), data->stride); break; // only available if VK_NV_mesh_shader is enabled case VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV_EXT: VkDrawMeshTasksIndirectCommandNV *data = input; vkCmdDrawMeshTasksNV(cmd, data->taskCount, data->firstTask); break; // only available if VK_NV_mesh_shader is enabled case VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_COUNT_NV_EXT: VkDrawIndirectCountIndirectCommandEXT* data = input; vkCmdDrawMeshTasksIndirectCountNV(cmd, deriveBuffer(data->bufferAddress), deriveoffset(data->bufferAddress), min(data->commandCount, indirectCommandsLayout.maxDrawCount), data->stride); break; // only available if VK_EXT_mesh_shader is enabled case VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_EXT: VkDrawMeshTasksIndirectCommandEXT *data = input; vkCmdDrawMeshTasksEXT(cmd, data->groupCountX, data->groupCountY, data->groupCountZ); break; // only available if VK_EXT_mesh_shader is enabled case VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_COUNT_EXT: VkDrawIndirectCountIndirectCommandEXT* data = input; vkCmdDrawMeshTasksIndirectCountEXT(cmd, deriveBuffer(data->bufferAddress), deriveoffset(data->bufferAddress), min(data->commandCount, indirectCommandsLayout.maxDrawCount), data->stride); break; case VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_EXT: VkDispatchIndirectCommand *data = input; vkCmdDispatch(cmd, data->x, data->y, data->z); break; // only available if VK_KHR_ray_tracing_maintenance1 is enabled case VK_INDIRECT_COMMANDS_TOKEN_TYPE_TRACE_RAYS2_EXT: vkCmdTraceRaysIndirect2KHR(cmd, deriveBuffer(input)); break; } } } The processing for VK_NV_device_generated_commands is in principle illustrated below: void cmdProcessSequence(cmd, pipeline, indirectCommandsLayout, pIndirectCommandsStreams, s) { for (t = 0; t groupIndex); break; case VK_INDIRECT_COMMANDS_TOKEN_TYPE_STATE_FLAGS_NV: VkSetStateFlagsIndirectCommandNV* state = input; if (token.indirectStateFlags & VK_INDIRECT_STATE_FLAG_FRONTFACE_BIT_NV){ if (state.data & (1 bufferAddress), deriveOffset(data->bufferAddress), data->indexType); break; case VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NV: VkBindVertexBufferIndirectCommandNV* data = input; // if token.vertexDynamicStride is VK_TRUE // then the stride for this binding is set // using data->stride as well vkCmdBindVertexBuffers(cmd, token.vertexBindingUnit, 1, &deriveBuffer(data->bufferAddress), &deriveOffset(data->bufferAddress)); break; case VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NV: vkCmdDrawIndexedIndirect(cmd, stream.buffer, offset, 1, 0); break; case VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NV: vkCmdDrawIndirect(cmd, stream.buffer, offset, 1, 0); break; // only available if VK_NV_mesh_shader is supported case VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_TASKS_NV: vkCmdDrawMeshTasksIndirectNV(cmd, stream.buffer, offset, 1, 0); break; // only available if VK_EXT_mesh_shader is supported case VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV: vkCmdDrawMeshTasksIndirectEXT(cmd, stream.buffer, offset, 1, 0); break; case VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NV: VkBindPipelineIndirectCommandNV *data = input; VkPipeline computePipeline = deriveFromDeviceAddress(data->pipelineAddress); vkCmdBindPipeline(cmd, VK_PIPELINE_BIND_POINT_COMPUTE, computePipeline); break; case VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NV: vkCmdDispatchIndirect(cmd, stream.buffer, offset); break; } } } The generation of commands on the device requires a preprocess buffer. With VK_EXT_device_generated_commands, to retrieve the memory size and alignment requirements of a particular execution state call: // Provided by VK_EXT_device_generated_commands void vkGetGeneratedCommandsMemoryRequirementsEXT( VkDevice device, const VkGeneratedCommandsMemoryRequirementsInfoEXT* pInfo, VkMemoryRequirements2* pMemoryRequirements); device is the logical device that owns the buffer. pInfo is a pointer to a VkGeneratedCommandsMemoryRequirementsInfoEXT structure containing parameters required for the memory requirements query. pMemoryRequirements is a pointer to a VkMemoryRequirements2 structure in which the memory requirements of the buffer object are returned. If the size returned is zero, the preprocessing step can be skipped for this layout. Valid Usage (Implicit) VUID-vkGetGeneratedCommandsMemoryRequirementsEXT-device-parameter device must be a valid VkDevice handle VUID-vkGetGeneratedCommandsMemoryRequirementsEXT-pInfo-parameter pInfo must be a valid pointer to a valid VkGeneratedCommandsMemoryRequirementsInfoEXT structure VUID-vkGetGeneratedCommandsMemoryRequirementsEXT-pMemoryRequirements-parameter pMemoryRequirements must be a valid pointer to a VkMemoryRequirements2 structure // Provided by VK_EXT_device_generated_commands typedef struct VkGeneratedCommandsMemoryRequirementsInfoEXT { VkStructureType sType; const void* pNext; VkIndirectExecutionSetEXT indirectExecutionSet; VkIndirectCommandsLayoutEXT indirectCommandsLayout; uint32_t maxSequenceCount; uint32_t maxDrawCount; } VkGeneratedCommandsMemoryRequirementsInfoEXT; sType is a VkStructureType value identifying this structure. pNext is NULL or a pointer to a structure extending this structure. indirectExecutionSet is the indirect execution set to be used for binding shaders. indirectCommandsLayout is the VkIndirectCommandsLayoutEXT that this buffer memory is intended to be used with. maxSequenceCount is the maximum number of sequences that this buffer memory can be used with. maxDrawCount is the maximum number of indirect draws that can be executed by any COUNT-type multi-draw indirect tokens. The draw count in the indirect buffer is clamped to this value for these token types. If the action command token for the layout is not a COUNT-type multi-draw indirect token, maxDrawCount is ignored. Valid Usage VUID-VkGeneratedCommandsMemoryRequirementsInfoEXT-maxSequencesCount-11009 maxSequencesCount must be less or equal to VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT::maxIndirectSequenceCount VUID-VkGeneratedCommandsMemoryRequirementsInfoEXT-indirectCommandsLayout-11010 If indirectCommandsLayout was created with a token sequence that contained the VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXECUTION_SET_EXT token, indirectExecutionSet must not be VK_NULL_HANDLE VUID-VkGeneratedCommandsMemoryRequirementsInfoEXT-indirectCommandsLayout-11151 If indirectCommandsLayout was created with a token sequence that contained the VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXECUTION_SET_EXT token, the shader stages used to create the initial shader state of indirectExecutionSet must equal the VkIndirectCommandsExecutionSetTokenEXT::shaderStages used to create indirectCommandsLayout VUID-VkGeneratedCommandsMemoryRequirementsInfoEXT-indirectCommandsLayout-11011 If indirectCommandsLayout was not created with a token sequence that contained the VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXECUTION_SET_EXT token, indirectExecutionSet must be VK_NULL_HANDLE VUID-VkGeneratedCommandsMemoryRequirementsInfoEXT-maxDrawCount-11146 When not ignored, maxDrawCount × maxSequenceCount must be less than 2^24 VUID-VkGeneratedCommandsMemoryRequirementsInfoEXT-indirectExecutionSet-11012 If indirectExecutionSet is VK_NULL_HANDLE, either a VkGeneratedCommandsPipelineInfoEXT or a VkGeneratedCommandsShaderInfoEXT must be included in the pNext chain Valid Usage (Implicit) VUID-VkGeneratedCommandsMemoryRequirementsInfoEXT-sType-sType sType must be VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_EXT VUID-VkGeneratedCommandsMemoryRequirementsInfoEXT-pNext-pNext Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkGeneratedCommandsPipelineInfoEXT or VkGeneratedCommandsShaderInfoEXT VUID-VkGeneratedCommandsMemoryRequirementsInfoEXT-sType-unique The sType value of each structure in the pNext chain must be unique VUID-VkGeneratedCommandsMemoryRequirementsInfoEXT-indirectExecutionSet-parameter If indirectExecutionSet is not VK_NULL_HANDLE, indirectExecutionSet must be a valid VkIndirectExecutionSetEXT handle VUID-VkGeneratedCommandsMemoryRequirementsInfoEXT-indirectCommandsLayout-parameter indirectCommandsLayout must be a valid VkIndirectCommandsLayoutEXT handle VUID-VkGeneratedCommandsMemoryRequirementsInfoEXT-commonparent Both of indirectCommandsLayout, and indirectExecutionSet that are valid handles of non-ignored parameters must have been created, allocated, or retrieved from the same VkDevice // Provided by VK_EXT_device_generated_commands typedef struct VkGeneratedCommandsPipelineInfoEXT { VkStructureType sType; void* pNext; VkPipeline pipeline; } VkGeneratedCommandsPipelineInfoEXT; sType is a VkStructureType value identifying this structure. pNext is NULL or a pointer to a structure extending this structure. pipeline is a valid pipeline object. Valid Usage (Implicit) VUID-VkGeneratedCommandsPipelineInfoEXT-sType-sType sType must be VK_STRUCTURE_TYPE_GENERATED_COMMANDS_PIPELINE_INFO_EXT VUID-VkGeneratedCommandsPipelineInfoEXT-pipeline-parameter pipeline must be a valid VkPipeline handle // Provided by VK_EXT_device_generated_commands typedef struct VkGeneratedCommandsShaderInfoEXT { VkStructureType sType; void* pNext; uint32_t shaderCount; const VkShaderEXT* pShaders; } VkGeneratedCommandsShaderInfoEXT; sType is a VkStructureType value identifying this structure. pNext is NULL or a pointer to a structure extending this structure. shaderCount is the size of the pShaders array. pShaders is a pointer to an array of shader objects. Valid Usage VUID-VkGeneratedCommandsShaderInfoEXT-pShaders-11127 pShaders must not contain more than one shader object for a given VkShaderStageFlagBits stage Valid Usage (Implicit) VUID-VkGeneratedCommandsShaderInfoEXT-sType-sType sType must be VK_STRUCTURE_TYPE_GENERATED_COMMANDS_SHADER_INFO_EXT VUID-VkGeneratedCommandsShaderInfoEXT-pShaders-parameter pShaders must be a valid pointer to an array of shaderCount valid VkShaderEXT handles VUID-VkGeneratedCommandsShaderInfoEXT-shaderCount-arraylength shaderCount must be greater than 0 With VK_NV_device_generated_commands, to retrieve the memory size and alignment requirements of a particular execution state call: // Provided by VK_NV_device_generated_commands void vkGetGeneratedCommandsMemoryRequirementsNV( VkDevice device, const VkGeneratedCommandsMemoryRequirementsInfoNV* pInfo, VkMemoryRequirements2* pMemoryRequirements); device is the logical device that owns the buffer. pInfo is a pointer to a VkGeneratedCommandsMemoryRequirementsInfoNV structure containing parameters required for the memory requirements query. pMemoryRequirements is a pointer to a VkMemoryRequirements2 structure in which the memory requirements of the buffer object are returned. Valid Usage VUID-vkGetGeneratedCommandsMemoryRequirementsNV-deviceGeneratedCommands-02906 The VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV::deviceGeneratedCommands feature must be enabled VUID-vkGetGeneratedCommandsMemoryRequirementsNV-pInfo-09074 If pInfo->pipelineBindPoint is of type VK_PIPELINE_BIND_POINT_COMPUTE, then the VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV::deviceGeneratedCompute feature must be enabled Valid Usage (Implicit) VUID-vkGetGeneratedCommandsMemoryRequirementsNV-device-parameter device must be a valid VkDevice handle VUID-vkGetGeneratedCommandsMemoryRequirementsNV-pInfo-parameter pInfo must be a valid pointer to a valid VkGeneratedCommandsMemoryRequirementsInfoNV structure VUID-vkGetGeneratedCommandsMemoryRequirementsNV-pMemoryRequirements-parameter pMemoryRequirements must be a valid pointer to a VkMemoryRequirements2 structure // Provided by VK_NV_device_generated_commands typedef struct VkGeneratedCommandsMemoryRequirementsInfoNV { VkStructureType sType; const void* pNext; VkPipelineBindPoint pipelineBindPoint; VkPipeline pipeline; VkIndirectCommandsLayoutNV indirectCommandsLayout; uint32_t maxSequencesCount; } VkGeneratedCommandsMemoryRequirementsInfoNV; sType is a VkStructureType value identifying this structure. pNext is NULL or a pointer to a structure extending this structure. pipelineBindPoint is the VkPipelineBindPoint of the pipeline that this buffer memory is intended to be used with during the execution. pipeline is the VkPipeline that this buffer memory is intended to be used with during the execution. indirectCommandsLayout is the VkIndirectCommandsLayoutNV that this buffer memory is intended to be used with. maxSequencesCount is the maximum number of sequences that this buffer memory in combination with the other state provided can be used with. Valid Usage VUID-VkGeneratedCommandsMemoryRequirementsInfoNV-maxSequencesCount-02907 maxSequencesCount must be less or equal to VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV::maxIndirectSequenceCount VUID-VkGeneratedCommandsMemoryRequirementsInfoNV-pipelineBindPoint-09075 If pipelineBindPoint is of type VK_PIPELINE_BIND_POINT_GRAPHICS, then pipeline must be a valid VkPipeline handle VUID-VkGeneratedCommandsMemoryRequirementsInfoNV-pipelineBindPoint-09076 If pipelineBindPoint is of type VK_PIPELINE_BIND_POINT_COMPUTE, and the indirectCommandsLayout was not created with a VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NV token, then the pipeline must be a valid VkPipeline handle VUID-VkGeneratedCommandsMemoryRequirementsInfoNV-pipelineBindPoint-09077 If pipelineBindPoint is of type VK_PIPELINE_BIND_POINT_COMPUTE, and the indirectCommandsLayout contains a VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NV token, then the pipeline must be VK_NULL_HANDLE Valid Usage (Implicit) VUID-VkGeneratedCommandsMemoryRequirementsInfoNV-sType-sType sType must be VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV VUID-VkGeneratedCommandsMemoryRequirementsInfoNV-pNext-pNext pNext must be NULL VUID-VkGeneratedCommandsMemoryRequirementsInfoNV-pipelineBindPoint-parameter pipelineBindPoint must be a valid VkPipelineBindPoint value VUID-VkGeneratedCommandsMemoryRequirementsInfoNV-pipeline-parameter If pipeline is not VK_NULL_HANDLE, pipeline must be a valid VkPipeline handle VUID-VkGeneratedCommandsMemoryRequirementsInfoNV-indirectCommandsLayout-parameter indirectCommandsLayout must be a valid VkIndirectCommandsLayoutNV handle VUID-VkGeneratedCommandsMemoryRequirementsInfoNV-commonparent Both of indirectCommandsLayout, and pipeline that are valid handles of non-ignored parameters must have been created, allocated, or retrieved from the same VkDevice With VK_NV_device_generated_commands, to bind a compute pipeline in Device-Generated Commands, an application must query the pipeline’s device address. To query a compute pipeline’s 64-bit device address, call: // Provided by VK_NV_device_generated_commands_compute VkDeviceAddress vkGetPipelineIndirectDeviceAddressNV( VkDevice device, const VkPipelineIndirectDeviceAddressInfoNV* pInfo); device is the logical device on which the pipeline was created. pInfo is a pointer to a VkPipelineIndirectDeviceAddressInfoNV structure specifying the pipeline to retrieve the address for. Valid Usage VUID-vkGetPipelineIndirectDeviceAddressNV-deviceGeneratedComputePipelines-09078 The VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV::deviceGeneratedComputePipelines feature must be enabled Valid Usage (Implicit) VUID-vkGetPipelineIndirectDeviceAddressNV-device-parameter device must be a valid VkDevice handle VUID-vkGetPipelineIndirectDeviceAddressNV-pInfo-parameter pInfo must be a valid pointer to a valid VkPipelineIndirectDeviceAddressInfoNV structure The VkPipelineIndirectDeviceAddressInfoNV structure is defined as: // Provided by VK_NV_device_generated_commands_compute typedef struct VkPipelineIndirectDeviceAddressInfoNV { VkStructureType sType; const void* pNext; VkPipelineBindPoint pipelineBindPoint; VkPipeline pipeline; } VkPipelineIndirectDeviceAddressInfoNV; sType is a VkStructureType value identifying this structure. pNext is NULL or a pointer to a structure extending this structure. pipelineBindPoint is a VkPipelineBindPoint value specifying the type of pipeline whose device address is being queried. pipeline specifies the pipeline whose device address is being queried. Valid Usage VUID-VkPipelineIndirectDeviceAddressInfoNV-pipelineBindPoint-09079 The provided pipelineBindPoint must be of type VK_PIPELINE_BIND_POINT_COMPUTE VUID-VkPipelineIndirectDeviceAddressInfoNV-pipeline-09080 pipeline must have been created with flag VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV set VUID-VkPipelineIndirectDeviceAddressInfoNV-pipeline-09081 pipeline must have been created with a VkComputePipelineIndirectBufferInfoNV structure specifying a valid address where its metadata will be saved Valid Usage (Implicit) VUID-VkPipelineIndirectDeviceAddressInfoNV-sType-sType sType must be VK_STRUCTURE_TYPE_PIPELINE_INDIRECT_DEVICE_ADDRESS_INFO_NV VUID-VkPipelineIndirectDeviceAddressInfoNV-pNext-pNext pNext must be NULL VUID-VkPipelineIndirectDeviceAddressInfoNV-pipelineBindPoint-parameter pipelineBindPoint must be a valid VkPipelineBindPoint value VUID-VkPipelineIndirectDeviceAddressInfoNV-pipeline-parameter pipeline must be a valid VkPipeline handle To determine the memory requirements for a compute pipeline’s metadata, call: // Provided by VK_NV_device_generated_commands_compute void vkGetPipelineIndirectMemoryRequirementsNV( VkDevice device, const VkComputePipelineCreateInfo* pCreateInfo, VkMemoryRequirements2* pMemoryRequirements); device is the logical device that owns the buffer. pCreateInfo is a VkComputePipelineCreateInfo structure specifying the creation parameters of the compute pipeline whose memory requirements are being queried. pMemoryRequirements is a pointer to a VkMemoryRequirements2 structure in which the requested pipeline’s memory requirements are returned. If pCreateInfo->pNext chain includes a pointer to a VkComputePipelineIndirectBufferInfoNV structure, then the contents of that structure are ignored. Valid Usage VUID-vkGetPipelineIndirectMemoryRequirementsNV-deviceGeneratedComputePipelines-09082 The VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV::deviceGeneratedComputePipelines feature must be enabled VUID-vkGetPipelineIndirectMemoryRequirementsNV-pCreateInfo-09083 pCreateInfo->flags must include VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV Valid Usage (Implicit) VUID-vkGetPipelineIndirectMemoryRequirementsNV-device-parameter device must be a valid VkDevice handle VUID-vkGetPipelineIndirectMemoryRequirementsNV-pCreateInfo-parameter pCreateInfo must be a valid pointer to a valid VkComputePipelineCreateInfo structure VUID-vkGetPipelineIndirectMemoryRequirementsNV-pMemoryRequirements-parameter pMemoryRequirements must be a valid pointer to a VkMemoryRequirements2 structure Indirect Execution Sets contain sets of pipelines or shader objects which can be bound individually. // Provided by VK_EXT_device_generated_commands VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkIndirectExecutionSetEXT) Indirect Execution Sets allow the device to bind different shaders and pipeline states using Device-Generated Commands. Indirect Execution Sets are created by calling: // Provided by VK_EXT_device_generated_commands VkResult vkCreateIndirectExecutionSetEXT( VkDevice device, const VkIndirectExecutionSetCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkIndirectExecutionSetEXT* pIndirectExecutionSet); device is the logical device that creates the indirect execution set. pCreateInfo is a pointer to a VkIndirectExecutionSetCreateInfoEXT structure containing parameters affecting creation of the indirect execution set. pAllocator controls host memory allocation as described in the Memory Allocation chapter. pIndirectExecutionSet is a pointer to a VkIndirectExecutionSetEXT handle in which the resulting indirect execution set is returned. Valid Usage VUID-vkCreateIndirectExecutionSetEXT-deviceGeneratedCommands-11013 The VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT::deviceGeneratedCommands feature must be enabled Valid Usage (Implicit) VUID-vkCreateIndirectExecutionSetEXT-device-parameter device must be a valid VkDevice handle VUID-vkCreateIndirectExecutionSetEXT-pCreateInfo-parameter pCreateInfo must be a valid pointer to a valid VkIndirectExecutionSetCreateInfoEXT structure VUID-vkCreateIndirectExecutionSetEXT-pAllocator-parameter If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure VUID-vkCreateIndirectExecutionSetEXT-pIndirectExecutionSet-parameter pIndirectExecutionSet must be a valid pointer to a VkIndirectExecutionSetEXT handle Return Codes Success VK_SUCCESS Failure VK_ERROR_OUT_OF_HOST_MEMORY VK_ERROR_OUT_OF_DEVICE_MEMORY The VkIndirectExecutionSetCreateInfoEXT structure is defined as: // Provided by VK_EXT_device_generated_commands typedef struct VkIndirectExecutionSetCreateInfoEXT { VkStructureType sType; const void* pNext; VkIndirectExecutionSetInfoTypeEXT type; VkIndirectExecutionSetInfoEXT info; } VkIndirectExecutionSetCreateInfoEXT; sType is a VkStructureType value identifying this structure. pNext is NULL or a pointer to a structure extending this structure. type is a VkIndirectExecutionSetInfoTypeEXT describing the type of set being created and determining which field of the info union will be used. info is a VkIndirectExecutionSetInfoEXT union containing layout information for the set. Valid Usage VUID-VkIndirectExecutionSetCreateInfoEXT-maxIndirectShaderObjectCount-11014 If VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT::maxIndirectShaderObjectCount is zero or the shaderObject feature is not enabled type must not be VK_INDIRECT_EXECUTION_SET_INFO_TYPE_SHADER_OBJECTS_EXT Valid Usage (Implicit) VUID-VkIndirectExecutionSetCreateInfoEXT-sType-sType sType must be VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_CREATE_INFO_EXT VUID-VkIndirectExecutionSetCreateInfoEXT-type-parameter type must be a valid VkIndirectExecutionSetInfoTypeEXT value VUID-VkIndirectExecutionSetCreateInfoEXT-pPipelineInfo-parameter If type is VK_INDIRECT_EXECUTION_SET_INFO_TYPE_PIPELINES_EXT, the pPipelineInfo member of info must be a valid pointer to a valid VkIndirectExecutionSetPipelineInfoEXT structure VUID-VkIndirectExecutionSetCreateInfoEXT-pShaderInfo-parameter If type is VK_INDIRECT_EXECUTION_SET_INFO_TYPE_SHADER_OBJECTS_EXT, the pShaderInfo member of info must be a valid pointer to a valid VkIndirectExecutionSetShaderInfoEXT structure Values which can be set in VkIndirectExecutionSetCreateInfoEXT::type, specifying contents of an indirect execution set, are: // Provided by VK_EXT_device_generated_commands typedef enum VkIndirectExecutionSetInfoTypeEXT { VK_INDIRECT_EXECUTION_SET_INFO_TYPE_PIPELINES_EXT = 0, VK_INDIRECT_EXECUTION_SET_INFO_TYPE_SHADER_OBJECTS_EXT = 1, } VkIndirectExecutionSetInfoTypeEXT; VK_INDIRECT_EXECUTION_SET_INFO_TYPE_PIPELINES_EXT specifies that the indirect execution set contains VkPipeline objects. VK_INDIRECT_EXECUTION_SET_INFO_TYPE_SHADER_OBJECTS_EXT specifies that the indirect execution set contains VkShaderEXT objects. The VkIndirectExecutionSetInfoEXT union is defined as: // Provided by VK_EXT_device_generated_commands typedef union VkIndirectExecutionSetInfoEXT { const VkIndirectExecutionSetPipelineInfoEXT* pPipelineInfo; const VkIndirectExecutionSetShaderInfoEXT* pShaderInfo; } VkIndirectExecutionSetInfoEXT; pPipelineInfo is a pointer to a VkIndirectExecutionSetPipelineInfoEXT structure containing pipeline layout information for the set. pShaderInfo is a pointer to a VkIndirectExecutionSetShaderInfoEXT structure containing shader object layout information for the set. The VkIndirectExecutionSetPipelineInfoEXT structure is defined as: // Provided by VK_EXT_device_generated_commands typedef struct VkIndirectExecutionSetPipelineInfoEXT { VkStructureType sType; const void* pNext; VkPipeline initialPipeline; uint32_t maxPipelineCount; } VkIndirectExecutionSetPipelineInfoEXT; sType is a VkStructureType value identifying this structure. pNext is NULL or a pointer to a structure extending this structure. initialPipeline is the initial pipeline for the set. This pipeline will be automatically added to the set at index 0. maxPipelineCount is the maximum number of pipelines stored in the set. The characteristics of initialPipeline will be used to validate all pipelines added to the set even if they are removed from the set or destroyed. When an Indirect Execution Set created with pipelines is used, initialPipeline constitutes the initial shader state. Valid Usage VUID-VkIndirectExecutionSetPipelineInfoEXT-supportedIndirectCommandsShaderStagesPipelineBinding-11015 If VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT::supportedIndirectCommandsShaderStagesPipelineBinding does not contain VK_SHADER_STAGE_COMPUTE_BIT, the VkPipelineBindPoint of initialPipeline must not be VK_PIPELINE_BIND_POINT_COMPUTE VUID-VkIndirectExecutionSetPipelineInfoEXT-supportedIndirectCommandsShaderStagesPipelineBinding-11016 If VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT::supportedIndirectCommandsShaderStagesPipelineBinding does not contain VK_SHADER_STAGE_FRAGMENT_BIT, the VkPipelineBindPoint of initialPipeline must not be VK_PIPELINE_BIND_POINT_GRAPHICS VUID-VkIndirectExecutionSetPipelineInfoEXT-supportedIndirectCommandsShaderStagesPipelineBinding-11017 If VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT::supportedIndirectCommandsShaderStagesPipelineBinding does not contain ray tracing stages, the VkPipelineBindPoint of initialPipeline must not be VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR VUID-VkIndirectExecutionSetPipelineInfoEXT-maxPipelineCount-11018 maxPipelineCount must be between 1 and VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT::maxIndirectPipelineCount VUID-VkIndirectExecutionSetPipelineInfoEXT-initialPipeline-11019 initialPipeline must not use descriptors of type VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC VUID-VkIndirectExecutionSetPipelineInfoEXT-initialPipeline-11153 initialPipeline must have been created with VK_PIPELINE_CREATE_2_INDIRECT_BINDABLE_BIT_EXT Valid Usage (Implicit) VUID-VkIndirectExecutionSetPipelineInfoEXT-sType-sType sType must be VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_PIPELINE_INFO_EXT VUID-VkIndirectExecutionSetPipelineInfoEXT-initialPipeline-parameter initialPipeline must be a valid VkPipeline handle The VkIndirectExecutionSetShaderInfoEXT structure is defined as: // Provided by VK_EXT_device_generated_commands typedef struct VkIndirectExecutionSetShaderInfoEXT { VkStructureType sType; const void* pNext; uint32_t shaderCount; const VkShaderEXT* pInitialShaders; const VkIndirectExecutionSetShaderLayoutInfoEXT* pSetLayoutInfos; uint32_t maxShaderCount; uint32_t pushConstantRangeCount; const VkPushConstantRange* pPushConstantRanges; } VkIndirectExecutionSetShaderInfoEXT; sType is a VkStructureType value identifying this structure. pNext is NULL or a pointer to a structure extending this structure. shaderCount is the number of members in the pInitialShaders and pSetLayoutInfos arrays. pInitialShaders is a pointer to an array containing a VkShaderEXT object for each shader stage that will be used in the set. These shaders will be automatically added to the set beginning at index 0. pSetLayoutInfos is a pointer to an array containing a VkIndirectExecutionSetShaderLayoutInfoEXT used by each corresponding pInitialShaders shader stage in the set. maxShaderCount is the maximum number of shader objects stored in the set. pushConstantRangeCount is the number of members in the pPushConstantRanges array. pPushConstantRanges is a pointer to the array of VkPushConstantRange ranges used by all shaders in the set. The characteristics of pInitialShaders will be used to validate all shaders added to the set even if they are removed from the set or destroyed. When an Indirect Execution Set created with shader objects is used, pInitialShaders constitutes the initial shader state. Valid Usage VUID-VkIndirectExecutionSetShaderInfoEXT-pInitialShaders-11020 All members of pInitialShaders must have a stage supported by VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT::supportedIndirectCommandsShaderStagesShaderBinding VUID-VkIndirectExecutionSetShaderInfoEXT-maxShaderCount-11021 maxShaderCount must not be zero VUID-VkIndirectExecutionSetShaderInfoEXT-maxShaderCount-11022 maxShaderCount must be less than or equal to VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT::maxIndirectShaderObjectCount VUID-VkIndirectExecutionSetShaderInfoEXT-maxShaderCount-11036 maxShaderCount must be greater than or equal to shaderCount VUID-VkIndirectExecutionSetShaderInfoEXT-stage-11023 The stage of each element in the pInitialShaders array must be unique VUID-VkIndirectExecutionSetShaderInfoEXT-pInitialShaders-11154 Each member of pInitialShaders must have been created with VK_SHADER_CREATE_INDIRECT_BINDABLE_BIT_EXT Valid Usage (Implicit) VUID-VkIndirectExecutionSetShaderInfoEXT-sType-sType sType must be VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_INFO_EXT VUID-VkIndirectExecutionSetShaderInfoEXT-pInitialShaders-parameter pInitialShaders must be a valid pointer to an array of shaderCount valid VkShaderEXT handles VUID-VkIndirectExecutionSetShaderInfoEXT-pSetLayoutInfos-parameter If pSetLayoutInfos is not NULL, pSetLayoutInfos must be a valid pointer to an array of shaderCount valid VkIndirectExecutionSetShaderLayoutInfoEXT structures VUID-VkIndirectExecutionSetShaderInfoEXT-pPushConstantRanges-parameter If pushConstantRangeCount is not 0, pPushConstantRanges must be a valid pointer to an array of pushConstantRangeCount valid VkPushConstantRange structures VUID-VkIndirectExecutionSetShaderInfoEXT-shaderCount-arraylength shaderCount must be greater than 0 The VkIndirectExecutionSetShaderLayoutInfoEXT structure is defined as: // Provided by VK_EXT_device_generated_commands typedef struct VkIndirectExecutionSetShaderLayoutInfoEXT { VkStructureType sType; const void* pNext; uint32_t setLayoutCount; const VkDescriptorSetLayout* pSetLayouts; } VkIndirectExecutionSetShaderLayoutInfoEXT; sType is a VkStructureType value identifying this structure. pNext is NULL or a pointer to a structure extending this structure. setLayoutCount is the number of members in the pSetLayouts array pSetLayouts is a pointer to an array containing VkDescriptorSetLayout objects used by the shader stage. The implementation must not access these objects outside of the duration of the command this structure is passed to. Valid Usage VUID-VkIndirectExecutionSetShaderLayoutInfoEXT-pSetLayouts-11024 All members of pSetLayouts must not contain descriptors of type VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC Valid Usage (Implicit) VUID-VkIndirectExecutionSetShaderLayoutInfoEXT-sType-sType sType must be VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_LAYOUT_INFO_EXT VUID-VkIndirectExecutionSetShaderLayoutInfoEXT-pSetLayouts-parameter If setLayoutCount is not 0, pSetLayouts must be a valid pointer to an array of setLayoutCount valid or VK_NULL_HANDLE VkDescriptorSetLayout handles Destroy an Indirect Execution Set by calling: // Provided by VK_EXT_device_generated_commands void vkDestroyIndirectExecutionSetEXT( VkDevice device, VkIndirectExecutionSetEXT indirectExecutionSet, const VkAllocationCallbacks* pAllocator); device is the logical device that owns the indirect execution set. indirectExecutionSet is the indirect execution set to destroy. pAllocator controls host memory allocation as described in the Memory Allocation chapter. Valid Usage VUID-vkDestroyIndirectExecutionSetEXT-indirectExecutionSet-11025 All submitted commands that refer to indirectExecutionSet must have completed execution Valid Usage (Implicit) VUID-vkDestroyIndirectExecutionSetEXT-device-parameter device must be a valid VkDevice handle VUID-vkDestroyIndirectExecutionSetEXT-indirectExecutionSet-parameter If indirectExecutionSet is not VK_NULL_HANDLE, indirectExecutionSet must be a valid VkIndirectExecutionSetEXT handle VUID-vkDestroyIndirectExecutionSetEXT-pAllocator-parameter If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure VUID-vkDestroyIndirectExecutionSetEXT-indirectExecutionSet-parent If indirectExecutionSet is a valid handle, it must have been created, allocated, or retrieved from device Host Synchronization Host access to indirectExecutionSet must be externally synchronized The VkWriteIndirectExecutionSetPipelineEXT structure is defined as: // Provided by VK_EXT_device_generated_commands typedef struct VkWriteIndirectExecutionSetPipelineEXT { VkStructureType sType; const void* pNext; uint32_t index; VkPipeline pipeline; } VkWriteIndirectExecutionSetPipelineEXT; sType is a VkStructureType value identifying this structure. pNext is NULL or a pointer to a structure extending this structure. index is the element of the set to update pipeline is the pipeline to store in the indirect execution set Valid Usage VUID-VkWriteIndirectExecutionSetPipelineEXT-index-11026 index must be less than the value of VkIndirectExecutionSetPipelineInfoEXT::maxPipelineCount used to create the set VUID-VkWriteIndirectExecutionSetPipelineEXT-pipeline-11027 pipeline must have been created with VK_PIPELINE_CREATE_2_INDIRECT_BINDABLE_BIT_EXT VUID-VkWriteIndirectExecutionSetPipelineEXT-index-11029 index must not be referenced by submitted command buffers VUID-VkWriteIndirectExecutionSetPipelineEXT-pipeline-11030 The shader stages contained in pipeline must be supported by VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT::supportedIndirectCommandsShaderStagesPipelineBinding Valid Usage (Implicit) VUID-VkWriteIndirectExecutionSetPipelineEXT-sType-sType sType must be VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_PIPELINE_EXT VUID-VkWriteIndirectExecutionSetPipelineEXT-pipeline-parameter pipeline must be a valid VkPipeline handle The VkWriteIndirectExecutionSetShaderEXT structure is defined as: // Provided by VK_EXT_device_generated_commands with VK_EXT_shader_object typedef struct VkWriteIndirectExecutionSetShaderEXT { VkStructureType sType; const void* pNext; uint32_t index; VkShaderEXT shader; } VkWriteIndirectExecutionSetShaderEXT; sType is a VkStructureType value identifying this structure. pNext is NULL or a pointer to a structure extending this structure. index is the element of the set to update shader is the shader to store in the indirect execution set Shaders need not be stored in the Indirect Execution Set according to their stage. The only restriction for shader indices within a set is that the value of the index must be less than the maximum number of shaders in the set. Valid Usage VUID-VkWriteIndirectExecutionSetShaderEXT-index-11031 index must be less than VkIndirectExecutionSetShaderInfoEXT::maxShaderCount VUID-VkWriteIndirectExecutionSetShaderEXT-shader-11032 shader must have been created with VK_SHADER_CREATE_INDIRECT_BINDABLE_BIT_EXT VUID-VkWriteIndirectExecutionSetShaderEXT-pInitialShaders-11033 A shader created with the same VkShaderStageFlagBits must have been passed in the VkIndirectExecutionSetShaderInfoEXT::pInitialShaders array VUID-VkWriteIndirectExecutionSetShaderEXT-index-11034 index must not be in use by submitted command buffers Valid Usage (Implicit) VUID-VkWriteIndirectExecutionSetShaderEXT-sType-sType sType must be VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_SHADER_EXT VUID-VkWriteIndirectExecutionSetShaderEXT-shader-parameter shader must be a valid VkShaderEXT handle Pipeline elements in an Indirect Execution Set can be updated by calling: // Provided by VK_EXT_device_generated_commands void vkUpdateIndirectExecutionSetPipelineEXT( VkDevice device, VkIndirectExecutionSetEXT indirectExecutionSet, uint32_t executionSetWriteCount, const VkWriteIndirectExecutionSetPipelineEXT* pExecutionSetWrites); device is the logical device that owns the indirect execution set. indirectExecutionSet is the indirect execution set being updated. executionSetWriteCount is the number of elements in the pExecutionSetWrites array. pExecutionSetWrites is a pointer to an array of VkWriteIndirectExecutionSetPipelineEXT structures describing the elements to update. Valid Usage VUID-vkUpdateIndirectExecutionSetPipelineEXT-indirectExecutionSet-11035 indirectExecutionSet must have been created with type VK_INDIRECT_EXECUTION_SET_INFO_TYPE_PIPELINES_EXT VUID-vkUpdateIndirectExecutionSetPipelineEXT-executionSetWriteCount-11037 executionSetWriteCount must be less than or equal to VkIndirectExecutionSetPipelineInfoEXT::maxPipelineCount VUID-vkUpdateIndirectExecutionSetPipelineEXT-pExecutionSetWrites-11042 Each element in the pExecutionSetWrites array must have a unique VkWriteIndirectExecutionSetPipelineEXT::index VUID-vkUpdateIndirectExecutionSetPipelineEXT-None-11038 Each member of the Indirect Execution Set referenced by the update command must not be in use by the device VUID-vkUpdateIndirectExecutionSetPipelineEXT-None-11039 The layout of each pipeline in pExecutionSetWrites must be compatible with the initialPipeline used to create the Indirect Execution Set VUID-vkUpdateIndirectExecutionSetPipelineEXT-None-11040 Each pipeline in the Indirect Execution Set must have identically defined static and dynamic state values to the initialPipeline used to create the Indirect Execution Set VUID-vkUpdateIndirectExecutionSetPipelineEXT-initialPipeline-11147 Each pipeline in the Indirect Execution Set must have identically defined fragment outputs interface to the initialPipeline used to create the Indirect Execution Set VUID-vkUpdateIndirectExecutionSetPipelineEXT-initialPipeline-11152 Each pipeline in the Indirect Execution Set must match the initialPipeline used to create the Indirect Execution Set in its included shader stages VUID-vkUpdateIndirectExecutionSetPipelineEXT-initialPipeline-11098 Each pipeline in the Indirect Execution Set must match the initialPipeline used to create the Indirect Execution Set in its use of FragDepth VUID-vkUpdateIndirectExecutionSetPipelineEXT-initialPipeline-11086 Each pipeline in the Indirect Execution Set must match the initialPipeline used to create the Indirect Execution Set in its use of SampleMask VUID-vkUpdateIndirectExecutionSetPipelineEXT-initialPipeline-11085 Each pipeline in the Indirect Execution Set must match the initialPipeline used to create the Indirect Execution Set in its use of StencilExportEXT Valid Usage (Implicit) VUID-vkUpdateIndirectExecutionSetPipelineEXT-device-parameter device must be a valid VkDevice handle VUID-vkUpdateIndirectExecutionSetPipelineEXT-indirectExecutionSet-parameter indirectExecutionSet must be a valid VkIndirectExecutionSetEXT handle VUID-vkUpdateIndirectExecutionSetPipelineEXT-pExecutionSetWrites-parameter pExecutionSetWrites must be a valid pointer to an array of executionSetWriteCount valid VkWriteIndirectExecutionSetPipelineEXT structures VUID-vkUpdateIndirectExecutionSetPipelineEXT-executionSetWriteCount-arraylength executionSetWriteCount must be greater than 0 VUID-vkUpdateIndirectExecutionSetPipelineEXT-indirectExecutionSet-parent indirectExecutionSet must have been created, allocated, or retrieved from device Host Synchronization Host access to indirectExecutionSet must be externally synchronized Shader object elements in an Indirect Execution Set can be updated by calling: // Provided by VK_EXT_device_generated_commands void vkUpdateIndirectExecutionSetShaderEXT( VkDevice device, VkIndirectExecutionSetEXT indirectExecutionSet, uint32_t executionSetWriteCount, const VkWriteIndirectExecutionSetShaderEXT* pExecutionSetWrites); device is the logical device that owns the indirect execution set. indirectExecutionSet is the indirect execution set being updated. executionSetWriteCount is the number of elements in the pExecutionSetWrites array. pExecutionSetWrites is a pointer to an array of VkWriteIndirectExecutionSetShaderEXT structures describing the elements to update. Valid Usage VUID-vkUpdateIndirectExecutionSetShaderEXT-indirectExecutionSet-11041 indirectExecutionSet must have been created with type VK_INDIRECT_EXECUTION_SET_INFO_TYPE_SHADER_OBJECTS_EXT VUID-vkUpdateIndirectExecutionSetShaderEXT-pExecutionSetWrites-11043 Each element in the pExecutionSetWrites array must have a unique VkWriteIndirectExecutionSetShaderEXT::index VUID-vkUpdateIndirectExecutionSetShaderEXT-None-11044 Each member of the Indirect Execution Set referenced by the update command must not be in use by the device VUID-vkUpdateIndirectExecutionSetShaderEXT-pExecutionSetWrites-11140 The descriptor layout of each shader in pExecutionSetWrites must be compatible with the initial layout info used to create the Indirect Execution Set VUID-vkUpdateIndirectExecutionSetShaderEXT-None-11148 Each fragment shader element in the Indirect Execution Set must have identically defined fragment outputs interface to the initial shader state used to create the Indirect Execution Set VUID-vkUpdateIndirectExecutionSetShaderEXT-FragDepth-11054 Each fragment shader element in the Indirect Execution Set must match the initial shader state used to create the Indirect Execution Set in its use of FragDepth VUID-vkUpdateIndirectExecutionSetShaderEXT-SampleMask-11050 Each fragment shader element in the Indirect Execution Set must match the initial shader state used to create the Indirect Execution Set in its use of SampleMask VUID-vkUpdateIndirectExecutionSetShaderEXT-StencilExportEXT-11003 Each fragment shader element in the Indirect Execution Set must match the initial shader state used to create the Indirect Execution Set in its use of StencilExportEXT Valid Usage (Implicit) VUID-vkUpdateIndirectExecutionSetShaderEXT-device-parameter device must be a valid VkDevice handle VUID-vkUpdateIndirectExecutionSetShaderEXT-indirectExecutionSet-parameter indirectExecutionSet must be a valid VkIndirectExecutionSetEXT handle VUID-vkUpdateIndirectExecutionSetShaderEXT-pExecutionSetWrites-parameter pExecutionSetWrites must be a valid pointer to an array of executionSetWriteCount valid VkWriteIndirectExecutionSetShaderEXT structures VUID-vkUpdateIndirectExecutionSetShaderEXT-executionSetWriteCount-arraylength executionSetWriteCount must be greater than 0 VUID-vkUpdateIndirectExecutionSetShaderEXT-indirectExecutionSet-parent indirectExecutionSet must have been created, allocated, or retrieved from device Host Synchronization Host access to indirectExecutionSet must be externally synchronized It is legal to update an Indirect Execution Set that is in flight as long as the element indices in pExecutionSetWrites are not in use. Any change to an indirect execution set requires recalculating memory requirements by calling vkGetGeneratedCommandsMemoryRequirementsEXT for commands that use that modified state. Commands that are in flight or those not using updated elements require no changes. The lifetimes of pipelines and shader objects contained in a set must match or exceed the lifetime of the set. With VK_NV_device_generated_commands, the actual generation of commands as well as their execution on the device is handled as single action with: // Provided by VK_NV_device_generated_commands void vkCmdExecuteGeneratedCommandsNV( VkCommandBuffer commandBuffer, VkBool32 isPreprocessed, const VkGeneratedCommandsInfoNV* pGeneratedCommandsInfo); commandBuffer is the command buffer into which the command is recorded. isPreprocessed represents whether the input data has already been preprocessed on the device. If it is VK_FALSE this command will implicitly trigger the preprocessing step, otherwise not. pGeneratedCommandsInfo is a pointer to a VkGeneratedCommandsInfoNV structure containing parameters affecting the generation of commands. If the VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NV flag was used to create the VkGeneratedCommandsInfoNV::indirectCommandsLayout then the order of execution of individual draws through this command may execute in any order, and may not necessarily be in the same order as specified in VkGeneratedCommandsInfoNV::pStreams. The order of execution of individual dispatches through this command may execute in any order and may not necessarily be in the same order as specified in VkGeneratedCommandsInfoNV::pStreams. Valid Usage VUID-vkCmdExecuteGeneratedCommandsNV-magFilter-04553 If a VkSampler created with magFilter or minFilter equal to VK_FILTER_LINEAR, reductionMode equal to VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE, and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT VUID-vkCmdExecuteGeneratedCommandsNV-magFilter-09598 If a VkSampler created with magFilter or minFilter equal to VK_FILTER_LINEAR and reductionMode equal to either VK_SAMPLER_REDUCTION_MODE_MIN or VK_SAMPLER_REDUCTION_MODE_MAX is used to sample a VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT VUID-vkCmdExecuteGeneratedCommandsNV-mipmapMode-04770 If a VkSampler created with mipmapMode equal to VK_SAMPLER_MIPMAP_MODE_LINEAR, reductionMode equal to VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE, and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT VUID-vkCmdExecuteGeneratedCommandsNV-mipmapMode-09599 If a VkSampler created with mipmapMode equal to VK_SAMPLER_MIPMAP_MODE_LINEAR and reductionMode equal to either VK_SAMPLER_REDUCTION_MODE_MIN or VK_SAMPLER_REDUCTION_MODE_MAX is used to sample a VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT VUID-vkCmdExecuteGeneratedCommandsNV-unnormalizedCoordinates-09635 If a VkSampler created with unnormalizedCoordinates equal to VK_TRUE is used to sample a VkImageView as a result of this command, then the image view’s levelCount and layerCount must be 1 VUID-vkCmdExecuteGeneratedCommandsNV-None-08609 If a VkSampler created with unnormalizedCoordinates equal to VK_TRUE is used to sample a VkImageView as a result of this command, then the image view’s viewType must be VK_IMAGE_VIEW_TYPE_1D or VK_IMAGE_VIEW_TYPE_2D VUID-vkCmdExecuteGeneratedCommandsNV-None-08610 If a VkSampler created with unnormalizedCoordinates equal to VK_TRUE is used to sample a VkImageView as a result of this command, then the sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name VUID-vkCmdExecuteGeneratedCommandsNV-None-08611 If a VkSampler created with unnormalizedCoordinates equal to VK_TRUE is used to sample a VkImageView as a result of this command, then the sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values VUID-vkCmdExecuteGeneratedCommandsNV-None-06479 If a VkImageView is sampled with depth comparison, the image view’s format features must contain VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT VUID-vkCmdExecuteGeneratedCommandsNV-None-02691 If a VkImageView is accessed using atomic operations as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT VUID-vkCmdExecuteGeneratedCommandsNV-None-07888 If a VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER descriptor is accessed using atomic operations as a result of this command, then the storage texel buffer’s format features must contain VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT VUID-vkCmdExecuteGeneratedCommandsNV-None-02692 If a VkImageView is sampled with VK_FILTER_CUBIC_EXT as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT VUID-vkCmdExecuteGeneratedCommandsNV-None-02693 If the VK_EXT_filter_cubic extension is not enabled and any VkImageView is sampled with VK_FILTER_CUBIC_EXT as a result of this command, it must not have a VkImageViewType of VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY VUID-vkCmdExecuteGeneratedCommandsNV-filterCubic-02694 Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic returned by vkGetPhysicalDeviceImageFormatProperties2 VUID-vkCmdExecuteGeneratedCommandsNV-filterCubicMinmax-02695 Any VkImageView being sampled with VK_FILTER_CUBIC_EXT with a reduction mode of either VK_SAMPLER_REDUCTION_MODE_MIN or VK_SAMPLER_REDUCTION_MODE_MAX as a result of this command must have a VkImageViewType and format that supports cubic filtering together with minmax filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax returned by vkGetPhysicalDeviceImageFormatProperties2 VUID-vkCmdExecuteGeneratedCommandsNV-cubicRangeClamp-09212 If the cubicRangeClamp feature is not enabled, then any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must not have a VkSamplerReductionModeCreateInfo::reductionMode equal to VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM VUID-vkCmdExecuteGeneratedCommandsNV-reductionMode-09213 Any VkImageView being sampled with a VkSamplerReductionModeCreateInfo::reductionMode equal to VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM as a result of this command must sample with VK_FILTER_CUBIC_EXT VUID-vkCmdExecuteGeneratedCommandsNV-selectableCubicWeights-09214 If the selectableCubicWeights feature is not enabled, then any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must have VkSamplerCubicWeightsCreateInfoQCOM::cubicWeights equal to VK_CUBIC_FILTER_WEIGHTS_CATMULL_ROM_QCOM VUID-vkCmdExecuteGeneratedCommandsNV-flags-02696 Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE VUID-vkCmdExecuteGeneratedCommandsNV-OpTypeImage-07027 For any VkImageView being written as a storage image where the image format field of the OpTypeImage is Unknown, the view’s format features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT VUID-vkCmdExecuteGeneratedCommandsNV-OpTypeImage-07028 For any VkImageView being read as a storage image where the image format field of the OpTypeImage is Unknown, the view’s format features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT VUID-vkCmdExecuteGeneratedCommandsNV-OpTypeImage-07029 For any VkBufferView being written as a storage texel buffer where the image format field of the OpTypeImage is Unknown, the view’s buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT VUID-vkCmdExecuteGeneratedCommandsNV-OpTypeImage-07030 Any VkBufferView being read as a storage texel buffer where the image format field of the OpTypeImage is Unknown then the view’s buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT VUID-vkCmdExecuteGeneratedCommandsNV-None-08600 For each set n that is statically used by a bound shader, a descriptor set must have been bound to n at the same pipeline bind point, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline or the VkDescriptorSetLayout array used to create the current VkShaderEXT , as described in Pipeline Layout Compatibility VUID-vkCmdExecuteGeneratedCommandsNV-None-08601 For each push constant that is statically used by a bound shader, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline or the VkDescriptorSetLayout array used to create the current VkShaderEXT , as described in Pipeline Layout Compatibility VUID-vkCmdExecuteGeneratedCommandsNV-None-10068 For each array of resources that is used by a bound shader, the indices used to access members of the array must be less than the descriptor count for the identified binding in the descriptor sets used by this command VUID-vkCmdExecuteGeneratedCommandsNV-maintenance4-08602 If the maintenance4 feature is not enabled, then for each push constant that is statically used by a bound shader, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline or the VkDescriptorSetLayout and VkPushConstantRange arrays used to create the current VkShaderEXT , as described in Pipeline Layout Compatibility VUID-vkCmdExecuteGeneratedCommandsNV-None-08114 Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid as described by descriptor validity if they are statically used by the VkPipeline bound to the pipeline bind point used by this command and the bound VkPipeline was not created with VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT VUID-vkCmdExecuteGeneratedCommandsNV-None-08115 If the descriptors used by the VkPipeline bound to the pipeline bind point were specified via vkCmdBindDescriptorSets, the bound VkPipeline must have been created without VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT VUID-vkCmdExecuteGeneratedCommandsNV-None-08116 Descriptors in bound descriptor buffers, specified via vkCmdSetDescriptorBufferOffsetsEXT, must be valid if they are dynamically used by the VkPipeline bound to the pipeline bind point used by this command and the bound VkPipeline was created with VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT VUID-vkCmdExecuteGeneratedCommandsNV-None-08604 Descriptors in bound descriptor buffers, specified via vkCmdSetDescriptorBufferOffsetsEXT, must be valid if they are dynamically used by any VkShaderEXT bound to a stage corresponding to the pipeline bind point used by this command VUID-vkCmdExecuteGeneratedCommandsNV-None-08117 If the descriptors used by the VkPipeline bound to the pipeline bind point were specified via vkCmdSetDescriptorBufferOffsetsEXT, the bound VkPipeline must have been created with VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT VUID-vkCmdExecuteGeneratedCommandsNV-None-08119 If a descriptor is dynamically used with a VkPipeline created with VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT, the descriptor memory must be resident VUID-vkCmdExecuteGeneratedCommandsNV-None-08605 If a descriptor is dynamically used with a VkShaderEXT created with a VkDescriptorSetLayout that was created with VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT, the descriptor memory must be resident VUID-vkCmdExecuteGeneratedCommandsNV-None-08606 If the shaderObject feature is not enabled, a valid pipeline must be bound to the pipeline bind point used by this command VUID-vkCmdExecuteGeneratedCommandsNV-None-08608 If a pipeline is bound to the pipeline bind point used by this command, there must not have been any calls to dynamic state setting commands for any state specified statically in the VkPipeline object bound to the pipeline bind point used by this command, since that pipeline was bound VUID-vkCmdExecuteGeneratedCommandsNV-uniformBuffers-06935 If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a uniform buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2 for uniformBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point VUID-vkCmdExecuteGeneratedCommandsNV-None-08612 If the robustBufferAccess feature is not enabled, and any VkShaderEXT bound to a stage corresponding to the pipeline bind point used by this command accesses a uniform buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point VUID-vkCmdExecuteGeneratedCommandsNV-storageBuffers-06936 If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a storage buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2 for storageBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point VUID-vkCmdExecuteGeneratedCommandsNV-None-08613 If the robustBufferAccess feature is not enabled, and any VkShaderEXT bound to a stage corresponding to the pipeline bind point used by this command accesses a storage buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point VUID-vkCmdExecuteGeneratedCommandsNV-commandBuffer-02707 If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, any resource accessed by bound shaders must not be a protected resource VUID-vkCmdExecuteGeneratedCommandsNV-viewType-07752 If a VkImageView is accessed as a result of this command, then the image view’s viewType must match the Dim operand of the OpTypeImage as described in Compatibility Between SPIR-V Image Dimensions and Vulkan ImageView Types VUID-vkCmdExecuteGeneratedCommandsNV-format-07753 If a VkImageView or VkBufferView is accessed as a result of this command, then the numeric type of the view’s format and the Sampled Type operand of the OpTypeImage must match VUID-vkCmdExecuteGeneratedCommandsNV-OpImageWrite-08795 If a VkImageView created with a format other than VK_FORMAT_A8_UNORM is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the image view’s format VUID-vkCmdExecuteGeneratedCommandsNV-OpImageWrite-08796 If a VkImageView created with the format VK_FORMAT_A8_UNORM is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have four components VUID-vkCmdExecuteGeneratedCommandsNV-OpImageWrite-04469 If a VkBufferView is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the buffer view’s format VUID-vkCmdExecuteGeneratedCommandsNV-SampledType-04470 If a VkImageView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64 VUID-vkCmdExecuteGeneratedCommandsNV-SampledType-04471 If a VkImageView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32 VUID-vkCmdExecuteGeneratedCommandsNV-SampledType-04472 If a VkBufferView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64 VUID-vkCmdExecuteGeneratedCommandsNV-SampledType-04473 If a VkBufferView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32 VUID-vkCmdExecuteGeneratedCommandsNV-sparseImageInt64Atomics-04474 If the sparseImageInt64Atomics feature is not enabled, VkImage objects created with the VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command VUID-vkCmdExecuteGeneratedCommandsNV-sparseImageInt64Atomics-04475 If the sparseImageInt64Atomics feature is not enabled, VkBuffer objects created with the VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command VUID-vkCmdExecuteGeneratedCommandsNV-OpImageWeightedSampleQCOM-06971 If OpImageWeightedSampleQCOM is used to sample a VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM VUID-vkCmdExecuteGeneratedCommandsNV-OpImageWeightedSampleQCOM-06972 If OpImageWeightedSampleQCOM uses a VkImageView as a sample weight image as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM VUID-vkCmdExecuteGeneratedCommandsNV-OpImageBoxFilterQCOM-06973 If OpImageBoxFilterQCOM is used to sample a VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM VUID-vkCmdExecuteGeneratedCommandsNV-OpImageBlockMatchSSDQCOM-06974 If OpImageBlockMatchSSDQCOM is used to read from an VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM VUID-vkCmdExecuteGeneratedCommandsNV-OpImageBlockMatchSADQCOM-06975 If OpImageBlockMatchSADQCOM is used to read from an VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM VUID-vkCmdExecuteGeneratedCommandsNV-OpImageBlockMatchSADQCOM-06976 If OpImageBlockMatchSADQCOM or OpImageBlockMatchSSDQCOM is used to read from a reference image as result of this command, then the specified reference coordinates must not fail integer texel coordinate validation VUID-vkCmdExecuteGeneratedCommandsNV-OpImageWeightedSampleQCOM-06977 If OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchWindowSSDQCOM, OpImageBlockMatchWindowSADQCOM, OpImageBlockMatchGatherSSDQCOM, OpImageBlockMatchGatherSADQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM VUID-vkCmdExecuteGeneratedCommandsNV-OpImageWeightedSampleQCOM-06978 If any command other than OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchWindowSSDQCOM, OpImageBlockMatchWindowSADQCOM, OpImageBlockMatchGatherSSDQCOM, OpImageBlockMatchGatherSADQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must not have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM VUID-vkCmdExecuteGeneratedCommandsNV-OpImageBlockMatchWindow-09215 If a OpImageBlockMatchWindow*QCOM or OpImageBlockMatchGather*QCOM instruction is used to read from an VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM VUID-vkCmdExecuteGeneratedCommandsNV-OpImageBlockMatchWindow-09216 If a OpImageBlockMatchWindow*QCOM or OpImageBlockMatchGather*QCOM instruction is used to read from an VkImageView as a result of this command, then the image view’s format must be a single-component format VUID-vkCmdExecuteGeneratedCommandsNV-OpImageBlockMatchWindow-09217 If a OpImageBlockMatchWindow*QCOM or OpImageBlockMatchGather*QCOM read from a reference image as result of this command, then the specified reference coordinates must not fail integer texel coordinate validation VUID-vkCmdExecuteGeneratedCommandsNV-None-07288 Any shader invocation executed by this command must terminate VUID-vkCmdExecuteGeneratedCommandsNV-None-09600 If a descriptor with type equal to any of VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM, VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, or VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT is accessed as a result of this command, all image subresources identified by that descriptor must be in the image layout identified when the descriptor was written VUID-vkCmdExecuteGeneratedCommandsNV-commandBuffer-10746 The VkDeviceMemory object allocated from a VkMemoryHeap with the VK_MEMORY_HEAP_TILE_MEMORY_BIT_QCOM property that is bound to a resource accessed as a result of this command must be the active bound bound tile memory object in commandBuffer VUID-vkCmdExecuteGeneratedCommandsNV-None-10678 If this command is recorded inside a tile shading render pass instance, the stages corresponding to the pipeline bind point used by this command must only include VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_FRAGMENT_BIT, and/or VK_SHADER_STAGE_COMPUTE_BIT VUID-vkCmdExecuteGeneratedCommandsNV-None-10679 If this command is recorded where per-tile execution model is enabled, there must be no access to any image while the image was be transitioned to the VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT layout VUID-vkCmdExecuteGeneratedCommandsNV-renderPass-02684 The current render pass must be compatible with the renderPass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS VUID-vkCmdExecuteGeneratedCommandsNV-subpass-02685 The subpass index of the current render pass must be equal to the subpass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS VUID-vkCmdExecuteGeneratedCommandsNV-None-07748 If any shader statically accesses an input attachment, a valid descriptor must be bound to the pipeline via a descriptor set VUID-vkCmdExecuteGeneratedCommandsNV-OpTypeImage-07468 If any shader executed by this pipeline accesses an OpTypeImage variable with a Dim operand of SubpassData, it must be decorated with an InputAttachmentIndex that corresponds to a valid input attachment in the current subpass VUID-vkCmdExecuteGeneratedCommandsNV-None-07469 Input attachment views accessed in a subpass must be created with the same VkFormat as the corresponding subpass definition, and be created with a VkImageView that is compatible with the attachment referenced by the subpass' pInputAttachments[InputAttachmentIndex] in the bound VkFramebuffer as specified by Fragment Input Attachment Compatibility VUID-vkCmdExecuteGeneratedCommandsNV-pDepthInputAttachmentIndex-09595 Input attachment views accessed in a dynamic render pass with a InputAttachmentIndex referenced by VkRenderingInputAttachmentIndexInfo, or no InputAttachmentIndex if VkRenderingInputAttachmentIndexInfo:pDepthInputAttachmentIndex or VkRenderingInputAttachmentIndexInfo:pStencilInputAttachmentIndex are NULL, must be created with a VkImageView that is compatible with the corresponding color, depth, or stencil attachment in VkRenderingInfo VUID-vkCmdExecuteGeneratedCommandsNV-pDepthInputAttachmentIndex-09596 Input attachment views accessed in a dynamic render pass via a shader object must have an InputAttachmentIndex if both VkRenderingInputAttachmentIndexInfo:pDepthInputAttachmentIndex and VkRenderingInputAttachmentIndexInfo:pStencilInputAttachmentIndex are non-NULL VUID-vkCmdExecuteGeneratedCommandsNV-InputAttachmentIndex-09597 If an input attachment view accessed in a dynamic render pass via a shader object has an InputAttachmentIndex, the InputAttachmentIndex must match an index in VkRenderingInputAttachmentIndexInfo VUID-vkCmdExecuteGeneratedCommandsNV-None-06537 Memory backing image subresources used as attachments in the current render pass must not be written in any way other than as an attachment by this command VUID-vkCmdExecuteGeneratedCommandsNV-None-09000 If a color attachment is written by any prior command in this subpass or by the load, store, or resolve operations for this subpass, it is not in the VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT image layout, and either: the VK_PIPELINE_CREATE_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT is set on the bound pipeline or the last call to vkCmdSetAttachmentFeedbackLoopEnableEXT included VK_IMAGE_ASPECT_COLOR_BIT and there is no bound graphics pipeline or the bound graphics pipeline was created with VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT it must not be accessed in any way other than as an attachment by this command VUID-vkCmdExecuteGeneratedCommandsNV-None-09001 If a depth attachment is written by any prior command in this subpass or by the load, store, or resolve operations for this subpass, it is not in the VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT image layout, and either: the VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT is set on the bound pipeline or the last call to vkCmdSetAttachmentFeedbackLoopEnableEXT included VK_IMAGE_ASPECT_DEPTH_BIT and there is no bound graphics pipeline or the bound graphics pipeline was created with VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT it must not be accessed in any way other than as an attachment by this command VUID-vkCmdExecuteGeneratedCommandsNV-None-09002 If a stencil attachment is written by any prior command in this subpass or by the load, store, or resolve operations for this subpass, it is not in the VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT image layout, and either: the VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT is set on the bound pipeline or the last call to vkCmdSetAttachmentFeedbackLoopEnableEXT included VK_IMAGE_ASPECT_STENCIL_BIT and there is no bound graphics pipeline or the bound graphics pipeline was created with VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT it must not be accessed in any way other than as an attachment by this command VUID-vkCmdExecuteGeneratedCommandsNV-None-09003 If an attachment is written by any prior command in this subpass or by the load, store, or resolve operations for this subpass, it must not be accessed in any way other than as an attachment, storage image, or sampled image by this command VUID-vkCmdExecuteGeneratedCommandsNV-None-06539 If any previously recorded command in the current subpass accessed an image subresource used as an attachment in this subpass in any way other than as an attachment, this command must not write to that image subresource as an attachment VUID-vkCmdExecuteGeneratedCommandsNV-None-06886 If the current render pass instance uses a depth/stencil attachment with a read-only layout for the depth aspect, depth writes must be disabled VUID-vkCmdExecuteGeneratedCommandsNV-None-06887 If the current render pass instance uses a depth/stencil attachment with a read-only layout for the stencil aspect, both front and back writeMask are not zero, and stencil test is enabled, all stencil ops must be VK_STENCIL_OP_KEEP VUID-vkCmdExecuteGeneratedCommandsNV-None-07831 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT dynamic state enabled then vkCmdSetViewport must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-07832 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SCISSOR dynamic state enabled then vkCmdSetScissor must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-07833 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_WIDTH dynamic state enabled then vkCmdSetLineWidth must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-08617 If a shader object is bound to any graphics stage, and the most recent call to vkCmdSetRasterizerDiscardEnable in the current command buffer set rasterizerDiscardEnable to VK_FALSE, and the most recent call to vkCmdSetPolygonModeEXT in the current command buffer set polygonMode to VK_POLYGON_MODE_LINE, vkCmdSetLineWidth must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-08618 If a shader object is bound to any graphics stage, and the most recent call to vkCmdSetRasterizerDiscardEnable in the current command buffer set rasterizerDiscardEnable to VK_FALSE, and the most recent call to vkCmdSetPrimitiveTopology in the current command buffer set primitiveTopology to any line topology, vkCmdSetLineWidth must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-08619 If a shader object that outputs line primitives is bound to the VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT or VK_SHADER_STAGE_GEOMETRY_BIT stage, and the most recent call to vkCmdSetRasterizerDiscardEnable in the current command buffer set rasterizerDiscardEnable to VK_FALSE, vkCmdSetLineWidth must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-07834 If a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_DEPTH_BIAS dynamic state enabled, the current value of rasterizerDiscardEnable is VK_FALSE, and the current value of depthBiasEnable is VK_TRUE, then vkCmdSetDepthBias or vkCmdSetDepthBias2EXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-07835 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_BLEND_CONSTANTS dynamic state enabled then vkCmdSetBlendConstants must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-08621 If a shader object is bound to the VK_SHADER_STAGE_FRAGMENT_BIT stage, and the most recent call to vkCmdSetRasterizerDiscardEnable in the current command buffer set rasterizerDiscardEnable to VK_FALSE, and the most recent call to vkCmdSetColorBlendEnableEXT in the current command buffer set any element of pColorBlendEnables to VK_TRUE, and the most recent call to vkCmdSetColorBlendEquationEXT in the current command buffer set the same element of pColorBlendEquations to a VkColorBlendEquationEXT structure with any VkBlendFactor member with a value of VK_BLEND_FACTOR_CONSTANT_COLOR, VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR, VK_BLEND_FACTOR_CONSTANT_ALPHA, or VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA, vkCmdSetBlendConstants must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-07836 If a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_DEPTH_BOUNDS dynamic state enabled, the current value of rasterizerDiscardEnable is VK_FALSE, and the current value of depthBoundsTestEnable is VK_TRUE, then vkCmdSetDepthBounds must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-07837 If a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK dynamic state enabled, the current value of rasterizerDiscardEnable is VK_FALSE, and the current value of stencilTestEnable is VK_TRUE, then vkCmdSetStencilCompareMask must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-07838 If a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_STENCIL_WRITE_MASK dynamic state enabled, the current value of rasterizerDiscardEnable is VK_FALSE, and the current value of stencilTestEnable is VK_TRUE, then vkCmdSetStencilWriteMask must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-07839 If a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_STENCIL_REFERENCE dynamic state enabled, the current value of and rasterizerDiscardEnable is VK_FALSE, the current value of stencilTestEnable is VK_TRUE, then vkCmdSetStencilReference must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-maxMultiviewInstanceIndex-02688 If the draw is recorded in a render pass instance with multiview enabled, the maximum instance index must be less than or equal to VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex VUID-vkCmdExecuteGeneratedCommandsNV-sampleLocationsEnable-02689 If the bound graphics pipeline was created with VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable set to VK_TRUE and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set VUID-vkCmdExecuteGeneratedCommandsNV-None-07634 If the VK_EXT_sample_locations extension is enabled, a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT dynamic state enabled, and the current value of rasterizerDiscardEnable is VK_FALSE, then vkCmdSetSampleLocationsEnableEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-06666 If the VK_EXT_sample_locations extension is enabled, a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT dynamic state enabled, the current value of rasterizerDiscardEnable is VK_FALSE, and the current value of sampleLocationsEnable is VK_TRUE, then vkCmdSetSampleLocationsEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-07840 If a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_CULL_MODE dynamic state enabled, and the current value of rasterizerDiscardEnable is VK_FALSE, then vkCmdSetCullMode must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-07841 If a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_FRONT_FACE dynamic state enabled, and the current value of rasterizerDiscardEnable is VK_FALSE, then vkCmdSetFrontFace must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-07843 If a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE dynamic state enabled, and the current value of rasterizerDiscardEnable is VK_FALSE, vkCmdSetDepthTestEnable must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-07844 If a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE dynamic state enabled, and the current value of rasterizerDiscardEnable is VK_FALSE, then vkCmdSetDepthWriteEnable must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-07845 If a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_DEPTH_COMPARE_OP dynamic state enabled, the current value of rasterizerDiscardEnable is VK_FALSE, and the current value of depthTestEnable is VK_TRUE, then vkCmdSetDepthCompareOp must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-07846 If the depthBounds feature is enabled, a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE dynamic state enabled, and the current value of rasterizerDiscardEnable is VK_FALSE, then vkCmdSetDepthBoundsTestEnable must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-07847 If a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE dynamic state enabled, and the current value of rasterizerDiscardEnable is VK_FALSE, then vkCmdSetStencilTestEnable must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-07848 If a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_STENCIL_OP dynamic state enabled, the current value of rasterizerDiscardEnable is VK_FALSE, the current value of stencilTestEnable is VK_TRUE, then vkCmdSetStencilOp must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-viewportCount-03417 If a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, and the state is not inherited, then vkCmdSetViewportWithCount must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-scissorCount-03418 If a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT dynamic state enabled, and the state is not inherited, then vkCmdSetScissorWithCount must have been called and not subsequently invalidated in the current command buffer prior to this drawing VUID-vkCmdExecuteGeneratedCommandsNV-viewportCount-03419 If a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with both the VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic states enabled, and the state is not inherited, then the viewportCount parameter of vkCmdSetViewportWithCount must match the scissorCount parameter of vkCmdSetScissorWithCount VUID-vkCmdExecuteGeneratedCommandsNV-viewportCount-04137 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV dynamic state enabled, then the bound graphics pipeline must have been created with VkPipelineViewportWScalingStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount VUID-vkCmdExecuteGeneratedCommandsNV-viewportCount-04138 If the VK_NV_clip_space_w_scaling extension is enabled, and a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV dynamic state enabled, the current value of viewportWScalingEnable is VK_TRUE, then vkCmdSetViewportWScalingNV must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-08636 If the VK_NV_clip_space_w_scaling extension is enabled, and a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV dynamic state enabled, the current value of viewportWScalingEnable is VK_TRUE, then the viewportCount parameter in the last call to vkCmdSetViewportWScalingNV must be greater than or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount VUID-vkCmdExecuteGeneratedCommandsNV-viewportCount-04139 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV dynamic state enabled, then the bound graphics pipeline must have been created with VkPipelineViewportShadingRateImageStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount VUID-vkCmdExecuteGeneratedCommandsNV-shadingRateImage-09233 If the shadingRateImage feature is enabled, and a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV and the current value of rasterizerDiscardEnable is VK_FALSE, then vkCmdSetCoarseSampleOrderNV must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-shadingRateImage-09234 If the shadingRateImage feature is enabled, and a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV dynamic state enabled, the current value of rasterizerDiscardEnable is VK_FALSE, and the current value of shadingRateImageEnable is VK_TRUE, then vkCmdSetViewportShadingRatePaletteNV must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-08637 If the shadingRateImage feature is enabled, and a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV dynamic state enabled, the current value of rasterizerDiscardEnable is VK_FALSE, and the current value of shadingRateImageEnable is VK_TRUE, then the viewportCount parameter in the last call to vkCmdSetViewportShadingRatePaletteNV must be greater than or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount VUID-vkCmdExecuteGeneratedCommandsNV-VkPipelineVieportCreateInfo-04141 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled and a VkPipelineViewportSwizzleStateCreateInfoNV structure chained from VkPipelineViewportStateCreateInfo, then the bound graphics pipeline must have been created with VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount VUID-vkCmdExecuteGeneratedCommandsNV-VkPipelineVieportCreateInfo-04142 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled and a VkPipelineViewportExclusiveScissorStateCreateInfoNV structure chained from VkPipelineViewportStateCreateInfo, then the bound graphics pipeline must have been created with VkPipelineViewportExclusiveScissorStateCreateInfoNV::exclusiveScissorCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount VUID-vkCmdExecuteGeneratedCommandsNV-None-07878 If the exclusiveScissor feature is enabled, and a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_ENABLE_NV dynamic state enabled, then vkCmdSetExclusiveScissorEnableNV must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-07879 If the exclusiveScissor feature is enabled, a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV dynamic state enabled, and the most recent call to vkCmdSetExclusiveScissorEnableNV in the current command buffer set any element of pExclusiveScissorEnables to VK_TRUE, then vkCmdSetExclusiveScissorNV must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-04876 If a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE dynamic state enabled, then vkCmdSetRasterizerDiscardEnable must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-04877 If a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE dynamic state enabled, and the current value of rasterizerDiscardEnable is VK_FALSE, then vkCmdSetDepthBiasEnable must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-logicOp-04878 If a shader object is bound to the VK_SHADER_STAGE_FRAGMENT_BIT or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_LOGIC_OP_EXT dynamic state enabled, the current value of rasterizerDiscardEnable is VK_FALSE, and the current value of logicOpEnable is VK_TRUE, then vkCmdSetLogicOpEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-primitiveFragmentShadingRateWithMultipleViewports-04552 If the primitiveFragmentShadingRateWithMultipleViewports limit is not supported, the bound graphics pipeline was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, and any of the shader stages of the bound graphics pipeline write to the PrimitiveShadingRateKHR built-in, then vkCmdSetViewportWithCount must have been called in the current command buffer prior to this drawing command, and the viewportCount parameter of vkCmdSetViewportWithCount must be 1 VUID-vkCmdExecuteGeneratedCommandsNV-primitiveFragmentShadingRateWithMultipleViewports-08642 If the primitiveFragmentShadingRateWithMultipleViewports limit is not supported, and any shader object bound to a graphics stage writes to the PrimitiveShadingRateKHR built-in, then vkCmdSetViewportWithCount must have been called in the current command buffer prior to this drawing command, and the viewportCount parameter of vkCmdSetViewportWithCount must be 1 VUID-vkCmdExecuteGeneratedCommandsNV-blendEnable-04727 If rasterization is not disabled in the bound graphics pipeline, then for each color attachment in the subpass, if the corresponding image view’s format features do not contain VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT, then the blendEnable member of the corresponding element of the pAttachments member of pColorBlendState must be VK_FALSE VUID-vkCmdExecuteGeneratedCommandsNV-None-08643 If a shader object is bound to the VK_SHADER_STAGE_FRAGMENT_BIT stage, and the most recent call to vkCmdSetRasterizerDiscardEnable in the current command buffer set rasterizerDiscardEnable to VK_FALSE, then for each color attachment in the render pass, if the corresponding image view’s format features do not contain VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT, then the corresponding member of pColorBlendEnables in the most recent call to vkCmdSetColorBlendEnableEXT in the current command buffer that affected that attachment index must have been VK_FALSE VUID-vkCmdExecuteGeneratedCommandsNV-multisampledRenderToSingleSampled-07284 If rasterization is not disabled in the bound graphics pipeline, and none of the following is enabled: the VK_AMD_mixed_attachment_samples extension the VK_NV_framebuffer_mixed_samples extension the multisampledRenderToSingleSampled feature then rasterizationSamples for the bound graphics pipeline must be the same as the current subpass color and/or depth/stencil attachments VUID-vkCmdExecuteGeneratedCommandsNV-None-08644 If a shader object is bound to any graphics stage, and the most recent call to vkCmdSetRasterizerDiscardEnable in the current command buffer set rasterizerDiscardEnable to VK_FALSE, and none of the following is enabled: the VK_AMD_mixed_attachment_samples extension the VK_NV_framebuffer_mixed_samples extension the multisampledRenderToSingleSampled feature then the most recent call to vkCmdSetRasterizationSamplesEXT in the current command buffer must have set rasterizationSamples to be the same as the number of samples for the current render pass color and/or depth/stencil attachments VUID-vkCmdExecuteGeneratedCommandsNV-None-08876 If a shader object is bound to any graphics stage, the current render pass instance must have been begun with vkCmdBeginRendering VUID-vkCmdExecuteGeneratedCommandsNV-imageView-06172 If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pDepthAttachment is not VK_NULL_HANDLE, and the layout member of pDepthAttachment is VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the depth attachment VUID-vkCmdExecuteGeneratedCommandsNV-imageView-06173 If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pStencilAttachment is not VK_NULL_HANDLE, and the layout member of pStencilAttachment is VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the stencil attachment VUID-vkCmdExecuteGeneratedCommandsNV-imageView-06174 If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pDepthAttachment is not VK_NULL_HANDLE, and the layout member of pDepthAttachment is VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL, this command must not write any values to the depth attachment VUID-vkCmdExecuteGeneratedCommandsNV-imageView-06175 If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pStencilAttachment is not VK_NULL_HANDLE, and the layout member of pStencilAttachment is VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the stencil attachment VUID-vkCmdExecuteGeneratedCommandsNV-imageView-06176 If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pDepthAttachment is not VK_NULL_HANDLE, and the layout member of pDepthAttachment is VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL, this command must not write any values to the depth attachment VUID-vkCmdExecuteGeneratedCommandsNV-imageView-06177 If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pStencilAttachment is not VK_NULL_HANDLE, and the layout member of pStencilAttachment is VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the stencil attachment VUID-vkCmdExecuteGeneratedCommandsNV-viewMask-06178 If the current render pass instance was begun with vkCmdBeginRendering, the bound graphics pipeline must have been created with a VkPipelineRenderingCreateInfo::viewMask equal to VkRenderingInfo::viewMask VUID-vkCmdExecuteGeneratedCommandsNV-colorAttachmentCount-06179 If the dynamicRenderingUnusedAttachments feature is not enabled and the current render pass instance was begun with vkCmdBeginRendering, the bound graphics pipeline must have been created with a VkPipelineRenderingCreateInfo::colorAttachmentCount equal to VkRenderingInfo::colorAttachmentCount VUID-vkCmdExecuteGeneratedCommandsNV-dynamicRenderingUnusedAttachments-08910 If the dynamicRenderingUnusedAttachments feature is not enabled, and the current render pass instance was begun with vkCmdBeginRendering and VkRenderingInfo::colorAttachmentCount greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with an imageView not equal to VK_NULL_HANDLE must have been created with a VkFormat equal to the corresponding element of VkPipelineRenderingCreateInfo::pColorAttachmentFormats used to create the bound graphics pipeline VUID-vkCmdExecuteGeneratedCommandsNV-dynamicRenderingUnusedAttachments-08912 If the dynamicRenderingUnusedAttachments feature is not enabled, and the current render pass instance was begun with vkCmdBeginRendering and VkRenderingInfo::colorAttachmentCount greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with an imageView equal to VK_NULL_HANDLE must have the corresponding element of VkPipelineRenderingCreateInfo::pColorAttachmentFormats used to create the bound pipeline equal to VK_FORMAT_UNDEFINED VUID-vkCmdExecuteGeneratedCommandsNV-dynamicRenderingUnusedAttachments-08911 If the dynamicRenderingUnusedAttachments feature is enabled, and the current render pass instance was begun with vkCmdBeginRendering and VkRenderingInfo::colorAttachmentCount greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with an imageView not equal to VK_NULL_HANDLE must have been created with a VkFormat equal to the corresponding element of VkPipelineRenderingCreateInfo::pColorAttachmentFormats used to create the bound graphics pipeline, or the corresponding element of VkPipelineRenderingCreateInfo::pColorAttachmentFormats, if it exists, must be VK_FORMAT_UNDEFINED VUID-vkCmdExecuteGeneratedCommandsNV-colorAttachmentCount-09362 If the current render pass instance was begun with vkCmdBeginRendering, with a VkRenderingInfo::colorAttachmentCount equal to 1, there is no shader object bound to any graphics stage, and a color attachment with a resolve mode of VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID, each element of the VkRenderingInfo::pColorAttachments array with a resolveImageView not equal to VK_NULL_HANDLE must have been created with an image created with a VkExternalFormatANDROID::externalFormat value equal to the VkExternalFormatANDROID::externalFormat value used to create the bound graphics pipeline VUID-vkCmdExecuteGeneratedCommandsNV-None-09363 If there is no shader object bound to any graphics stage, the current render pass instance was begun with vkCmdBeginRendering and a VkRenderingInfo::colorAttachmentCount equal to 1, and a color attachment with a resolve mode of VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID, each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with an image created with a VkExternalFormatANDROID::externalFormat value equal to the VkExternalFormatANDROID::externalFormat value used to create the bound graphics pipeline VUID-vkCmdExecuteGeneratedCommandsNV-None-09364 If the current render pass instance was begun with vkCmdBeginRendering, there is no shader object bound to any graphics stage, and the bound graphics pipeline was created with a non-zero VkExternalFormatANDROID::externalFormat value and with the VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT dynamic state enabled, then vkCmdSetColorBlendEnableEXT must have set the blend enable to VK_FALSE prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-09365 If the current render pass instance was begun with vkCmdBeginRendering, there is no shader object bound to any graphics stage, and the bound graphics pipeline was created with a non-zero VkExternalFormatANDROID::externalFormat value and with the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT dynamic state enabled, then vkCmdSetRasterizationSamplesEXT must have set rasterizationSamples to VK_SAMPLE_COUNT_1_BIT prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-09366 If there is a shader object bound to any graphics stage, and the current render pass includes a color attachment that uses the VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID resolve mode, then vkCmdSetColorBlendEnableEXT must have set blend enable to VK_FALSE prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-rasterizationSamples-09367 If there is a shader object bound to any graphics stage, and the current render pass includes a color attachment that uses the VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID resolve mode, then vkCmdSetRasterizationSamplesEXT must have set rasterizationSamples to VK_SAMPLE_COUNT_1_BIT prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-09368 If the current render pass instance was begun with vkCmdBeginRendering, there is no shader object bound to any graphics stage, and the bound graphics pipeline was created with a non-zero VkExternalFormatANDROID::externalFormat value and with the VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR dynamic state enabled, then vkCmdSetFragmentShadingRateKHR must have set pFragmentSize->width to 1 prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-09369 If the current render pass instance was begun with vkCmdBeginRendering, there is no shader object bound to any graphics stage, and the bound graphics pipeline was created with a non-zero VkExternalFormatANDROID::externalFormat value and with the VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR dynamic state enabled, then vkCmdSetFragmentShadingRateKHR must have set pFragmentSize->height to 1 prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-pFragmentSize-09370 If there is a shader object bound to any graphics stage, and the current render pass includes a color attachment that uses the VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID resolve mode, then vkCmdSetFragmentShadingRateKHR must have set pFragmentSize->width to 1 prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-pFragmentSize-09371 If there is a shader object bound to any graphics stage, and the current render pass includes a color attachment that uses the VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID resolve mode, then vkCmdSetFragmentShadingRateKHR must have set pFragmentSize->height to 1 prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-07749 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT dynamic state enabled then vkCmdSetColorWriteEnableEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-08646 If the colorWriteEnable feature is enabled, and a shader object is bound to the VK_SHADER_STAGE_FRAGMENT_BIT stage, and the most recent call to vkCmdSetRasterizerDiscardEnable in the current command buffer set rasterizerDiscardEnable to VK_FALSE, then vkCmdSetColorWriteEnableEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-attachmentCount-07750 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT dynamic state enabled then the attachmentCount parameter of vkCmdSetColorWriteEnableEXT must be greater than or equal to the VkPipelineColorBlendStateCreateInfo::attachmentCount of the bound graphics pipeline VUID-vkCmdExecuteGeneratedCommandsNV-None-08647 If the colorWriteEnable feature is enabled, and a shader object is bound to the VK_SHADER_STAGE_FRAGMENT_BIT stage, and the most recent call to vkCmdSetRasterizerDiscardEnable in the current command buffer set rasterizerDiscardEnable to VK_FALSE, then the attachmentCount parameter of most recent call to vkCmdSetColorWriteEnableEXT in the current command buffer must be greater than or equal to the number of color attachments in the current render pass instance VUID-vkCmdExecuteGeneratedCommandsNV-None-07751 If the VK_EXT_discard_rectangles extension is enabled, a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT dynamic state enabled and the pNext chain of VkGraphicsPipelineCreateInfo included a VkPipelineDiscardRectangleStateCreateInfoEXT structure, the current value of rasterizerDiscardEnable is VK_FALSE, and the current value of discardRectangleEnable is VK_TRUE, then vkCmdSetDiscardRectangleEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command for each discard rectangle in VkPipelineDiscardRectangleStateCreateInfoEXT::discardRectangleCount VUID-vkCmdExecuteGeneratedCommandsNV-rasterizerDiscardEnable-09236 If the VK_EXT_discard_rectangles extension is enabled, a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT dynamic state enabled and the pNext chain of VkGraphicsPipelineCreateInfo did not include a VkPipelineDiscardRectangleStateCreateInfoEXT structure, the current value of rasterizerDiscardEnable is VK_FALSE, and the current value of discardRectangleEnable is VK_TRUE, then vkCmdSetDiscardRectangleEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command for each discard rectangle in VkPhysicalDeviceDiscardRectanglePropertiesEXT::maxDiscardRectangles VUID-vkCmdExecuteGeneratedCommandsNV-None-07880 If the VK_EXT_discard_rectangles extension is enabled, a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_DISCARD_RECTANGLE_ENABLE_EXT dynamic state enabled, the current value of rasterizerDiscardEnable is VK_FALSE, then vkCmdSetDiscardRectangleEnableEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-07881 If the VK_EXT_discard_rectangles extension is enabled, a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_DISCARD_RECTANGLE_MODE_EXT dynamic state enabled, the current value of rasterizerDiscardEnable is VK_FALSE, and the current value of discardRectangleEnable is VK_TRUE, then vkCmdSetDiscardRectangleModeEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-dynamicRenderingUnusedAttachments-08913 If the current render pass instance was begun with vkCmdBeginRendering, the dynamicRenderingUnusedAttachments feature is not enabled, and VkRenderingInfo::pDepthAttachment->imageView was VK_NULL_HANDLE, the value of VkPipelineRenderingCreateInfo::depthAttachmentFormat used to create the bound graphics pipeline must be equal to VK_FORMAT_UNDEFINED VUID-vkCmdExecuteGeneratedCommandsNV-dynamicRenderingUnusedAttachments-08914 If current render pass instance was begun with vkCmdBeginRendering, the dynamicRenderingUnusedAttachments feature is not enabled, and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineRenderingCreateInfo::depthAttachmentFormat used to create the bound graphics pipeline must be equal to the VkFormat used to create VkRenderingInfo::pDepthAttachment->imageView VUID-vkCmdExecuteGeneratedCommandsNV-dynamicRenderingUnusedAttachments-08915 If the current render pass instance was begun with vkCmdBeginRendering, the dynamicRenderingUnusedAttachments feature is enabled, VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, and the value of VkPipelineRenderingCreateInfo::depthAttachmentFormat used to create the bound graphics pipeline was not equal to the VkFormat used to create VkRenderingInfo::pDepthAttachment->imageView, the value of the format must be VK_FORMAT_UNDEFINED VUID-vkCmdExecuteGeneratedCommandsNV-dynamicRenderingUnusedAttachments-08916 If the current render pass instance was begun with vkCmdBeginRendering, the dynamicRenderingUnusedAttachments feature is not enabled, and VkRenderingInfo::pStencilAttachment->imageView was VK_NULL_HANDLE, the value of VkPipelineRenderingCreateInfo::stencilAttachmentFormat used to create the bound graphics pipeline must be equal to VK_FORMAT_UNDEFINED VUID-vkCmdExecuteGeneratedCommandsNV-dynamicRenderingUnusedAttachments-08917 If current render pass instance was begun with vkCmdBeginRendering, the dynamicRenderingUnusedAttachments feature is not enabled, and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineRenderingCreateInfo::stencilAttachmentFormat used to create the bound graphics pipeline must be equal to the VkFormat used to create VkRenderingInfo::pStencilAttachment->imageView VUID-vkCmdExecuteGeneratedCommandsNV-dynamicRenderingUnusedAttachments-08918 If the current render pass instance was begun with vkCmdBeginRendering, the dynamicRenderingUnusedAttachments feature is enabled, VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, and the value of VkPipelineRenderingCreateInfo::stencilAttachmentFormat used to create the bound graphics pipeline was not equal to the VkFormat used to create VkRenderingInfo::pStencilAttachment->imageView, the value of the format must be VK_FORMAT_UNDEFINED VUID-vkCmdExecuteGeneratedCommandsNV-imageView-06183 If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingFragmentShadingRateAttachmentInfoKHR::imageView was not VK_NULL_HANDLE, the bound graphics pipeline must have been created with VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR VUID-vkCmdExecuteGeneratedCommandsNV-imageView-06184 If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingFragmentDensityMapAttachmentInfoEXT::imageView was not VK_NULL_HANDLE, the bound graphics pipeline must have been created with VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT VUID-vkCmdExecuteGeneratedCommandsNV-colorAttachmentCount-06185 If the bound pipeline was created with a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the current render pass instance was begun with vkCmdBeginRendering with a VkRenderingInfo::colorAttachmentCount parameter greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a sample count equal to the corresponding element of the pColorAttachmentSamples member of VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV used to create the bound graphics pipeline VUID-vkCmdExecuteGeneratedCommandsNV-pDepthAttachment-06186 If the current render pass instance was begun with vkCmdBeginRendering, the bound pipeline was created with a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of the depthStencilAttachmentSamples member of VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV used to create the bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pDepthAttachment->imageView VUID-vkCmdExecuteGeneratedCommandsNV-pStencilAttachment-06187 If the current render pass instance was begun with vkCmdBeginRendering, the bound pipeline was created with a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of the depthStencilAttachmentSamples member of VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV used to create the bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pStencilAttachment->imageView VUID-vkCmdExecuteGeneratedCommandsNV-multisampledRenderToSingleSampled-07285 If the bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the multisampledRenderToSingleSampled feature is not enabled, and the current render pass instance was begun with vkCmdBeginRendering with a VkRenderingInfo::colorAttachmentCount parameter greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a sample count equal to the value of rasterizationSamples for the bound graphics pipeline VUID-vkCmdExecuteGeneratedCommandsNV-multisampledRenderToSingleSampled-07286 If the bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the multisampledRenderToSingleSampled feature is not enabled, and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of rasterizationSamples for the bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pDepthAttachment->imageView VUID-vkCmdExecuteGeneratedCommandsNV-multisampledRenderToSingleSampled-07287 If the bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the multisampledRenderToSingleSampled feature is not enabled, and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of rasterizationSamples for the bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pStencilAttachment->imageView VUID-vkCmdExecuteGeneratedCommandsNV-pNext-07935 If this command has been called inside a render pass instance started with vkCmdBeginRendering, and the pNext chain of VkRenderingInfo includes a VkMultisampledRenderToSingleSampledInfoEXT structure with multisampledRenderToSingleSampledEnable equal to VK_TRUE, then the value of rasterizationSamples for the bound graphics pipeline must be equal to VkMultisampledRenderToSingleSampledInfoEXT::rasterizationSamples VUID-vkCmdExecuteGeneratedCommandsNV-renderPass-06198 If the current render pass instance was begun with vkCmdBeginRendering, the bound pipeline must have been created with a VkGraphicsPipelineCreateInfo::renderPass equal to VK_NULL_HANDLE VUID-vkCmdExecuteGeneratedCommandsNV-pColorAttachments-08963 If the current render pass instance was begun with vkCmdBeginRendering, there is a graphics pipeline bound with a fragment shader that statically writes to a color attachment, the color write mask is not zero, color writes are enabled, and the corresponding element of the VkRenderingInfo::pColorAttachments->imageView was not VK_NULL_HANDLE, then the corresponding element of VkPipelineRenderingCreateInfo::pColorAttachmentFormats used to create the pipeline must not be VK_FORMAT_UNDEFINED VUID-vkCmdExecuteGeneratedCommandsNV-pDepthAttachment-08964 If the current render pass instance was begun with vkCmdBeginRendering, there is a graphics pipeline bound, depth test is enabled, depth write is enabled, and the VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, then the VkPipelineRenderingCreateInfo::depthAttachmentFormat used to create the pipeline must not be VK_FORMAT_UNDEFINED VUID-vkCmdExecuteGeneratedCommandsNV-pStencilAttachment-08965 If the current render pass instance was begun with vkCmdBeginRendering, there is a graphics pipeline bound, stencil test is enabled and the VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, then the VkPipelineRenderingCreateInfo::stencilAttachmentFormat used to create the pipeline must not be VK_FORMAT_UNDEFINED VUID-vkCmdExecuteGeneratedCommandsNV-flags-10582 If the current render pass instance was begun with vkCmdBeginRendering, its VkRenderingInfo::flags parameter must not have VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT set unless VK_RENDERING_CONTENTS_INLINE_BIT_KHR is also set VUID-vkCmdExecuteGeneratedCommandsNV-primitivesGeneratedQueryWithRasterizerDiscard-06708 If the primitivesGeneratedQueryWithRasterizerDiscard feature is not enabled and the VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query is active, rasterization discard must not be enabled VUID-vkCmdExecuteGeneratedCommandsNV-primitivesGeneratedQueryWithNonZeroStreams-06709 If the primitivesGeneratedQueryWithNonZeroStreams feature is not enabled and the VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query is active, the bound graphics pipeline must not have been created with a non-zero value in VkPipelineRasterizationStateStreamCreateInfoEXT::rasterizationStream VUID-vkCmdExecuteGeneratedCommandsNV-None-07620 If the depthClamp feature is enabled, a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_DEPTH_CLAMP_ENABLE_EXT dynamic state enabled, and the current value of rasterizerDiscardEnable is VK_FALSE, then vkCmdSetDepthClampEnableEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-07621 If a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_POLYGON_MODE_EXT dynamic state enabled, and the current value of rasterizerDiscardEnable is VK_FALSE, then vkCmdSetPolygonModeEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-07622 If a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT dynamic state enabled, and the current value of rasterizerDiscardEnable is VK_FALSE, then vkCmdSetRasterizationSamplesEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-07623 If a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_SAMPLE_MASK_EXT dynamic state enabled, and the current value of rasterizerDiscardEnable is VK_FALSE, then vkCmdSetSampleMaskEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-alphaToCoverageEnable-08919 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT dynamic state enabled, and alphaToCoverageEnable was VK_TRUE in the last call to vkCmdSetAlphaToCoverageEnableEXT, then the Fragment Output Interface must contain a variable for the alpha Component word in Location 0 at Index 0 VUID-vkCmdExecuteGeneratedCommandsNV-alphaToCoverageEnable-08920 If a shader object is bound to any graphics stage, and the most recent call to vkCmdSetAlphaToCoverageEnableEXT in the current command buffer set alphaToCoverageEnable to VK_TRUE, then the Fragment Output Interface must contain a variable for the alpha Component word in Location 0 at Index 0 VUID-vkCmdExecuteGeneratedCommandsNV-None-07624 If a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT dynamic state enabled, and the current value of rasterizerDiscardEnable is VK_FALSE, then vkCmdSetAlphaToCoverageEnableEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-07625 If the alphaToOne feature is enabled, a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_ALPHA_TO_ONE_ENABLE_EXT dynamic state enabled, and the current value of rasterizerDiscardEnable is VK_FALSE, then vkCmdSetAlphaToOneEnableEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-07626 If the logicOp feature is enabled, a shader object is bound to the VK_SHADER_STAGE_FRAGMENT_BIT stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_LOGIC_OP_ENABLE_EXT dynamic state enabled, and the current value of rasterizerDiscardEnable is VK_FALSE, then vkCmdSetLogicOpEnableEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-07627 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT dynamic state enabled then vkCmdSetColorBlendEnableEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-08657 If a shader object is bound to the VK_SHADER_STAGE_FRAGMENT_BIT stage, and both the most recent call to vkCmdSetRasterizerDiscardEnable in the current command buffer set rasterizerDiscardEnable to VK_FALSE and there are color attachments bound, then vkCmdSetColorBlendEnableEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-07628 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT dynamic state enabled then vkCmdSetColorBlendEquationEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-08658 If a shader object is bound to the VK_SHADER_STAGE_FRAGMENT_BIT stage, and the most recent call to vkCmdSetRasterizerDiscardEnable in the current command buffer set rasterizerDiscardEnable to VK_FALSE, and the most recent call to vkCmdSetColorBlendEnableEXT for any attachment set that attachment’s value in pColorBlendEnables to VK_TRUE, then vkCmdSetColorBlendEquationEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-07629 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT dynamic state enabled then vkCmdSetColorWriteMaskEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-08659 If a shader object is bound to the VK_SHADER_STAGE_FRAGMENT_BIT stage, and both the most recent call to vkCmdSetRasterizerDiscardEnable in the current command buffer set rasterizerDiscardEnable to VK_FALSE and there are color attachments bound, then vkCmdSetColorWriteMaskEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-07630 If the geometryStreams feature is enabled, and a shader object is bound to the VK_SHADER_STAGE_GEOMETRY_BIT stage or a graphics pipeline is bound which was created with both a VK_SHADER_STAGE_GEOMETRY_BIT stage and the VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT dynamic state enabled, then vkCmdSetRasterizationStreamEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-07631 If the VK_EXT_conservative_rasterization extension is enabled, a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT dynamic state enabled, and the current value of rasterizerDiscardEnable is VK_FALSE, then vkCmdSetConservativeRasterizationModeEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-07632 If the VK_EXT_conservative_rasterization extension is enabled, a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_EXTRA_PRIMITIVE_OVERESTIMATION_SIZE_EXT dynamic state enabled, the current value of rasterizerDiscardEnable is VK_FALSE, and the current value of conservativeRasterizationMode is VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT, then vkCmdSetExtraPrimitiveOverestimationSizeEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-07633 If the depthClipEnable feature is enabled, and a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_DEPTH_CLIP_ENABLE_EXT dynamic state, then vkCmdSetDepthClipEnableEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-07635 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT dynamic state enabled then vkCmdSetColorBlendAdvancedEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-rasterizerDiscardEnable-09416 If the VK_EXT_blend_operation_advanced extension is enabled, and a shader object is bound to the VK_SHADER_STAGE_FRAGMENT_BIT stage, and the most recent call to vkCmdSetRasterizerDiscardEnable in the current command buffer set rasterizerDiscardEnable to VK_FALSE, then at least one of vkCmdSetColorBlendEquationEXT and vkCmdSetColorBlendAdvancedEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-07636 If the VK_EXT_provoking_vertex extension is enabled, a shader object is bound to the VK_SHADER_STAGE_VERTEX_BIT stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_PROVOKING_VERTEX_MODE_EXT dynamic state enabled, and the current value of rasterizerDiscardEnable is VK_FALSE, then vkCmdSetProvokingVertexModeEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-07637 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic state enabled then vkCmdSetLineRasterizationModeEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-08666 If any of the stippledRectangularLines, stippledBresenhamLines or stippledSmoothLines features are enabled, and a shader object is bound to any graphics stage, and the most recent call to vkCmdSetRasterizerDiscardEnable in the current command buffer set rasterizerDiscardEnable to VK_FALSE, and the most recent call to vkCmdSetPolygonModeEXT in the current command buffer set polygonMode to VK_POLYGON_MODE_LINE, then vkCmdSetLineRasterizationModeEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-08667 If any of the stippledRectangularLines, stippledBresenhamLines or stippledSmoothLines features are enabled, and a shader object is bound to the VK_SHADER_STAGE_VERTEX_BIT stage, and the most recent call to vkCmdSetRasterizerDiscardEnable in the current command buffer set rasterizerDiscardEnable to VK_FALSE, and the most recent call to vkCmdSetPrimitiveTopology in the current command buffer set primitiveTopology to any line topology, then vkCmdSetLineRasterizationModeEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-08668 If any of the stippledRectangularLines, stippledBresenhamLines or stippledSmoothLines features are enabled, and a shader object that outputs line primitives is bound to the VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT or VK_SHADER_STAGE_GEOMETRY_BIT stage, and the most recent call to vkCmdSetRasterizerDiscardEnable in the current command buffer set rasterizerDiscardEnable to VK_FALSE, then vkCmdSetLineRasterizationModeEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-07638 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT dynamic state enabled then vkCmdSetLineStippleEnableEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-08669 If any of the stippledRectangularLines, stippledBresenhamLines or stippledSmoothLines features are enabled, and a shader object is bound to any graphics stage, and the most recent call to vkCmdSetRasterizerDiscardEnable in the current command buffer set rasterizerDiscardEnable to VK_FALSE, and the most recent call to vkCmdSetPolygonModeEXT in the current command buffer set polygonMode to VK_POLYGON_MODE_LINE, then vkCmdSetLineStippleEnableEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-08670 If any of the stippledRectangularLines, stippledBresenhamLines or stippledSmoothLines features are enabled, and a shader object is bound to the VK_SHADER_STAGE_VERTEX_BIT stage, and the most recent call to vkCmdSetRasterizerDiscardEnable in the current command buffer set rasterizerDiscardEnable to VK_FALSE, and the most recent call to vkCmdSetPrimitiveTopology in the current command buffer set primitiveTopology to any line topology, then vkCmdSetLineStippleEnableEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-08671 If any of the stippledRectangularLines, stippledBresenhamLines or stippledSmoothLines features are enabled, and a shader object that outputs line primitives is bound to the VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT or VK_SHADER_STAGE_GEOMETRY_BIT stage, and the most recent call to vkCmdSetRasterizerDiscardEnable in the current command buffer set rasterizerDiscardEnable to VK_FALSE, then vkCmdSetLineStippleEnableEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-07849 If any of the stippledRectangularLines, stippledBresenhamLines or stippledSmoothLines features are enabled and a shader object is bound to any graphics stage, or a bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE dynamic state enabled, the current value of rasterizerDiscardEnable is VK_FALSE, and the current value of stippledLineEnable is VK_TRUE, then vkCmdSetLineStipple must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-10608 If a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic state enabled, and the current lineRasterizationMode is VK_LINE_RASTERIZATION_MODE_BRESENHAM or VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH, then the current alphaToCoverageEnable, alphaToOneEnable and sampleShadingEnable states must all be VK_FALSE VUID-vkCmdExecuteGeneratedCommandsNV-None-07639 If the depthClipControl feature is enabled, and a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_DEPTH_CLIP_NEGATIVE_ONE_TO_ONE_EXT dynamic state enabled, then vkCmdSetDepthClipNegativeOneToOneEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-09650 If the depthClampControl feature is enabled, and a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_DEPTH_CLAMP_RANGE_EXT dynamic state enabled, and the current value of depthClampEnable is VK_TRUE, then vkCmdSetDepthClampRangeEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-07640 If the VK_NV_clip_space_w_scaling extension is enabled, and a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_ENABLE_NV dynamic state enabled, then vkCmdSetViewportWScalingEnableNV must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-07641 If the VK_NV_viewport_swizzle extension is enabled, and a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV dynamic state enabled, then vkCmdSetViewportSwizzleNV must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-07642 If the VK_NV_fragment_coverage_to_color extension is enabled, a shader object is bound to the VK_SHADER_STAGE_FRAGMENT_BIT stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV dynamic state enabled, and the current value of rasterizerDiscardEnable is VK_FALSE, then vkCmdSetCoverageToColorEnableNV must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-07643 If the VK_NV_fragment_coverage_to_color extension is enabled, a shader object is bound to the VK_SHADER_STAGE_FRAGMENT_BIT stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_LOCATION_NV dynamic state enabled, the current value of rasterizerDiscardEnable is VK_FALSE, and the current value of coverageToColorEnable is VK_TRUE, then vkCmdSetCoverageToColorLocationNV must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-07644 If the VK_NV_framebuffer_mixed_samples extension is enabled, a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_COVERAGE_MODULATION_MODE_NV dynamic state enabled, and the current value of rasterizerDiscardEnable is VK_FALSE, then vkCmdSetCoverageModulationModeNV must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-07645 If the VK_NV_framebuffer_mixed_samples extension is enabled, a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV dynamic state enabled, the current value of rasterizerDiscardEnable is VK_FALSE, and the current value of coverageModulationMode is any value other than VK_COVERAGE_MODULATION_MODE_NONE_NV, then vkCmdSetCoverageModulationTableEnableNV must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-07646 If the VK_NV_framebuffer_mixed_samples extension is enabled, a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_NV dynamic state enabled, the current value of rasterizerDiscardEnable is VK_FALSE, and the current value of coverageModulationTableEnable is VK_TRUE, then vkCmdSetCoverageModulationTableNV must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-07647 If the shadingRateImage feature is enabled, a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_SHADING_RATE_IMAGE_ENABLE_NV dynamic state enabled, and the current value of rasterizerDiscardEnable is VK_FALSE, then vkCmdSetShadingRateImageEnableNV must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-pipelineFragmentShadingRate-09238 If the pipelineFragmentShadingRate feature is enabled, a shader object is bound to the VK_SHADER_STAGE_FRAGMENT_BIT stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR dynamic state enabled, and the current value of rasterizerDiscardEnable is VK_FALSE, then vkCmdSetFragmentShadingRateKHR must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-07648 If the representativeFragmentTest feature is enabled, a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_REPRESENTATIVE_FRAGMENT_TEST_ENABLE_NV dynamic state enabled, and the current value of rasterizerDiscardEnable is VK_FALSE, then vkCmdSetRepresentativeFragmentTestEnableNV must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-07649 If the coverageReductionMode feature is enabled, a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_COVERAGE_REDUCTION_MODE_NV dynamic state enabled, and the current value of rasterizerDiscardEnable is VK_FALSE, then vkCmdSetCoverageReductionModeNV must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-pColorBlendEnables-07470 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT state enabled and the last call to vkCmdSetColorBlendEnableEXT set pColorBlendEnables for any attachment to VK_TRUE, then for those attachments in the subpass the corresponding image view’s format features must contain VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT VUID-vkCmdExecuteGeneratedCommandsNV-rasterizationSamples-07471 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, and the current subpass does not use any color and/or depth/stencil attachments, then the rasterizationSamples in the last call to vkCmdSetRasterizationSamplesEXT must follow the rules for a zero-attachment subpass VUID-vkCmdExecuteGeneratedCommandsNV-samples-07472 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_MASK_EXT state enabled and the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state disabled, then the samples parameter in the last call to vkCmdSetSampleMaskEXT must be greater or equal to the VkPipelineMultisampleStateCreateInfo::rasterizationSamples parameter used to create the bound graphics pipeline VUID-vkCmdExecuteGeneratedCommandsNV-samples-07473 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_MASK_EXT state and VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT states enabled, then the samples parameter in the last call to vkCmdSetSampleMaskEXT must be greater or equal to the rasterizationSamples parameter in the last call to vkCmdSetRasterizationSamplesEXT VUID-vkCmdExecuteGeneratedCommandsNV-rasterizationSamples-07474 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, and the multisampledRenderToSingleSampled feature is not enabled, and neither the VK_AMD_mixed_attachment_samples nor the VK_NV_framebuffer_mixed_samples extensions are enabled, then the rasterizationSamples in the last call to vkCmdSetRasterizationSamplesEXT must be the same as the current subpass color and/or depth/stencil attachments VUID-vkCmdExecuteGeneratedCommandsNV-None-09211 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, or a shader object is bound to any graphics stage, and the current render pass instance includes a VkMultisampledRenderToSingleSampledInfoEXT structure with multisampledRenderToSingleSampledEnable equal to VK_TRUE, then the rasterizationSamples in the last call to vkCmdSetRasterizationSamplesEXT must be the same as the rasterizationSamples member of that structure VUID-vkCmdExecuteGeneratedCommandsNV-firstAttachment-07476 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT dynamic state enabled then vkCmdSetColorBlendEnableEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorBlendEnableEXT calls must specify an enable for all active color attachments in the current subpass VUID-vkCmdExecuteGeneratedCommandsNV-rasterizerDiscardEnable-09417 If a shader object is bound to the VK_SHADER_STAGE_FRAGMENT_BIT stage, and the most recent call to vkCmdSetRasterizerDiscardEnable in the current command buffer set rasterizerDiscardEnable to VK_FALSE, then vkCmdSetColorBlendEnableEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorBlendEnableEXT calls must specify an enable for all active color attachments in the current subpass VUID-vkCmdExecuteGeneratedCommandsNV-firstAttachment-07477 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT dynamic state enabled then vkCmdSetColorBlendEquationEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorBlendEquationEXT calls must specify the blend equations for all active color attachments in the current subpass where blending is enabled VUID-vkCmdExecuteGeneratedCommandsNV-rasterizerDiscardEnable-09418 If a shader object is bound to the VK_SHADER_STAGE_FRAGMENT_BIT stage, and both the most recent call to vkCmdSetRasterizerDiscardEnable in the current command buffer set rasterizerDiscardEnable to VK_FALSE and there are color attachments bound, then vkCmdSetColorBlendEquationEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorBlendEquationEXT calls must specify the blend equations for all active color attachments in the current subpass where blending is enabled VUID-vkCmdExecuteGeneratedCommandsNV-firstAttachment-07478 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT dynamic state enabled then vkCmdSetColorWriteMaskEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorWriteMaskEXT calls must specify the color write mask for all active color attachments in the current subpass VUID-vkCmdExecuteGeneratedCommandsNV-rasterizerDiscardEnable-09419 If a shader object is bound to the VK_SHADER_STAGE_FRAGMENT_BIT stage, and the most recent call to vkCmdSetRasterizerDiscardEnable in the current command buffer set rasterizerDiscardEnable to VK_FALSE, then vkCmdSetColorWriteMaskEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorWriteMaskEXT calls must specify the color write mask for all active color attachments in the current subpass VUID-vkCmdExecuteGeneratedCommandsNV-firstAttachment-07479 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT dynamic state enabled then vkCmdSetColorBlendAdvancedEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorBlendAdvancedEXT calls must specify the advanced blend equations for all active color attachments in the current subpass where blending is enabled VUID-vkCmdExecuteGeneratedCommandsNV-advancedBlendMaxColorAttachments-07480 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT and VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT dynamic states enabled and the last calls to vkCmdSetColorBlendEnableEXT and vkCmdSetColorBlendAdvancedEXT have enabled advanced blending, then the number of active color attachments in the current subpass must not exceed advancedBlendMaxColorAttachments VUID-vkCmdExecuteGeneratedCommandsNV-primitivesGeneratedQueryWithNonZeroStreams-07481 If the primitivesGeneratedQueryWithNonZeroStreams feature is not enabled and the VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query is active, and the bound graphics pipeline was created with VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT state enabled, the last call to vkCmdSetRasterizationStreamEXT must have set the rasterizationStream to zero VUID-vkCmdExecuteGeneratedCommandsNV-sampleLocationsPerPixel-07482 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state disabled, and the current value of sampleLocationsEnable is VK_TRUE, then the sampleLocationsPerPixel member of pSampleLocationsInfo in the last call to vkCmdSetSampleLocationsEXT must equal the rasterizationSamples member of the VkPipelineMultisampleStateCreateInfo structure the bound graphics pipeline has been created with VUID-vkCmdExecuteGeneratedCommandsNV-sampleLocationsPerPixel-07483 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, and the current value of sampleLocationsEnable is VK_TRUE, then the sampleLocationsPerPixel member of pSampleLocationsInfo in the last call to vkCmdSetSampleLocationsEXT must equal the rasterizationSamples parameter of the last call to vkCmdSetRasterizationSamplesEXT VUID-vkCmdExecuteGeneratedCommandsNV-sampleLocationsEnable-07484 If a shader object is bound to the VK_SHADER_STAGE_FRAGMENT_BIT stage, or the bound graphics pipeline was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set VUID-vkCmdExecuteGeneratedCommandsNV-sampleLocationsEnable-07485 If a shader object is bound to the VK_SHADER_STAGE_FRAGMENT_BIT stage, or the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and if sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, then the sampleLocationsInfo.maxSampleLocationGridSize.width in the last call to vkCmdSetSampleLocationsEXT must evenly divide VkMultisamplePropertiesEXT::maxSampleLocationGridSize.width as returned by vkGetPhysicalDeviceMultisamplePropertiesEXT with a samples parameter equaling rasterizationSamples VUID-vkCmdExecuteGeneratedCommandsNV-sampleLocationsEnable-07486 If a shader object is bound to the VK_SHADER_STAGE_FRAGMENT_BIT stage, or the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and if sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, then the sampleLocationsInfo.maxSampleLocationGridSize.height in the last call to vkCmdSetSampleLocationsEXT must evenly divide VkMultisamplePropertiesEXT::maxSampleLocationGridSize.height as returned by vkGetPhysicalDeviceMultisamplePropertiesEXT with a samples parameter equaling rasterizationSamples VUID-vkCmdExecuteGeneratedCommandsNV-sampleLocationsEnable-07487 If a shader object is bound to the VK_SHADER_STAGE_FRAGMENT_BIT stage, or the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and if sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, the fragment shader code must not statically use the extended instruction InterpolateAtSample VUID-vkCmdExecuteGeneratedCommandsNV-sampleLocationsEnable-07936 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state disabled and the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, and the current value of sampleLocationsEnable is VK_TRUE, then sampleLocationsInfo.sampleLocationGridSize.width must evenly divide VkMultisamplePropertiesEXT::maxSampleLocationGridSize.width as returned by vkGetPhysicalDeviceMultisamplePropertiesEXT with a samples parameter equaling the value of rasterizationSamples in the last call to vkCmdSetRasterizationSamplesEXT VUID-vkCmdExecuteGeneratedCommandsNV-sampleLocationsEnable-07937 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state disabled and the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, and the current value of sampleLocationsEnable is VK_TRUE, then sampleLocationsInfo.sampleLocationGridSize.height must evenly divide VkMultisamplePropertiesEXT::maxSampleLocationGridSize.height as returned by vkGetPhysicalDeviceMultisamplePropertiesEXT with a samples parameter equaling the value of rasterizationSamples in the last call to vkCmdSetRasterizationSamplesEXT VUID-vkCmdExecuteGeneratedCommandsNV-sampleLocationsEnable-07938 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state disabled and the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, and the current value of sampleLocationsEnable is VK_TRUE, then sampleLocationsInfo.sampleLocationsPerPixel must equal rasterizationSamples in the last call to vkCmdSetRasterizationSamplesEXT VUID-vkCmdExecuteGeneratedCommandsNV-coverageModulationTableEnable-07488 If a shader object is bound to any graphics stage or the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV state enabled, and the last call to vkCmdSetCoverageModulationTableEnableNV set coverageModulationTableEnable to VK_TRUE, then the coverageModulationTableCount parameter in the last call to vkCmdSetCoverageModulationTableNV must equal the current rasterizationSamples divided by the number of color samples in the current subpass VUID-vkCmdExecuteGeneratedCommandsNV-rasterizationSamples-07489 If the VK_NV_framebuffer_mixed_samples extension is enabled, and if current subpass has a depth/stencil attachment and depth test, stencil test, or depth bounds test are enabled in the bound pipeline, then the current rasterizationSamples must be the same as the sample count of the depth/stencil attachment VUID-vkCmdExecuteGeneratedCommandsNV-coverageToColorEnable-07490 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV state enabled and the last call to vkCmdSetCoverageToColorEnableNV set the coverageToColorEnable to VK_TRUE, then the current subpass must have a color attachment at the location selected by the last call to vkCmdSetCoverageToColorLocationNV coverageToColorLocation, with a VkFormat of VK_FORMAT_R8_UINT, VK_FORMAT_R8_SINT, VK_FORMAT_R16_UINT, VK_FORMAT_R16_SINT, VK_FORMAT_R32_UINT, or VK_FORMAT_R32_SINT VUID-vkCmdExecuteGeneratedCommandsNV-rasterizerDiscardEnable-09420 If the VK_NV_fragment_coverage_to_color extension is enabled, and a shader object is bound to the VK_SHADER_STAGE_FRAGMENT_BIT stage, and the most recent call to vkCmdSetRasterizerDiscardEnable in the current command buffer set rasterizerDiscardEnable to VK_FALSE, and the last call to vkCmdSetCoverageToColorEnableNV set the coverageToColorEnable to VK_TRUE, then the current subpass must have a color attachment at the location selected by the last call to vkCmdSetCoverageToColorLocationNV coverageToColorLocation, with a VkFormat of VK_FORMAT_R8_UINT, VK_FORMAT_R8_SINT, VK_FORMAT_R16_UINT, VK_FORMAT_R16_SINT, VK_FORMAT_R32_UINT, or VK_FORMAT_R32_SINT VUID-vkCmdExecuteGeneratedCommandsNV-coverageReductionMode-07491 If the coverageReductionMode feature is enabled, a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_COVERAGE_REDUCTION_MODE_NV or VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT dynamic states enabled, then the current values of coverageReductionMode, rasterizationSamples, the sample counts for the color and depth/stencil attachments (if the subpass has them) must be a valid combination returned by vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV VUID-vkCmdExecuteGeneratedCommandsNV-viewportCount-07492 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV dynamic state enabled, then the bound graphics pipeline must have been created with VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount VUID-vkCmdExecuteGeneratedCommandsNV-viewportCount-07493 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV dynamic states enabled then the viewportCount parameter in the last call to vkCmdSetViewportSwizzleNV must be greater than or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount VUID-vkCmdExecuteGeneratedCommandsNV-viewportCount-09421 If the VK_NV_viewport_swizzle extension is enabled, and a shader object is bound to any graphics stage, then the viewportCount parameter in the last call to vkCmdSetViewportSwizzleNV must be greater than or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount VUID-vkCmdExecuteGeneratedCommandsNV-rasterizationSamples-07494 If the VK_NV_framebuffer_mixed_samples extension is enabled, and the coverageReductionMode feature is not enabled, or the current value of coverageReductionMode is not VK_COVERAGE_REDUCTION_MODE_TRUNCATE_NV, and the current value of rasterizationSamples is greater than sample count of the color attachment, then sample shading must be disabled VUID-vkCmdExecuteGeneratedCommandsNV-stippledLineEnable-07495 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_RECTANGULAR, then the stippledRectangularLines feature must be enabled VUID-vkCmdExecuteGeneratedCommandsNV-stippledLineEnable-07496 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_BRESENHAM, then the stippledBresenhamLines feature must be enabled VUID-vkCmdExecuteGeneratedCommandsNV-stippledLineEnable-07497 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH, then the stippledSmoothLines feature must be enabled VUID-vkCmdExecuteGeneratedCommandsNV-stippledLineEnable-07498 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_DEFAULT, then the stippledRectangularLines feature must be enabled and VkPhysicalDeviceLimits::strictLines must be VK_TRUE VUID-vkCmdExecuteGeneratedCommandsNV-conservativePointAndLineRasterization-07499 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT dynamic state enabled, conservativePointAndLineRasterization is not supported, and the effective primitive topology output by the last pre-rasterization shader stage is a line or point, then the conservativeRasterizationMode set by the last call to vkCmdSetConservativeRasterizationModeEXT must be VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT VUID-vkCmdExecuteGeneratedCommandsNV-stage-07073 If the bound pipeline was created with the VkPipelineShaderStageCreateInfo::stage member of an element of VkGraphicsPipelineCreateInfo::pStages set to VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT or VK_SHADER_STAGE_GEOMETRY_BIT, then Mesh Shader Queries must not be active VUID-vkCmdExecuteGeneratedCommandsNV-None-08877 If a shader object is bound to the VK_SHADER_STAGE_FRAGMENT_BIT stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT dynamic state enabled, and the current value of rasterizerDiscardEnable is VK_FALSE, then vkCmdSetAttachmentFeedbackLoopEnableEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-07850 If dynamic state was inherited from VkCommandBufferInheritanceViewportScissorInfoNV, it must be set in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-nextStage-10745 For each shader object bound to a graphics stage, except for shader object bound to the last graphics stage in the logical pipeline, it must have been created with a nextStage including the corresponding bit to the shader object bound to the following graphics stage in the logical pipeline VUID-vkCmdExecuteGeneratedCommandsNV-None-08684 If there is no bound graphics pipeline, vkCmdBindShadersEXT must have been called in the current command buffer with pStages with an element of VK_SHADER_STAGE_VERTEX_BIT VUID-vkCmdExecuteGeneratedCommandsNV-None-08685 If there is no bound graphics pipeline, and the tessellationShader feature is enabled, vkCmdBindShadersEXT must have been called in the current command buffer with pStages with an element of VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT VUID-vkCmdExecuteGeneratedCommandsNV-None-08686 If there is no bound graphics pipeline, and the tessellationShader feature is enabled, vkCmdBindShadersEXT must have been called in the current command buffer with pStages with an element of VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT VUID-vkCmdExecuteGeneratedCommandsNV-None-08687 If there is no bound graphics pipeline, and the geometryShader feature is enabled, vkCmdBindShadersEXT must have been called in the current command buffer with pStages with an element of VK_SHADER_STAGE_GEOMETRY_BIT VUID-vkCmdExecuteGeneratedCommandsNV-None-08688 If there is no bound graphics pipeline, vkCmdBindShadersEXT must have been called in the current command buffer with pStages with an element of VK_SHADER_STAGE_FRAGMENT_BIT VUID-vkCmdExecuteGeneratedCommandsNV-None-08689 If there is no bound graphics pipeline, and the taskShader feature is enabled, vkCmdBindShadersEXT must have been called in the current command buffer with pStages with an element of VK_SHADER_STAGE_TASK_BIT_EXT VUID-vkCmdExecuteGeneratedCommandsNV-None-08690 If there is no bound graphics pipeline, and the meshShader feature is enabled, vkCmdBindShadersEXT must have been called in the current command buffer with pStages with an element of VK_SHADER_STAGE_MESH_BIT_EXT VUID-vkCmdExecuteGeneratedCommandsNV-None-08693 If there is no bound graphics pipeline, and at least one of the taskShader and meshShader features is enabled, one of the VK_SHADER_STAGE_VERTEX_BIT or VK_SHADER_STAGE_MESH_BIT_EXT stages must have a valid VkShaderEXT bound, and the other must have no VkShaderEXT bound VUID-vkCmdExecuteGeneratedCommandsNV-None-08696 If there is no bound graphics pipeline, and a valid VkShaderEXT is bound to the VK_SHADER_STAGE_VERTEX_BIT stage, there must be no VkShaderEXT bound to either the VK_SHADER_STAGE_TASK_BIT_EXT stage or the VK_SHADER_STAGE_MESH_BIT_EXT stage VUID-vkCmdExecuteGeneratedCommandsNV-None-08698 If any graphics shader is bound which was created with the VK_SHADER_CREATE_LINK_STAGE_BIT_EXT flag, then all shaders created with the VK_SHADER_CREATE_LINK_STAGE_BIT_EXT flag in the same vkCreateShadersEXT call must also be bound VUID-vkCmdExecuteGeneratedCommandsNV-None-08699 If any graphics shader is bound which was created with the VK_SHADER_CREATE_LINK_STAGE_BIT_EXT flag, any stages in between stages whose shaders which did not create a shader with the VK_SHADER_CREATE_LINK_STAGE_BIT_EXT flag as part of the same vkCreateShadersEXT call must not have any VkShaderEXT bound VUID-vkCmdExecuteGeneratedCommandsNV-None-08878 All bound graphics shader objects must have been created with identical or identically defined push constant ranges VUID-vkCmdExecuteGeneratedCommandsNV-None-08879 All bound graphics shader objects must have been created with identical or identically defined arrays of descriptor set layouts VUID-vkCmdExecuteGeneratedCommandsNV-colorAttachmentCount-09372 If the current render pass instance was begun with vkCmdBeginRendering and a VkRenderingInfo::colorAttachmentCount equal to 1, a color attachment with a resolve mode of VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID, and a fragment shader is bound, it must not declare the DepthReplacing or StencilRefReplacingEXT execution modes VUID-vkCmdExecuteGeneratedCommandsNV-pDynamicStates-08715 If the bound graphics pipeline state includes a fragment shader stage, was created with VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE set in VkPipelineDynamicStateCreateInfo::pDynamicStates, and the fragment shader declares the EarlyFragmentTests execution mode and uses OpDepthAttachmentReadEXT, the depthWriteEnable parameter in the last call to vkCmdSetDepthWriteEnable must be VK_FALSE VUID-vkCmdExecuteGeneratedCommandsNV-pDynamicStates-08716 If the bound graphics pipeline state includes a fragment shader stage, was created with VK_DYNAMIC_STATE_STENCIL_WRITE_MASK set in VkPipelineDynamicStateCreateInfo::pDynamicStates, and the fragment shader declares the EarlyFragmentTests execution mode and uses OpStencilAttachmentReadEXT, the writeMask parameter in the last call to vkCmdSetStencilWriteMask must be 0 VUID-vkCmdExecuteGeneratedCommandsNV-None-09116 If a shader object is bound to any graphics stage or the bound graphics pipeline was created with VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, and the format of any color attachment is VK_FORMAT_E5B9G9R9_UFLOAT_PACK32, the corresponding element of the pColorWriteMasks parameter of vkCmdSetColorWriteMaskEXT must either include all of VK_COLOR_COMPONENT_R_BIT, VK_COLOR_COMPONENT_G_BIT, and VK_COLOR_COMPONENT_B_BIT, or none of them VUID-vkCmdExecuteGeneratedCommandsNV-maxFragmentDualSrcAttachments-09239 If blending is enabled for any attachment where either the source or destination blend factors for that attachment use the secondary color input, the maximum value of Location for any output attachment statically used in the Fragment Execution Model executed by this command must be less than maxFragmentDualSrcAttachments VUID-vkCmdExecuteGeneratedCommandsNV-None-09548 If the current render pass was begun with vkCmdBeginRendering, and there is no shader object bound to any graphics stage, the value of each element of VkRenderingAttachmentLocationInfo::pColorAttachmentLocations set by vkCmdSetRenderingAttachmentLocations must match the value set for the corresponding element in the bound pipeline VUID-vkCmdExecuteGeneratedCommandsNV-None-09549 If the current render pass was begun with vkCmdBeginRendering, and there is no shader object bound to any graphics stage, input attachment index mappings in the bound pipeline must match those set for the current render pass instance via VkRenderingInputAttachmentIndexInfo VUID-vkCmdExecuteGeneratedCommandsNV-None-09642 If the current render pass was begun with vkCmdBeginRendering with the VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT flag, the bound graphics pipeline must have been created with VK_PIPELINE_CREATE_2_ENABLE_LEGACY_DITHERING_BIT_EXT VUID-vkCmdExecuteGeneratedCommandsNV-None-09643 If the bound graphics pipeline was created with VK_PIPELINE_CREATE_2_ENABLE_LEGACY_DITHERING_BIT_EXT, the current render pass must have begun with vkCmdBeginRendering with the VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT flag VUID-vkCmdExecuteGeneratedCommandsNV-None-10677 If the per-tile execution model is enabled, the tileShadingPerTileDraw feature must be enabled VUID-vkCmdExecuteGeneratedCommandsNV-None-04007 All vertex input bindings accessed via vertex input variables declared in the vertex shader entry point’s interface must have either valid or VK_NULL_HANDLE buffers bound VUID-vkCmdExecuteGeneratedCommandsNV-None-04008 If the nullDescriptor feature is not enabled, all vertex input bindings accessed via vertex input variables declared in the vertex shader entry point’s interface must not be VK_NULL_HANDLE VUID-vkCmdExecuteGeneratedCommandsNV-None-02721 If the robustBufferAccess feature is not enabled, and that pipeline was created without enabling VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS for vertexInputs, then for a given vertex buffer binding, any attribute data fetched must be entirely contained within the corresponding vertex buffer binding, as described in Vertex Input Description VUID-vkCmdExecuteGeneratedCommandsNV-format-10389 For each vertex attribute accessed by this command, if its VkVertexInputAttributeDescription::format or VkVertexInputAttributeDescription2EXT::format is a packed format, and legacyVertexAttributes is not enabled, the value of attribAddress, calculated as described in Vertex Input Calculation, must be a multiple of the size of the format VUID-vkCmdExecuteGeneratedCommandsNV-format-10390 For each vertex attribute accessed by this command, if its VkVertexInputAttributeDescription::format or VkVertexInputAttributeDescription2EXT::format is not a packed format, and either legacyVertexAttributes is not enabled or format has 64-bit components, the value of attribAddress, calculated as described in Vertex Input Calculation, must be a multiple of the component size of the format VUID-vkCmdExecuteGeneratedCommandsNV-None-07842 If there is a shader object bound to the VK_SHADER_STAGE_VERTEX_BIT stage or the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY dynamic state enabled then vkCmdSetPrimitiveTopology must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-dynamicPrimitiveTopologyUnrestricted-07500 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY dynamic state enabled and the dynamicPrimitiveTopologyUnrestricted is VK_FALSE, then the primitiveTopology parameter of vkCmdSetPrimitiveTopology must be of the same topology class as the pipeline VkPipelineInputAssemblyStateCreateInfo::topology state VUID-vkCmdExecuteGeneratedCommandsNV-primitiveTopology-10286 If a VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT stage is bound, then the current value of primitiveTopology must be VK_PRIMITIVE_TOPOLOGY_PATCH_LIST prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-primitiveTopology-10747 If vkCmdSetPrimitiveTopology set primitiveTopology to VK_PRIMITIVE_TOPOLOGY_PATCH_LIST prior to this drawing command, then a VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT stage must be bound VUID-vkCmdExecuteGeneratedCommandsNV-primitiveTopology-10748 If vkCmdSetPrimitiveTopology set primitiveTopology to VK_PRIMITIVE_TOPOLOGY_POINT_LIST prior to this drawing command, the maintenance5 feature is not enabled, both a VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT and VK_SHADER_STAGE_GEOMETRY_BIT stage are not bound, then the Vertex Execution Model must have a PointSize decorated variable that is statically written to VUID-vkCmdExecuteGeneratedCommandsNV-pStrides-04913 If the bound graphics pipeline was created with the VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE dynamic state enabled, but without the VK_DYNAMIC_STATE_VERTEX_INPUT_EXT dynamic state enabled, then vkCmdBindVertexBuffers2 must have been called and not subsequently invalidated in the current command buffer prior to this draw command, and the pStrides parameter of vkCmdBindVertexBuffers2 must not be NULL VUID-vkCmdExecuteGeneratedCommandsNV-None-04914 If there is a shader object bound to the VK_SHADER_STAGE_VERTEX_BIT stage or the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VERTEX_INPUT_EXT dynamic state enabled then vkCmdSetVertexInputEXT must have been called and not subsequently invalidated in the current command buffer prior to this draw command VUID-vkCmdExecuteGeneratedCommandsNV-Input-07939 If vertexAttributeRobustness is not enabled and there is a shader object bound to the VK_SHADER_STAGE_VERTEX_BIT stage or the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VERTEX_INPUT_EXT dynamic state enabled then all variables with the Input storage class decorated with Location in the Vertex Execution Model OpEntryPoint must contain a location in VkVertexInputAttributeDescription2EXT::location VUID-vkCmdExecuteGeneratedCommandsNV-Input-08734 If there is a shader object bound to the VK_SHADER_STAGE_VERTEX_BIT stage or the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VERTEX_INPUT_EXT dynamic state enabled and either the legacyVertexAttributes feature is not enabled or the SPIR-V Type associated with a given Input variable of the corresponding Location in the Vertex Execution Model OpEntryPoint is 64-bit, then the numeric type associated with all Input variables of the corresponding Location in the Vertex Execution Model OpEntryPoint must be the same as VkVertexInputAttributeDescription2EXT::format VUID-vkCmdExecuteGeneratedCommandsNV-format-08936 If there is a shader object bound to the VK_SHADER_STAGE_VERTEX_BIT stage or the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VERTEX_INPUT_EXT dynamic state enabled and VkVertexInputAttributeDescription2EXT::format has a 64-bit component, then the scalar width associated with all Input variables of the corresponding Location in the Vertex Execution Model OpEntryPoint must be 64-bit VUID-vkCmdExecuteGeneratedCommandsNV-format-08937 If there is a shader object bound to the VK_SHADER_STAGE_VERTEX_BIT stage or the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VERTEX_INPUT_EXT dynamic state enabled and the scalar width associated with a Location decorated Input variable in the Vertex Execution Model OpEntryPoint is 64-bit, then the corresponding VkVertexInputAttributeDescription2EXT::format must have a 64-bit component VUID-vkCmdExecuteGeneratedCommandsNV-None-09203 If there is a shader object bound to the VK_SHADER_STAGE_VERTEX_BIT stage or the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VERTEX_INPUT_EXT dynamic state enabled and VkVertexInputAttributeDescription2EXT::format has a 64-bit component, then all Input variables at the corresponding Location in the Vertex Execution Model OpEntryPoint must not use components that are not present in the format VUID-vkCmdExecuteGeneratedCommandsNV-None-04875 If there is a shader object bound to the VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT stage or the bound graphics pipeline state was created with both a VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT stage and the VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT dynamic state enabled, and the current value of primitiveTopology is VK_PRIMITIVE_TOPOLOGY_PATCH_LIST, then vkCmdSetPatchControlPointsEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-04879 If there is a shader object bound to the VK_SHADER_STAGE_VERTEX_BIT stage or the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE dynamic state enabled then vkCmdSetPrimitiveRestartEnable must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-None-09637 If the primitiveTopologyListRestart feature is not enabled, the topology is VK_PRIMITIVE_TOPOLOGY_POINT_LIST, VK_PRIMITIVE_TOPOLOGY_LINE_LIST, VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST, VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY, or VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY, there is a shader object bound to the VK_SHADER_STAGE_VERTEX_BIT stage or the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE dynamic state enabled then vkCmdSetPrimitiveRestartEnable must be VK_FALSE VUID-vkCmdExecuteGeneratedCommandsNV-stage-06481 The bound graphics pipeline must not have been created with the VkPipelineShaderStageCreateInfo::stage member of any element of VkGraphicsPipelineCreateInfo::pStages set to VK_SHADER_STAGE_TASK_BIT_EXT or VK_SHADER_STAGE_MESH_BIT_EXT VUID-vkCmdExecuteGeneratedCommandsNV-None-08885 There must be no shader object bound to either of the VK_SHADER_STAGE_TASK_BIT_EXT or VK_SHADER_STAGE_MESH_BIT_EXT stages VUID-vkCmdExecuteGeneratedCommandsNV-None-07619 If a shader object is bound to the VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT stage or a graphics pipeline is bound which was created with both a VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT stage and the VK_DYNAMIC_STATE_TESSELLATION_DOMAIN_ORIGIN_EXT dynamic state enabled, then vkCmdSetTessellationDomainOriginEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsNV-commandBuffer-02970 commandBuffer must not be a protected command buffer VUID-vkCmdExecuteGeneratedCommandsNV-isPreprocessed-02908 If isPreprocessed is VK_TRUE then vkCmdPreprocessGeneratedCommandsNV must have already been executed on the device, using the same pGeneratedCommandsInfo content as well as the content of the input buffers it references (all except VkGeneratedCommandsInfoNV::preprocessBuffer). Furthermore pGeneratedCommandsInfo`s indirectCommandsLayout must have been created with the VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_NV bit set VUID-vkCmdExecuteGeneratedCommandsNV-pipeline-02909 VkGeneratedCommandsInfoNV::pipeline must match the current bound pipeline at VkGeneratedCommandsInfoNV::pipelineBindPoint VUID-vkCmdExecuteGeneratedCommandsNV-None-02910 Transform feedback must not be active VUID-vkCmdExecuteGeneratedCommandsNV-deviceGeneratedCommands-02911 The VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV::deviceGeneratedCommands feature must be enabled Valid Usage (Implicit) VUID-vkCmdExecuteGeneratedCommandsNV-commandBuffer-parameter commandBuffer must be a valid VkCommandBuffer handle VUID-vkCmdExecuteGeneratedCommandsNV-pGeneratedCommandsInfo-parameter pGeneratedCommandsInfo must be a valid pointer to a valid VkGeneratedCommandsInfoNV structure VUID-vkCmdExecuteGeneratedCommandsNV-commandBuffer-recording commandBuffer must be in the recording state VUID-vkCmdExecuteGeneratedCommandsNV-commandBuffer-cmdpool The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations VUID-vkCmdExecuteGeneratedCommandsNV-renderpass This command must only be called inside of a render pass instance VUID-vkCmdExecuteGeneratedCommandsNV-videocoding This command must only be called outside of a video coding scope Host Synchronization Host access to commandBuffer must be externally synchronized Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized Command Properties Command Buffer Levels Render Pass Scope Video Coding Scope Supported Queue Types Command Type Primary Secondary Inside Outside Graphics Compute Action Indirection The VkGeneratedCommandsInfoNV is defined as: // Provided by VK_NV_device_generated_commands typedef struct VkGeneratedCommandsInfoNV { VkStructureType sType; const void* pNext; VkPipelineBindPoint pipelineBindPoint; VkPipeline pipeline; VkIndirectCommandsLayoutNV indirectCommandsLayout; uint32_t streamCount; const VkIndirectCommandsStreamNV* pStreams; uint32_t sequencesCount; VkBuffer preprocessBuffer; VkDeviceSize preprocessOffset; VkDeviceSize preprocessSize; VkBuffer sequencesCountBuffer; VkDeviceSize sequencesCountOffset; VkBuffer sequencesIndexBuffer; VkDeviceSize sequencesIndexOffset; } VkGeneratedCommandsInfoNV; sType is a VkStructureType value identifying this structure. pNext is NULL or a pointer to a structure extending this structure. pipelineBindPoint is the VkPipelineBindPoint used for the pipeline. pipeline is the VkPipeline used in the generation and execution process. indirectCommandsLayout is the VkIndirectCommandsLayoutNV that provides the command sequence to generate. streamCount defines the number of input streams pStreams is a pointer to an array of streamCount VkIndirectCommandsStreamNV structures providing the input data for the tokens used in indirectCommandsLayout. sequencesCount is the maximum number of sequences to reserve. If sequencesCountBuffer is VK_NULL_HANDLE, this is also the actual number of sequences generated. preprocessBuffer is the VkBuffer that is used for preprocessing the input data for execution. If this structure is used with vkCmdExecuteGeneratedCommandsNV with its isPreprocessed set to VK_TRUE, then the preprocessing step is skipped and data in this buffer will not be modified. The contents and the layout of this buffer are opaque to applications and must not be modified outside functions related to device-generated commands or copied to another buffer for reuse. preprocessOffset is the byte offset into preprocessBuffer where the preprocessed data is stored. preprocessSize is the maximum byte size within the preprocessBuffer after the preprocessOffset that is available for preprocessing. sequencesCountBuffer is a VkBuffer in which the actual number of sequences is provided as single uint32_t value. sequencesCountOffset is the byte offset into sequencesCountBuffer where the count value is stored. sequencesIndexBuffer is a VkBuffer that encodes the used sequence indices as uint32_t array. sequencesIndexOffset is the byte offset into sequencesIndexBuffer where the index values start. Valid Usage VUID-VkGeneratedCommandsInfoNV-pipeline-02912 The provided pipeline must match the pipeline bound at execution time VUID-VkGeneratedCommandsInfoNV-indirectCommandsLayout-02913 If the indirectCommandsLayout uses a token of VK_INDIRECT_COMMANDS_TOKEN_TYPE_SHADER_GROUP_NV, then the pipeline must have been created with multiple shader groups VUID-VkGeneratedCommandsInfoNV-indirectCommandsLayout-02914 If the indirectCommandsLayout uses a token of VK_INDIRECT_COMMANDS_TOKEN_TYPE_SHADER_GROUP_NV, then the pipeline must have been created with VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV set in VkGraphicsPipelineCreateInfo::flags VUID-VkGeneratedCommandsInfoNV-indirectCommandsLayout-02915 If the indirectCommandsLayout uses a token of VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV, then the pipeline’s VkPipelineLayout must match the VkIndirectCommandsLayoutTokenNV::pushconstantPipelineLayout VUID-VkGeneratedCommandsInfoNV-streamCount-02916 streamCount must match the indirectCommandsLayout’s streamCount VUID-VkGeneratedCommandsInfoNV-pipelineBindPoint-09084 If pipelineBindPoint is of type VK_PIPELINE_BIND_POINT_COMPUTE, then the pipeline must have been created with the flag VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV VUID-VkGeneratedCommandsInfoNV-pipelineBindPoint-09085 If pipelineBindPoint is of type VK_PIPELINE_BIND_POINT_COMPUTE, then the pipeline must have been created with a VkComputePipelineIndirectBufferInfoNV structure specifying a valid address where its metadata will be saved VUID-VkGeneratedCommandsInfoNV-pipelineBindPoint-09086 If pipelineBindPoint is of type VK_PIPELINE_BIND_POINT_COMPUTE, then vkCmdUpdatePipelineIndirectBufferNV must have been called on that pipeline to save its metadata to a device address VUID-VkGeneratedCommandsInfoNV-pipelineBindPoint-09087 If pipelineBindPoint is of type VK_PIPELINE_BIND_POINT_COMPUTE, and if VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NV is used, then pipeline must be VK_NULL_HANDLE VUID-VkGeneratedCommandsInfoNV-sequencesCount-02917 sequencesCount must be less or equal to VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV::maxIndirectSequenceCount and VkGeneratedCommandsMemoryRequirementsInfoNV::maxSequencesCount that was used to determine the preprocessSize VUID-VkGeneratedCommandsInfoNV-preprocessBuffer-02918 preprocessBuffer must have the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set in its usage flag VUID-VkGeneratedCommandsInfoNV-preprocessOffset-02919 preprocessOffset must be aligned to VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV::minIndirectCommandsBufferOffsetAlignment VUID-VkGeneratedCommandsInfoNV-preprocessBuffer-02971 If preprocessBuffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object VUID-VkGeneratedCommandsInfoNV-preprocessSize-02920 preprocessSize must be at least equal to the memory requirement`s size returned by vkGetGeneratedCommandsMemoryRequirementsNV using the matching inputs (indirectCommandsLayout, …​) as within this structure VUID-VkGeneratedCommandsInfoNV-sequencesCountBuffer-02921 sequencesCountBuffer can be set if the actual used count of sequences is sourced from the provided buffer. In that case the sequencesCount serves as upper bound VUID-VkGeneratedCommandsInfoNV-sequencesCountBuffer-02922 If sequencesCountBuffer is not VK_NULL_HANDLE, its usage flag must have the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set VUID-VkGeneratedCommandsInfoNV-sequencesCountBuffer-02923 If sequencesCountBuffer is not VK_NULL_HANDLE, sequencesCountOffset must be aligned to VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV::minSequencesCountBufferOffsetAlignment VUID-VkGeneratedCommandsInfoNV-sequencesCountBuffer-02972 If sequencesCountBuffer is not VK_NULL_HANDLE and is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object VUID-VkGeneratedCommandsInfoNV-sequencesIndexBuffer-02924 If indirectCommandsLayout’s VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NV is set, sequencesIndexBuffer must be set otherwise it must be VK_NULL_HANDLE VUID-VkGeneratedCommandsInfoNV-sequencesIndexBuffer-02925 If sequencesIndexBuffer is not VK_NULL_HANDLE, its usage flag must have the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT bit set VUID-VkGeneratedCommandsInfoNV-sequencesIndexBuffer-02926 If sequencesIndexBuffer is not VK_NULL_HANDLE, sequencesIndexOffset must be aligned to VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV::minSequencesIndexBufferOffsetAlignment VUID-VkGeneratedCommandsInfoNV-sequencesIndexBuffer-02973 If sequencesIndexBuffer is not VK_NULL_HANDLE and is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object VUID-VkGeneratedCommandsInfoNV-indirectCommandsLayout-07078 If the indirectCommandsLayout uses a token of VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_TASKS_NV, then the pipeline must contain a shader stage using the MeshNV Execution Model VUID-VkGeneratedCommandsInfoNV-indirectCommandsLayout-07079 If the indirectCommandsLayout uses a token of VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV, then the pipeline must contain a shader stage using the MeshEXT Execution Model Valid Usage (Implicit) VUID-VkGeneratedCommandsInfoNV-sType-sType sType must be VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV VUID-VkGeneratedCommandsInfoNV-pNext-pNext pNext must be NULL VUID-VkGeneratedCommandsInfoNV-pipelineBindPoint-parameter pipelineBindPoint must be a valid VkPipelineBindPoint value VUID-VkGeneratedCommandsInfoNV-pipeline-parameter If pipeline is not VK_NULL_HANDLE, pipeline must be a valid VkPipeline handle VUID-VkGeneratedCommandsInfoNV-indirectCommandsLayout-parameter indirectCommandsLayout must be a valid VkIndirectCommandsLayoutNV handle VUID-VkGeneratedCommandsInfoNV-pStreams-parameter pStreams must be a valid pointer to an array of streamCount valid VkIndirectCommandsStreamNV structures VUID-VkGeneratedCommandsInfoNV-preprocessBuffer-parameter preprocessBuffer must be a valid VkBuffer handle VUID-VkGeneratedCommandsInfoNV-sequencesCountBuffer-parameter If sequencesCountBuffer is not VK_NULL_HANDLE, sequencesCountBuffer must be a valid VkBuffer handle VUID-VkGeneratedCommandsInfoNV-sequencesIndexBuffer-parameter If sequencesIndexBuffer is not VK_NULL_HANDLE, sequencesIndexBuffer must be a valid VkBuffer handle VUID-VkGeneratedCommandsInfoNV-streamCount-arraylength streamCount must be greater than 0 VUID-VkGeneratedCommandsInfoNV-commonparent Each of indirectCommandsLayout, pipeline, preprocessBuffer, sequencesCountBuffer, and sequencesIndexBuffer that are valid handles of non-ignored parameters must have been created, allocated, or retrieved from the same VkDevice Referencing the functions defined in Indirect Commands Layout, vkCmdExecuteGeneratedCommandsNV behaves as: uint32_t sequencesCount = sequencesCountBuffer ? min(maxSequencesCount, sequencesCountBuffer.load_uint32(sequencesCountOffset) : maxSequencesCount; cmdProcessAllSequences(commandBuffer, pipeline, indirectCommandsLayout, pIndirectCommandsStreams, sequencesCount, sequencesIndexBuffer, sequencesIndexOffset); // The stateful commands within indirectCommandsLayout will not // affect the state of subsequent commands in the target // command buffer (cmd) It is important to note that the values of all state related to the pipelineBindPoint used are undefined after this command. Commands can be preprocessed prior execution using the following command: // Provided by VK_NV_device_generated_commands void vkCmdPreprocessGeneratedCommandsNV( VkCommandBuffer commandBuffer, const VkGeneratedCommandsInfoNV* pGeneratedCommandsInfo); commandBuffer is the command buffer which does the preprocessing. pGeneratedCommandsInfo is a pointer to a VkGeneratedCommandsInfoNV structure containing parameters affecting the preprocessing step. Valid Usage VUID-vkCmdPreprocessGeneratedCommandsNV-commandBuffer-02974 commandBuffer must not be a protected command buffer VUID-vkCmdPreprocessGeneratedCommandsNV-pGeneratedCommandsInfo-02927 pGeneratedCommandsInfo`s indirectCommandsLayout must have been created with the VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_NV bit set VUID-vkCmdPreprocessGeneratedCommandsNV-deviceGeneratedCommands-02928 The VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV::deviceGeneratedCommands feature must be enabled Valid Usage (Implicit) VUID-vkCmdPreprocessGeneratedCommandsNV-commandBuffer-parameter commandBuffer must be a valid VkCommandBuffer handle VUID-vkCmdPreprocessGeneratedCommandsNV-pGeneratedCommandsInfo-parameter pGeneratedCommandsInfo must be a valid pointer to a valid VkGeneratedCommandsInfoNV structure VUID-vkCmdPreprocessGeneratedCommandsNV-commandBuffer-recording commandBuffer must be in the recording state VUID-vkCmdPreprocessGeneratedCommandsNV-commandBuffer-cmdpool The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations VUID-vkCmdPreprocessGeneratedCommandsNV-renderpass This command must only be called outside of a render pass instance VUID-vkCmdPreprocessGeneratedCommandsNV-videocoding This command must only be called outside of a video coding scope Host Synchronization Host access to commandBuffer must be externally synchronized Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized Command Properties Command Buffer Levels Render Pass Scope Video Coding Scope Supported Queue Types Command Type Primary Secondary Outside Outside Graphics Compute Action The bound descriptor sets and push constants that will be used with indirect command generation for the compute pipelines must already be specified at the time of preprocessing commands with vkCmdPreprocessGeneratedCommandsNV. They must not change until the execution of indirect commands is submitted with vkCmdExecuteGeneratedCommandsNV. If push constants for the compute pipeline are also specified in the VkGeneratedCommandsInfoNV::indirectCommandsLayout with VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV token, then those values override the push constants that were previously pushed for the compute pipeline. With VK_EXT_device_generated_commands, the actual generation of commands as well as their execution on the device is handled as single action with: // Provided by VK_EXT_device_generated_commands void vkCmdExecuteGeneratedCommandsEXT( VkCommandBuffer commandBuffer, VkBool32 isPreprocessed, const VkGeneratedCommandsInfoEXT* pGeneratedCommandsInfo); commandBuffer is the command buffer into which the command is recorded. isPreprocessed represents whether the input data has already been preprocessed on the device. If it is VK_FALSE this command will implicitly trigger the preprocessing step, otherwise not. pGeneratedCommandsInfo is a pointer to a VkGeneratedCommandsInfoEXT structure containing parameters affecting the generation of commands. If the VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_EXT flag was used to create the VkGeneratedCommandsInfoEXT::indirectCommandsLayout then the execution of sequences through this command may use implementation-defined ordering which is not guaranteed to be coherent using the same input data. It does not affect the order of token processing within a sequence. This is the implied ordering with VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_EXT. After a call to vkCmdExecuteGeneratedCommandsEXT, command buffer state will become undefined according to the tokens executed. This table specifies the relationship between tokens used and state invalidation. Table 3. Indirect Execution State Invalidation Common Tokens States Invalidated VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXECUTION_SET_EXT Bound shaders and pipelines VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_EXT Push constant data VK_INDIRECT_COMMANDS_TOKEN_TYPE_SEQUENCE_INDEX_EXT Push constant data VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_EXT Index buffer VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_EXT Vertex buffer Valid Usage VUID-vkCmdExecuteGeneratedCommandsEXT-magFilter-04553 If a VkSampler created with magFilter or minFilter equal to VK_FILTER_LINEAR, reductionMode equal to VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE, and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT VUID-vkCmdExecuteGeneratedCommandsEXT-magFilter-09598 If a VkSampler created with magFilter or minFilter equal to VK_FILTER_LINEAR and reductionMode equal to either VK_SAMPLER_REDUCTION_MODE_MIN or VK_SAMPLER_REDUCTION_MODE_MAX is used to sample a VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT VUID-vkCmdExecuteGeneratedCommandsEXT-mipmapMode-04770 If a VkSampler created with mipmapMode equal to VK_SAMPLER_MIPMAP_MODE_LINEAR, reductionMode equal to VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE, and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT VUID-vkCmdExecuteGeneratedCommandsEXT-mipmapMode-09599 If a VkSampler created with mipmapMode equal to VK_SAMPLER_MIPMAP_MODE_LINEAR and reductionMode equal to either VK_SAMPLER_REDUCTION_MODE_MIN or VK_SAMPLER_REDUCTION_MODE_MAX is used to sample a VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT VUID-vkCmdExecuteGeneratedCommandsEXT-unnormalizedCoordinates-09635 If a VkSampler created with unnormalizedCoordinates equal to VK_TRUE is used to sample a VkImageView as a result of this command, then the image view’s levelCount and layerCount must be 1 VUID-vkCmdExecuteGeneratedCommandsEXT-None-08609 If a VkSampler created with unnormalizedCoordinates equal to VK_TRUE is used to sample a VkImageView as a result of this command, then the image view’s viewType must be VK_IMAGE_VIEW_TYPE_1D or VK_IMAGE_VIEW_TYPE_2D VUID-vkCmdExecuteGeneratedCommandsEXT-None-08610 If a VkSampler created with unnormalizedCoordinates equal to VK_TRUE is used to sample a VkImageView as a result of this command, then the sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name VUID-vkCmdExecuteGeneratedCommandsEXT-None-08611 If a VkSampler created with unnormalizedCoordinates equal to VK_TRUE is used to sample a VkImageView as a result of this command, then the sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values VUID-vkCmdExecuteGeneratedCommandsEXT-None-06479 If a VkImageView is sampled with depth comparison, the image view’s format features must contain VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT VUID-vkCmdExecuteGeneratedCommandsEXT-None-02691 If a VkImageView is accessed using atomic operations as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT VUID-vkCmdExecuteGeneratedCommandsEXT-None-07888 If a VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER descriptor is accessed using atomic operations as a result of this command, then the storage texel buffer’s format features must contain VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT VUID-vkCmdExecuteGeneratedCommandsEXT-None-02692 If a VkImageView is sampled with VK_FILTER_CUBIC_EXT as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT VUID-vkCmdExecuteGeneratedCommandsEXT-None-02693 If the VK_EXT_filter_cubic extension is not enabled and any VkImageView is sampled with VK_FILTER_CUBIC_EXT as a result of this command, it must not have a VkImageViewType of VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY VUID-vkCmdExecuteGeneratedCommandsEXT-filterCubic-02694 Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic returned by vkGetPhysicalDeviceImageFormatProperties2 VUID-vkCmdExecuteGeneratedCommandsEXT-filterCubicMinmax-02695 Any VkImageView being sampled with VK_FILTER_CUBIC_EXT with a reduction mode of either VK_SAMPLER_REDUCTION_MODE_MIN or VK_SAMPLER_REDUCTION_MODE_MAX as a result of this command must have a VkImageViewType and format that supports cubic filtering together with minmax filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax returned by vkGetPhysicalDeviceImageFormatProperties2 VUID-vkCmdExecuteGeneratedCommandsEXT-cubicRangeClamp-09212 If the cubicRangeClamp feature is not enabled, then any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must not have a VkSamplerReductionModeCreateInfo::reductionMode equal to VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM VUID-vkCmdExecuteGeneratedCommandsEXT-reductionMode-09213 Any VkImageView being sampled with a VkSamplerReductionModeCreateInfo::reductionMode equal to VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM as a result of this command must sample with VK_FILTER_CUBIC_EXT VUID-vkCmdExecuteGeneratedCommandsEXT-selectableCubicWeights-09214 If the selectableCubicWeights feature is not enabled, then any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must have VkSamplerCubicWeightsCreateInfoQCOM::cubicWeights equal to VK_CUBIC_FILTER_WEIGHTS_CATMULL_ROM_QCOM VUID-vkCmdExecuteGeneratedCommandsEXT-flags-02696 Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE VUID-vkCmdExecuteGeneratedCommandsEXT-OpTypeImage-07027 For any VkImageView being written as a storage image where the image format field of the OpTypeImage is Unknown, the view’s format features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT VUID-vkCmdExecuteGeneratedCommandsEXT-OpTypeImage-07028 For any VkImageView being read as a storage image where the image format field of the OpTypeImage is Unknown, the view’s format features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT VUID-vkCmdExecuteGeneratedCommandsEXT-OpTypeImage-07029 For any VkBufferView being written as a storage texel buffer where the image format field of the OpTypeImage is Unknown, the view’s buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT VUID-vkCmdExecuteGeneratedCommandsEXT-OpTypeImage-07030 Any VkBufferView being read as a storage texel buffer where the image format field of the OpTypeImage is Unknown then the view’s buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT VUID-vkCmdExecuteGeneratedCommandsEXT-None-08600 For each set n that is statically used by a bound shader, a descriptor set must have been bound to n at the same pipeline bind point, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline or the VkDescriptorSetLayout array used to create the current VkShaderEXT , as described in Pipeline Layout Compatibility VUID-vkCmdExecuteGeneratedCommandsEXT-None-08601 For each push constant that is statically used by a bound shader, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline or the VkDescriptorSetLayout array used to create the current VkShaderEXT , as described in Pipeline Layout Compatibility VUID-vkCmdExecuteGeneratedCommandsEXT-None-10068 For each array of resources that is used by a bound shader, the indices used to access members of the array must be less than the descriptor count for the identified binding in the descriptor sets used by this command VUID-vkCmdExecuteGeneratedCommandsEXT-maintenance4-08602 If the maintenance4 feature is not enabled, then for each push constant that is statically used by a bound shader, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline or the VkDescriptorSetLayout and VkPushConstantRange arrays used to create the current VkShaderEXT , as described in Pipeline Layout Compatibility VUID-vkCmdExecuteGeneratedCommandsEXT-None-08114 Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid as described by descriptor validity if they are statically used by the VkPipeline bound to the pipeline bind point used by this command and the bound VkPipeline was not created with VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT VUID-vkCmdExecuteGeneratedCommandsEXT-None-08115 If the descriptors used by the VkPipeline bound to the pipeline bind point were specified via vkCmdBindDescriptorSets, the bound VkPipeline must have been created without VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT VUID-vkCmdExecuteGeneratedCommandsEXT-None-08116 Descriptors in bound descriptor buffers, specified via vkCmdSetDescriptorBufferOffsetsEXT, must be valid if they are dynamically used by the VkPipeline bound to the pipeline bind point used by this command and the bound VkPipeline was created with VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT VUID-vkCmdExecuteGeneratedCommandsEXT-None-08604 Descriptors in bound descriptor buffers, specified via vkCmdSetDescriptorBufferOffsetsEXT, must be valid if they are dynamically used by any VkShaderEXT bound to a stage corresponding to the pipeline bind point used by this command VUID-vkCmdExecuteGeneratedCommandsEXT-None-08117 If the descriptors used by the VkPipeline bound to the pipeline bind point were specified via vkCmdSetDescriptorBufferOffsetsEXT, the bound VkPipeline must have been created with VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT VUID-vkCmdExecuteGeneratedCommandsEXT-None-08119 If a descriptor is dynamically used with a VkPipeline created with VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT, the descriptor memory must be resident VUID-vkCmdExecuteGeneratedCommandsEXT-None-08605 If a descriptor is dynamically used with a VkShaderEXT created with a VkDescriptorSetLayout that was created with VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT, the descriptor memory must be resident VUID-vkCmdExecuteGeneratedCommandsEXT-None-08606 If the shaderObject feature is not enabled, a valid pipeline must be bound to the pipeline bind point used by this command VUID-vkCmdExecuteGeneratedCommandsEXT-None-08608 If a pipeline is bound to the pipeline bind point used by this command, there must not have been any calls to dynamic state setting commands for any state specified statically in the VkPipeline object bound to the pipeline bind point used by this command, since that pipeline was bound VUID-vkCmdExecuteGeneratedCommandsEXT-uniformBuffers-06935 If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a uniform buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2 for uniformBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point VUID-vkCmdExecuteGeneratedCommandsEXT-None-08612 If the robustBufferAccess feature is not enabled, and any VkShaderEXT bound to a stage corresponding to the pipeline bind point used by this command accesses a uniform buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point VUID-vkCmdExecuteGeneratedCommandsEXT-storageBuffers-06936 If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a storage buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2 for storageBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point VUID-vkCmdExecuteGeneratedCommandsEXT-None-08613 If the robustBufferAccess feature is not enabled, and any VkShaderEXT bound to a stage corresponding to the pipeline bind point used by this command accesses a storage buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point VUID-vkCmdExecuteGeneratedCommandsEXT-commandBuffer-02707 If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, any resource accessed by bound shaders must not be a protected resource VUID-vkCmdExecuteGeneratedCommandsEXT-viewType-07752 If a VkImageView is accessed as a result of this command, then the image view’s viewType must match the Dim operand of the OpTypeImage as described in Compatibility Between SPIR-V Image Dimensions and Vulkan ImageView Types VUID-vkCmdExecuteGeneratedCommandsEXT-format-07753 If a VkImageView or VkBufferView is accessed as a result of this command, then the numeric type of the view’s format and the Sampled Type operand of the OpTypeImage must match VUID-vkCmdExecuteGeneratedCommandsEXT-OpImageWrite-08795 If a VkImageView created with a format other than VK_FORMAT_A8_UNORM is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the image view’s format VUID-vkCmdExecuteGeneratedCommandsEXT-OpImageWrite-08796 If a VkImageView created with the format VK_FORMAT_A8_UNORM is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have four components VUID-vkCmdExecuteGeneratedCommandsEXT-OpImageWrite-04469 If a VkBufferView is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the buffer view’s format VUID-vkCmdExecuteGeneratedCommandsEXT-SampledType-04470 If a VkImageView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64 VUID-vkCmdExecuteGeneratedCommandsEXT-SampledType-04471 If a VkImageView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32 VUID-vkCmdExecuteGeneratedCommandsEXT-SampledType-04472 If a VkBufferView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64 VUID-vkCmdExecuteGeneratedCommandsEXT-SampledType-04473 If a VkBufferView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32 VUID-vkCmdExecuteGeneratedCommandsEXT-sparseImageInt64Atomics-04474 If the sparseImageInt64Atomics feature is not enabled, VkImage objects created with the VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command VUID-vkCmdExecuteGeneratedCommandsEXT-sparseImageInt64Atomics-04475 If the sparseImageInt64Atomics feature is not enabled, VkBuffer objects created with the VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command VUID-vkCmdExecuteGeneratedCommandsEXT-OpImageWeightedSampleQCOM-06971 If OpImageWeightedSampleQCOM is used to sample a VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM VUID-vkCmdExecuteGeneratedCommandsEXT-OpImageWeightedSampleQCOM-06972 If OpImageWeightedSampleQCOM uses a VkImageView as a sample weight image as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM VUID-vkCmdExecuteGeneratedCommandsEXT-OpImageBoxFilterQCOM-06973 If OpImageBoxFilterQCOM is used to sample a VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM VUID-vkCmdExecuteGeneratedCommandsEXT-OpImageBlockMatchSSDQCOM-06974 If OpImageBlockMatchSSDQCOM is used to read from an VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM VUID-vkCmdExecuteGeneratedCommandsEXT-OpImageBlockMatchSADQCOM-06975 If OpImageBlockMatchSADQCOM is used to read from an VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM VUID-vkCmdExecuteGeneratedCommandsEXT-OpImageBlockMatchSADQCOM-06976 If OpImageBlockMatchSADQCOM or OpImageBlockMatchSSDQCOM is used to read from a reference image as result of this command, then the specified reference coordinates must not fail integer texel coordinate validation VUID-vkCmdExecuteGeneratedCommandsEXT-OpImageWeightedSampleQCOM-06977 If OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchWindowSSDQCOM, OpImageBlockMatchWindowSADQCOM, OpImageBlockMatchGatherSSDQCOM, OpImageBlockMatchGatherSADQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM VUID-vkCmdExecuteGeneratedCommandsEXT-OpImageWeightedSampleQCOM-06978 If any command other than OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchWindowSSDQCOM, OpImageBlockMatchWindowSADQCOM, OpImageBlockMatchGatherSSDQCOM, OpImageBlockMatchGatherSADQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must not have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM VUID-vkCmdExecuteGeneratedCommandsEXT-OpImageBlockMatchWindow-09215 If a OpImageBlockMatchWindow*QCOM or OpImageBlockMatchGather*QCOM instruction is used to read from an VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM VUID-vkCmdExecuteGeneratedCommandsEXT-OpImageBlockMatchWindow-09216 If a OpImageBlockMatchWindow*QCOM or OpImageBlockMatchGather*QCOM instruction is used to read from an VkImageView as a result of this command, then the image view’s format must be a single-component format VUID-vkCmdExecuteGeneratedCommandsEXT-OpImageBlockMatchWindow-09217 If a OpImageBlockMatchWindow*QCOM or OpImageBlockMatchGather*QCOM read from a reference image as result of this command, then the specified reference coordinates must not fail integer texel coordinate validation VUID-vkCmdExecuteGeneratedCommandsEXT-None-07288 Any shader invocation executed by this command must terminate VUID-vkCmdExecuteGeneratedCommandsEXT-None-09600 If a descriptor with type equal to any of VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM, VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, or VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT is accessed as a result of this command, all image subresources identified by that descriptor must be in the image layout identified when the descriptor was written VUID-vkCmdExecuteGeneratedCommandsEXT-commandBuffer-10746 The VkDeviceMemory object allocated from a VkMemoryHeap with the VK_MEMORY_HEAP_TILE_MEMORY_BIT_QCOM property that is bound to a resource accessed as a result of this command must be the active bound bound tile memory object in commandBuffer VUID-vkCmdExecuteGeneratedCommandsEXT-None-10678 If this command is recorded inside a tile shading render pass instance, the stages corresponding to the pipeline bind point used by this command must only include VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_FRAGMENT_BIT, and/or VK_SHADER_STAGE_COMPUTE_BIT VUID-vkCmdExecuteGeneratedCommandsEXT-None-10679 If this command is recorded where per-tile execution model is enabled, there must be no access to any image while the image was be transitioned to the VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT layout VUID-vkCmdExecuteGeneratedCommandsEXT-renderPass-02684 The current render pass must be compatible with the renderPass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS VUID-vkCmdExecuteGeneratedCommandsEXT-subpass-02685 The subpass index of the current render pass must be equal to the subpass member of the VkGraphicsPipelineCreateInfo structure specified when creating the VkPipeline bound to VK_PIPELINE_BIND_POINT_GRAPHICS VUID-vkCmdExecuteGeneratedCommandsEXT-None-07748 If any shader statically accesses an input attachment, a valid descriptor must be bound to the pipeline via a descriptor set VUID-vkCmdExecuteGeneratedCommandsEXT-OpTypeImage-07468 If any shader executed by this pipeline accesses an OpTypeImage variable with a Dim operand of SubpassData, it must be decorated with an InputAttachmentIndex that corresponds to a valid input attachment in the current subpass VUID-vkCmdExecuteGeneratedCommandsEXT-None-07469 Input attachment views accessed in a subpass must be created with the same VkFormat as the corresponding subpass definition, and be created with a VkImageView that is compatible with the attachment referenced by the subpass' pInputAttachments[InputAttachmentIndex] in the bound VkFramebuffer as specified by Fragment Input Attachment Compatibility VUID-vkCmdExecuteGeneratedCommandsEXT-pDepthInputAttachmentIndex-09595 Input attachment views accessed in a dynamic render pass with a InputAttachmentIndex referenced by VkRenderingInputAttachmentIndexInfo, or no InputAttachmentIndex if VkRenderingInputAttachmentIndexInfo:pDepthInputAttachmentIndex or VkRenderingInputAttachmentIndexInfo:pStencilInputAttachmentIndex are NULL, must be created with a VkImageView that is compatible with the corresponding color, depth, or stencil attachment in VkRenderingInfo VUID-vkCmdExecuteGeneratedCommandsEXT-pDepthInputAttachmentIndex-09596 Input attachment views accessed in a dynamic render pass via a shader object must have an InputAttachmentIndex if both VkRenderingInputAttachmentIndexInfo:pDepthInputAttachmentIndex and VkRenderingInputAttachmentIndexInfo:pStencilInputAttachmentIndex are non-NULL VUID-vkCmdExecuteGeneratedCommandsEXT-InputAttachmentIndex-09597 If an input attachment view accessed in a dynamic render pass via a shader object has an InputAttachmentIndex, the InputAttachmentIndex must match an index in VkRenderingInputAttachmentIndexInfo VUID-vkCmdExecuteGeneratedCommandsEXT-None-06537 Memory backing image subresources used as attachments in the current render pass must not be written in any way other than as an attachment by this command VUID-vkCmdExecuteGeneratedCommandsEXT-None-09000 If a color attachment is written by any prior command in this subpass or by the load, store, or resolve operations for this subpass, it is not in the VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT image layout, and either: the VK_PIPELINE_CREATE_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT is set on the bound pipeline or the last call to vkCmdSetAttachmentFeedbackLoopEnableEXT included VK_IMAGE_ASPECT_COLOR_BIT and there is no bound graphics pipeline or the bound graphics pipeline was created with VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT it must not be accessed in any way other than as an attachment by this command VUID-vkCmdExecuteGeneratedCommandsEXT-None-09001 If a depth attachment is written by any prior command in this subpass or by the load, store, or resolve operations for this subpass, it is not in the VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT image layout, and either: the VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT is set on the bound pipeline or the last call to vkCmdSetAttachmentFeedbackLoopEnableEXT included VK_IMAGE_ASPECT_DEPTH_BIT and there is no bound graphics pipeline or the bound graphics pipeline was created with VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT it must not be accessed in any way other than as an attachment by this command VUID-vkCmdExecuteGeneratedCommandsEXT-None-09002 If a stencil attachment is written by any prior command in this subpass or by the load, store, or resolve operations for this subpass, it is not in the VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT image layout, and either: the VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT is set on the bound pipeline or the last call to vkCmdSetAttachmentFeedbackLoopEnableEXT included VK_IMAGE_ASPECT_STENCIL_BIT and there is no bound graphics pipeline or the bound graphics pipeline was created with VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT it must not be accessed in any way other than as an attachment by this command VUID-vkCmdExecuteGeneratedCommandsEXT-None-09003 If an attachment is written by any prior command in this subpass or by the load, store, or resolve operations for this subpass, it must not be accessed in any way other than as an attachment, storage image, or sampled image by this command VUID-vkCmdExecuteGeneratedCommandsEXT-None-06539 If any previously recorded command in the current subpass accessed an image subresource used as an attachment in this subpass in any way other than as an attachment, this command must not write to that image subresource as an attachment VUID-vkCmdExecuteGeneratedCommandsEXT-None-06886 If the current render pass instance uses a depth/stencil attachment with a read-only layout for the depth aspect, depth writes must be disabled VUID-vkCmdExecuteGeneratedCommandsEXT-None-06887 If the current render pass instance uses a depth/stencil attachment with a read-only layout for the stencil aspect, both front and back writeMask are not zero, and stencil test is enabled, all stencil ops must be VK_STENCIL_OP_KEEP VUID-vkCmdExecuteGeneratedCommandsEXT-None-07831 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT dynamic state enabled then vkCmdSetViewport must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-07832 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SCISSOR dynamic state enabled then vkCmdSetScissor must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-07833 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_WIDTH dynamic state enabled then vkCmdSetLineWidth must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-08617 If a shader object is bound to any graphics stage, and the most recent call to vkCmdSetRasterizerDiscardEnable in the current command buffer set rasterizerDiscardEnable to VK_FALSE, and the most recent call to vkCmdSetPolygonModeEXT in the current command buffer set polygonMode to VK_POLYGON_MODE_LINE, vkCmdSetLineWidth must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-08618 If a shader object is bound to any graphics stage, and the most recent call to vkCmdSetRasterizerDiscardEnable in the current command buffer set rasterizerDiscardEnable to VK_FALSE, and the most recent call to vkCmdSetPrimitiveTopology in the current command buffer set primitiveTopology to any line topology, vkCmdSetLineWidth must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-08619 If a shader object that outputs line primitives is bound to the VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT or VK_SHADER_STAGE_GEOMETRY_BIT stage, and the most recent call to vkCmdSetRasterizerDiscardEnable in the current command buffer set rasterizerDiscardEnable to VK_FALSE, vkCmdSetLineWidth must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-07834 If a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_DEPTH_BIAS dynamic state enabled, the current value of rasterizerDiscardEnable is VK_FALSE, and the current value of depthBiasEnable is VK_TRUE, then vkCmdSetDepthBias or vkCmdSetDepthBias2EXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-07835 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_BLEND_CONSTANTS dynamic state enabled then vkCmdSetBlendConstants must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-08621 If a shader object is bound to the VK_SHADER_STAGE_FRAGMENT_BIT stage, and the most recent call to vkCmdSetRasterizerDiscardEnable in the current command buffer set rasterizerDiscardEnable to VK_FALSE, and the most recent call to vkCmdSetColorBlendEnableEXT in the current command buffer set any element of pColorBlendEnables to VK_TRUE, and the most recent call to vkCmdSetColorBlendEquationEXT in the current command buffer set the same element of pColorBlendEquations to a VkColorBlendEquationEXT structure with any VkBlendFactor member with a value of VK_BLEND_FACTOR_CONSTANT_COLOR, VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR, VK_BLEND_FACTOR_CONSTANT_ALPHA, or VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA, vkCmdSetBlendConstants must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-07836 If a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_DEPTH_BOUNDS dynamic state enabled, the current value of rasterizerDiscardEnable is VK_FALSE, and the current value of depthBoundsTestEnable is VK_TRUE, then vkCmdSetDepthBounds must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-07837 If a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK dynamic state enabled, the current value of rasterizerDiscardEnable is VK_FALSE, and the current value of stencilTestEnable is VK_TRUE, then vkCmdSetStencilCompareMask must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-07838 If a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_STENCIL_WRITE_MASK dynamic state enabled, the current value of rasterizerDiscardEnable is VK_FALSE, and the current value of stencilTestEnable is VK_TRUE, then vkCmdSetStencilWriteMask must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-07839 If a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_STENCIL_REFERENCE dynamic state enabled, the current value of and rasterizerDiscardEnable is VK_FALSE, the current value of stencilTestEnable is VK_TRUE, then vkCmdSetStencilReference must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-maxMultiviewInstanceIndex-02688 If the draw is recorded in a render pass instance with multiview enabled, the maximum instance index must be less than or equal to VkPhysicalDeviceMultiviewProperties::maxMultiviewInstanceIndex VUID-vkCmdExecuteGeneratedCommandsEXT-sampleLocationsEnable-02689 If the bound graphics pipeline was created with VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable set to VK_TRUE and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set VUID-vkCmdExecuteGeneratedCommandsEXT-None-07634 If the VK_EXT_sample_locations extension is enabled, a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT dynamic state enabled, and the current value of rasterizerDiscardEnable is VK_FALSE, then vkCmdSetSampleLocationsEnableEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-06666 If the VK_EXT_sample_locations extension is enabled, a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT dynamic state enabled, the current value of rasterizerDiscardEnable is VK_FALSE, and the current value of sampleLocationsEnable is VK_TRUE, then vkCmdSetSampleLocationsEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-07840 If a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_CULL_MODE dynamic state enabled, and the current value of rasterizerDiscardEnable is VK_FALSE, then vkCmdSetCullMode must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-07841 If a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_FRONT_FACE dynamic state enabled, and the current value of rasterizerDiscardEnable is VK_FALSE, then vkCmdSetFrontFace must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-07843 If a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE dynamic state enabled, and the current value of rasterizerDiscardEnable is VK_FALSE, vkCmdSetDepthTestEnable must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-07844 If a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE dynamic state enabled, and the current value of rasterizerDiscardEnable is VK_FALSE, then vkCmdSetDepthWriteEnable must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-07845 If a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_DEPTH_COMPARE_OP dynamic state enabled, the current value of rasterizerDiscardEnable is VK_FALSE, and the current value of depthTestEnable is VK_TRUE, then vkCmdSetDepthCompareOp must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-07846 If the depthBounds feature is enabled, a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE dynamic state enabled, and the current value of rasterizerDiscardEnable is VK_FALSE, then vkCmdSetDepthBoundsTestEnable must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-07847 If a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE dynamic state enabled, and the current value of rasterizerDiscardEnable is VK_FALSE, then vkCmdSetStencilTestEnable must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-07848 If a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_STENCIL_OP dynamic state enabled, the current value of rasterizerDiscardEnable is VK_FALSE, the current value of stencilTestEnable is VK_TRUE, then vkCmdSetStencilOp must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-viewportCount-03417 If a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, and the state is not inherited, then vkCmdSetViewportWithCount must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-scissorCount-03418 If a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT dynamic state enabled, and the state is not inherited, then vkCmdSetScissorWithCount must have been called and not subsequently invalidated in the current command buffer prior to this drawing VUID-vkCmdExecuteGeneratedCommandsEXT-viewportCount-03419 If a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with both the VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic states enabled, and the state is not inherited, then the viewportCount parameter of vkCmdSetViewportWithCount must match the scissorCount parameter of vkCmdSetScissorWithCount VUID-vkCmdExecuteGeneratedCommandsEXT-viewportCount-04137 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV dynamic state enabled, then the bound graphics pipeline must have been created with VkPipelineViewportWScalingStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount VUID-vkCmdExecuteGeneratedCommandsEXT-viewportCount-04138 If the VK_NV_clip_space_w_scaling extension is enabled, and a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV dynamic state enabled, the current value of viewportWScalingEnable is VK_TRUE, then vkCmdSetViewportWScalingNV must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-08636 If the VK_NV_clip_space_w_scaling extension is enabled, and a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV dynamic state enabled, the current value of viewportWScalingEnable is VK_TRUE, then the viewportCount parameter in the last call to vkCmdSetViewportWScalingNV must be greater than or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount VUID-vkCmdExecuteGeneratedCommandsEXT-viewportCount-04139 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV dynamic state enabled, then the bound graphics pipeline must have been created with VkPipelineViewportShadingRateImageStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount VUID-vkCmdExecuteGeneratedCommandsEXT-shadingRateImage-09233 If the shadingRateImage feature is enabled, and a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV and the current value of rasterizerDiscardEnable is VK_FALSE, then vkCmdSetCoarseSampleOrderNV must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-shadingRateImage-09234 If the shadingRateImage feature is enabled, and a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV dynamic state enabled, the current value of rasterizerDiscardEnable is VK_FALSE, and the current value of shadingRateImageEnable is VK_TRUE, then vkCmdSetViewportShadingRatePaletteNV must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-08637 If the shadingRateImage feature is enabled, and a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV dynamic state enabled, the current value of rasterizerDiscardEnable is VK_FALSE, and the current value of shadingRateImageEnable is VK_TRUE, then the viewportCount parameter in the last call to vkCmdSetViewportShadingRatePaletteNV must be greater than or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount VUID-vkCmdExecuteGeneratedCommandsEXT-VkPipelineVieportCreateInfo-04141 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled and a VkPipelineViewportSwizzleStateCreateInfoNV structure chained from VkPipelineViewportStateCreateInfo, then the bound graphics pipeline must have been created with VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount VUID-vkCmdExecuteGeneratedCommandsEXT-VkPipelineVieportCreateInfo-04142 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled and a VkPipelineViewportExclusiveScissorStateCreateInfoNV structure chained from VkPipelineViewportStateCreateInfo, then the bound graphics pipeline must have been created with VkPipelineViewportExclusiveScissorStateCreateInfoNV::exclusiveScissorCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount VUID-vkCmdExecuteGeneratedCommandsEXT-None-07878 If the exclusiveScissor feature is enabled, and a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_ENABLE_NV dynamic state enabled, then vkCmdSetExclusiveScissorEnableNV must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-07879 If the exclusiveScissor feature is enabled, a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV dynamic state enabled, and the most recent call to vkCmdSetExclusiveScissorEnableNV in the current command buffer set any element of pExclusiveScissorEnables to VK_TRUE, then vkCmdSetExclusiveScissorNV must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-04876 If a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE dynamic state enabled, then vkCmdSetRasterizerDiscardEnable must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-04877 If a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE dynamic state enabled, and the current value of rasterizerDiscardEnable is VK_FALSE, then vkCmdSetDepthBiasEnable must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-logicOp-04878 If a shader object is bound to the VK_SHADER_STAGE_FRAGMENT_BIT or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_LOGIC_OP_EXT dynamic state enabled, the current value of rasterizerDiscardEnable is VK_FALSE, and the current value of logicOpEnable is VK_TRUE, then vkCmdSetLogicOpEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-primitiveFragmentShadingRateWithMultipleViewports-04552 If the primitiveFragmentShadingRateWithMultipleViewports limit is not supported, the bound graphics pipeline was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, and any of the shader stages of the bound graphics pipeline write to the PrimitiveShadingRateKHR built-in, then vkCmdSetViewportWithCount must have been called in the current command buffer prior to this drawing command, and the viewportCount parameter of vkCmdSetViewportWithCount must be 1 VUID-vkCmdExecuteGeneratedCommandsEXT-primitiveFragmentShadingRateWithMultipleViewports-08642 If the primitiveFragmentShadingRateWithMultipleViewports limit is not supported, and any shader object bound to a graphics stage writes to the PrimitiveShadingRateKHR built-in, then vkCmdSetViewportWithCount must have been called in the current command buffer prior to this drawing command, and the viewportCount parameter of vkCmdSetViewportWithCount must be 1 VUID-vkCmdExecuteGeneratedCommandsEXT-blendEnable-04727 If rasterization is not disabled in the bound graphics pipeline, then for each color attachment in the subpass, if the corresponding image view’s format features do not contain VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT, then the blendEnable member of the corresponding element of the pAttachments member of pColorBlendState must be VK_FALSE VUID-vkCmdExecuteGeneratedCommandsEXT-None-08643 If a shader object is bound to the VK_SHADER_STAGE_FRAGMENT_BIT stage, and the most recent call to vkCmdSetRasterizerDiscardEnable in the current command buffer set rasterizerDiscardEnable to VK_FALSE, then for each color attachment in the render pass, if the corresponding image view’s format features do not contain VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT, then the corresponding member of pColorBlendEnables in the most recent call to vkCmdSetColorBlendEnableEXT in the current command buffer that affected that attachment index must have been VK_FALSE VUID-vkCmdExecuteGeneratedCommandsEXT-multisampledRenderToSingleSampled-07284 If rasterization is not disabled in the bound graphics pipeline, and none of the following is enabled: the VK_AMD_mixed_attachment_samples extension the VK_NV_framebuffer_mixed_samples extension the multisampledRenderToSingleSampled feature then rasterizationSamples for the bound graphics pipeline must be the same as the current subpass color and/or depth/stencil attachments VUID-vkCmdExecuteGeneratedCommandsEXT-None-08644 If a shader object is bound to any graphics stage, and the most recent call to vkCmdSetRasterizerDiscardEnable in the current command buffer set rasterizerDiscardEnable to VK_FALSE, and none of the following is enabled: the VK_AMD_mixed_attachment_samples extension the VK_NV_framebuffer_mixed_samples extension the multisampledRenderToSingleSampled feature then the most recent call to vkCmdSetRasterizationSamplesEXT in the current command buffer must have set rasterizationSamples to be the same as the number of samples for the current render pass color and/or depth/stencil attachments VUID-vkCmdExecuteGeneratedCommandsEXT-None-08876 If a shader object is bound to any graphics stage, the current render pass instance must have been begun with vkCmdBeginRendering VUID-vkCmdExecuteGeneratedCommandsEXT-imageView-06172 If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pDepthAttachment is not VK_NULL_HANDLE, and the layout member of pDepthAttachment is VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the depth attachment VUID-vkCmdExecuteGeneratedCommandsEXT-imageView-06173 If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pStencilAttachment is not VK_NULL_HANDLE, and the layout member of pStencilAttachment is VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the stencil attachment VUID-vkCmdExecuteGeneratedCommandsEXT-imageView-06174 If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pDepthAttachment is not VK_NULL_HANDLE, and the layout member of pDepthAttachment is VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL, this command must not write any values to the depth attachment VUID-vkCmdExecuteGeneratedCommandsEXT-imageView-06175 If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pStencilAttachment is not VK_NULL_HANDLE, and the layout member of pStencilAttachment is VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the stencil attachment VUID-vkCmdExecuteGeneratedCommandsEXT-imageView-06176 If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pDepthAttachment is not VK_NULL_HANDLE, and the layout member of pDepthAttachment is VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL, this command must not write any values to the depth attachment VUID-vkCmdExecuteGeneratedCommandsEXT-imageView-06177 If the current render pass instance was begun with vkCmdBeginRendering, the imageView member of pStencilAttachment is not VK_NULL_HANDLE, and the layout member of pStencilAttachment is VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL, this command must not write any values to the stencil attachment VUID-vkCmdExecuteGeneratedCommandsEXT-viewMask-06178 If the current render pass instance was begun with vkCmdBeginRendering, the bound graphics pipeline must have been created with a VkPipelineRenderingCreateInfo::viewMask equal to VkRenderingInfo::viewMask VUID-vkCmdExecuteGeneratedCommandsEXT-colorAttachmentCount-06179 If the dynamicRenderingUnusedAttachments feature is not enabled and the current render pass instance was begun with vkCmdBeginRendering, the bound graphics pipeline must have been created with a VkPipelineRenderingCreateInfo::colorAttachmentCount equal to VkRenderingInfo::colorAttachmentCount VUID-vkCmdExecuteGeneratedCommandsEXT-dynamicRenderingUnusedAttachments-08910 If the dynamicRenderingUnusedAttachments feature is not enabled, and the current render pass instance was begun with vkCmdBeginRendering and VkRenderingInfo::colorAttachmentCount greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with an imageView not equal to VK_NULL_HANDLE must have been created with a VkFormat equal to the corresponding element of VkPipelineRenderingCreateInfo::pColorAttachmentFormats used to create the bound graphics pipeline VUID-vkCmdExecuteGeneratedCommandsEXT-dynamicRenderingUnusedAttachments-08912 If the dynamicRenderingUnusedAttachments feature is not enabled, and the current render pass instance was begun with vkCmdBeginRendering and VkRenderingInfo::colorAttachmentCount greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with an imageView equal to VK_NULL_HANDLE must have the corresponding element of VkPipelineRenderingCreateInfo::pColorAttachmentFormats used to create the bound pipeline equal to VK_FORMAT_UNDEFINED VUID-vkCmdExecuteGeneratedCommandsEXT-dynamicRenderingUnusedAttachments-08911 If the dynamicRenderingUnusedAttachments feature is enabled, and the current render pass instance was begun with vkCmdBeginRendering and VkRenderingInfo::colorAttachmentCount greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with an imageView not equal to VK_NULL_HANDLE must have been created with a VkFormat equal to the corresponding element of VkPipelineRenderingCreateInfo::pColorAttachmentFormats used to create the bound graphics pipeline, or the corresponding element of VkPipelineRenderingCreateInfo::pColorAttachmentFormats, if it exists, must be VK_FORMAT_UNDEFINED VUID-vkCmdExecuteGeneratedCommandsEXT-colorAttachmentCount-09362 If the current render pass instance was begun with vkCmdBeginRendering, with a VkRenderingInfo::colorAttachmentCount equal to 1, there is no shader object bound to any graphics stage, and a color attachment with a resolve mode of VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID, each element of the VkRenderingInfo::pColorAttachments array with a resolveImageView not equal to VK_NULL_HANDLE must have been created with an image created with a VkExternalFormatANDROID::externalFormat value equal to the VkExternalFormatANDROID::externalFormat value used to create the bound graphics pipeline VUID-vkCmdExecuteGeneratedCommandsEXT-None-09363 If there is no shader object bound to any graphics stage, the current render pass instance was begun with vkCmdBeginRendering and a VkRenderingInfo::colorAttachmentCount equal to 1, and a color attachment with a resolve mode of VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID, each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with an image created with a VkExternalFormatANDROID::externalFormat value equal to the VkExternalFormatANDROID::externalFormat value used to create the bound graphics pipeline VUID-vkCmdExecuteGeneratedCommandsEXT-None-09364 If the current render pass instance was begun with vkCmdBeginRendering, there is no shader object bound to any graphics stage, and the bound graphics pipeline was created with a non-zero VkExternalFormatANDROID::externalFormat value and with the VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT dynamic state enabled, then vkCmdSetColorBlendEnableEXT must have set the blend enable to VK_FALSE prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-09365 If the current render pass instance was begun with vkCmdBeginRendering, there is no shader object bound to any graphics stage, and the bound graphics pipeline was created with a non-zero VkExternalFormatANDROID::externalFormat value and with the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT dynamic state enabled, then vkCmdSetRasterizationSamplesEXT must have set rasterizationSamples to VK_SAMPLE_COUNT_1_BIT prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-09366 If there is a shader object bound to any graphics stage, and the current render pass includes a color attachment that uses the VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID resolve mode, then vkCmdSetColorBlendEnableEXT must have set blend enable to VK_FALSE prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-rasterizationSamples-09367 If there is a shader object bound to any graphics stage, and the current render pass includes a color attachment that uses the VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID resolve mode, then vkCmdSetRasterizationSamplesEXT must have set rasterizationSamples to VK_SAMPLE_COUNT_1_BIT prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-09368 If the current render pass instance was begun with vkCmdBeginRendering, there is no shader object bound to any graphics stage, and the bound graphics pipeline was created with a non-zero VkExternalFormatANDROID::externalFormat value and with the VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR dynamic state enabled, then vkCmdSetFragmentShadingRateKHR must have set pFragmentSize->width to 1 prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-09369 If the current render pass instance was begun with vkCmdBeginRendering, there is no shader object bound to any graphics stage, and the bound graphics pipeline was created with a non-zero VkExternalFormatANDROID::externalFormat value and with the VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR dynamic state enabled, then vkCmdSetFragmentShadingRateKHR must have set pFragmentSize->height to 1 prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-pFragmentSize-09370 If there is a shader object bound to any graphics stage, and the current render pass includes a color attachment that uses the VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID resolve mode, then vkCmdSetFragmentShadingRateKHR must have set pFragmentSize->width to 1 prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-pFragmentSize-09371 If there is a shader object bound to any graphics stage, and the current render pass includes a color attachment that uses the VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID resolve mode, then vkCmdSetFragmentShadingRateKHR must have set pFragmentSize->height to 1 prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-07749 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT dynamic state enabled then vkCmdSetColorWriteEnableEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-08646 If the colorWriteEnable feature is enabled, and a shader object is bound to the VK_SHADER_STAGE_FRAGMENT_BIT stage, and the most recent call to vkCmdSetRasterizerDiscardEnable in the current command buffer set rasterizerDiscardEnable to VK_FALSE, then vkCmdSetColorWriteEnableEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-attachmentCount-07750 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT dynamic state enabled then the attachmentCount parameter of vkCmdSetColorWriteEnableEXT must be greater than or equal to the VkPipelineColorBlendStateCreateInfo::attachmentCount of the bound graphics pipeline VUID-vkCmdExecuteGeneratedCommandsEXT-None-08647 If the colorWriteEnable feature is enabled, and a shader object is bound to the VK_SHADER_STAGE_FRAGMENT_BIT stage, and the most recent call to vkCmdSetRasterizerDiscardEnable in the current command buffer set rasterizerDiscardEnable to VK_FALSE, then the attachmentCount parameter of most recent call to vkCmdSetColorWriteEnableEXT in the current command buffer must be greater than or equal to the number of color attachments in the current render pass instance VUID-vkCmdExecuteGeneratedCommandsEXT-None-07751 If the VK_EXT_discard_rectangles extension is enabled, a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT dynamic state enabled and the pNext chain of VkGraphicsPipelineCreateInfo included a VkPipelineDiscardRectangleStateCreateInfoEXT structure, the current value of rasterizerDiscardEnable is VK_FALSE, and the current value of discardRectangleEnable is VK_TRUE, then vkCmdSetDiscardRectangleEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command for each discard rectangle in VkPipelineDiscardRectangleStateCreateInfoEXT::discardRectangleCount VUID-vkCmdExecuteGeneratedCommandsEXT-rasterizerDiscardEnable-09236 If the VK_EXT_discard_rectangles extension is enabled, a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT dynamic state enabled and the pNext chain of VkGraphicsPipelineCreateInfo did not include a VkPipelineDiscardRectangleStateCreateInfoEXT structure, the current value of rasterizerDiscardEnable is VK_FALSE, and the current value of discardRectangleEnable is VK_TRUE, then vkCmdSetDiscardRectangleEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command for each discard rectangle in VkPhysicalDeviceDiscardRectanglePropertiesEXT::maxDiscardRectangles VUID-vkCmdExecuteGeneratedCommandsEXT-None-07880 If the VK_EXT_discard_rectangles extension is enabled, a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_DISCARD_RECTANGLE_ENABLE_EXT dynamic state enabled, the current value of rasterizerDiscardEnable is VK_FALSE, then vkCmdSetDiscardRectangleEnableEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-07881 If the VK_EXT_discard_rectangles extension is enabled, a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_DISCARD_RECTANGLE_MODE_EXT dynamic state enabled, the current value of rasterizerDiscardEnable is VK_FALSE, and the current value of discardRectangleEnable is VK_TRUE, then vkCmdSetDiscardRectangleModeEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-dynamicRenderingUnusedAttachments-08913 If the current render pass instance was begun with vkCmdBeginRendering, the dynamicRenderingUnusedAttachments feature is not enabled, and VkRenderingInfo::pDepthAttachment->imageView was VK_NULL_HANDLE, the value of VkPipelineRenderingCreateInfo::depthAttachmentFormat used to create the bound graphics pipeline must be equal to VK_FORMAT_UNDEFINED VUID-vkCmdExecuteGeneratedCommandsEXT-dynamicRenderingUnusedAttachments-08914 If current render pass instance was begun with vkCmdBeginRendering, the dynamicRenderingUnusedAttachments feature is not enabled, and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineRenderingCreateInfo::depthAttachmentFormat used to create the bound graphics pipeline must be equal to the VkFormat used to create VkRenderingInfo::pDepthAttachment->imageView VUID-vkCmdExecuteGeneratedCommandsEXT-dynamicRenderingUnusedAttachments-08915 If the current render pass instance was begun with vkCmdBeginRendering, the dynamicRenderingUnusedAttachments feature is enabled, VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, and the value of VkPipelineRenderingCreateInfo::depthAttachmentFormat used to create the bound graphics pipeline was not equal to the VkFormat used to create VkRenderingInfo::pDepthAttachment->imageView, the value of the format must be VK_FORMAT_UNDEFINED VUID-vkCmdExecuteGeneratedCommandsEXT-dynamicRenderingUnusedAttachments-08916 If the current render pass instance was begun with vkCmdBeginRendering, the dynamicRenderingUnusedAttachments feature is not enabled, and VkRenderingInfo::pStencilAttachment->imageView was VK_NULL_HANDLE, the value of VkPipelineRenderingCreateInfo::stencilAttachmentFormat used to create the bound graphics pipeline must be equal to VK_FORMAT_UNDEFINED VUID-vkCmdExecuteGeneratedCommandsEXT-dynamicRenderingUnusedAttachments-08917 If current render pass instance was begun with vkCmdBeginRendering, the dynamicRenderingUnusedAttachments feature is not enabled, and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of VkPipelineRenderingCreateInfo::stencilAttachmentFormat used to create the bound graphics pipeline must be equal to the VkFormat used to create VkRenderingInfo::pStencilAttachment->imageView VUID-vkCmdExecuteGeneratedCommandsEXT-dynamicRenderingUnusedAttachments-08918 If the current render pass instance was begun with vkCmdBeginRendering, the dynamicRenderingUnusedAttachments feature is enabled, VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, and the value of VkPipelineRenderingCreateInfo::stencilAttachmentFormat used to create the bound graphics pipeline was not equal to the VkFormat used to create VkRenderingInfo::pStencilAttachment->imageView, the value of the format must be VK_FORMAT_UNDEFINED VUID-vkCmdExecuteGeneratedCommandsEXT-imageView-06183 If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingFragmentShadingRateAttachmentInfoKHR::imageView was not VK_NULL_HANDLE, the bound graphics pipeline must have been created with VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR VUID-vkCmdExecuteGeneratedCommandsEXT-imageView-06184 If the current render pass instance was begun with vkCmdBeginRendering and VkRenderingFragmentDensityMapAttachmentInfoEXT::imageView was not VK_NULL_HANDLE, the bound graphics pipeline must have been created with VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT VUID-vkCmdExecuteGeneratedCommandsEXT-colorAttachmentCount-06185 If the bound pipeline was created with a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the current render pass instance was begun with vkCmdBeginRendering with a VkRenderingInfo::colorAttachmentCount parameter greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a sample count equal to the corresponding element of the pColorAttachmentSamples member of VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV used to create the bound graphics pipeline VUID-vkCmdExecuteGeneratedCommandsEXT-pDepthAttachment-06186 If the current render pass instance was begun with vkCmdBeginRendering, the bound pipeline was created with a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of the depthStencilAttachmentSamples member of VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV used to create the bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pDepthAttachment->imageView VUID-vkCmdExecuteGeneratedCommandsEXT-pStencilAttachment-06187 If the current render pass instance was begun with vkCmdBeginRendering, the bound pipeline was created with a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of the depthStencilAttachmentSamples member of VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV used to create the bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pStencilAttachment->imageView VUID-vkCmdExecuteGeneratedCommandsEXT-multisampledRenderToSingleSampled-07285 If the bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the multisampledRenderToSingleSampled feature is not enabled, and the current render pass instance was begun with vkCmdBeginRendering with a VkRenderingInfo::colorAttachmentCount parameter greater than 0, then each element of the VkRenderingInfo::pColorAttachments array with a imageView not equal to VK_NULL_HANDLE must have been created with a sample count equal to the value of rasterizationSamples for the bound graphics pipeline VUID-vkCmdExecuteGeneratedCommandsEXT-multisampledRenderToSingleSampled-07286 If the bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the multisampledRenderToSingleSampled feature is not enabled, and VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, the value of rasterizationSamples for the bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pDepthAttachment->imageView VUID-vkCmdExecuteGeneratedCommandsEXT-multisampledRenderToSingleSampled-07287 If the bound pipeline was created without a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, and the multisampledRenderToSingleSampled feature is not enabled, and VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, the value of rasterizationSamples for the bound graphics pipeline must be equal to the sample count used to create VkRenderingInfo::pStencilAttachment->imageView VUID-vkCmdExecuteGeneratedCommandsEXT-pNext-07935 If this command has been called inside a render pass instance started with vkCmdBeginRendering, and the pNext chain of VkRenderingInfo includes a VkMultisampledRenderToSingleSampledInfoEXT structure with multisampledRenderToSingleSampledEnable equal to VK_TRUE, then the value of rasterizationSamples for the bound graphics pipeline must be equal to VkMultisampledRenderToSingleSampledInfoEXT::rasterizationSamples VUID-vkCmdExecuteGeneratedCommandsEXT-renderPass-06198 If the current render pass instance was begun with vkCmdBeginRendering, the bound pipeline must have been created with a VkGraphicsPipelineCreateInfo::renderPass equal to VK_NULL_HANDLE VUID-vkCmdExecuteGeneratedCommandsEXT-pColorAttachments-08963 If the current render pass instance was begun with vkCmdBeginRendering, there is a graphics pipeline bound with a fragment shader that statically writes to a color attachment, the color write mask is not zero, color writes are enabled, and the corresponding element of the VkRenderingInfo::pColorAttachments->imageView was not VK_NULL_HANDLE, then the corresponding element of VkPipelineRenderingCreateInfo::pColorAttachmentFormats used to create the pipeline must not be VK_FORMAT_UNDEFINED VUID-vkCmdExecuteGeneratedCommandsEXT-pDepthAttachment-08964 If the current render pass instance was begun with vkCmdBeginRendering, there is a graphics pipeline bound, depth test is enabled, depth write is enabled, and the VkRenderingInfo::pDepthAttachment->imageView was not VK_NULL_HANDLE, then the VkPipelineRenderingCreateInfo::depthAttachmentFormat used to create the pipeline must not be VK_FORMAT_UNDEFINED VUID-vkCmdExecuteGeneratedCommandsEXT-pStencilAttachment-08965 If the current render pass instance was begun with vkCmdBeginRendering, there is a graphics pipeline bound, stencil test is enabled and the VkRenderingInfo::pStencilAttachment->imageView was not VK_NULL_HANDLE, then the VkPipelineRenderingCreateInfo::stencilAttachmentFormat used to create the pipeline must not be VK_FORMAT_UNDEFINED VUID-vkCmdExecuteGeneratedCommandsEXT-flags-10582 If the current render pass instance was begun with vkCmdBeginRendering, its VkRenderingInfo::flags parameter must not have VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT set unless VK_RENDERING_CONTENTS_INLINE_BIT_KHR is also set VUID-vkCmdExecuteGeneratedCommandsEXT-primitivesGeneratedQueryWithRasterizerDiscard-06708 If the primitivesGeneratedQueryWithRasterizerDiscard feature is not enabled and the VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query is active, rasterization discard must not be enabled VUID-vkCmdExecuteGeneratedCommandsEXT-primitivesGeneratedQueryWithNonZeroStreams-06709 If the primitivesGeneratedQueryWithNonZeroStreams feature is not enabled and the VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query is active, the bound graphics pipeline must not have been created with a non-zero value in VkPipelineRasterizationStateStreamCreateInfoEXT::rasterizationStream VUID-vkCmdExecuteGeneratedCommandsEXT-None-07620 If the depthClamp feature is enabled, a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_DEPTH_CLAMP_ENABLE_EXT dynamic state enabled, and the current value of rasterizerDiscardEnable is VK_FALSE, then vkCmdSetDepthClampEnableEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-07621 If a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_POLYGON_MODE_EXT dynamic state enabled, and the current value of rasterizerDiscardEnable is VK_FALSE, then vkCmdSetPolygonModeEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-07622 If a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT dynamic state enabled, and the current value of rasterizerDiscardEnable is VK_FALSE, then vkCmdSetRasterizationSamplesEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-07623 If a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_SAMPLE_MASK_EXT dynamic state enabled, and the current value of rasterizerDiscardEnable is VK_FALSE, then vkCmdSetSampleMaskEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-alphaToCoverageEnable-08919 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT dynamic state enabled, and alphaToCoverageEnable was VK_TRUE in the last call to vkCmdSetAlphaToCoverageEnableEXT, then the Fragment Output Interface must contain a variable for the alpha Component word in Location 0 at Index 0 VUID-vkCmdExecuteGeneratedCommandsEXT-alphaToCoverageEnable-08920 If a shader object is bound to any graphics stage, and the most recent call to vkCmdSetAlphaToCoverageEnableEXT in the current command buffer set alphaToCoverageEnable to VK_TRUE, then the Fragment Output Interface must contain a variable for the alpha Component word in Location 0 at Index 0 VUID-vkCmdExecuteGeneratedCommandsEXT-None-07624 If a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT dynamic state enabled, and the current value of rasterizerDiscardEnable is VK_FALSE, then vkCmdSetAlphaToCoverageEnableEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-07625 If the alphaToOne feature is enabled, a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_ALPHA_TO_ONE_ENABLE_EXT dynamic state enabled, and the current value of rasterizerDiscardEnable is VK_FALSE, then vkCmdSetAlphaToOneEnableEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-07626 If the logicOp feature is enabled, a shader object is bound to the VK_SHADER_STAGE_FRAGMENT_BIT stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_LOGIC_OP_ENABLE_EXT dynamic state enabled, and the current value of rasterizerDiscardEnable is VK_FALSE, then vkCmdSetLogicOpEnableEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-07627 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT dynamic state enabled then vkCmdSetColorBlendEnableEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-08657 If a shader object is bound to the VK_SHADER_STAGE_FRAGMENT_BIT stage, and both the most recent call to vkCmdSetRasterizerDiscardEnable in the current command buffer set rasterizerDiscardEnable to VK_FALSE and there are color attachments bound, then vkCmdSetColorBlendEnableEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-07628 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT dynamic state enabled then vkCmdSetColorBlendEquationEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-08658 If a shader object is bound to the VK_SHADER_STAGE_FRAGMENT_BIT stage, and the most recent call to vkCmdSetRasterizerDiscardEnable in the current command buffer set rasterizerDiscardEnable to VK_FALSE, and the most recent call to vkCmdSetColorBlendEnableEXT for any attachment set that attachment’s value in pColorBlendEnables to VK_TRUE, then vkCmdSetColorBlendEquationEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-07629 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT dynamic state enabled then vkCmdSetColorWriteMaskEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-08659 If a shader object is bound to the VK_SHADER_STAGE_FRAGMENT_BIT stage, and both the most recent call to vkCmdSetRasterizerDiscardEnable in the current command buffer set rasterizerDiscardEnable to VK_FALSE and there are color attachments bound, then vkCmdSetColorWriteMaskEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-07630 If the geometryStreams feature is enabled, and a shader object is bound to the VK_SHADER_STAGE_GEOMETRY_BIT stage or a graphics pipeline is bound which was created with both a VK_SHADER_STAGE_GEOMETRY_BIT stage and the VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT dynamic state enabled, then vkCmdSetRasterizationStreamEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-07631 If the VK_EXT_conservative_rasterization extension is enabled, a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT dynamic state enabled, and the current value of rasterizerDiscardEnable is VK_FALSE, then vkCmdSetConservativeRasterizationModeEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-07632 If the VK_EXT_conservative_rasterization extension is enabled, a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_EXTRA_PRIMITIVE_OVERESTIMATION_SIZE_EXT dynamic state enabled, the current value of rasterizerDiscardEnable is VK_FALSE, and the current value of conservativeRasterizationMode is VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT, then vkCmdSetExtraPrimitiveOverestimationSizeEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-07633 If the depthClipEnable feature is enabled, and a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_DEPTH_CLIP_ENABLE_EXT dynamic state, then vkCmdSetDepthClipEnableEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-07635 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT dynamic state enabled then vkCmdSetColorBlendAdvancedEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-rasterizerDiscardEnable-09416 If the VK_EXT_blend_operation_advanced extension is enabled, and a shader object is bound to the VK_SHADER_STAGE_FRAGMENT_BIT stage, and the most recent call to vkCmdSetRasterizerDiscardEnable in the current command buffer set rasterizerDiscardEnable to VK_FALSE, then at least one of vkCmdSetColorBlendEquationEXT and vkCmdSetColorBlendAdvancedEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-07636 If the VK_EXT_provoking_vertex extension is enabled, a shader object is bound to the VK_SHADER_STAGE_VERTEX_BIT stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_PROVOKING_VERTEX_MODE_EXT dynamic state enabled, and the current value of rasterizerDiscardEnable is VK_FALSE, then vkCmdSetProvokingVertexModeEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-07637 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic state enabled then vkCmdSetLineRasterizationModeEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-08666 If any of the stippledRectangularLines, stippledBresenhamLines or stippledSmoothLines features are enabled, and a shader object is bound to any graphics stage, and the most recent call to vkCmdSetRasterizerDiscardEnable in the current command buffer set rasterizerDiscardEnable to VK_FALSE, and the most recent call to vkCmdSetPolygonModeEXT in the current command buffer set polygonMode to VK_POLYGON_MODE_LINE, then vkCmdSetLineRasterizationModeEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-08667 If any of the stippledRectangularLines, stippledBresenhamLines or stippledSmoothLines features are enabled, and a shader object is bound to the VK_SHADER_STAGE_VERTEX_BIT stage, and the most recent call to vkCmdSetRasterizerDiscardEnable in the current command buffer set rasterizerDiscardEnable to VK_FALSE, and the most recent call to vkCmdSetPrimitiveTopology in the current command buffer set primitiveTopology to any line topology, then vkCmdSetLineRasterizationModeEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-08668 If any of the stippledRectangularLines, stippledBresenhamLines or stippledSmoothLines features are enabled, and a shader object that outputs line primitives is bound to the VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT or VK_SHADER_STAGE_GEOMETRY_BIT stage, and the most recent call to vkCmdSetRasterizerDiscardEnable in the current command buffer set rasterizerDiscardEnable to VK_FALSE, then vkCmdSetLineRasterizationModeEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-07638 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT dynamic state enabled then vkCmdSetLineStippleEnableEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-08669 If any of the stippledRectangularLines, stippledBresenhamLines or stippledSmoothLines features are enabled, and a shader object is bound to any graphics stage, and the most recent call to vkCmdSetRasterizerDiscardEnable in the current command buffer set rasterizerDiscardEnable to VK_FALSE, and the most recent call to vkCmdSetPolygonModeEXT in the current command buffer set polygonMode to VK_POLYGON_MODE_LINE, then vkCmdSetLineStippleEnableEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-08670 If any of the stippledRectangularLines, stippledBresenhamLines or stippledSmoothLines features are enabled, and a shader object is bound to the VK_SHADER_STAGE_VERTEX_BIT stage, and the most recent call to vkCmdSetRasterizerDiscardEnable in the current command buffer set rasterizerDiscardEnable to VK_FALSE, and the most recent call to vkCmdSetPrimitiveTopology in the current command buffer set primitiveTopology to any line topology, then vkCmdSetLineStippleEnableEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-08671 If any of the stippledRectangularLines, stippledBresenhamLines or stippledSmoothLines features are enabled, and a shader object that outputs line primitives is bound to the VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT or VK_SHADER_STAGE_GEOMETRY_BIT stage, and the most recent call to vkCmdSetRasterizerDiscardEnable in the current command buffer set rasterizerDiscardEnable to VK_FALSE, then vkCmdSetLineStippleEnableEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-07849 If any of the stippledRectangularLines, stippledBresenhamLines or stippledSmoothLines features are enabled and a shader object is bound to any graphics stage, or a bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE dynamic state enabled, the current value of rasterizerDiscardEnable is VK_FALSE, and the current value of stippledLineEnable is VK_TRUE, then vkCmdSetLineStipple must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-10608 If a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic state enabled, and the current lineRasterizationMode is VK_LINE_RASTERIZATION_MODE_BRESENHAM or VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH, then the current alphaToCoverageEnable, alphaToOneEnable and sampleShadingEnable states must all be VK_FALSE VUID-vkCmdExecuteGeneratedCommandsEXT-None-07639 If the depthClipControl feature is enabled, and a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_DEPTH_CLIP_NEGATIVE_ONE_TO_ONE_EXT dynamic state enabled, then vkCmdSetDepthClipNegativeOneToOneEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-09650 If the depthClampControl feature is enabled, and a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_DEPTH_CLAMP_RANGE_EXT dynamic state enabled, and the current value of depthClampEnable is VK_TRUE, then vkCmdSetDepthClampRangeEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-07640 If the VK_NV_clip_space_w_scaling extension is enabled, and a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_ENABLE_NV dynamic state enabled, then vkCmdSetViewportWScalingEnableNV must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-07641 If the VK_NV_viewport_swizzle extension is enabled, and a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV dynamic state enabled, then vkCmdSetViewportSwizzleNV must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-07642 If the VK_NV_fragment_coverage_to_color extension is enabled, a shader object is bound to the VK_SHADER_STAGE_FRAGMENT_BIT stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV dynamic state enabled, and the current value of rasterizerDiscardEnable is VK_FALSE, then vkCmdSetCoverageToColorEnableNV must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-07643 If the VK_NV_fragment_coverage_to_color extension is enabled, a shader object is bound to the VK_SHADER_STAGE_FRAGMENT_BIT stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_LOCATION_NV dynamic state enabled, the current value of rasterizerDiscardEnable is VK_FALSE, and the current value of coverageToColorEnable is VK_TRUE, then vkCmdSetCoverageToColorLocationNV must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-07644 If the VK_NV_framebuffer_mixed_samples extension is enabled, a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_COVERAGE_MODULATION_MODE_NV dynamic state enabled, and the current value of rasterizerDiscardEnable is VK_FALSE, then vkCmdSetCoverageModulationModeNV must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-07645 If the VK_NV_framebuffer_mixed_samples extension is enabled, a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV dynamic state enabled, the current value of rasterizerDiscardEnable is VK_FALSE, and the current value of coverageModulationMode is any value other than VK_COVERAGE_MODULATION_MODE_NONE_NV, then vkCmdSetCoverageModulationTableEnableNV must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-07646 If the VK_NV_framebuffer_mixed_samples extension is enabled, a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_NV dynamic state enabled, the current value of rasterizerDiscardEnable is VK_FALSE, and the current value of coverageModulationTableEnable is VK_TRUE, then vkCmdSetCoverageModulationTableNV must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-07647 If the shadingRateImage feature is enabled, a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_SHADING_RATE_IMAGE_ENABLE_NV dynamic state enabled, and the current value of rasterizerDiscardEnable is VK_FALSE, then vkCmdSetShadingRateImageEnableNV must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-pipelineFragmentShadingRate-09238 If the pipelineFragmentShadingRate feature is enabled, a shader object is bound to the VK_SHADER_STAGE_FRAGMENT_BIT stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR dynamic state enabled, and the current value of rasterizerDiscardEnable is VK_FALSE, then vkCmdSetFragmentShadingRateKHR must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-07648 If the representativeFragmentTest feature is enabled, a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_REPRESENTATIVE_FRAGMENT_TEST_ENABLE_NV dynamic state enabled, and the current value of rasterizerDiscardEnable is VK_FALSE, then vkCmdSetRepresentativeFragmentTestEnableNV must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-07649 If the coverageReductionMode feature is enabled, a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_COVERAGE_REDUCTION_MODE_NV dynamic state enabled, and the current value of rasterizerDiscardEnable is VK_FALSE, then vkCmdSetCoverageReductionModeNV must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-pColorBlendEnables-07470 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT state enabled and the last call to vkCmdSetColorBlendEnableEXT set pColorBlendEnables for any attachment to VK_TRUE, then for those attachments in the subpass the corresponding image view’s format features must contain VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT VUID-vkCmdExecuteGeneratedCommandsEXT-rasterizationSamples-07471 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, and the current subpass does not use any color and/or depth/stencil attachments, then the rasterizationSamples in the last call to vkCmdSetRasterizationSamplesEXT must follow the rules for a zero-attachment subpass VUID-vkCmdExecuteGeneratedCommandsEXT-samples-07472 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_MASK_EXT state enabled and the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state disabled, then the samples parameter in the last call to vkCmdSetSampleMaskEXT must be greater or equal to the VkPipelineMultisampleStateCreateInfo::rasterizationSamples parameter used to create the bound graphics pipeline VUID-vkCmdExecuteGeneratedCommandsEXT-samples-07473 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_MASK_EXT state and VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT states enabled, then the samples parameter in the last call to vkCmdSetSampleMaskEXT must be greater or equal to the rasterizationSamples parameter in the last call to vkCmdSetRasterizationSamplesEXT VUID-vkCmdExecuteGeneratedCommandsEXT-rasterizationSamples-07474 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, and the multisampledRenderToSingleSampled feature is not enabled, and neither the VK_AMD_mixed_attachment_samples nor the VK_NV_framebuffer_mixed_samples extensions are enabled, then the rasterizationSamples in the last call to vkCmdSetRasterizationSamplesEXT must be the same as the current subpass color and/or depth/stencil attachments VUID-vkCmdExecuteGeneratedCommandsEXT-None-09211 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, or a shader object is bound to any graphics stage, and the current render pass instance includes a VkMultisampledRenderToSingleSampledInfoEXT structure with multisampledRenderToSingleSampledEnable equal to VK_TRUE, then the rasterizationSamples in the last call to vkCmdSetRasterizationSamplesEXT must be the same as the rasterizationSamples member of that structure VUID-vkCmdExecuteGeneratedCommandsEXT-firstAttachment-07476 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT dynamic state enabled then vkCmdSetColorBlendEnableEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorBlendEnableEXT calls must specify an enable for all active color attachments in the current subpass VUID-vkCmdExecuteGeneratedCommandsEXT-rasterizerDiscardEnable-09417 If a shader object is bound to the VK_SHADER_STAGE_FRAGMENT_BIT stage, and the most recent call to vkCmdSetRasterizerDiscardEnable in the current command buffer set rasterizerDiscardEnable to VK_FALSE, then vkCmdSetColorBlendEnableEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorBlendEnableEXT calls must specify an enable for all active color attachments in the current subpass VUID-vkCmdExecuteGeneratedCommandsEXT-firstAttachment-07477 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT dynamic state enabled then vkCmdSetColorBlendEquationEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorBlendEquationEXT calls must specify the blend equations for all active color attachments in the current subpass where blending is enabled VUID-vkCmdExecuteGeneratedCommandsEXT-rasterizerDiscardEnable-09418 If a shader object is bound to the VK_SHADER_STAGE_FRAGMENT_BIT stage, and both the most recent call to vkCmdSetRasterizerDiscardEnable in the current command buffer set rasterizerDiscardEnable to VK_FALSE and there are color attachments bound, then vkCmdSetColorBlendEquationEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorBlendEquationEXT calls must specify the blend equations for all active color attachments in the current subpass where blending is enabled VUID-vkCmdExecuteGeneratedCommandsEXT-firstAttachment-07478 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT dynamic state enabled then vkCmdSetColorWriteMaskEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorWriteMaskEXT calls must specify the color write mask for all active color attachments in the current subpass VUID-vkCmdExecuteGeneratedCommandsEXT-rasterizerDiscardEnable-09419 If a shader object is bound to the VK_SHADER_STAGE_FRAGMENT_BIT stage, and the most recent call to vkCmdSetRasterizerDiscardEnable in the current command buffer set rasterizerDiscardEnable to VK_FALSE, then vkCmdSetColorWriteMaskEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorWriteMaskEXT calls must specify the color write mask for all active color attachments in the current subpass VUID-vkCmdExecuteGeneratedCommandsEXT-firstAttachment-07479 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT dynamic state enabled then vkCmdSetColorBlendAdvancedEXT must have been called in the current command buffer prior to this drawing command, and the attachments specified by the firstAttachment and attachmentCount parameters of vkCmdSetColorBlendAdvancedEXT calls must specify the advanced blend equations for all active color attachments in the current subpass where blending is enabled VUID-vkCmdExecuteGeneratedCommandsEXT-advancedBlendMaxColorAttachments-07480 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT and VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT dynamic states enabled and the last calls to vkCmdSetColorBlendEnableEXT and vkCmdSetColorBlendAdvancedEXT have enabled advanced blending, then the number of active color attachments in the current subpass must not exceed advancedBlendMaxColorAttachments VUID-vkCmdExecuteGeneratedCommandsEXT-primitivesGeneratedQueryWithNonZeroStreams-07481 If the primitivesGeneratedQueryWithNonZeroStreams feature is not enabled and the VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT query is active, and the bound graphics pipeline was created with VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT state enabled, the last call to vkCmdSetRasterizationStreamEXT must have set the rasterizationStream to zero VUID-vkCmdExecuteGeneratedCommandsEXT-sampleLocationsPerPixel-07482 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state disabled, and the current value of sampleLocationsEnable is VK_TRUE, then the sampleLocationsPerPixel member of pSampleLocationsInfo in the last call to vkCmdSetSampleLocationsEXT must equal the rasterizationSamples member of the VkPipelineMultisampleStateCreateInfo structure the bound graphics pipeline has been created with VUID-vkCmdExecuteGeneratedCommandsEXT-sampleLocationsPerPixel-07483 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, and the current value of sampleLocationsEnable is VK_TRUE, then the sampleLocationsPerPixel member of pSampleLocationsInfo in the last call to vkCmdSetSampleLocationsEXT must equal the rasterizationSamples parameter of the last call to vkCmdSetRasterizationSamplesEXT VUID-vkCmdExecuteGeneratedCommandsEXT-sampleLocationsEnable-07484 If a shader object is bound to the VK_SHADER_STAGE_FRAGMENT_BIT stage, or the bound graphics pipeline was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, and the current subpass has a depth/stencil attachment, then that attachment must have been created with the VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT bit set VUID-vkCmdExecuteGeneratedCommandsEXT-sampleLocationsEnable-07485 If a shader object is bound to the VK_SHADER_STAGE_FRAGMENT_BIT stage, or the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and if sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, then the sampleLocationsInfo.maxSampleLocationGridSize.width in the last call to vkCmdSetSampleLocationsEXT must evenly divide VkMultisamplePropertiesEXT::maxSampleLocationGridSize.width as returned by vkGetPhysicalDeviceMultisamplePropertiesEXT with a samples parameter equaling rasterizationSamples VUID-vkCmdExecuteGeneratedCommandsEXT-sampleLocationsEnable-07486 If a shader object is bound to the VK_SHADER_STAGE_FRAGMENT_BIT stage, or the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state enabled and the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and if sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, then the sampleLocationsInfo.maxSampleLocationGridSize.height in the last call to vkCmdSetSampleLocationsEXT must evenly divide VkMultisamplePropertiesEXT::maxSampleLocationGridSize.height as returned by vkGetPhysicalDeviceMultisamplePropertiesEXT with a samples parameter equaling rasterizationSamples VUID-vkCmdExecuteGeneratedCommandsEXT-sampleLocationsEnable-07487 If a shader object is bound to the VK_SHADER_STAGE_FRAGMENT_BIT stage, or the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT state enabled, and if sampleLocationsEnable was VK_TRUE in the last call to vkCmdSetSampleLocationsEnableEXT, the fragment shader code must not statically use the extended instruction InterpolateAtSample VUID-vkCmdExecuteGeneratedCommandsEXT-sampleLocationsEnable-07936 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state disabled and the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, and the current value of sampleLocationsEnable is VK_TRUE, then sampleLocationsInfo.sampleLocationGridSize.width must evenly divide VkMultisamplePropertiesEXT::maxSampleLocationGridSize.width as returned by vkGetPhysicalDeviceMultisamplePropertiesEXT with a samples parameter equaling the value of rasterizationSamples in the last call to vkCmdSetRasterizationSamplesEXT VUID-vkCmdExecuteGeneratedCommandsEXT-sampleLocationsEnable-07937 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state disabled and the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, and the current value of sampleLocationsEnable is VK_TRUE, then sampleLocationsInfo.sampleLocationGridSize.height must evenly divide VkMultisamplePropertiesEXT::maxSampleLocationGridSize.height as returned by vkGetPhysicalDeviceMultisamplePropertiesEXT with a samples parameter equaling the value of rasterizationSamples in the last call to vkCmdSetRasterizationSamplesEXT VUID-vkCmdExecuteGeneratedCommandsEXT-sampleLocationsEnable-07938 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT state disabled and the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT state enabled, and the current value of sampleLocationsEnable is VK_TRUE, then sampleLocationsInfo.sampleLocationsPerPixel must equal rasterizationSamples in the last call to vkCmdSetRasterizationSamplesEXT VUID-vkCmdExecuteGeneratedCommandsEXT-coverageModulationTableEnable-07488 If a shader object is bound to any graphics stage or the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV state enabled, and the last call to vkCmdSetCoverageModulationTableEnableNV set coverageModulationTableEnable to VK_TRUE, then the coverageModulationTableCount parameter in the last call to vkCmdSetCoverageModulationTableNV must equal the current rasterizationSamples divided by the number of color samples in the current subpass VUID-vkCmdExecuteGeneratedCommandsEXT-rasterizationSamples-07489 If the VK_NV_framebuffer_mixed_samples extension is enabled, and if current subpass has a depth/stencil attachment and depth test, stencil test, or depth bounds test are enabled in the bound pipeline, then the current rasterizationSamples must be the same as the sample count of the depth/stencil attachment VUID-vkCmdExecuteGeneratedCommandsEXT-coverageToColorEnable-07490 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV state enabled and the last call to vkCmdSetCoverageToColorEnableNV set the coverageToColorEnable to VK_TRUE, then the current subpass must have a color attachment at the location selected by the last call to vkCmdSetCoverageToColorLocationNV coverageToColorLocation, with a VkFormat of VK_FORMAT_R8_UINT, VK_FORMAT_R8_SINT, VK_FORMAT_R16_UINT, VK_FORMAT_R16_SINT, VK_FORMAT_R32_UINT, or VK_FORMAT_R32_SINT VUID-vkCmdExecuteGeneratedCommandsEXT-rasterizerDiscardEnable-09420 If the VK_NV_fragment_coverage_to_color extension is enabled, and a shader object is bound to the VK_SHADER_STAGE_FRAGMENT_BIT stage, and the most recent call to vkCmdSetRasterizerDiscardEnable in the current command buffer set rasterizerDiscardEnable to VK_FALSE, and the last call to vkCmdSetCoverageToColorEnableNV set the coverageToColorEnable to VK_TRUE, then the current subpass must have a color attachment at the location selected by the last call to vkCmdSetCoverageToColorLocationNV coverageToColorLocation, with a VkFormat of VK_FORMAT_R8_UINT, VK_FORMAT_R8_SINT, VK_FORMAT_R16_UINT, VK_FORMAT_R16_SINT, VK_FORMAT_R32_UINT, or VK_FORMAT_R32_SINT VUID-vkCmdExecuteGeneratedCommandsEXT-coverageReductionMode-07491 If the coverageReductionMode feature is enabled, a shader object is bound to any graphics stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_COVERAGE_REDUCTION_MODE_NV or VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT dynamic states enabled, then the current values of coverageReductionMode, rasterizationSamples, the sample counts for the color and depth/stencil attachments (if the subpass has them) must be a valid combination returned by vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV VUID-vkCmdExecuteGeneratedCommandsEXT-viewportCount-07492 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT dynamic state enabled, but not the VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV dynamic state enabled, then the bound graphics pipeline must have been created with VkPipelineViewportSwizzleStateCreateInfoNV::viewportCount greater or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount VUID-vkCmdExecuteGeneratedCommandsEXT-viewportCount-07493 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT and VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV dynamic states enabled then the viewportCount parameter in the last call to vkCmdSetViewportSwizzleNV must be greater than or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount VUID-vkCmdExecuteGeneratedCommandsEXT-viewportCount-09421 If the VK_NV_viewport_swizzle extension is enabled, and a shader object is bound to any graphics stage, then the viewportCount parameter in the last call to vkCmdSetViewportSwizzleNV must be greater than or equal to the viewportCount parameter in the last call to vkCmdSetViewportWithCount VUID-vkCmdExecuteGeneratedCommandsEXT-rasterizationSamples-07494 If the VK_NV_framebuffer_mixed_samples extension is enabled, and the coverageReductionMode feature is not enabled, or the current value of coverageReductionMode is not VK_COVERAGE_REDUCTION_MODE_TRUNCATE_NV, and the current value of rasterizationSamples is greater than sample count of the color attachment, then sample shading must be disabled VUID-vkCmdExecuteGeneratedCommandsEXT-stippledLineEnable-07495 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_RECTANGULAR, then the stippledRectangularLines feature must be enabled VUID-vkCmdExecuteGeneratedCommandsEXT-stippledLineEnable-07496 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_BRESENHAM, then the stippledBresenhamLines feature must be enabled VUID-vkCmdExecuteGeneratedCommandsEXT-stippledLineEnable-07497 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH, then the stippledSmoothLines feature must be enabled VUID-vkCmdExecuteGeneratedCommandsEXT-stippledLineEnable-07498 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT or VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT dynamic states enabled, and if the current stippledLineEnable state is VK_TRUE and the current lineRasterizationMode state is VK_LINE_RASTERIZATION_MODE_DEFAULT, then the stippledRectangularLines feature must be enabled and VkPhysicalDeviceLimits::strictLines must be VK_TRUE VUID-vkCmdExecuteGeneratedCommandsEXT-conservativePointAndLineRasterization-07499 If the bound graphics pipeline state was created with the VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT dynamic state enabled, conservativePointAndLineRasterization is not supported, and the effective primitive topology output by the last pre-rasterization shader stage is a line or point, then the conservativeRasterizationMode set by the last call to vkCmdSetConservativeRasterizationModeEXT must be VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT VUID-vkCmdExecuteGeneratedCommandsEXT-stage-07073 If the bound pipeline was created with the VkPipelineShaderStageCreateInfo::stage member of an element of VkGraphicsPipelineCreateInfo::pStages set to VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT or VK_SHADER_STAGE_GEOMETRY_BIT, then Mesh Shader Queries must not be active VUID-vkCmdExecuteGeneratedCommandsEXT-None-08877 If a shader object is bound to the VK_SHADER_STAGE_FRAGMENT_BIT stage or a graphics pipeline is bound which was created with the VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT dynamic state enabled, and the current value of rasterizerDiscardEnable is VK_FALSE, then vkCmdSetAttachmentFeedbackLoopEnableEXT must have been called and not subsequently invalidated in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-None-07850 If dynamic state was inherited from VkCommandBufferInheritanceViewportScissorInfoNV, it must be set in the current command buffer prior to this drawing command VUID-vkCmdExecuteGeneratedCommandsEXT-nextStage-10745 For each shader object bound to a graphics stage, except for shader object bound to the last graphics stage in the logical pipeline, it must have been created with a nextStage including the corresponding bit to the shader object bound to the following graphics stage in the logical pipeline VUID-vkCmdExecuteGeneratedCommandsEXT-None-08684 If there is no bound graphics pipeline, vkCmdBindShadersEXT must have been called in the current command buffer with pStages with an element of VK_SHADER_STAGE_VERTEX_BIT VUID-vkCmdExecuteGeneratedCommandsEXT-None-08685 If there is no bound graphics pipeline, and the tessellationShader feature is enabled, vkCmdBindShadersEXT must have been called in the current command buffer with pStages with an element of VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT VUID-vkCmdExecuteGeneratedCommandsEXT-None-08686 If there is no bound graphics pipeline, and the tessellationShader feature is enabled, vkCmdBindShadersEXT must have been called in the current command buffer with pStages with an element of VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT VUID-vkCmdExecuteGeneratedCommandsEXT-None-08687 If there is no bound graphics pipeline, and the geometryShader feature is enabled, vkCmdBindShadersEXT must have been called in the current command buffer with pStages with an element of VK_SHADER_STAGE_GEOMETRY_BIT VUID-vkCmdExecuteGeneratedCommandsEXT-None-08688 If there is no bound graphics pipeline, vkCmdBindShadersEXT must have been called in the current command buffer with pStages with an element of VK_SHADER_STAGE_FRAGMENT_BIT VUID-vkCmdExecuteGeneratedCommandsEXT-None-08689 If there is no bound graphics pipeline, and the taskShader feature is enabled, vkCmdBindShadersEXT must have been called in the current command buffer with pStages with an element of VK_SHADER_STAGE_TASK_BIT_EXT VUID-vkCmdExecuteGeneratedCommandsEXT-None-08690 If there is no bound graphics pipeline, and the meshShader feature is enabled, vkCmdBindShadersEXT must have been called in the current command buffer with pStages with an element of VK_SHADER_STAGE_MESH_BIT_EXT VUID-vkCmdExecuteGeneratedCommandsEXT-None-08693 If there is no bound graphics pipeline, and at least one of the taskShader and meshShader features is enabled, one of the VK_SHADER_STAGE_VERTEX_BIT or VK_SHADER_STAGE_MESH_BIT_EXT stages must have a valid VkShaderEXT bound, and the other must have no VkShaderEXT bound VUID-vkCmdExecuteGeneratedCommandsEXT-None-08696 If there is no bound graphics pipeline, and a valid VkShaderEXT is bound to the VK_SHADER_STAGE_VERTEX_BIT stage, there must be no VkShaderEXT bound to either the VK_SHADER_STAGE_TASK_BIT_EXT stage or the VK_SHADER_STAGE_MESH_BIT_EXT stage VUID-vkCmdExecuteGeneratedCommandsEXT-None-08698 If any graphics shader is bound which was created with the VK_SHADER_CREATE_LINK_STAGE_BIT_EXT flag, then all shaders created with the VK_SHADER_CREATE_LINK_STAGE_BIT_EXT flag in the same vkCreateShadersEXT call must also be bound VUID-vkCmdExecuteGeneratedCommandsEXT-None-08699 If any graphics shader is bound which was created with the VK_SHADER_CREATE_LINK_STAGE_BIT_EXT flag, any stages in between stages whose shaders which did not create a shader with the VK_SHADER_CREATE_LINK_STAGE_BIT_EXT flag as part of the same vkCreateShadersEXT call must not have any VkShaderEXT bound VUID-vkCmdExecuteGeneratedCommandsEXT-None-08878 All bound graphics shader objects must have been created with identical or identically defined push constant ranges VUID-vkCmdExecuteGeneratedCommandsEXT-None-08879 All bound graphics shader objects must have been created with identical or identically defined arrays of descriptor set layouts VUID-vkCmdExecuteGeneratedCommandsEXT-colorAttachmentCount-09372 If the current render pass instance was begun with vkCmdBeginRendering and a VkRenderingInfo::colorAttachmentCount equal to 1, a color attachment with a resolve mode of VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID, and a fragment shader is bound, it must not declare the DepthReplacing or StencilRefReplacingEXT execution modes VUID-vkCmdExecuteGeneratedCommandsEXT-pDynamicStates-08715 If the bound graphics pipeline state includes a fragment shader stage, was created with VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE set in VkPipelineDynamicStateCreateInfo::pDynamicStates, and the fragment shader declares the EarlyFragmentTests execution mode and uses OpDepthAttachmentReadEXT, the depthWriteEnable parameter in the last call to vkCmdSetDepthWriteEnable must be VK_FALSE VUID-vkCmdExecuteGeneratedCommandsEXT-pDynamicStates-08716 If the bound graphics pipeline state includes a fragment shader stage, was created with VK_DYNAMIC_STATE_STENCIL_WRITE_MASK set in VkPipelineDynamicStateCreateInfo::pDynamicStates, and the fragment shader declares the EarlyFragmentTests execution mode and uses OpStencilAttachmentReadEXT, the writeMask parameter in the last call to vkCmdSetStencilWriteMask must be 0 VUID-vkCmdExecuteGeneratedCommandsEXT-None-09116 If a shader object is bound to any graphics stage or the bound graphics pipeline was created with VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT, and the format of any color attachment is VK_FORMAT_E5B9G9R9_UFLOAT_PACK32, the corresponding element of the pColorWriteMasks parameter of vkCmdSetColorWriteMaskEXT must either include all of VK_COLOR_COMPONENT_R_BIT, VK_COLOR_COMPONENT_G_BIT, and VK_COLOR_COMPONENT_B_BIT, or none of them VUID-vkCmdExecuteGeneratedCommandsEXT-maxFragmentDualSrcAttachments-09239 If blending is enabled for any attachment where either the source or destination blend factors for that attachment use the secondary color input, the maximum value of Location for any output attachment statically used in the Fragment Execution Model executed by this command must be less than maxFragmentDualSrcAttachments VUID-vkCmdExecuteGeneratedCommandsEXT-None-09548 If the current render pass was begun with vkCmdBeginRendering, and there is no shader object bound to any graphics stage, the value of each element of VkRenderingAttachmentLocationInfo::pColorAttachmentLocations set by vkCmdSetRenderingAttachmentLocations must match the value set for the corresponding element in the bound pipeline VUID-vkCmdExecuteGeneratedCommandsEXT-None-09549 If the current render pass was begun with vkCmdBeginRendering, and there is no shader object bound to any graphics stage, input attachment index mappings in the bound pipeline must match those set for the current render pass instance via VkRenderingInputAttachmentIndexInfo VUID-vkCmdExecuteGeneratedCommandsEXT-None-09642 If the current render pass was begun with vkCmdBeginRendering with the VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT flag, the bound graphics pipeline must have been created with VK_PIPELINE_CREATE_2_ENABLE_LEGACY_DITHERING_BIT_EXT VUID-vkCmdExecuteGeneratedCommandsEXT-None-09643 If the bound graphics pipeline was created with VK_PIPELINE_CREATE_2_ENABLE_LEGACY_DITHERING_BIT_EXT, the current render pass must have begun with vkCmdBeginRendering with the VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT flag VUID-vkCmdExecuteGeneratedCommandsEXT-None-10677 If the per-tile execution model is enabled, the tileShadingPerTileDraw feature must be enabled VUID-vkCmdExecuteGeneratedCommandsEXT-commandBuffer-11045 commandBuffer must not be a protected command buffer VUID-vkCmdExecuteGeneratedCommandsEXT-isPreprocessed-11046 If isPreprocessed is VK_TRUE and vkGetGeneratedCommandsMemoryRequirementsEXT did not return a required size of zero then vkCmdPreprocessGeneratedCommandsEXT must have already been executed on the device before this command executes, and the preprocessing command must have used the same pGeneratedCommandsInfo content as well as the content of the input buffers it references (all except VkGeneratedCommandsInfoEXT::preprocessAddress) VUID-vkCmdExecuteGeneratedCommandsEXT-isPreprocessed-11047 If isPreprocessed is VK_TRUE then the indirectCommandsLayout member of pGeneratedCommandsInfo must have been created with the VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_EXT bit set VUID-vkCmdExecuteGeneratedCommandsEXT-indirectCommandsLayout-11141 If the indirectCommandsLayout member of pGeneratedCommandsInfo was created with the VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_EXT bit set, then isPreprocessed must be VK_TRUE VUID-vkCmdExecuteGeneratedCommandsEXT-preprocessAddress-11142 The contents of the preprocessAddress member of pGeneratedCommandsInfo must not have been previously used to record another vkCmdExecuteGeneratedCommandsEXT VUID-vkCmdExecuteGeneratedCommandsEXT-isPreprocessed-11048 If isPreprocessed is VK_TRUE then the bound descriptor sets and push constants must match identically with those bound during recording of the corresponding call to vkCmdPreprocessGeneratedCommandsEXT VUID-vkCmdExecuteGeneratedCommandsEXT-isPreprocessed-10198 If isPreprocessed is VK_TRUE then the conditional render state and its predicate value must match identically with the state and value set during execution of the corresponding call to vkCmdPreprocessGeneratedCommandsEXT VUID-vkCmdExecuteGeneratedCommandsEXT-isPreprocessed-11049 If isPreprocessed is VK_TRUE and the indirectCommandsLayout member of pGeneratedCommandsInfo contains a draw token, then the graphics state bound on commandBuffer must match identically with the graphics state bound on the stateCommandBuffer passed to vkCmdPreprocessGeneratedCommandsEXT VUID-vkCmdExecuteGeneratedCommandsEXT-isPreprocessed-11149 If isPreprocessed is VK_TRUE, then the queue family index of commandBuffer must be the same as the queue family index used to allocate the stateCommandBuffer passed to vkCmdPreprocessGeneratedCommandsEXT VUID-vkCmdExecuteGeneratedCommandsEXT-isPreprocessed-11051 If isPreprocessed is VK_TRUE and the indirectCommandsLayout member of pGeneratedCommandsInfo contains a dispatch token, then the compute state bound on commandBuffer must match identically with the compute state bound on the stateCommandBuffer passed to vkCmdPreprocessGeneratedCommandsEXT VUID-vkCmdExecuteGeneratedCommandsEXT-isPreprocessed-11052 If isPreprocessed is VK_TRUE and the indirectCommandsLayout member of pGeneratedCommandsInfo contains a ray tracing token, then the ray tracing state bound on commandBuffer must match identically with the ray tracing state bound on the stateCommandBuffer passed to vkCmdPreprocessGeneratedCommandsEXT VUID-vkCmdExecuteGeneratedCommandsEXT-isPreprocessed-11150 If isPreprocessed is VK_TRUE and the indirectCommandsLayout member of pGeneratedCommandsInfo contains a ray tracing token, the queue family index commandBuffer was allocated from must be the same queue family index used to allocate the stateCommandBuffer passed to vkCmdPreprocessGeneratedCommandsEXT VUID-vkCmdExecuteGeneratedCommandsEXT-indirectCommandsLayout-11053 If the token sequence of the passed VkGeneratedCommandsInfoEXT::indirectCommandsLayout contains a VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXECUTION_SET_EXT token, the initial shader state of VkGeneratedCommandsInfoEXT::indirectExecutionSet must be bound on commandBuffer VUID-vkCmdExecuteGeneratedCommandsEXT-indirectCommandsLayout-11004 If indirectCommandsLayout was created with a token sequence that contained the VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXECUTION_SET_EXT token and indirectExecutionSet was created using VK_INDIRECT_EXECUTION_SET_INFO_TYPE_SHADER_OBJECTS_EXT, every executed VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXECUTION_SET_EXT token must bind all the shader stages set in the VkIndirectCommandsExecutionSetTokenEXT::shaderStages used to create indirectCommandsLayout VUID-vkCmdExecuteGeneratedCommandsEXT-isPreprocessed-11055 If isPreprocessed is VK_TRUE and the token sequence of the passed VkGeneratedCommandsInfoEXT::indirectCommandsLayout contains a VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXECUTION_SET_EXT token, the members of VkGeneratedCommandsInfoEXT::indirectExecutionSet accessed by this command must not have been modified since the preprocess buffer was generated VUID-vkCmdExecuteGeneratedCommandsEXT-indirectCommandsLayout-11056 If the indirectCommandsLayout member of pGeneratedCommandsInfo contains a draw token, then the active render pass must not have a specified fragment density map VUID-vkCmdExecuteGeneratedCommandsEXT-deviceGeneratedCommandsTransformFeedback-11057 If deviceGeneratedCommandsTransformFeedback is not supported on device, transform feedback must not be active VUID-vkCmdExecuteGeneratedCommandsEXT-indirectExecutionSet-11058 If transform feedback is active, VkGeneratedCommandsInfoEXT::indirectExecutionSet must be VK_NULL_HANDLE VUID-vkCmdExecuteGeneratedCommandsEXT-deviceGeneratedCommands-11059 The VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT::deviceGeneratedCommands feature must be enabled VUID-vkCmdExecuteGeneratedCommandsEXT-supportedIndirectCommandsShaderStages-11060 The bound shader stages must be supported by VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT::supportedIndirectCommandsShaderStages VUID-vkCmdExecuteGeneratedCommandsEXT-supportedIndirectCommandsShaderStages-11061 Only stages specified in VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT::supportedIndirectCommandsShaderStages can be set in pGeneratedCommandsInfo->shaderStages VUID-vkCmdExecuteGeneratedCommandsEXT-None-11062 If a rendering pass is currently active, the view mask must be 0 VUID-vkCmdExecuteGeneratedCommandsEXT-commandBuffer-11143 commandBuffer must not have been created with VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT VUID-vkCmdExecuteGeneratedCommandsEXT-indirectCommandsLayout-10769 If the indirectCommandsLayout member of pGeneratedCommandsInfo contains a draw token, this command must not be called outside a render pass instance Valid Usage (Implicit) VUID-vkCmdExecuteGeneratedCommandsEXT-commandBuffer-parameter commandBuffer must be a valid VkCommandBuffer handle VUID-vkCmdExecuteGeneratedCommandsEXT-pGeneratedCommandsInfo-parameter pGeneratedCommandsInfo must be a valid pointer to a valid VkGeneratedCommandsInfoEXT structure VUID-vkCmdExecuteGeneratedCommandsEXT-commandBuffer-recording commandBuffer must be in the recording state VUID-vkCmdExecuteGeneratedCommandsEXT-commandBuffer-cmdpool The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations VUID-vkCmdExecuteGeneratedCommandsEXT-videocoding This command must only be called outside of a video coding scope VUID-vkCmdExecuteGeneratedCommandsEXT-bufferlevel commandBuffer must be a primary VkCommandBuffer Host Synchronization Host access to commandBuffer must be externally synchronized Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized Command Properties Command Buffer Levels Render Pass Scope Video Coding Scope Supported Queue Types Command Type Primary Both Outside Graphics Compute Action Indirection The VkGeneratedCommandsInfoEXT is defined as: // Provided by VK_EXT_device_generated_commands typedef struct VkGeneratedCommandsInfoEXT { VkStructureType sType; const void* pNext; VkShaderStageFlags shaderStages; VkIndirectExecutionSetEXT indirectExecutionSet; VkIndirectCommandsLayoutEXT indirectCommandsLayout; VkDeviceAddress indirectAddress; VkDeviceSize indirectAddressSize; VkDeviceAddress preprocessAddress; VkDeviceSize preprocessSize; uint32_t maxSequenceCount; VkDeviceAddress sequenceCountAddress; uint32_t maxDrawCount; } VkGeneratedCommandsInfoEXT; sType is a VkStructureType value identifying this structure. pNext is NULL or a pointer to a structure extending this structure. shaderStages is the mask of shader stages used by the commands. indirectExecutionSet is the indirect execution set to be used for binding shaders. indirectCommandsLayout is the VkIndirectCommandsLayoutEXT that specifies the command sequence data. indirectAddress is an address that holds the indirect buffer data. indirectAddressSize is the size in bytes of indirect buffer data starting at indirectAddress. preprocessAddress specifies a physical address of the VkBuffer used for preprocessing the input data for execution. If this structure is used with vkCmdExecuteGeneratedCommandsEXT with its isPreprocessed set to VK_TRUE, then the preprocessing step is skipped but data in this address may still be modified. The contents and the layout of this address are opaque to applications and must not be modified outside functions related to device-generated commands or copied to another buffer for reuse. preprocessSize is the maximum byte size within preprocessAddress that is available for preprocessing. maxSequenceCount is used to determine the number of sequences to execute. sequenceCountAddress specifies an optional physical address of a single uint32_t value containing the requested number of sequences to execute. maxDrawCount is the maximum number of indirect draws that can be executed by any COUNT-type multi-draw indirect tokens. The draw count in the indirect buffer is clamped to this value for these token types. If sequenceCountAddress is not NULL, then maxSequenceCount is the maximum number of sequences that can be executed. The actual number is min(maxSequenceCount, *sequenceCountAddress). If sequenceCountAddress is NULL, then maxSequenceCount is the exact number of sequences to execute. If the action command token for the layout is not a COUNT-type multi-draw indirect token, maxDrawCount is ignored. Valid Usage VUID-VkGeneratedCommandsInfoEXT-preprocessAddress-11063 If vkGetGeneratedCommandsMemoryRequirementsEXT returns a non-zero size, preprocessAddress must not be NULL VUID-VkGeneratedCommandsInfoEXT-preprocessAddress-11064 VkDeviceMemory objects bound to the underlying buffer for preprocessAddress must have been allocated using one of the memory types allowed in the memoryTypeBits member of the VkMemoryRequirements structure returned by vkGetGeneratedCommandsMemoryRequirementsEXT VUID-VkGeneratedCommandsInfoEXT-indirectCommandsLayout-11065 If the indirectCommandsLayout uses a token of VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_EXT, then the indirectExecutionSet’s push constant layout must contain the updateRange specified in VkIndirectCommandsPushConstantTokenEXT VUID-VkGeneratedCommandsInfoEXT-indirectCommandsLayout-11066 If the indirectCommandsLayout uses a token of VK_INDIRECT_COMMANDS_TOKEN_TYPE_SEQUENCE_INDEX_EXT, then the indirectExecutionSet’s push constant layout must contain the updateRange specified in VkIndirectCommandsPushConstantTokenEXT VUID-VkGeneratedCommandsInfoEXT-maxSequenceCount-11067 maxSequenceCount must be less or equal to VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT::maxIndirectSequenceCount and VkGeneratedCommandsMemoryRequirementsInfoEXT::maxSequenceCount that was used to determine the preprocessSize VUID-VkGeneratedCommandsInfoEXT-sequenceCountAddress-11068 If sequenceCountAddress is not NULL, the value contained in the address must be less or equal to VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT::maxIndirectSequenceCount and VkGeneratedCommandsMemoryRequirementsInfoEXT::maxSequenceCount that was used to determine the preprocessSize VUID-VkGeneratedCommandsInfoEXT-maxSequenceCount-10246 maxSequenceCount must not be zero VUID-VkGeneratedCommandsInfoEXT-preprocessAddress-11069 The underlying buffer for preprocessAddress must have the VK_BUFFER_USAGE_2_PREPROCESS_BUFFER_BIT_EXT bit set in its usage flag VUID-VkGeneratedCommandsInfoEXT-preprocessAddress-11070 If the underlying buffer for preprocessAddress is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object VUID-VkGeneratedCommandsInfoEXT-indirectCommandsLayout-11144 If the indirectCommandsLayout contains a VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXECUTION_SET_EXT token, then the descriptor and push constant layout info provided either by pipelineLayout or through a VkPipelineLayoutCreateInfo in pNext of the VkIndirectCommandsLayoutCreateInfoEXT used to create indirectCommandsLayout must be compatible with the descriptor and push constant layout info used by indirectExecutionSet VUID-VkGeneratedCommandsInfoEXT-indirectCommandsLayout-11002 If indirectCommandsLayout was created with a token sequence that contained the VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXECUTION_SET_EXT token, the shader stages used to create the initial shader state of indirectExecutionSet must equal the VkIndirectCommandsExecutionSetTokenEXT::shaderStages used to create indirectCommandsLayout VUID-VkGeneratedCommandsInfoEXT-preprocessSize-11071 preprocessSize must be greater than or equal to the memory requirement’s size returned by vkGetGeneratedCommandsMemoryRequirementsEXT using the matching inputs (indirectCommandsLayout, …​) as within this structure VUID-VkGeneratedCommandsInfoEXT-sequenceCountAddress-11072 The underlying buffer for sequenceCountAddress must have the VK_BUFFER_USAGE_2_INDIRECT_BUFFER_BIT_KHR bit set in its usage flag VUID-VkGeneratedCommandsInfoEXT-sequenceCountAddress-11073 If sequenceCountAddress is not NULL, sequenceCountAddress must be aligned to 4 VUID-VkGeneratedCommandsInfoEXT-indirectAddress-11074 indirectAddress must be aligned to 4 VUID-VkGeneratedCommandsInfoEXT-sequenceCountAddress-11075 If the underlying buffer for sequenceCountAddress is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object VUID-VkGeneratedCommandsInfoEXT-indirectAddress-11076 indirectAddress must not be NULL VUID-VkGeneratedCommandsInfoEXT-indirectAddressSize-11077 indirectAddressSize must be greater than zero VUID-VkGeneratedCommandsInfoEXT-maxDrawCount-11078 When not ignored, maxDrawCount × maxSequenceCount must be less than 2^24 VUID-VkGeneratedCommandsInfoEXT-indirectCommandsLayout-11079 If indirectCommandsLayout was created using a VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_EXT token and shader objects are not bound then the bound graphics pipeline must have been created with VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE in pDynamicStates VUID-VkGeneratedCommandsInfoEXT-indirectCommandsLayout-11083 If the token sequence of the passed indirectCommandsLayout contains a VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXECUTION_SET_EXT token, the indirectExecutionSet must not be VK_NULL_HANDLE VUID-VkGeneratedCommandsInfoEXT-indirectCommandsLayout-10241 If the token sequence of the passed indirectCommandsLayout does not contains a VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXECUTION_SET_EXT token, the indirectExecutionSet must be VK_NULL_HANDLE VUID-VkGeneratedCommandsInfoEXT-indirectExecutionSet-11080 If indirectExecutionSet is VK_NULL_HANDLE, a VkGeneratedCommandsPipelineInfoEXT or VkGeneratedCommandsShaderInfoEXT must be included in the pNext chain Valid Usage (Implicit) VUID-VkGeneratedCommandsInfoEXT-sType-sType sType must be VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_EXT VUID-VkGeneratedCommandsInfoEXT-shaderStages-parameter shaderStages must be a valid combination of VkShaderStageFlagBits values VUID-VkGeneratedCommandsInfoEXT-shaderStages-requiredbitmask shaderStages must not be 0 VUID-VkGeneratedCommandsInfoEXT-indirectExecutionSet-parameter If indirectExecutionSet is not VK_NULL_HANDLE, indirectExecutionSet must be a valid VkIndirectExecutionSetEXT handle VUID-VkGeneratedCommandsInfoEXT-indirectCommandsLayout-parameter indirectCommandsLayout must be a valid VkIndirectCommandsLayoutEXT handle VUID-VkGeneratedCommandsInfoEXT-commonparent Both of indirectCommandsLayout, and indirectExecutionSet that are valid handles of non-ignored parameters must have been created, allocated, or retrieved from the same VkDevice Referencing the functions defined in Indirect Commands Layout, vkCmdExecuteGeneratedCommandsEXT behaves as: uint32_t sequencesCount = sequenceCountAddress ? min(maxSequenceCount, sequenceCountAddress.load_uint32()) : maxSequenceCount; cmdProcessAllSequences(commandBuffer, indirectExecutionSet, indirectCommandsLayout, indirectAddress, sequencesCount); // The stateful commands within indirectCommandsLayout will not // affect the state of subsequent commands in the target // command buffer (cmd) It is important to note that the affected values of all state related to the shaderStages used are undefined after this command. This means that e.g., if this command indirectly alters push constants, the push constant state becomes undefined. Commands can be preprocessed prior execution using the following command: // Provided by VK_EXT_device_generated_commands void vkCmdPreprocessGeneratedCommandsEXT( VkCommandBuffer commandBuffer, const VkGeneratedCommandsInfoEXT* pGeneratedCommandsInfo, VkCommandBuffer stateCommandBuffer); commandBuffer is the command buffer which does the preprocessing. pGeneratedCommandsInfo is a pointer to a VkGeneratedCommandsInfoEXT structure containing parameters affecting the preprocessing step. stateCommandBuffer is a command buffer from which to snapshot current states affecting the preprocessing step. When a graphics command action token is used, graphics state is snapshotted. When a compute action command token is used, compute state is snapshotted. When a ray tracing action command token is used, ray tracing state is snapshotted. It can be deleted at any time after this command has been recorded. stateCommandBuffer access is not synchronized by the driver, meaning that this command buffer must not be modified between threads in an unsafe manner. Valid Usage VUID-vkCmdPreprocessGeneratedCommandsEXT-commandBuffer-11081 commandBuffer must not be a protected command buffer VUID-vkCmdPreprocessGeneratedCommandsEXT-pGeneratedCommandsInfo-11082 pGeneratedCommandsInfo’s indirectCommandsLayout must have been created with the VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_EXT bit set VUID-vkCmdPreprocessGeneratedCommandsEXT-indirectCommandsLayout-11084 If the token sequence of the passed VkGeneratedCommandsInfoEXT::indirectCommandsLayout contains a VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXECUTION_SET_EXT token, the initial shader state of VkGeneratedCommandsInfoEXT::indirectExecutionSet must be bound on stateCommandBuffer VUID-vkCmdPreprocessGeneratedCommandsEXT-stateCommandBuffer-11138 stateCommandBuffer must be in the recording state VUID-vkCmdPreprocessGeneratedCommandsEXT-deviceGeneratedCommands-11087 The VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT::deviceGeneratedCommands feature must be enabled VUID-vkCmdPreprocessGeneratedCommandsEXT-supportedIndirectCommandsShaderStages-11088 Only stages specified in VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT::supportedIndirectCommandsShaderStages can be set in pGeneratedCommandsInfo->shaderStages Valid Usage (Implicit) VUID-vkCmdPreprocessGeneratedCommandsEXT-commandBuffer-parameter commandBuffer must be a valid VkCommandBuffer handle VUID-vkCmdPreprocessGeneratedCommandsEXT-pGeneratedCommandsInfo-parameter pGeneratedCommandsInfo must be a valid pointer to a valid VkGeneratedCommandsInfoEXT structure VUID-vkCmdPreprocessGeneratedCommandsEXT-stateCommandBuffer-parameter stateCommandBuffer must be a valid VkCommandBuffer handle VUID-vkCmdPreprocessGeneratedCommandsEXT-commandBuffer-recording commandBuffer must be in the recording state VUID-vkCmdPreprocessGeneratedCommandsEXT-commandBuffer-cmdpool The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations VUID-vkCmdPreprocessGeneratedCommandsEXT-renderpass This command must only be called outside of a render pass instance VUID-vkCmdPreprocessGeneratedCommandsEXT-videocoding This command must only be called outside of a video coding scope VUID-vkCmdPreprocessGeneratedCommandsEXT-bufferlevel commandBuffer must be a primary VkCommandBuffer VUID-vkCmdPreprocessGeneratedCommandsEXT-commonparent Both of commandBuffer, and stateCommandBuffer must have been created, allocated, or retrieved from the same VkDevice Host Synchronization Host access to commandBuffer must be externally synchronized Host access to stateCommandBuffer must be externally synchronized Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized Command Properties Command Buffer Levels Render Pass Scope Video Coding Scope Supported Queue Types Command Type Primary Outside Outside Graphics Compute Action The bound descriptor sets and push constants that will be used with indirect command generation must already be specified on stateCommandBuffer at the time of preprocessing commands with vkCmdPreprocessGeneratedCommandsEXT. They must match the bound descriptor sets and push constants used in the execution of indirect commands with vkCmdExecuteGeneratedCommandsEXT. If push constants for shader stages are also specified in the VkGeneratedCommandsInfoEXT::indirectCommandsLayout with a VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_EXT or VK_INDIRECT_COMMANDS_TOKEN_TYPE_SEQUENCE_INDEX_EXT token, then those values override the push constants that were previously pushed. All state bound on stateCommandBuffer will be used. All state bound on stateCommandBuffer must be identical to the state bound at the time vkCmdExecuteGeneratedCommandsEXT is recorded. The queue family index stateCommandBuffer was allocated from must be the same as the queue family index of the command buffer used in vkCmdExecuteGeneratedCommandsEXT. On some implementations, preprocessing may have no effect on performance. vkCmdExecuteGeneratedCommandsEXT may write to the preprocess buffer, no matter the isPreprocess parameter. In this case, the implementation must insert appropriate synchronization automatically, which corresponds to the following pseudocode: Barrier srcStageMask = DRAW_INDIRECT srcAccesMask = 0 dstStageMask = COMMAND_PREPROCESS_BIT dstAccessMask = COMMAND_PREPROCESS_WRITE_BIT | COMMAND_PREPROCESS_READ_BIT Do internal writes Barrier srcStageMask = COMMAND_PREPROCESS_BIT srcAccesMask = COMMAND_PREPROCESS_WRITE_BIT dstStageMask = DRAW_INDIRECT dstAccessMask = INDIRECT_COMMAND_READ_BIT Execute

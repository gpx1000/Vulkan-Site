# Layers & Extensions (Informative)

## Metadata

- **Component**: spec
- **Version**: latest
- **URL**: /spec/latest/appendices/extensions.html

## Table of Contents

- [Extension Dependencies](#_extension_dependencies)
- [Extension Interactions](#_extension_interactions)
- [List of Current Extensions](#current-extension-appendices-list)
- [List_of_Current_Extensions](#current-extension-appendices-list)
- [VK_KHR_acceleration_structure](#VK_KHR_acceleration_structure)
- [Other Extension Metadata](#_other_extension_metadata)
- [Other_Extension_Metadata](#_other_extension_metadata)
- [Description](#_description)
- [New Object Types](#_new_object_types)
- [New_Object_Types](#_new_object_types)
- [New Commands](#_new_commands)
- [New Structures](#_new_structures)
- [New Unions](#_new_unions)
- [New Enums](#_new_enums)
- [New Bitmasks](#_new_bitmasks)
- [New Enum Constants](#_new_enum_constants)
- [New_Enum_Constants](#_new_enum_constants)
- [Issues](#_issues)
- [Version History](#_version_history)
- [VK_KHR_android_surface](#VK_KHR_android_surface)
- [Other Extension Metadata](#_other_extension_metadata_2)
- [Other_Extension_Metadata](#_other_extension_metadata_2)
- [Description](#_description_2)
- [New Base Types](#_new_base_types)
- [New_Base_Types](#_new_base_types)
- [New Commands](#_new_commands_2)
- [New Structures](#_new_structures_2)
- [New Bitmasks](#_new_bitmasks_2)
- [New Enum Constants](#_new_enum_constants_2)
- [New_Enum_Constants](#_new_enum_constants_2)
- [Issues](#_issues_2)
- [Version History](#_version_history_2)
- [VK_KHR_calibrated_timestamps](#VK_KHR_calibrated_timestamps)
- [Other Extension Metadata](#_other_extension_metadata_3)
- [Other_Extension_Metadata](#_other_extension_metadata_3)
- [Description](#_description_3)
- [New Commands](#_new_commands_3)
- [New Structures](#_new_structures_3)
- [New Enums](#_new_enums_2)
- [New Enum Constants](#_new_enum_constants_3)
- [New_Enum_Constants](#_new_enum_constants_3)
- [Version History](#_version_history_3)
- [VK_KHR_compute_shader_derivatives](#VK_KHR_compute_shader_derivatives)
- [Other Extension Metadata](#_other_extension_metadata_4)
- [Other_Extension_Metadata](#_other_extension_metadata_4)
- [Description](#_description_4)
- [New Structures](#_new_structures_4)
- [New Enum Constants](#_new_enum_constants_4)
- [New_Enum_Constants](#_new_enum_constants_4)
- [New SPIR-V Capability](#_new_spir_v_capability)
- [New_SPIR-V_Capability](#_new_spir_v_capability)
- [Examples](#_examples)
- [Version History](#_version_history_4)
- [VK_KHR_cooperative_matrix](#VK_KHR_cooperative_matrix)
- [Other Extension Metadata](#_other_extension_metadata_5)
- [Other_Extension_Metadata](#_other_extension_metadata_5)
- [Description](#_description_5)
- [New Commands](#_new_commands_4)
- [New Structures](#_new_structures_5)
- [New Enums](#_new_enums_3)
- [New Enum Constants](#_new_enum_constants_5)
- [New_Enum_Constants](#_new_enum_constants_5)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities)
- [Issues](#_issues_3)
- [Version History](#_version_history_5)
- [VK_KHR_deferred_host_operations](#VK_KHR_deferred_host_operations)
- [Other Extension Metadata](#_other_extension_metadata_6)
- [Other_Extension_Metadata](#_other_extension_metadata_6)
- [Description](#_description_6)
- [New Object Types](#_new_object_types_2)
- [New_Object_Types](#_new_object_types_2)
- [New Commands](#_new_commands_5)
- [New Enum Constants](#_new_enum_constants_6)
- [New_Enum_Constants](#_new_enum_constants_6)
- [Code Examples](#_code_examples)
- [Issues](#_issues_4)
- [Version History](#_version_history_6)
- [VK_KHR_depth_clamp_zero_one](#VK_KHR_depth_clamp_zero_one)
- [Other Extension Metadata](#_other_extension_metadata_7)
- [Other_Extension_Metadata](#_other_extension_metadata_7)
- [Description](#_description_7)
- [New Structures](#_new_structures_6)
- [New Enum Constants](#_new_enum_constants_7)
- [New_Enum_Constants](#_new_enum_constants_7)
- [Version History](#_version_history_7)
- [VK_KHR_display](#VK_KHR_display)
- [Other Extension Metadata](#_other_extension_metadata_8)
- [Other_Extension_Metadata](#_other_extension_metadata_8)
- [Description](#_description_8)
- [New Object Types](#_new_object_types_3)
- [New_Object_Types](#_new_object_types_3)
- [New Commands](#_new_commands_6)
- [New Structures](#_new_structures_7)
- [New Enums](#_new_enums_4)
- [New Bitmasks](#_new_bitmasks_3)
- [New Enum Constants](#_new_enum_constants_8)
- [New_Enum_Constants](#_new_enum_constants_8)
- [Issues](#_issues_5)
- [Examples](#_examples_2)
- [Version History](#_version_history_8)
- [VK_KHR_display_swapchain](#VK_KHR_display_swapchain)
- [Other Extension Metadata](#_other_extension_metadata_9)
- [Other_Extension_Metadata](#_other_extension_metadata_9)
- [Description](#_description_9)
- [New Commands](#_new_commands_7)
- [New Structures](#_new_structures_8)
- [New Enum Constants](#_new_enum_constants_9)
- [New_Enum_Constants](#_new_enum_constants_9)
- [Issues](#_issues_6)
- [Examples](#_examples_3)
- [Version History](#_version_history_9)
- [VK_KHR_external_fence_fd](#VK_KHR_external_fence_fd)
- [Other Extension Metadata](#_other_extension_metadata_10)
- [Other_Extension_Metadata](#_other_extension_metadata_10)
- [Description](#_description_10)
- [New Commands](#_new_commands_8)
- [New Structures](#_new_structures_9)
- [New Enum Constants](#_new_enum_constants_10)
- [New_Enum_Constants](#_new_enum_constants_10)
- [Issues](#_issues_7)
- [Version History](#_version_history_10)
- [VK_KHR_external_fence_win32](#VK_KHR_external_fence_win32)
- [Other Extension Metadata](#_other_extension_metadata_11)
- [Other_Extension_Metadata](#_other_extension_metadata_11)
- [Description](#_description_11)
- [New Commands](#_new_commands_9)
- [New Structures](#_new_structures_10)
- [New Enum Constants](#_new_enum_constants_11)
- [New_Enum_Constants](#_new_enum_constants_11)
- [Issues](#_issues_8)
- [Version History](#_version_history_11)
- [VK_KHR_external_memory_fd](#VK_KHR_external_memory_fd)
- [Other Extension Metadata](#_other_extension_metadata_12)
- [Other_Extension_Metadata](#_other_extension_metadata_12)
- [Description](#_description_12)
- [New Commands](#_new_commands_10)
- [New Structures](#_new_structures_11)
- [New Enum Constants](#_new_enum_constants_12)
- [New_Enum_Constants](#_new_enum_constants_12)
- [Issues](#_issues_9)
- [Version History](#_version_history_12)
- [VK_KHR_external_memory_win32](#VK_KHR_external_memory_win32)
- [Other Extension Metadata](#_other_extension_metadata_13)
- [Other_Extension_Metadata](#_other_extension_metadata_13)
- [Description](#_description_13)
- [New Commands](#_new_commands_11)
- [New Structures](#_new_structures_12)
- [New Enum Constants](#_new_enum_constants_13)
- [New_Enum_Constants](#_new_enum_constants_13)
- [Issues](#_issues_10)
- [Version History](#_version_history_13)
- [VK_KHR_external_semaphore_fd](#VK_KHR_external_semaphore_fd)
- [Other Extension Metadata](#_other_extension_metadata_14)
- [Other_Extension_Metadata](#_other_extension_metadata_14)
- [Description](#_description_14)
- [New Commands](#_new_commands_12)
- [New Structures](#_new_structures_13)
- [New Enum Constants](#_new_enum_constants_14)
- [New_Enum_Constants](#_new_enum_constants_14)
- [Issues](#_issues_11)
- [Version History](#_version_history_14)
- [VK_KHR_external_semaphore_win32](#VK_KHR_external_semaphore_win32)
- [Other Extension Metadata](#_other_extension_metadata_15)
- [Other_Extension_Metadata](#_other_extension_metadata_15)
- [Description](#_description_15)
- [New Commands](#_new_commands_13)
- [New Structures](#_new_structures_14)
- [New Enum Constants](#_new_enum_constants_15)
- [New_Enum_Constants](#_new_enum_constants_15)
- [Issues](#_issues_12)
- [Version History](#_version_history_15)
- [VK_KHR_fragment_shader_barycentric](#VK_KHR_fragment_shader_barycentric)
- [Other Extension Metadata](#_other_extension_metadata_16)
- [Other_Extension_Metadata](#_other_extension_metadata_16)
- [Description](#_description_16)
- [New Structures](#_new_structures_15)
- [New Enum Constants](#_new_enum_constants_16)
- [New_Enum_Constants](#_new_enum_constants_16)
- [New Built-In Variables](#_new_built_in_variables)
- [New_Built-In_Variables](#_new_built_in_variables)
- [New SPIR-V Decorations](#_new_spir_v_decorations)
- [New_SPIR-V_Decorations](#_new_spir_v_decorations)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_2)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_2)
- [Issues](#_issues_13)
- [Version History](#_version_history_16)
- [VK_KHR_fragment_shading_rate](#VK_KHR_fragment_shading_rate)
- [Other Extension Metadata](#_other_extension_metadata_17)
- [Other_Extension_Metadata](#_other_extension_metadata_17)
- [Description](#_description_17)
- [New Commands](#_new_commands_14)
- [New Structures](#_new_structures_16)
- [New Enums](#_new_enums_5)
- [New Enum Constants](#_new_enum_constants_17)
- [New_Enum_Constants](#_new_enum_constants_17)
- [Version History](#_version_history_17)
- [VK_KHR_get_display_properties2](#VK_KHR_get_display_properties2)
- [Other Extension Metadata](#_other_extension_metadata_18)
- [Other_Extension_Metadata](#_other_extension_metadata_18)
- [Description](#_description_18)
- [New Commands](#_new_commands_15)
- [New Structures](#_new_structures_17)
- [New Enum Constants](#_new_enum_constants_18)
- [New_Enum_Constants](#_new_enum_constants_18)
- [Issues](#_issues_14)
- [Version History](#_version_history_18)
- [VK_KHR_get_surface_capabilities2](#VK_KHR_get_surface_capabilities2)
- [Other Extension Metadata](#_other_extension_metadata_19)
- [Other_Extension_Metadata](#_other_extension_metadata_19)
- [Description](#_description_19)
- [New Commands](#_new_commands_16)
- [New Structures](#_new_structures_18)
- [New Enum Constants](#_new_enum_constants_19)
- [New_Enum_Constants](#_new_enum_constants_19)
- [Issues](#_issues_15)
- [Version History](#_version_history_19)
- [VK_KHR_incremental_present](#VK_KHR_incremental_present)
- [Other Extension Metadata](#_other_extension_metadata_20)
- [Other_Extension_Metadata](#_other_extension_metadata_20)
- [Description](#_description_20)
- [New Structures](#_new_structures_19)
- [New Enum Constants](#_new_enum_constants_20)
- [New_Enum_Constants](#_new_enum_constants_20)
- [Issues](#_issues_16)
- [Version History](#_version_history_20)
- [VK_KHR_maintenance7](#VK_KHR_maintenance7)
- [Other Extension Metadata](#_other_extension_metadata_21)
- [Other_Extension_Metadata](#_other_extension_metadata_21)
- [Description](#_description_21)
- [New Structures](#_new_structures_20)
- [New Enums](#_new_enums_6)
- [New Enum Constants](#_new_enum_constants_21)
- [New_Enum_Constants](#_new_enum_constants_21)
- [Issues](#_issues_17)
- [Version History](#_version_history_21)
- [VK_KHR_maintenance8](#VK_KHR_maintenance8)
- [Other Extension Metadata](#_other_extension_metadata_22)
- [Other_Extension_Metadata](#_other_extension_metadata_22)
- [Description](#_description_22)
- [New Structures](#_new_structures_21)
- [New Enums](#_new_enums_7)
- [New Bitmasks](#_new_bitmasks_4)
- [New Enum Constants](#_new_enum_constants_22)
- [New_Enum_Constants](#_new_enum_constants_22)
- [Issues](#_issues_18)
- [Version History](#_version_history_22)
- [VK_KHR_performance_query](#VK_KHR_performance_query)
- [Other Extension Metadata](#_other_extension_metadata_23)
- [Other_Extension_Metadata](#_other_extension_metadata_23)
- [Description](#_description_23)
- [New Commands](#_new_commands_17)
- [New Structures](#_new_structures_22)
- [New Unions](#_new_unions_2)
- [New Enums](#_new_enums_8)
- [New Bitmasks](#_new_bitmasks_5)
- [New Enum Constants](#_new_enum_constants_23)
- [New_Enum_Constants](#_new_enum_constants_23)
- [Issues](#_issues_19)
- [Examples](#_examples_4)
- [Version History](#_version_history_23)
- [VK_KHR_pipeline_binary](#VK_KHR_pipeline_binary)
- [Other Extension Metadata](#_other_extension_metadata_24)
- [Other_Extension_Metadata](#_other_extension_metadata_24)
- [Description](#_description_24)
- [New Object Types](#_new_object_types_4)
- [New_Object_Types](#_new_object_types_4)
- [New Commands](#_new_commands_18)
- [New Structures](#_new_structures_23)
- [New Enum Constants](#_new_enum_constants_24)
- [New_Enum_Constants](#_new_enum_constants_24)
- [Version History](#_version_history_24)
- [VK_KHR_pipeline_executable_properties](#VK_KHR_pipeline_executable_properties)
- [Other Extension Metadata](#_other_extension_metadata_25)
- [Other_Extension_Metadata](#_other_extension_metadata_25)
- [Description](#_description_25)
- [New Commands](#_new_commands_19)
- [New Structures](#_new_structures_24)
- [New Unions](#_new_unions_3)
- [New Enums](#_new_enums_9)
- [New Enum Constants](#_new_enum_constants_25)
- [New_Enum_Constants](#_new_enum_constants_25)
- [Issues](#_issues_20)
- [Version History](#_version_history_25)
- [VK_KHR_pipeline_library](#VK_KHR_pipeline_library)
- [Other Extension Metadata](#_other_extension_metadata_26)
- [Other_Extension_Metadata](#_other_extension_metadata_26)
- [Description](#_description_26)
- [New Structures](#_new_structures_25)
- [New Enum Constants](#_new_enum_constants_26)
- [New_Enum_Constants](#_new_enum_constants_26)
- [Version History](#_version_history_26)
- [VK_KHR_portability_enumeration](#VK_KHR_portability_enumeration)
- [Other Extension Metadata](#_other_extension_metadata_27)
- [Other_Extension_Metadata](#_other_extension_metadata_27)
- [Description](#_description_27)
- [New Enum Constants](#_new_enum_constants_27)
- [New_Enum_Constants](#_new_enum_constants_27)
- [Version History](#_version_history_27)
- [VK_KHR_present_id](#VK_KHR_present_id)
- [Other Extension Metadata](#_other_extension_metadata_28)
- [Other_Extension_Metadata](#_other_extension_metadata_28)
- [Description](#_description_28)
- [New Structures](#_new_structures_26)
- [New Enum Constants](#_new_enum_constants_28)
- [New_Enum_Constants](#_new_enum_constants_28)
- [Issues](#_issues_21)
- [Examples](#_examples_5)
- [Version History](#_version_history_28)
- [VK_KHR_present_wait](#VK_KHR_present_wait)
- [Other Extension Metadata](#_other_extension_metadata_29)
- [Other_Extension_Metadata](#_other_extension_metadata_29)
- [Description](#_description_29)
- [New Commands](#_new_commands_20)
- [New Structures](#_new_structures_27)
- [New Enum Constants](#_new_enum_constants_29)
- [New_Enum_Constants](#_new_enum_constants_29)
- [Issues](#_issues_22)
- [Examples](#_examples_6)
- [Version History](#_version_history_29)
- [VK_KHR_ray_query](#VK_KHR_ray_query)
- [Other Extension Metadata](#_other_extension_metadata_30)
- [Other_Extension_Metadata](#_other_extension_metadata_30)
- [Description](#_description_30)
- [New Structures](#_new_structures_28)
- [New Enum Constants](#_new_enum_constants_30)
- [New_Enum_Constants](#_new_enum_constants_30)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_3)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_3)
- [Sample Code](#_sample_code)
- [Issues](#_issues_23)
- [Version History](#_version_history_30)
- [VK_KHR_ray_tracing_maintenance1](#VK_KHR_ray_tracing_maintenance1)
- [Other Extension Metadata](#_other_extension_metadata_31)
- [Other_Extension_Metadata](#_other_extension_metadata_31)
- [Description](#_description_31)
- [New Commands](#_new_commands_21)
- [New Structures](#_new_structures_29)
- [New Enum Constants](#_new_enum_constants_31)
- [New_Enum_Constants](#_new_enum_constants_31)
- [New Built-In Variables](#_new_built_in_variables_2)
- [New_Built-In_Variables](#_new_built_in_variables_2)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_4)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_4)
- [Issues](#_issues_24)
- [Version History](#_version_history_31)
- [VK_KHR_ray_tracing_pipeline](#VK_KHR_ray_tracing_pipeline)
- [Other Extension Metadata](#_other_extension_metadata_32)
- [Other_Extension_Metadata](#_other_extension_metadata_32)
- [Description](#_description_32)
- [New Commands](#_new_commands_22)
- [New Structures](#_new_structures_30)
- [New Enums](#_new_enums_10)
- [New Enum Constants](#_new_enum_constants_32)
- [New_Enum_Constants](#_new_enum_constants_32)
- [New or Modified Built-In Variables](#_new_or_modified_built_in_variables)
- [New_or_Modified_Built-In_Variables](#_new_or_modified_built_in_variables)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_5)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_5)
- [Issues](#_issues_25)
- [Sample Code](#_sample_code_2)
- [Version History](#_version_history_32)
- [VK_KHR_ray_tracing_position_fetch](#VK_KHR_ray_tracing_position_fetch)
- [Other Extension Metadata](#_other_extension_metadata_33)
- [Other_Extension_Metadata](#_other_extension_metadata_33)
- [Description](#_description_33)
- [New Structures](#_new_structures_31)
- [New Enum Constants](#_new_enum_constants_33)
- [New_Enum_Constants](#_new_enum_constants_33)
- [New Built-In Variables](#_new_built_in_variables_3)
- [New_Built-In_Variables](#_new_built_in_variables_3)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_6)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_6)
- [Issues](#_issues_26)
- [Version History](#_version_history_33)
- [VK_KHR_robustness2](#VK_KHR_robustness2)
- [Other Extension Metadata](#_other_extension_metadata_34)
- [Other_Extension_Metadata](#_other_extension_metadata_34)
- [Description](#_description_34)
- [New Structures](#_new_structures_32)
- [New Enum Constants](#_new_enum_constants_34)
- [New_Enum_Constants](#_new_enum_constants_34)
- [Issues](#_issues_27)
- [Version History](#_version_history_34)
- [VK_KHR_shader_bfloat16](#VK_KHR_shader_bfloat16)
- [Other Extension Metadata](#_other_extension_metadata_35)
- [Other_Extension_Metadata](#_other_extension_metadata_35)
- [Description](#_description_35)
- [New Structures](#_new_structures_33)
- [New Enum Constants](#_new_enum_constants_35)
- [New_Enum_Constants](#_new_enum_constants_35)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_7)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_7)
- [Version History](#_version_history_35)
- [VK_KHR_shader_clock](#VK_KHR_shader_clock)
- [Other Extension Metadata](#_other_extension_metadata_36)
- [Other_Extension_Metadata](#_other_extension_metadata_36)
- [Description](#_description_36)
- [New Structures](#_new_structures_34)
- [New Enum Constants](#_new_enum_constants_36)
- [New_Enum_Constants](#_new_enum_constants_36)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_8)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_8)
- [Version History](#_version_history_36)
- [VK_KHR_shader_maximal_reconvergence](#VK_KHR_shader_maximal_reconvergence)
- [Other Extension Metadata](#_other_extension_metadata_37)
- [Other_Extension_Metadata](#_other_extension_metadata_37)
- [Description](#_description_37)
- [New Structures](#_new_structures_35)
- [New Enum Constants](#_new_enum_constants_37)
- [New_Enum_Constants](#_new_enum_constants_37)
- [Version History](#_version_history_37)
- [VK_KHR_shader_quad_control](#VK_KHR_shader_quad_control)
- [Other Extension Metadata](#_other_extension_metadata_38)
- [Other_Extension_Metadata](#_other_extension_metadata_38)
- [Description](#_description_38)
- [New Structures](#_new_structures_36)
- [New Enum Constants](#_new_enum_constants_38)
- [New_Enum_Constants](#_new_enum_constants_38)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_9)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_9)
- [Version History](#_version_history_38)
- [VK_KHR_shader_relaxed_extended_instruction](#VK_KHR_shader_relaxed_extended_instruction)
- [Other Extension Metadata](#_other_extension_metadata_39)
- [Other_Extension_Metadata](#_other_extension_metadata_39)
- [Description](#_description_39)
- [New Structures](#_new_structures_37)
- [New Enum Constants](#_new_enum_constants_39)
- [New_Enum_Constants](#_new_enum_constants_39)
- [Version History](#_version_history_39)
- [VK_KHR_shader_subgroup_uniform_control_flow](#VK_KHR_shader_subgroup_uniform_control_flow)
- [Other Extension Metadata](#_other_extension_metadata_40)
- [Other_Extension_Metadata](#_other_extension_metadata_40)
- [Description](#_description_40)
- [New Structures](#_new_structures_38)
- [New Enum Constants](#_new_enum_constants_40)
- [New_Enum_Constants](#_new_enum_constants_40)
- [Version History](#_version_history_40)
- [VK_KHR_shared_presentable_image](#VK_KHR_shared_presentable_image)
- [Other Extension Metadata](#_other_extension_metadata_41)
- [Other_Extension_Metadata](#_other_extension_metadata_41)
- [Description](#_description_41)
- [New Commands](#_new_commands_23)
- [New Structures](#_new_structures_39)
- [New Enum Constants](#_new_enum_constants_41)
- [New_Enum_Constants](#_new_enum_constants_41)
- [Issues](#_issues_28)
- [Version History](#_version_history_41)
- [VK_KHR_surface](#VK_KHR_surface)
- [Other Extension Metadata](#_other_extension_metadata_42)
- [Other_Extension_Metadata](#_other_extension_metadata_42)
- [Description](#_description_42)
- [New Object Types](#_new_object_types_5)
- [New_Object_Types](#_new_object_types_5)
- [New Commands](#_new_commands_24)
- [New Structures](#_new_structures_40)
- [New Enums](#_new_enums_11)
- [New Bitmasks](#_new_bitmasks_6)
- [New Enum Constants](#_new_enum_constants_42)
- [New_Enum_Constants](#_new_enum_constants_42)
- [Examples](#_examples_7)
- [Issues](#_issues_29)
- [Version History](#_version_history_42)
- [VK_KHR_surface_protected_capabilities](#VK_KHR_surface_protected_capabilities)
- [Other Extension Metadata](#_other_extension_metadata_43)
- [Other_Extension_Metadata](#_other_extension_metadata_43)
- [Description](#_description_43)
- [New Structures](#_new_structures_41)
- [New Enum Constants](#_new_enum_constants_43)
- [New_Enum_Constants](#_new_enum_constants_43)
- [Version History](#_version_history_43)
- [VK_KHR_swapchain](#VK_KHR_swapchain)
- [Other Extension Metadata](#_other_extension_metadata_44)
- [Other_Extension_Metadata](#_other_extension_metadata_44)
- [Description](#_description_44)
- [New Object Types](#_new_object_types_6)
- [New_Object_Types](#_new_object_types_6)
- [New Commands](#_new_commands_25)
- [New Structures](#_new_structures_42)
- [New Enums](#_new_enums_12)
- [New Bitmasks](#_new_bitmasks_7)
- [New Enum Constants](#_new_enum_constants_44)
- [New_Enum_Constants](#_new_enum_constants_44)
- [Issues](#_issues_30)
- [Examples](#_examples_8)
- [Version History](#_version_history_44)
- [VK_KHR_swapchain_mutable_format](#VK_KHR_swapchain_mutable_format)
- [Other Extension Metadata](#_other_extension_metadata_45)
- [Other_Extension_Metadata](#_other_extension_metadata_45)
- [Description](#_description_45)
- [New Enum Constants](#_new_enum_constants_45)
- [New_Enum_Constants](#_new_enum_constants_45)
- [Issues](#_issues_31)
- [Version History](#_version_history_45)
- [VK_KHR_video_decode_av1](#VK_KHR_video_decode_av1)
- [Other Extension Metadata](#_other_extension_metadata_46)
- [Other_Extension_Metadata](#_other_extension_metadata_46)
- [Description](#_description_46)
- [New Structures](#_new_structures_43)
- [New Enum Constants](#_new_enum_constants_46)
- [New_Enum_Constants](#_new_enum_constants_46)
- [Version History](#_version_history_46)
- [VK_KHR_video_decode_h264](#VK_KHR_video_decode_h264)
- [Other Extension Metadata](#_other_extension_metadata_47)
- [Other_Extension_Metadata](#_other_extension_metadata_47)
- [Description](#_description_47)
- [New Structures](#_new_structures_44)
- [New Enums](#_new_enums_13)
- [New Bitmasks](#_new_bitmasks_8)
- [New Enum Constants](#_new_enum_constants_47)
- [New_Enum_Constants](#_new_enum_constants_47)
- [Version History](#_version_history_47)
- [VK_KHR_video_decode_h265](#VK_KHR_video_decode_h265)
- [Other Extension Metadata](#_other_extension_metadata_48)
- [Other_Extension_Metadata](#_other_extension_metadata_48)
- [Description](#_description_48)
- [New Structures](#_new_structures_45)
- [New Enum Constants](#_new_enum_constants_48)
- [New_Enum_Constants](#_new_enum_constants_48)
- [Version History](#_version_history_48)
- [VK_KHR_video_decode_queue](#VK_KHR_video_decode_queue)
- [Other Extension Metadata](#_other_extension_metadata_49)
- [Other_Extension_Metadata](#_other_extension_metadata_49)
- [Description](#_description_49)
- [New Commands](#_new_commands_26)
- [New Structures](#_new_structures_46)
- [New Enums](#_new_enums_14)
- [New Bitmasks](#_new_bitmasks_9)
- [New Enum Constants](#_new_enum_constants_49)
- [New_Enum_Constants](#_new_enum_constants_49)
- [Version History](#_version_history_49)
- [VK_KHR_video_encode_av1](#VK_KHR_video_encode_av1)
- [Other Extension Metadata](#_other_extension_metadata_50)
- [Other_Extension_Metadata](#_other_extension_metadata_50)
- [Description](#_description_50)
- [New Structures](#_new_structures_47)
- [New Enums](#_new_enums_15)
- [New Bitmasks](#_new_bitmasks_10)
- [New Enum Constants](#_new_enum_constants_50)
- [New_Enum_Constants](#_new_enum_constants_50)
- [Version History](#_version_history_50)
- [VK_KHR_video_encode_h264](#VK_KHR_video_encode_h264)
- [Other Extension Metadata](#_other_extension_metadata_51)
- [Other_Extension_Metadata](#_other_extension_metadata_51)
- [Description](#_description_51)
- [New Structures](#_new_structures_48)
- [New Enums](#_new_enums_16)
- [New Bitmasks](#_new_bitmasks_11)
- [New Enum Constants](#_new_enum_constants_51)
- [New_Enum_Constants](#_new_enum_constants_51)
- [Version History](#_version_history_51)
- [VK_KHR_video_encode_h265](#VK_KHR_video_encode_h265)
- [Other Extension Metadata](#_other_extension_metadata_52)
- [Other_Extension_Metadata](#_other_extension_metadata_52)
- [Description](#_description_52)
- [New Structures](#_new_structures_49)
- [New Enums](#_new_enums_17)
- [New Bitmasks](#_new_bitmasks_12)
- [New Enum Constants](#_new_enum_constants_52)
- [New_Enum_Constants](#_new_enum_constants_52)
- [Version History](#_version_history_52)
- [VK_KHR_video_encode_quantization_map](#VK_KHR_video_encode_quantization_map)
- [Other Extension Metadata](#_other_extension_metadata_53)
- [Other_Extension_Metadata](#_other_extension_metadata_53)
- [Description](#_description_53)
- [New Structures](#_new_structures_50)
- [New Enums](#_new_enums_18)
- [New Enum Constants](#_new_enum_constants_53)
- [New_Enum_Constants](#_new_enum_constants_53)
- [Version History](#_version_history_53)
- [VK_KHR_video_encode_queue](#VK_KHR_video_encode_queue)
- [Other Extension Metadata](#_other_extension_metadata_54)
- [Other_Extension_Metadata](#_other_extension_metadata_54)
- [Description](#_description_54)
- [New Commands](#_new_commands_27)
- [New Structures](#_new_structures_51)
- [New Enums](#_new_enums_19)
- [New Bitmasks](#_new_bitmasks_13)
- [New Enum Constants](#_new_enum_constants_54)
- [New_Enum_Constants](#_new_enum_constants_54)
- [Version History](#_version_history_54)
- [VK_KHR_video_maintenance1](#VK_KHR_video_maintenance1)
- [Other Extension Metadata](#_other_extension_metadata_55)
- [Other_Extension_Metadata](#_other_extension_metadata_55)
- [Description](#_description_55)
- [New Structures](#_new_structures_52)
- [New Enum Constants](#_new_enum_constants_55)
- [New_Enum_Constants](#_new_enum_constants_55)
- [Version History](#_version_history_55)
- [VK_KHR_video_maintenance2](#VK_KHR_video_maintenance2)
- [Other Extension Metadata](#_other_extension_metadata_56)
- [Other_Extension_Metadata](#_other_extension_metadata_56)
- [Description](#_description_56)
- [New Structures](#_new_structures_53)
- [New Enum Constants](#_new_enum_constants_56)
- [New_Enum_Constants](#_new_enum_constants_56)
- [Version History](#_version_history_56)
- [VK_KHR_video_queue](#VK_KHR_video_queue)
- [Other Extension Metadata](#_other_extension_metadata_57)
- [Other_Extension_Metadata](#_other_extension_metadata_57)
- [Description](#_description_57)
- [New Object Types](#_new_object_types_7)
- [New_Object_Types](#_new_object_types_7)
- [New Commands](#_new_commands_28)
- [New Structures](#_new_structures_54)
- [New Enums](#_new_enums_20)
- [New Bitmasks](#_new_bitmasks_14)
- [New Enum Constants](#_new_enum_constants_57)
- [New_Enum_Constants](#_new_enum_constants_57)
- [Version History](#_version_history_57)
- [VK_KHR_wayland_surface](#VK_KHR_wayland_surface)
- [Other Extension Metadata](#_other_extension_metadata_58)
- [Other_Extension_Metadata](#_other_extension_metadata_58)
- [Description](#_description_58)
- [New Commands](#_new_commands_29)
- [New Structures](#_new_structures_55)
- [New Bitmasks](#_new_bitmasks_15)
- [New Enum Constants](#_new_enum_constants_58)
- [New_Enum_Constants](#_new_enum_constants_58)
- [Issues](#_issues_32)
- [Version History](#_version_history_58)
- [VK_KHR_win32_keyed_mutex](#VK_KHR_win32_keyed_mutex)
- [Other Extension Metadata](#_other_extension_metadata_59)
- [Other_Extension_Metadata](#_other_extension_metadata_59)
- [Description](#_description_59)
- [New Structures](#_new_structures_56)
- [New Enum Constants](#_new_enum_constants_59)
- [New_Enum_Constants](#_new_enum_constants_59)
- [Version History](#_version_history_59)
- [VK_KHR_win32_surface](#VK_KHR_win32_surface)
- [Other Extension Metadata](#_other_extension_metadata_60)
- [Other_Extension_Metadata](#_other_extension_metadata_60)
- [Description](#_description_60)
- [New Commands](#_new_commands_30)
- [New Structures](#_new_structures_57)
- [New Bitmasks](#_new_bitmasks_16)
- [New Enum Constants](#_new_enum_constants_60)
- [New_Enum_Constants](#_new_enum_constants_60)
- [Issues](#_issues_33)
- [Version History](#_version_history_60)
- [VK_KHR_workgroup_memory_explicit_layout](#VK_KHR_workgroup_memory_explicit_layout)
- [Other Extension Metadata](#_other_extension_metadata_61)
- [Other_Extension_Metadata](#_other_extension_metadata_61)
- [Description](#_description_61)
- [New Structures](#_new_structures_58)
- [New Enum Constants](#_new_enum_constants_61)
- [New_Enum_Constants](#_new_enum_constants_61)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_10)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_10)
- [Version History](#_version_history_61)
- [VK_KHR_xcb_surface](#VK_KHR_xcb_surface)
- [Other Extension Metadata](#_other_extension_metadata_62)
- [Other_Extension_Metadata](#_other_extension_metadata_62)
- [Description](#_description_62)
- [New Commands](#_new_commands_31)
- [New Structures](#_new_structures_59)
- [New Bitmasks](#_new_bitmasks_17)
- [New Enum Constants](#_new_enum_constants_62)
- [New_Enum_Constants](#_new_enum_constants_62)
- [Issues](#_issues_34)
- [Version History](#_version_history_62)
- [VK_KHR_xlib_surface](#VK_KHR_xlib_surface)
- [Other Extension Metadata](#_other_extension_metadata_63)
- [Other_Extension_Metadata](#_other_extension_metadata_63)
- [Description](#_description_63)
- [New Commands](#_new_commands_32)
- [New Structures](#_new_structures_60)
- [New Bitmasks](#_new_bitmasks_18)
- [New Enum Constants](#_new_enum_constants_63)
- [New_Enum_Constants](#_new_enum_constants_63)
- [Issues](#_issues_35)
- [Version History](#_version_history_63)
- [VK_EXT_acquire_drm_display](#VK_EXT_acquire_drm_display)
- [Other Extension Metadata](#_other_extension_metadata_64)
- [Other_Extension_Metadata](#_other_extension_metadata_64)
- [Description](#_description_64)
- [New Commands](#_new_commands_33)
- [New Enum Constants](#_new_enum_constants_64)
- [New_Enum_Constants](#_new_enum_constants_64)
- [Issues](#_issues_36)
- [Version History](#_version_history_64)
- [VK_EXT_acquire_xlib_display](#VK_EXT_acquire_xlib_display)
- [Other Extension Metadata](#_other_extension_metadata_65)
- [Other_Extension_Metadata](#_other_extension_metadata_65)
- [Description](#_description_65)
- [New Commands](#_new_commands_34)
- [New Enum Constants](#_new_enum_constants_65)
- [New_Enum_Constants](#_new_enum_constants_65)
- [Issues](#_issues_37)
- [Version History](#_version_history_65)
- [VK_EXT_astc_decode_mode](#VK_EXT_astc_decode_mode)
- [Other Extension Metadata](#_other_extension_metadata_66)
- [Other_Extension_Metadata](#_other_extension_metadata_66)
- [Description](#_description_66)
- [New Structures](#_new_structures_61)
- [New Enum Constants](#_new_enum_constants_66)
- [New_Enum_Constants](#_new_enum_constants_66)
- [Issues](#_issues_38)
- [Example](#_example)
- [Version History](#_version_history_66)
- [VK_EXT_attachment_feedback_loop_dynamic_state](#VK_EXT_attachment_feedback_loop_dynamic_state)
- [Other Extension Metadata](#_other_extension_metadata_67)
- [Other_Extension_Metadata](#_other_extension_metadata_67)
- [Description](#_description_67)
- [New Commands](#_new_commands_35)
- [New Structures](#_new_structures_62)
- [New Enum Constants](#_new_enum_constants_67)
- [New_Enum_Constants](#_new_enum_constants_67)
- [Version History](#_version_history_67)
- [VK_EXT_attachment_feedback_loop_layout](#VK_EXT_attachment_feedback_loop_layout)
- [Other Extension Metadata](#_other_extension_metadata_68)
- [Other_Extension_Metadata](#_other_extension_metadata_68)
- [Description](#_description_68)
- [New Structures](#_new_structures_63)
- [New Enum Constants](#_new_enum_constants_68)
- [New_Enum_Constants](#_new_enum_constants_68)
- [Version History](#_version_history_68)
- [VK_EXT_blend_operation_advanced](#VK_EXT_blend_operation_advanced)
- [Other Extension Metadata](#_other_extension_metadata_69)
- [Other_Extension_Metadata](#_other_extension_metadata_69)
- [Description](#_description_69)
- [New Structures](#_new_structures_64)
- [New Enums](#_new_enums_21)
- [New Enum Constants](#_new_enum_constants_69)
- [New_Enum_Constants](#_new_enum_constants_69)
- [Issues](#_issues_39)
- [Version History](#_version_history_69)
- [VK_EXT_border_color_swizzle](#VK_EXT_border_color_swizzle)
- [Other Extension Metadata](#_other_extension_metadata_70)
- [Other_Extension_Metadata](#_other_extension_metadata_70)
- [Description](#_description_70)
- [New Structures](#_new_structures_65)
- [New Enum Constants](#_new_enum_constants_70)
- [New_Enum_Constants](#_new_enum_constants_70)
- [Issues](#_issues_40)
- [Version History](#_version_history_70)
- [VK_EXT_color_write_enable](#VK_EXT_color_write_enable)
- [Other Extension Metadata](#_other_extension_metadata_71)
- [Other_Extension_Metadata](#_other_extension_metadata_71)
- [Description](#_description_71)
- [New Commands](#_new_commands_36)
- [New Structures](#_new_structures_66)
- [New Enum Constants](#_new_enum_constants_71)
- [New_Enum_Constants](#_new_enum_constants_71)
- [Version History](#_version_history_71)
- [VK_EXT_conditional_rendering](#VK_EXT_conditional_rendering)
- [Other Extension Metadata](#_other_extension_metadata_72)
- [Other_Extension_Metadata](#_other_extension_metadata_72)
- [Description](#_description_72)
- [New Commands](#_new_commands_37)
- [New Structures](#_new_structures_67)
- [New Enums](#_new_enums_22)
- [New Bitmasks](#_new_bitmasks_19)
- [New Enum Constants](#_new_enum_constants_72)
- [New_Enum_Constants](#_new_enum_constants_72)
- [Issues](#_issues_41)
- [Examples](#_examples_9)
- [Version History](#_version_history_72)
- [VK_EXT_conservative_rasterization](#VK_EXT_conservative_rasterization)
- [Other Extension Metadata](#_other_extension_metadata_73)
- [Other_Extension_Metadata](#_other_extension_metadata_73)
- [Description](#_description_73)
- [New Structures](#_new_structures_68)
- [New Enums](#_new_enums_23)
- [New Bitmasks](#_new_bitmasks_20)
- [New Enum Constants](#_new_enum_constants_73)
- [New_Enum_Constants](#_new_enum_constants_73)
- [New Built-In Variables](#_new_built_in_variables_4)
- [New_Built-In_Variables](#_new_built_in_variables_4)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_11)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_11)
- [Version History](#_version_history_73)
- [VK_EXT_custom_border_color](#VK_EXT_custom_border_color)
- [Other Extension Metadata](#_other_extension_metadata_74)
- [Other_Extension_Metadata](#_other_extension_metadata_74)
- [Description](#_description_74)
- [New Structures](#_new_structures_69)
- [New Enum Constants](#_new_enum_constants_74)
- [New_Enum_Constants](#_new_enum_constants_74)
- [Issues](#_issues_42)
- [Version History](#_version_history_74)
- [VK_EXT_debug_utils](#VK_EXT_debug_utils)
- [Other Extension Metadata](#_other_extension_metadata_75)
- [Other_Extension_Metadata](#_other_extension_metadata_75)
- [Description](#_description_75)
- [New Object Types](#_new_object_types_8)
- [New_Object_Types](#_new_object_types_8)
- [New Commands](#_new_commands_38)
- [New Structures](#_new_structures_70)
- [New Function Pointers](#_new_function_pointers)
- [New_Function_Pointers](#_new_function_pointers)
- [New Enums](#_new_enums_24)
- [New Bitmasks](#_new_bitmasks_21)
- [New Enum Constants](#_new_enum_constants_75)
- [New_Enum_Constants](#_new_enum_constants_75)
- [Examples](#_examples_10)
- [Issues](#_issues_43)
- [Version History](#_version_history_75)
- [VK_EXT_depth_bias_control](#VK_EXT_depth_bias_control)
- [Other Extension Metadata](#_other_extension_metadata_76)
- [Other_Extension_Metadata](#_other_extension_metadata_76)
- [Description](#_description_76)
- [New Commands](#_new_commands_39)
- [New Structures](#_new_structures_71)
- [New Enums](#_new_enums_25)
- [New Enum Constants](#_new_enum_constants_76)
- [New_Enum_Constants](#_new_enum_constants_76)
- [Version History](#_version_history_76)
- [VK_EXT_depth_clamp_control](#VK_EXT_depth_clamp_control)
- [Other Extension Metadata](#_other_extension_metadata_77)
- [Other_Extension_Metadata](#_other_extension_metadata_77)
- [Description](#_description_77)
- [New Commands](#_new_commands_40)
- [New Structures](#_new_structures_72)
- [New Enums](#_new_enums_26)
- [New Enum Constants](#_new_enum_constants_77)
- [New_Enum_Constants](#_new_enum_constants_77)
- [Issues](#_issues_44)
- [Version History](#_version_history_77)
- [VK_EXT_depth_clip_control](#VK_EXT_depth_clip_control)
- [Other Extension Metadata](#_other_extension_metadata_78)
- [Other_Extension_Metadata](#_other_extension_metadata_78)
- [Description](#_description_78)
- [New Structures](#_new_structures_73)
- [New Enum Constants](#_new_enum_constants_78)
- [New_Enum_Constants](#_new_enum_constants_78)
- [Issues](#_issues_45)
- [Version History](#_version_history_78)
- [VK_EXT_depth_clip_enable](#VK_EXT_depth_clip_enable)
- [Other Extension Metadata](#_other_extension_metadata_79)
- [Other_Extension_Metadata](#_other_extension_metadata_79)
- [Description](#_description_79)
- [New Structures](#_new_structures_74)
- [New Bitmasks](#_new_bitmasks_22)
- [New Enum Constants](#_new_enum_constants_79)
- [New_Enum_Constants](#_new_enum_constants_79)
- [Version History](#_version_history_79)
- [VK_EXT_depth_range_unrestricted](#VK_EXT_depth_range_unrestricted)
- [Other Extension Metadata](#_other_extension_metadata_80)
- [Other_Extension_Metadata](#_other_extension_metadata_80)
- [Description](#_description_80)
- [New Enum Constants](#_new_enum_constants_80)
- [New_Enum_Constants](#_new_enum_constants_80)
- [Issues](#_issues_46)
- [Version History](#_version_history_80)
- [VK_EXT_descriptor_buffer](#VK_EXT_descriptor_buffer)
- [Other Extension Metadata](#_other_extension_metadata_81)
- [Other_Extension_Metadata](#_other_extension_metadata_81)
- [Description](#_description_81)
- [New Commands](#_new_commands_41)
- [New Structures](#_new_structures_75)
- [New Unions](#_new_unions_4)
- [New Enum Constants](#_new_enum_constants_81)
- [New_Enum_Constants](#_new_enum_constants_81)
- [Version History](#_version_history_81)
- [VK_EXT_device_address_binding_report](#VK_EXT_device_address_binding_report)
- [Other Extension Metadata](#_other_extension_metadata_82)
- [Other_Extension_Metadata](#_other_extension_metadata_82)
- [Description](#_description_82)
- [New Structures](#_new_structures_76)
- [New Enums](#_new_enums_27)
- [New Bitmasks](#_new_bitmasks_23)
- [New Enum Constants](#_new_enum_constants_82)
- [New_Enum_Constants](#_new_enum_constants_82)
- [Issues](#_issues_47)
- [Version History](#_version_history_82)
- [VK_EXT_device_fault](#VK_EXT_device_fault)
- [Other Extension Metadata](#_other_extension_metadata_83)
- [Other_Extension_Metadata](#_other_extension_metadata_83)
- [Description](#_description_83)
- [New Commands](#_new_commands_42)
- [New Structures](#_new_structures_77)
- [New Enums](#_new_enums_28)
- [New Enum Constants](#_new_enum_constants_83)
- [New_Enum_Constants](#_new_enum_constants_83)
- [Version History](#_version_history_83)
- [VK_EXT_device_generated_commands](#VK_EXT_device_generated_commands)
- [Other Extension Metadata](#_other_extension_metadata_84)
- [Other_Extension_Metadata](#_other_extension_metadata_84)
- [Description](#_description_84)
- [New Object Types](#_new_object_types_9)
- [New_Object_Types](#_new_object_types_9)
- [New Commands](#_new_commands_43)
- [New Structures](#_new_structures_78)
- [New Unions](#_new_unions_5)
- [New Enums](#_new_enums_29)
- [New Bitmasks](#_new_bitmasks_24)
- [New Enum Constants](#_new_enum_constants_84)
- [New_Enum_Constants](#_new_enum_constants_84)
- [Example Code](#_example_code)
- [Version History](#_version_history_84)
- [VK_EXT_device_memory_report](#VK_EXT_device_memory_report)
- [Other Extension Metadata](#_other_extension_metadata_85)
- [Other_Extension_Metadata](#_other_extension_metadata_85)
- [Description](#_description_85)
- [New Structures](#_new_structures_79)
- [New Function Pointers](#_new_function_pointers_2)
- [New_Function_Pointers](#_new_function_pointers_2)
- [New Enums](#_new_enums_30)
- [New Bitmasks](#_new_bitmasks_25)
- [New Enum Constants](#_new_enum_constants_85)
- [New_Enum_Constants](#_new_enum_constants_85)
- [Issues](#_issues_48)
- [Version History](#_version_history_85)
- [VK_EXT_direct_mode_display](#VK_EXT_direct_mode_display)
- [Other Extension Metadata](#_other_extension_metadata_86)
- [Other_Extension_Metadata](#_other_extension_metadata_86)
- [Description](#_description_86)
- [New Commands](#_new_commands_44)
- [New Enum Constants](#_new_enum_constants_86)
- [New_Enum_Constants](#_new_enum_constants_86)
- [Issues](#_issues_49)
- [Version History](#_version_history_86)
- [VK_EXT_directfb_surface](#VK_EXT_directfb_surface)
- [Other Extension Metadata](#_other_extension_metadata_87)
- [Other_Extension_Metadata](#_other_extension_metadata_87)
- [Description](#_description_87)
- [New Commands](#_new_commands_45)
- [New Structures](#_new_structures_80)
- [New Bitmasks](#_new_bitmasks_26)
- [New Enum Constants](#_new_enum_constants_87)
- [New_Enum_Constants](#_new_enum_constants_87)
- [Version History](#_version_history_87)
- [VK_EXT_discard_rectangles](#VK_EXT_discard_rectangles)
- [Other Extension Metadata](#_other_extension_metadata_88)
- [Other_Extension_Metadata](#_other_extension_metadata_88)
- [Description](#_description_88)
- [New Commands](#_new_commands_46)
- [New Structures](#_new_structures_81)
- [New Enums](#_new_enums_31)
- [New Bitmasks](#_new_bitmasks_27)
- [New Enum Constants](#_new_enum_constants_88)
- [New_Enum_Constants](#_new_enum_constants_88)
- [Version History](#_version_history_88)
- [VK_EXT_display_control](#VK_EXT_display_control)
- [Other Extension Metadata](#_other_extension_metadata_89)
- [Other_Extension_Metadata](#_other_extension_metadata_89)
- [Description](#_description_89)
- [New Commands](#_new_commands_47)
- [New Structures](#_new_structures_82)
- [New Enums](#_new_enums_32)
- [New Enum Constants](#_new_enum_constants_89)
- [New_Enum_Constants](#_new_enum_constants_89)
- [Issues](#_issues_50)
- [Version History](#_version_history_89)
- [VK_EXT_display_surface_counter](#VK_EXT_display_surface_counter)
- [Other Extension Metadata](#_other_extension_metadata_90)
- [Other_Extension_Metadata](#_other_extension_metadata_90)
- [Description](#_description_90)
- [New Commands](#_new_commands_48)
- [New Structures](#_new_structures_83)
- [New Enums](#_new_enums_33)
- [New Bitmasks](#_new_bitmasks_28)
- [New Enum Constants](#_new_enum_constants_90)
- [New_Enum_Constants](#_new_enum_constants_90)
- [Version History](#_version_history_90)
- [VK_EXT_dynamic_rendering_unused_attachments](#VK_EXT_dynamic_rendering_unused_attachments)
- [Other Extension Metadata](#_other_extension_metadata_91)
- [Other_Extension_Metadata](#_other_extension_metadata_91)
- [Description](#_description_91)
- [New Structures](#_new_structures_84)
- [New Enum Constants](#_new_enum_constants_91)
- [New_Enum_Constants](#_new_enum_constants_91)
- [Issues](#_issues_51)
- [Version History](#_version_history_91)
- [VK_EXT_extended_dynamic_state3](#VK_EXT_extended_dynamic_state3)
- [Other Extension Metadata](#_other_extension_metadata_92)
- [Other_Extension_Metadata](#_other_extension_metadata_92)
- [Description](#_description_92)
- [New Commands](#_new_commands_49)
- [New Structures](#_new_structures_85)
- [New Enum Constants](#_new_enum_constants_92)
- [New_Enum_Constants](#_new_enum_constants_92)
- [Issues](#_issues_52)
- [Version History](#_version_history_92)
- [VK_EXT_external_memory_acquire_unmodified](#VK_EXT_external_memory_acquire_unmodified)
- [Other Extension Metadata](#_other_extension_metadata_93)
- [Other_Extension_Metadata](#_other_extension_metadata_93)
- [Description](#_description_93)
- [New Structures](#_new_structures_86)
- [New Enum Constants](#_new_enum_constants_93)
- [New_Enum_Constants](#_new_enum_constants_93)
- [Version History](#_version_history_93)
- [VK_EXT_external_memory_dma_buf](#VK_EXT_external_memory_dma_buf)
- [Other Extension Metadata](#_other_extension_metadata_94)
- [Other_Extension_Metadata](#_other_extension_metadata_94)
- [Description](#_description_94)
- [New Enum Constants](#_new_enum_constants_94)
- [New_Enum_Constants](#_new_enum_constants_94)
- [Issues](#_issues_53)
- [Version History](#_version_history_94)
- [VK_EXT_external_memory_host](#VK_EXT_external_memory_host)
- [Other Extension Metadata](#_other_extension_metadata_95)
- [Other_Extension_Metadata](#_other_extension_metadata_95)
- [Description](#_description_95)
- [New Commands](#_new_commands_50)
- [New Structures](#_new_structures_87)
- [New Enum Constants](#_new_enum_constants_95)
- [New_Enum_Constants](#_new_enum_constants_95)
- [Issues](#_issues_54)
- [Version History](#_version_history_95)
- [VK_EXT_external_memory_metal](#VK_EXT_external_memory_metal)
- [Other Extension Metadata](#_other_extension_metadata_96)
- [Other_Extension_Metadata](#_other_extension_metadata_96)
- [Description](#_description_96)
- [New Commands](#_new_commands_51)
- [New Structures](#_new_structures_88)
- [New Enum Constants](#_new_enum_constants_96)
- [New_Enum_Constants](#_new_enum_constants_96)
- [Version History](#_version_history_96)
- [VK_EXT_filter_cubic](#VK_EXT_filter_cubic)
- [Other Extension Metadata](#_other_extension_metadata_97)
- [Other_Extension_Metadata](#_other_extension_metadata_97)
- [Description](#_description_97)
- [New Structures](#_new_structures_89)
- [New Enum Constants](#_new_enum_constants_97)
- [New_Enum_Constants](#_new_enum_constants_97)
- [Version History](#_version_history_97)
- [VK_EXT_fragment_density_map](#VK_EXT_fragment_density_map)
- [Other Extension Metadata](#_other_extension_metadata_98)
- [Other_Extension_Metadata](#_other_extension_metadata_98)
- [Description](#_description_98)
- [New Structures](#_new_structures_90)
- [New Enum Constants](#_new_enum_constants_98)
- [New_Enum_Constants](#_new_enum_constants_98)
- [New or Modified Built-In Variables](#_new_or_modified_built_in_variables_2)
- [New_or_Modified_Built-In_Variables](#_new_or_modified_built_in_variables_2)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_12)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_12)
- [Version History](#_version_history_98)
- [VK_EXT_fragment_density_map2](#VK_EXT_fragment_density_map2)
- [Other Extension Metadata](#_other_extension_metadata_99)
- [Other_Extension_Metadata](#_other_extension_metadata_99)
- [Description](#_description_99)
- [New Structures](#_new_structures_91)
- [New Enum Constants](#_new_enum_constants_99)
- [New_Enum_Constants](#_new_enum_constants_99)
- [Version History](#_version_history_99)
- [VK_EXT_fragment_density_map_offset](#VK_EXT_fragment_density_map_offset)
- [Other Extension Metadata](#_other_extension_metadata_100)
- [Other_Extension_Metadata](#_other_extension_metadata_100)
- [Description](#_description_100)
- [New Commands](#_new_commands_52)
- [New Structures](#_new_structures_92)
- [New Enum Constants](#_new_enum_constants_100)
- [New_Enum_Constants](#_new_enum_constants_100)
- [Version History](#_version_history_100)
- [VK_EXT_fragment_shader_interlock](#VK_EXT_fragment_shader_interlock)
- [Other Extension Metadata](#_other_extension_metadata_101)
- [Other_Extension_Metadata](#_other_extension_metadata_101)
- [Description](#_description_101)
- [New Structures](#_new_structures_93)
- [New Enum Constants](#_new_enum_constants_101)
- [New_Enum_Constants](#_new_enum_constants_101)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_13)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_13)
- [Version History](#_version_history_101)
- [VK_EXT_frame_boundary](#VK_EXT_frame_boundary)
- [Other Extension Metadata](#_other_extension_metadata_102)
- [Other_Extension_Metadata](#_other_extension_metadata_102)
- [Description](#_description_102)
- [New Structures](#_new_structures_94)
- [New Enums](#_new_enums_34)
- [New Bitmasks](#_new_bitmasks_29)
- [New Enum Constants](#_new_enum_constants_102)
- [New_Enum_Constants](#_new_enum_constants_102)
- [Version History](#_version_history_102)
- [VK_EXT_full_screen_exclusive](#VK_EXT_full_screen_exclusive)
- [Other Extension Metadata](#_other_extension_metadata_103)
- [Other_Extension_Metadata](#_other_extension_metadata_103)
- [Description](#_description_103)
- [New Commands](#_new_commands_53)
- [New Structures](#_new_structures_95)
- [New Enums](#_new_enums_35)
- [New Enum Constants](#_new_enum_constants_103)
- [New_Enum_Constants](#_new_enum_constants_103)
- [Issues](#_issues_55)
- [Version History](#_version_history_103)
- [VK_EXT_graphics_pipeline_library](#VK_EXT_graphics_pipeline_library)
- [Other Extension Metadata](#_other_extension_metadata_104)
- [Other_Extension_Metadata](#_other_extension_metadata_104)
- [Description](#_description_104)
- [New Structures](#_new_structures_96)
- [New Enums](#_new_enums_36)
- [New Bitmasks](#_new_bitmasks_30)
- [New Enum Constants](#_new_enum_constants_104)
- [New_Enum_Constants](#_new_enum_constants_104)
- [Version History](#_version_history_104)
- [VK_EXT_hdr_metadata](#VK_EXT_hdr_metadata)
- [Other Extension Metadata](#_other_extension_metadata_105)
- [Other_Extension_Metadata](#_other_extension_metadata_105)
- [Description](#_description_105)
- [New Commands](#_new_commands_54)
- [New Structures](#_new_structures_97)
- [New Enum Constants](#_new_enum_constants_105)
- [New_Enum_Constants](#_new_enum_constants_105)
- [Issues](#_issues_56)
- [Version History](#_version_history_105)
- [VK_EXT_headless_surface](#VK_EXT_headless_surface)
- [Other Extension Metadata](#_other_extension_metadata_106)
- [Other_Extension_Metadata](#_other_extension_metadata_106)
- [Description](#_description_106)
- [New Commands](#_new_commands_55)
- [New Structures](#_new_structures_98)
- [New Bitmasks](#_new_bitmasks_31)
- [New Enum Constants](#_new_enum_constants_106)
- [New_Enum_Constants](#_new_enum_constants_106)
- [Version History](#_version_history_106)
- [VK_EXT_image_2d_view_of_3d](#VK_EXT_image_2d_view_of_3d)
- [Other Extension Metadata](#_other_extension_metadata_107)
- [Other_Extension_Metadata](#_other_extension_metadata_107)
- [Description](#_description_107)
- [New Structures](#_new_structures_99)
- [New Enum Constants](#_new_enum_constants_107)
- [New_Enum_Constants](#_new_enum_constants_107)
- [Version History](#_version_history_107)
- [VK_EXT_image_compression_control](#VK_EXT_image_compression_control)
- [Other Extension Metadata](#_other_extension_metadata_108)
- [Other_Extension_Metadata](#_other_extension_metadata_108)
- [Description](#_description_108)
- [New Commands](#_new_commands_56)
- [New Structures](#_new_structures_100)
- [New Enums](#_new_enums_37)
- [New Bitmasks](#_new_bitmasks_32)
- [New Enum Constants](#_new_enum_constants_108)
- [New_Enum_Constants](#_new_enum_constants_108)
- [Version History](#_version_history_108)
- [VK_EXT_image_compression_control_swapchain](#VK_EXT_image_compression_control_swapchain)
- [Other Extension Metadata](#_other_extension_metadata_109)
- [Other_Extension_Metadata](#_other_extension_metadata_109)
- [Description](#_description_109)
- [New Structures](#_new_structures_101)
- [New Enum Constants](#_new_enum_constants_109)
- [New_Enum_Constants](#_new_enum_constants_109)
- [Version History](#_version_history_109)
- [VK_EXT_image_drm_format_modifier](#VK_EXT_image_drm_format_modifier)
- [Other Extension Metadata](#_other_extension_metadata_110)
- [Other_Extension_Metadata](#_other_extension_metadata_110)
- [Description](#_description_110)
- [Introduction to DRM Format Modifiers](#_introduction_to_drm_format_modifiers)
- [Introduction_to_DRM_Format_Modifiers](#_introduction_to_drm_format_modifiers)
- [Format Translation](#_format_translation)
- [Usage Patterns](#_usage_patterns)
- [Prior Art](#_prior_art)
- [New Commands](#_new_commands_57)
- [New Structures](#_new_structures_102)
- [New Enum Constants](#_new_enum_constants_110)
- [New_Enum_Constants](#_new_enum_constants_110)
- [Issues](#_issues_57)
- [References](#_references)
- [Version History](#_version_history_110)
- [VK_EXT_image_sliced_view_of_3d](#VK_EXT_image_sliced_view_of_3d)
- [Other Extension Metadata](#_other_extension_metadata_111)
- [Other_Extension_Metadata](#_other_extension_metadata_111)
- [Description](#_description_111)
- [New Structures](#_new_structures_103)
- [New Enum Constants](#_new_enum_constants_111)
- [New_Enum_Constants](#_new_enum_constants_111)
- [Version History](#_version_history_111)
- [VK_EXT_image_view_min_lod](#VK_EXT_image_view_min_lod)
- [Other Extension Metadata](#_other_extension_metadata_112)
- [Other_Extension_Metadata](#_other_extension_metadata_112)
- [Description](#_description_112)
- [New Structures](#_new_structures_104)
- [New Enum Constants](#_new_enum_constants_112)
- [New_Enum_Constants](#_new_enum_constants_112)
- [Version History](#_version_history_112)
- [VK_EXT_layer_settings](#VK_EXT_layer_settings)
- [Other Extension Metadata](#_other_extension_metadata_113)
- [Other_Extension_Metadata](#_other_extension_metadata_113)
- [Description](#_description_113)
- [New Structures](#_new_structures_105)
- [New Enums](#_new_enums_38)
- [New Enum Constants](#_new_enum_constants_113)
- [New_Enum_Constants](#_new_enum_constants_113)
- [Example](#_example_2)
- [Issues](#_issues_58)
- [Version History](#_version_history_113)
- [VK_EXT_legacy_dithering](#VK_EXT_legacy_dithering)
- [Other Extension Metadata](#_other_extension_metadata_114)
- [Other_Extension_Metadata](#_other_extension_metadata_114)
- [Description](#_description_114)
- [New Structures](#_new_structures_106)
- [New Enum Constants](#_new_enum_constants_114)
- [New_Enum_Constants](#_new_enum_constants_114)
- [Version History](#_version_history_114)
- [Issues](#_issues_59)
- [VK_EXT_legacy_vertex_attributes](#VK_EXT_legacy_vertex_attributes)
- [Other Extension Metadata](#_other_extension_metadata_115)
- [Other_Extension_Metadata](#_other_extension_metadata_115)
- [Description](#_description_115)
- [New Structures](#_new_structures_107)
- [New Enum Constants](#_new_enum_constants_115)
- [New_Enum_Constants](#_new_enum_constants_115)
- [Issues](#_issues_60)
- [Version History](#_version_history_115)
- [VK_EXT_map_memory_placed](#VK_EXT_map_memory_placed)
- [Other Extension Metadata](#_other_extension_metadata_116)
- [Other_Extension_Metadata](#_other_extension_metadata_116)
- [Description](#_description_116)
- [New Structures](#_new_structures_108)
- [New Enum Constants](#_new_enum_constants_116)
- [New_Enum_Constants](#_new_enum_constants_116)
- [Version History](#_version_history_116)
- [VK_EXT_memory_budget](#VK_EXT_memory_budget)
- [Other Extension Metadata](#_other_extension_metadata_117)
- [Other_Extension_Metadata](#_other_extension_metadata_117)
- [Description](#_description_117)
- [New Structures](#_new_structures_109)
- [New Enum Constants](#_new_enum_constants_117)
- [New_Enum_Constants](#_new_enum_constants_117)
- [Version History](#_version_history_117)
- [VK_EXT_memory_priority](#VK_EXT_memory_priority)
- [Other Extension Metadata](#_other_extension_metadata_118)
- [Other_Extension_Metadata](#_other_extension_metadata_118)
- [Description](#_description_118)
- [New Structures](#_new_structures_110)
- [New Enum Constants](#_new_enum_constants_118)
- [New_Enum_Constants](#_new_enum_constants_118)
- [Version History](#_version_history_118)
- [VK_EXT_mesh_shader](#VK_EXT_mesh_shader)
- [Other Extension Metadata](#_other_extension_metadata_119)
- [Other_Extension_Metadata](#_other_extension_metadata_119)
- [Description](#_description_119)
- [New Commands](#_new_commands_58)
- [New Structures](#_new_structures_111)
- [New Enum Constants](#_new_enum_constants_119)
- [New_Enum_Constants](#_new_enum_constants_119)
- [New or Modified Built-In Variables](#_new_or_modified_built_in_variables_3)
- [New_or_Modified_Built-In_Variables](#_new_or_modified_built_in_variables_3)
- [New SPIR-V Capability](#_new_spir_v_capability_2)
- [New_SPIR-V_Capability](#_new_spir_v_capability_2)
- [Version History](#_version_history_119)
- [VK_EXT_metal_objects](#VK_EXT_metal_objects)
- [Other Extension Metadata](#_other_extension_metadata_120)
- [Other_Extension_Metadata](#_other_extension_metadata_120)
- [Description](#_description_120)
- [New Base Types](#_new_base_types_2)
- [New_Base_Types](#_new_base_types_2)
- [New Commands](#_new_commands_59)
- [New Structures](#_new_structures_112)
- [New Enums](#_new_enums_39)
- [New Bitmasks](#_new_bitmasks_33)
- [New Enum Constants](#_new_enum_constants_120)
- [New_Enum_Constants](#_new_enum_constants_120)
- [Issues](#_issues_61)
- [Version History](#_version_history_120)
- [VK_EXT_metal_surface](#VK_EXT_metal_surface)
- [Other Extension Metadata](#_other_extension_metadata_121)
- [Other_Extension_Metadata](#_other_extension_metadata_121)
- [Description](#_description_121)
- [New Base Types](#_new_base_types_3)
- [New_Base_Types](#_new_base_types_3)
- [New Commands](#_new_commands_60)
- [New Structures](#_new_structures_113)
- [New Bitmasks](#_new_bitmasks_34)
- [New Enum Constants](#_new_enum_constants_121)
- [New_Enum_Constants](#_new_enum_constants_121)
- [Version History](#_version_history_121)
- [VK_EXT_multi_draw](#VK_EXT_multi_draw)
- [Other Extension Metadata](#_other_extension_metadata_122)
- [Other_Extension_Metadata](#_other_extension_metadata_122)
- [Description](#_description_122)
- [New Commands](#_new_commands_61)
- [New Structures](#_new_structures_114)
- [New Enum Constants](#_new_enum_constants_122)
- [New_Enum_Constants](#_new_enum_constants_122)
- [New or Modified Built-In Variables](#_new_or_modified_built_in_variables_4)
- [New_or_Modified_Built-In_Variables](#_new_or_modified_built_in_variables_4)
- [Version History](#_version_history_122)
- [VK_EXT_multisampled_render_to_single_sampled](#VK_EXT_multisampled_render_to_single_sampled)
- [Other Extension Metadata](#_other_extension_metadata_123)
- [Other_Extension_Metadata](#_other_extension_metadata_123)
- [Description](#_description_123)
- [New Structures](#_new_structures_115)
- [New Enum Constants](#_new_enum_constants_123)
- [New_Enum_Constants](#_new_enum_constants_123)
- [Issues](#_issues_62)
- [Version History](#_version_history_123)
- [VK_EXT_mutable_descriptor_type](#VK_EXT_mutable_descriptor_type)
- [Other Extension Metadata](#_other_extension_metadata_124)
- [Other_Extension_Metadata](#_other_extension_metadata_124)
- [Description](#_description_124)
- [New Structures](#_new_structures_116)
- [New Enum Constants](#_new_enum_constants_124)
- [New_Enum_Constants](#_new_enum_constants_124)
- [Version History](#_version_history_124)
- [VK_EXT_nested_command_buffer](#VK_EXT_nested_command_buffer)
- [Other Extension Metadata](#_other_extension_metadata_125)
- [Other_Extension_Metadata](#_other_extension_metadata_125)
- [Description](#_description_125)
- [New Structures](#_new_structures_117)
- [New Enum Constants](#_new_enum_constants_125)
- [New_Enum_Constants](#_new_enum_constants_125)
- [Issues](#_issues_63)
- [Version History](#_version_history_125)
- [VK_EXT_non_seamless_cube_map](#VK_EXT_non_seamless_cube_map)
- [Other Extension Metadata](#_other_extension_metadata_126)
- [Other_Extension_Metadata](#_other_extension_metadata_126)
- [Description](#_description_126)
- [New Structures](#_new_structures_118)
- [New Enum Constants](#_new_enum_constants_126)
- [New_Enum_Constants](#_new_enum_constants_126)
- [Version History](#_version_history_126)
- [VK_EXT_opacity_micromap](#VK_EXT_opacity_micromap)
- [Other Extension Metadata](#_other_extension_metadata_127)
- [Other_Extension_Metadata](#_other_extension_metadata_127)
- [Description](#_description_127)
- [New Object Types](#_new_object_types_10)
- [New_Object_Types](#_new_object_types_10)
- [New Commands](#_new_commands_62)
- [New Structures](#_new_structures_119)
- [New Enums](#_new_enums_40)
- [New Bitmasks](#_new_bitmasks_35)
- [New Enum Constants](#_new_enum_constants_127)
- [New_Enum_Constants](#_new_enum_constants_127)
- [Reference Code](#_reference_code)
- [Issues](#_issues_64)
- [Version History](#_version_history_127)
- [VK_EXT_pageable_device_local_memory](#VK_EXT_pageable_device_local_memory)
- [Other Extension Metadata](#_other_extension_metadata_128)
- [Other_Extension_Metadata](#_other_extension_metadata_128)
- [Description](#_description_128)
- [New Commands](#_new_commands_63)
- [New Structures](#_new_structures_120)
- [New Enum Constants](#_new_enum_constants_128)
- [New_Enum_Constants](#_new_enum_constants_128)
- [Version History](#_version_history_128)
- [VK_EXT_pci_bus_info](#VK_EXT_pci_bus_info)
- [Other Extension Metadata](#_other_extension_metadata_129)
- [Other_Extension_Metadata](#_other_extension_metadata_129)
- [Description](#_description_129)
- [New Structures](#_new_structures_121)
- [New Enum Constants](#_new_enum_constants_129)
- [New_Enum_Constants](#_new_enum_constants_129)
- [Version History](#_version_history_129)
- [VK_EXT_physical_device_drm](#VK_EXT_physical_device_drm)
- [Other Extension Metadata](#_other_extension_metadata_130)
- [Other_Extension_Metadata](#_other_extension_metadata_130)
- [Description](#_description_130)
- [New Structures](#_new_structures_122)
- [New Enum Constants](#_new_enum_constants_130)
- [New_Enum_Constants](#_new_enum_constants_130)
- [References](#_references_2)
- [Version History](#_version_history_130)
- [VK_EXT_pipeline_library_group_handles](#VK_EXT_pipeline_library_group_handles)
- [Other Extension Metadata](#_other_extension_metadata_131)
- [Other_Extension_Metadata](#_other_extension_metadata_131)
- [Description](#_description_131)
- [New Structures](#_new_structures_123)
- [New Enum Constants](#_new_enum_constants_131)
- [New_Enum_Constants](#_new_enum_constants_131)
- [Version History](#_version_history_131)
- [VK_EXT_pipeline_properties](#VK_EXT_pipeline_properties)
- [Other Extension Metadata](#_other_extension_metadata_132)
- [Other_Extension_Metadata](#_other_extension_metadata_132)
- [Description](#_description_132)
- [New Commands](#_new_commands_64)
- [New Structures](#_new_structures_124)
- [New Enum Constants](#_new_enum_constants_132)
- [New_Enum_Constants](#_new_enum_constants_132)
- [Issues](#_issues_65)
- [Version History](#_version_history_132)
- [VK_EXT_post_depth_coverage](#VK_EXT_post_depth_coverage)
- [Other Extension Metadata](#_other_extension_metadata_133)
- [Other_Extension_Metadata](#_other_extension_metadata_133)
- [Description](#_description_133)
- [New Enum Constants](#_new_enum_constants_133)
- [New_Enum_Constants](#_new_enum_constants_133)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_14)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_14)
- [Version History](#_version_history_133)
- [VK_EXT_present_mode_fifo_latest_ready](#VK_EXT_present_mode_fifo_latest_ready)
- [Other Extension Metadata](#_other_extension_metadata_134)
- [Other_Extension_Metadata](#_other_extension_metadata_134)
- [Description](#_description_134)
- [New Structures](#_new_structures_125)
- [New Enum Constants](#_new_enum_constants_134)
- [New_Enum_Constants](#_new_enum_constants_134)
- [Version History](#_version_history_134)
- [VK_EXT_primitive_topology_list_restart](#VK_EXT_primitive_topology_list_restart)
- [Other Extension Metadata](#_other_extension_metadata_135)
- [Other_Extension_Metadata](#_other_extension_metadata_135)
- [Description](#_description_135)
- [New Structures](#_new_structures_126)
- [New Enum Constants](#_new_enum_constants_135)
- [New_Enum_Constants](#_new_enum_constants_135)
- [Version History](#_version_history_135)
- [VK_EXT_primitives_generated_query](#VK_EXT_primitives_generated_query)
- [Other Extension Metadata](#_other_extension_metadata_136)
- [Other_Extension_Metadata](#_other_extension_metadata_136)
- [Description](#_description_136)
- [New Structures](#_new_structures_127)
- [New Enum Constants](#_new_enum_constants_136)
- [New_Enum_Constants](#_new_enum_constants_136)
- [Issues](#_issues_66)
- [Version History](#_version_history_136)
- [VK_EXT_provoking_vertex](#VK_EXT_provoking_vertex)
- [Other Extension Metadata](#_other_extension_metadata_137)
- [Other_Extension_Metadata](#_other_extension_metadata_137)
- [Description](#_description_137)
- [New Structures](#_new_structures_128)
- [New Enums](#_new_enums_41)
- [New Enum Constants](#_new_enum_constants_137)
- [New_Enum_Constants](#_new_enum_constants_137)
- [Issues](#_issues_67)
- [Version History](#_version_history_137)
- [VK_EXT_queue_family_foreign](#VK_EXT_queue_family_foreign)
- [Other Extension Metadata](#_other_extension_metadata_138)
- [Other_Extension_Metadata](#_other_extension_metadata_138)
- [Description](#_description_138)
- [New Enum Constants](#_new_enum_constants_138)
- [New_Enum_Constants](#_new_enum_constants_138)
- [Version History](#_version_history_138)
- [VK_EXT_rasterization_order_attachment_access](#VK_EXT_rasterization_order_attachment_access)
- [Other Extension Metadata](#_other_extension_metadata_139)
- [Other_Extension_Metadata](#_other_extension_metadata_139)
- [Description](#_description_139)
- [New Structures](#_new_structures_129)
- [New Enums](#_new_enums_42)
- [New Enum Constants](#_new_enum_constants_139)
- [New_Enum_Constants](#_new_enum_constants_139)
- [Examples](#_examples_11)
- [Version History](#_version_history_139)
- [VK_EXT_rgba10x6_formats](#VK_EXT_rgba10x6_formats)
- [Other Extension Metadata](#_other_extension_metadata_140)
- [Other_Extension_Metadata](#_other_extension_metadata_140)
- [Description](#_description_140)
- [New Structures](#_new_structures_130)
- [New Enum Constants](#_new_enum_constants_140)
- [New_Enum_Constants](#_new_enum_constants_140)
- [Issues](#_issues_68)
- [Version History](#_version_history_140)
- [VK_EXT_sample_locations](#VK_EXT_sample_locations)
- [Other Extension Metadata](#_other_extension_metadata_141)
- [Other_Extension_Metadata](#_other_extension_metadata_141)
- [Description](#_description_141)
- [New Commands](#_new_commands_65)
- [New Structures](#_new_structures_131)
- [New Enum Constants](#_new_enum_constants_141)
- [New_Enum_Constants](#_new_enum_constants_141)
- [Version History](#_version_history_141)
- [VK_EXT_shader_atomic_float](#VK_EXT_shader_atomic_float)
- [Other Extension Metadata](#_other_extension_metadata_142)
- [Other_Extension_Metadata](#_other_extension_metadata_142)
- [Description](#_description_142)
- [New Structures](#_new_structures_132)
- [New Enum Constants](#_new_enum_constants_142)
- [New_Enum_Constants](#_new_enum_constants_142)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_15)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_15)
- [Version History](#_version_history_142)
- [VK_EXT_shader_atomic_float2](#VK_EXT_shader_atomic_float2)
- [Other Extension Metadata](#_other_extension_metadata_143)
- [Other_Extension_Metadata](#_other_extension_metadata_143)
- [Description](#_description_143)
- [New Structures](#_new_structures_133)
- [New Enum Constants](#_new_enum_constants_143)
- [New_Enum_Constants](#_new_enum_constants_143)
- [Issues](#_issues_69)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_16)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_16)
- [Version History](#_version_history_143)
- [VK_EXT_shader_image_atomic_int64](#VK_EXT_shader_image_atomic_int64)
- [Other Extension Metadata](#_other_extension_metadata_144)
- [Other_Extension_Metadata](#_other_extension_metadata_144)
- [Description](#_description_144)
- [New Structures](#_new_structures_134)
- [New Enum Constants](#_new_enum_constants_144)
- [New_Enum_Constants](#_new_enum_constants_144)
- [Version History](#_version_history_144)
- [VK_EXT_shader_module_identifier](#VK_EXT_shader_module_identifier)
- [Other Extension Metadata](#_other_extension_metadata_145)
- [Other_Extension_Metadata](#_other_extension_metadata_145)
- [Description](#_description_145)
- [New Commands](#_new_commands_66)
- [New Structures](#_new_structures_135)
- [New Enum Constants](#_new_enum_constants_145)
- [New_Enum_Constants](#_new_enum_constants_145)
- [Version History](#_version_history_145)
- [VK_EXT_shader_object](#VK_EXT_shader_object)
- [Other Extension Metadata](#_other_extension_metadata_146)
- [Other_Extension_Metadata](#_other_extension_metadata_146)
- [Description](#_description_146)
- [New Object Types](#_new_object_types_11)
- [New_Object_Types](#_new_object_types_11)
- [New Commands](#_new_commands_67)
- [New Structures](#_new_structures_136)
- [New Enums](#_new_enums_43)
- [New Bitmasks](#_new_bitmasks_36)
- [New Enum Constants](#_new_enum_constants_146)
- [New_Enum_Constants](#_new_enum_constants_146)
- [Examples](#_examples_12)
- [Version History](#_version_history_146)
- [VK_EXT_shader_replicated_composites](#VK_EXT_shader_replicated_composites)
- [New Structures](#_new_structures_137)
- [New Enum Constants](#_new_enum_constants_147)
- [New_Enum_Constants](#_new_enum_constants_147)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_17)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_17)
- [Version History](#_version_history_147)
- [VK_EXT_shader_stencil_export](#VK_EXT_shader_stencil_export)
- [Other Extension Metadata](#_other_extension_metadata_147)
- [Other_Extension_Metadata](#_other_extension_metadata_147)
- [Description](#_description_147)
- [New Enum Constants](#_new_enum_constants_148)
- [New_Enum_Constants](#_new_enum_constants_148)
- [Version History](#_version_history_148)
- [VK_EXT_shader_tile_image](#VK_EXT_shader_tile_image)
- [Other Extension Metadata](#_other_extension_metadata_148)
- [Other_Extension_Metadata](#_other_extension_metadata_148)
- [Description](#_description_148)
- [New Structures](#_new_structures_138)
- [New Enum Constants](#_new_enum_constants_149)
- [New_Enum_Constants](#_new_enum_constants_149)
- [Issues](#_issues_70)
- [Examples](#_examples_13)
- [Version History](#_version_history_149)
- [VK_EXT_subpass_merge_feedback](#VK_EXT_subpass_merge_feedback)
- [Other Extension Metadata](#_other_extension_metadata_149)
- [Other_Extension_Metadata](#_other_extension_metadata_149)
- [Description](#_description_149)
- [New Structures](#_new_structures_139)
- [New Enums](#_new_enums_44)
- [New Enum Constants](#_new_enum_constants_150)
- [New_Enum_Constants](#_new_enum_constants_150)
- [Version History](#_version_history_150)
- [VK_EXT_surface_maintenance1](#VK_EXT_surface_maintenance1)
- [Other Extension Metadata](#_other_extension_metadata_150)
- [Other_Extension_Metadata](#_other_extension_metadata_150)
- [Description](#_description_150)
- [New Structures](#_new_structures_140)
- [New Enums](#_new_enums_45)
- [New Bitmasks](#_new_bitmasks_37)
- [New Enum Constants](#_new_enum_constants_151)
- [New_Enum_Constants](#_new_enum_constants_151)
- [Version History](#_version_history_151)
- [VK_EXT_swapchain_colorspace](#VK_EXT_swapchain_colorspace)
- [Other Extension Metadata](#_other_extension_metadata_151)
- [Other_Extension_Metadata](#_other_extension_metadata_151)
- [Description](#_description_151)
- [New Enum Constants](#_new_enum_constants_152)
- [New_Enum_Constants](#_new_enum_constants_152)
- [Issues](#_issues_71)
- [Version History](#_version_history_152)
- [VK_EXT_swapchain_maintenance1](#VK_EXT_swapchain_maintenance1)
- [Other Extension Metadata](#_other_extension_metadata_152)
- [Other_Extension_Metadata](#_other_extension_metadata_152)
- [Description](#_description_152)
- [New Commands](#_new_commands_68)
- [New Structures](#_new_structures_141)
- [New Enum Constants](#_new_enum_constants_153)
- [New_Enum_Constants](#_new_enum_constants_153)
- [Version History](#_version_history_153)
- [VK_EXT_transform_feedback](#VK_EXT_transform_feedback)
- [Other Extension Metadata](#_other_extension_metadata_153)
- [Other_Extension_Metadata](#_other_extension_metadata_153)
- [Description](#_description_153)
- [New Commands](#_new_commands_69)
- [New Structures](#_new_structures_142)
- [New Bitmasks](#_new_bitmasks_38)
- [New Enum Constants](#_new_enum_constants_154)
- [New_Enum_Constants](#_new_enum_constants_154)
- [Issues](#_issues_72)
- [Version History](#_version_history_154)
- [VK_EXT_validation_cache](#VK_EXT_validation_cache)
- [Other Extension Metadata](#_other_extension_metadata_154)
- [Other_Extension_Metadata](#_other_extension_metadata_154)
- [Description](#_description_154)
- [New Object Types](#_new_object_types_12)
- [New_Object_Types](#_new_object_types_12)
- [New Commands](#_new_commands_70)
- [New Structures](#_new_structures_143)
- [New Enums](#_new_enums_46)
- [New Bitmasks](#_new_bitmasks_39)
- [New Enum Constants](#_new_enum_constants_155)
- [New_Enum_Constants](#_new_enum_constants_155)
- [Version History](#_version_history_155)
- [VK_EXT_vertex_attribute_robustness](#VK_EXT_vertex_attribute_robustness)
- [Other Extension Metadata](#_other_extension_metadata_155)
- [Other_Extension_Metadata](#_other_extension_metadata_155)
- [Description](#_description_155)
- [New Structures](#_new_structures_144)
- [New Enum Constants](#_new_enum_constants_156)
- [New_Enum_Constants](#_new_enum_constants_156)
- [Issues](#_issues_73)
- [Version History](#_version_history_156)
- [VK_EXT_vertex_input_dynamic_state](#VK_EXT_vertex_input_dynamic_state)
- [Other Extension Metadata](#_other_extension_metadata_156)
- [Other_Extension_Metadata](#_other_extension_metadata_156)
- [Description](#_description_156)
- [New Commands](#_new_commands_71)
- [New Structures](#_new_structures_145)
- [New Enum Constants](#_new_enum_constants_157)
- [New_Enum_Constants](#_new_enum_constants_157)
- [Version History](#_version_history_157)
- [VK_EXT_ycbcr_image_arrays](#VK_EXT_ycbcr_image_arrays)
- [Other Extension Metadata](#_other_extension_metadata_157)
- [Other_Extension_Metadata](#_other_extension_metadata_157)
- [Description](#_description_157)
- [New Structures](#_new_structures_146)
- [New Enum Constants](#_new_enum_constants_158)
- [New_Enum_Constants](#_new_enum_constants_158)
- [Version History](#_version_history_158)
- [VK_EXT_zero_initialize_device_memory](#VK_EXT_zero_initialize_device_memory)
- [Other Extension Metadata](#_other_extension_metadata_158)
- [Other_Extension_Metadata](#_other_extension_metadata_158)
- [Description](#_description_158)
- [New Structures](#_new_structures_147)
- [New Enum Constants](#_new_enum_constants_159)
- [New_Enum_Constants](#_new_enum_constants_159)
- [Version History](#_version_history_159)
- [VK_AMD_anti_lag](#VK_AMD_anti_lag)
- [Other Extension Metadata](#_other_extension_metadata_159)
- [Other_Extension_Metadata](#_other_extension_metadata_159)
- [Description](#_description_159)
- [New Commands](#_new_commands_72)
- [New Structures](#_new_structures_148)
- [New Enums](#_new_enums_47)
- [New Enum Constants](#_new_enum_constants_160)
- [New_Enum_Constants](#_new_enum_constants_160)
- [Version History](#_version_history_160)
- [VK_AMD_buffer_marker](#VK_AMD_buffer_marker)
- [Other Extension Metadata](#_other_extension_metadata_160)
- [Other_Extension_Metadata](#_other_extension_metadata_160)
- [Description](#_description_160)
- [New Commands](#_new_commands_73)
- [New Enum Constants](#_new_enum_constants_161)
- [New_Enum_Constants](#_new_enum_constants_161)
- [Examples](#_examples_14)
- [Version History](#_version_history_161)
- [VK_AMD_device_coherent_memory](#VK_AMD_device_coherent_memory)
- [Other Extension Metadata](#_other_extension_metadata_161)
- [Other_Extension_Metadata](#_other_extension_metadata_161)
- [Description](#_description_161)
- [New Structures](#_new_structures_149)
- [New Enum Constants](#_new_enum_constants_162)
- [New_Enum_Constants](#_new_enum_constants_162)
- [Version History](#_version_history_162)
- [VK_AMD_display_native_hdr](#VK_AMD_display_native_hdr)
- [Other Extension Metadata](#_other_extension_metadata_162)
- [Other_Extension_Metadata](#_other_extension_metadata_162)
- [Description](#_description_162)
- [New Commands](#_new_commands_74)
- [New Structures](#_new_structures_150)
- [New Enum Constants](#_new_enum_constants_163)
- [New_Enum_Constants](#_new_enum_constants_163)
- [Issues](#_issues_74)
- [Examples](#_examples_15)
- [Version History](#_version_history_163)
- [VK_AMD_gcn_shader](#VK_AMD_gcn_shader)
- [Other Extension Metadata](#_other_extension_metadata_163)
- [Other_Extension_Metadata](#_other_extension_metadata_163)
- [Description](#_description_163)
- [New Enum Constants](#_new_enum_constants_164)
- [New_Enum_Constants](#_new_enum_constants_164)
- [Version History](#_version_history_164)
- [VK_AMD_memory_overallocation_behavior](#VK_AMD_memory_overallocation_behavior)
- [Other Extension Metadata](#_other_extension_metadata_164)
- [Other_Extension_Metadata](#_other_extension_metadata_164)
- [Description](#_description_164)
- [New Structures](#_new_structures_151)
- [New Enums](#_new_enums_48)
- [New Enum Constants](#_new_enum_constants_165)
- [New_Enum_Constants](#_new_enum_constants_165)
- [Version History](#_version_history_165)
- [VK_AMD_mixed_attachment_samples](#VK_AMD_mixed_attachment_samples)
- [Other Extension Metadata](#_other_extension_metadata_165)
- [Other_Extension_Metadata](#_other_extension_metadata_165)
- [Description](#_description_165)
- [New Structures](#_new_structures_152)
- [New Enum Constants](#_new_enum_constants_166)
- [New_Enum_Constants](#_new_enum_constants_166)
- [Issues](#_issues_75)
- [Version History](#_version_history_166)
- [VK_AMD_pipeline_compiler_control](#VK_AMD_pipeline_compiler_control)
- [Other Extension Metadata](#_other_extension_metadata_166)
- [Other_Extension_Metadata](#_other_extension_metadata_166)
- [Description](#_description_166)
- [New Structures](#_new_structures_153)
- [New Enums](#_new_enums_49)
- [New Bitmasks](#_new_bitmasks_40)
- [New Enum Constants](#_new_enum_constants_167)
- [New_Enum_Constants](#_new_enum_constants_167)
- [Issues](#_issues_76)
- [Examples](#_examples_16)
- [Version History](#_version_history_167)
- [VK_AMD_rasterization_order](#VK_AMD_rasterization_order)
- [Other Extension Metadata](#_other_extension_metadata_167)
- [Other_Extension_Metadata](#_other_extension_metadata_167)
- [Description](#_description_167)
- [New Structures](#_new_structures_154)
- [New Enums](#_new_enums_50)
- [New Enum Constants](#_new_enum_constants_168)
- [New_Enum_Constants](#_new_enum_constants_168)
- [Issues](#_issues_77)
- [Examples](#_examples_17)
- [Issues](#_issues_78)
- [Version History](#_version_history_168)
- [VK_AMD_shader_ballot](#VK_AMD_shader_ballot)
- [Other Extension Metadata](#_other_extension_metadata_168)
- [Other_Extension_Metadata](#_other_extension_metadata_168)
- [Description](#_description_168)
- [New Enum Constants](#_new_enum_constants_169)
- [New_Enum_Constants](#_new_enum_constants_169)
- [Version History](#_version_history_169)
- [VK_AMD_shader_core_properties](#VK_AMD_shader_core_properties)
- [Other Extension Metadata](#_other_extension_metadata_169)
- [Other_Extension_Metadata](#_other_extension_metadata_169)
- [Description](#_description_169)
- [New Structures](#_new_structures_155)
- [New Enum Constants](#_new_enum_constants_170)
- [New_Enum_Constants](#_new_enum_constants_170)
- [Examples](#_examples_18)
- [Version History](#_version_history_170)
- [VK_AMD_shader_core_properties2](#VK_AMD_shader_core_properties2)
- [Other Extension Metadata](#_other_extension_metadata_170)
- [Other_Extension_Metadata](#_other_extension_metadata_170)
- [Description](#_description_170)
- [New Structures](#_new_structures_156)
- [New Enums](#_new_enums_51)
- [New Bitmasks](#_new_bitmasks_41)
- [New Enum Constants](#_new_enum_constants_171)
- [New_Enum_Constants](#_new_enum_constants_171)
- [Examples](#_examples_19)
- [Version History](#_version_history_171)
- [VK_AMD_shader_early_and_late_fragment_tests](#VK_AMD_shader_early_and_late_fragment_tests)
- [Other Extension Metadata](#_other_extension_metadata_171)
- [Other_Extension_Metadata](#_other_extension_metadata_171)
- [Description](#_description_171)
- [New Structures](#_new_structures_157)
- [New Enum Constants](#_new_enum_constants_172)
- [New_Enum_Constants](#_new_enum_constants_172)
- [Version History](#_version_history_172)
- [VK_AMD_shader_explicit_vertex_parameter](#VK_AMD_shader_explicit_vertex_parameter)
- [Other Extension Metadata](#_other_extension_metadata_172)
- [Other_Extension_Metadata](#_other_extension_metadata_172)
- [Description](#_description_172)
- [New Enum Constants](#_new_enum_constants_173)
- [New_Enum_Constants](#_new_enum_constants_173)
- [Version History](#_version_history_173)
- [VK_AMD_shader_fragment_mask](#VK_AMD_shader_fragment_mask)
- [Other Extension Metadata](#_other_extension_metadata_173)
- [Other_Extension_Metadata](#_other_extension_metadata_173)
- [Description](#_description_173)
- [New Enum Constants](#_new_enum_constants_174)
- [New_Enum_Constants](#_new_enum_constants_174)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_18)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_18)
- [Examples](#_examples_20)
- [Version History](#_version_history_174)
- [VK_AMD_shader_image_load_store_lod](#VK_AMD_shader_image_load_store_lod)
- [Other Extension Metadata](#_other_extension_metadata_174)
- [Other_Extension_Metadata](#_other_extension_metadata_174)
- [Description](#_description_174)
- [New Enum Constants](#_new_enum_constants_175)
- [New_Enum_Constants](#_new_enum_constants_175)
- [Version History](#_version_history_175)
- [VK_AMD_shader_info](#VK_AMD_shader_info)
- [Other Extension Metadata](#_other_extension_metadata_175)
- [Other_Extension_Metadata](#_other_extension_metadata_175)
- [Description](#_description_175)
- [New Commands](#_new_commands_75)
- [New Structures](#_new_structures_158)
- [New Enums](#_new_enums_52)
- [New Enum Constants](#_new_enum_constants_176)
- [New_Enum_Constants](#_new_enum_constants_176)
- [Examples](#_examples_21)
- [Version History](#_version_history_176)
- [VK_AMD_shader_trinary_minmax](#VK_AMD_shader_trinary_minmax)
- [Other Extension Metadata](#_other_extension_metadata_176)
- [Other_Extension_Metadata](#_other_extension_metadata_176)
- [Description](#_description_176)
- [New Enum Constants](#_new_enum_constants_177)
- [New_Enum_Constants](#_new_enum_constants_177)
- [Version History](#_version_history_177)
- [VK_AMD_texture_gather_bias_lod](#VK_AMD_texture_gather_bias_lod)
- [Other Extension Metadata](#_other_extension_metadata_177)
- [Other_Extension_Metadata](#_other_extension_metadata_177)
- [Description](#_description_177)
- [New Structures](#_new_structures_159)
- [New Enum Constants](#_new_enum_constants_178)
- [New_Enum_Constants](#_new_enum_constants_178)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_19)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_19)
- [Examples](#_examples_22)
- [Version History](#_version_history_178)
- [VK_ANDROID_external_format_resolve](#VK_ANDROID_external_format_resolve)
- [Other Extension Metadata](#_other_extension_metadata_178)
- [Other_Extension_Metadata](#_other_extension_metadata_178)
- [Description](#_description_178)
- [New Structures](#_new_structures_160)
- [New Enum Constants](#_new_enum_constants_179)
- [New_Enum_Constants](#_new_enum_constants_179)
- [Version History](#_version_history_179)
- [VK_ANDROID_external_memory_android_hardware_buffer](#VK_ANDROID_external_memory_android_hardware_buffer)
- [Other Extension Metadata](#_other_extension_metadata_179)
- [Other_Extension_Metadata](#_other_extension_metadata_179)
- [Description](#_description_179)
- [New Base Types](#_new_base_types_4)
- [New_Base_Types](#_new_base_types_4)
- [New Commands](#_new_commands_76)
- [New Structures](#_new_structures_161)
- [New Enum Constants](#_new_enum_constants_180)
- [New_Enum_Constants](#_new_enum_constants_180)
- [Issues](#_issues_79)
- [Version History](#_version_history_180)
- [VK_ARM_format_pack](#VK_ARM_format_pack)
- [Other Extension Metadata](#_other_extension_metadata_180)
- [Other_Extension_Metadata](#_other_extension_metadata_180)
- [Description](#_description_180)
- [New Structures](#_new_structures_162)
- [New Enum Constants](#_new_enum_constants_181)
- [New_Enum_Constants](#_new_enum_constants_181)
- [Issues](#_issues_80)
- [What do we call this extension?](#_what_do_we_call_this_extension)
- [What_do_we_call_this_extension?](#_what_do_we_call_this_extension)
- [Compatibility classes](#_compatibility_classes)
- [Format feature requirements](#_format_feature_requirements)
- [Format_feature_requirements](#_format_feature_requirements)
- [Version History](#_version_history_181)
- [VK_ARM_pipeline_opacity_micromap](#VK_ARM_pipeline_opacity_micromap)
- [Other Extension Metadata](#_other_extension_metadata_181)
- [Other_Extension_Metadata](#_other_extension_metadata_181)
- [Description](#_description_181)
- [New Structures](#_new_structures_163)
- [New Enum Constants](#_new_enum_constants_182)
- [New_Enum_Constants](#_new_enum_constants_182)
- [Issues](#_issues_81)
- [Examples](#_examples_23)
- [Version History](#_version_history_182)
- [VK_ARM_render_pass_striped](#VK_ARM_render_pass_striped)
- [Other Extension Metadata](#_other_extension_metadata_182)
- [Other_Extension_Metadata](#_other_extension_metadata_182)
- [Description](#_description_182)
- [New Structures](#_new_structures_164)
- [New Enum Constants](#_new_enum_constants_183)
- [New_Enum_Constants](#_new_enum_constants_183)
- [Examples](#_examples_24)
- [Version History](#_version_history_183)
- [VK_ARM_scheduling_controls](#VK_ARM_scheduling_controls)
- [Other Extension Metadata](#_other_extension_metadata_183)
- [Other_Extension_Metadata](#_other_extension_metadata_183)
- [Description](#_description_183)
- [New Structures](#_new_structures_165)
- [New Enums](#_new_enums_53)
- [New Bitmasks](#_new_bitmasks_42)
- [New Enum Constants](#_new_enum_constants_184)
- [New_Enum_Constants](#_new_enum_constants_184)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_20)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_20)
- [Issues](#_issues_82)
- [Version History](#_version_history_184)
- [VK_ARM_shader_core_builtins](#VK_ARM_shader_core_builtins)
- [Other Extension Metadata](#_other_extension_metadata_184)
- [Other_Extension_Metadata](#_other_extension_metadata_184)
- [Description](#_description_184)
- [New Structures](#_new_structures_166)
- [New Enum Constants](#_new_enum_constants_185)
- [New_Enum_Constants](#_new_enum_constants_185)
- [New or Modified Built-In Variables](#_new_or_modified_built_in_variables_5)
- [New_or_Modified_Built-In_Variables](#_new_or_modified_built_in_variables_5)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_21)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_21)
- [Issues](#_issues_83)
- [Version History](#_version_history_185)
- [VK_ARM_shader_core_properties](#VK_ARM_shader_core_properties)
- [Other Extension Metadata](#_other_extension_metadata_185)
- [Other_Extension_Metadata](#_other_extension_metadata_185)
- [Description](#_description_185)
- [New Structures](#_new_structures_167)
- [New Enum Constants](#_new_enum_constants_186)
- [New_Enum_Constants](#_new_enum_constants_186)
- [Version History](#_version_history_186)
- [VK_FUCHSIA_buffer_collection](#VK_FUCHSIA_buffer_collection)
- [Other Extension Metadata](#_other_extension_metadata_186)
- [Other_Extension_Metadata](#_other_extension_metadata_186)
- [Description](#_description_186)
- [New Object Types](#_new_object_types_13)
- [New_Object_Types](#_new_object_types_13)
- [New Commands](#_new_commands_77)
- [New Structures](#_new_structures_168)
- [New Enums](#_new_enums_54)
- [New Bitmasks](#_new_bitmasks_43)
- [New Enum Constants](#_new_enum_constants_187)
- [New_Enum_Constants](#_new_enum_constants_187)
- [Issues](#_issues_84)
- [Version History](#_version_history_187)
- [VK_FUCHSIA_external_memory](#VK_FUCHSIA_external_memory)
- [Other Extension Metadata](#_other_extension_metadata_187)
- [Other_Extension_Metadata](#_other_extension_metadata_187)
- [Description](#_description_187)
- [New Commands](#_new_commands_78)
- [New Structures](#_new_structures_169)
- [New Enum Constants](#_new_enum_constants_188)
- [New_Enum_Constants](#_new_enum_constants_188)
- [Issues](#_issues_85)
- [Version History](#_version_history_188)
- [VK_FUCHSIA_external_semaphore](#VK_FUCHSIA_external_semaphore)
- [Other Extension Metadata](#_other_extension_metadata_188)
- [Other_Extension_Metadata](#_other_extension_metadata_188)
- [Description](#_description_188)
- [New Commands](#_new_commands_79)
- [New Structures](#_new_structures_170)
- [New Enum Constants](#_new_enum_constants_189)
- [New_Enum_Constants](#_new_enum_constants_189)
- [Issues](#_issues_86)
- [Version History](#_version_history_189)
- [VK_FUCHSIA_imagepipe_surface](#VK_FUCHSIA_imagepipe_surface)
- [Other Extension Metadata](#_other_extension_metadata_189)
- [Other_Extension_Metadata](#_other_extension_metadata_189)
- [Description](#_description_189)
- [New Commands](#_new_commands_80)
- [New Structures](#_new_structures_171)
- [New Bitmasks](#_new_bitmasks_44)
- [New Enum Constants](#_new_enum_constants_190)
- [New_Enum_Constants](#_new_enum_constants_190)
- [Version History](#_version_history_190)
- [VK_GGP_frame_token](#VK_GGP_frame_token)
- [Other Extension Metadata](#_other_extension_metadata_190)
- [Other_Extension_Metadata](#_other_extension_metadata_190)
- [Description](#_description_190)
- [New Structures](#_new_structures_172)
- [New Enum Constants](#_new_enum_constants_191)
- [New_Enum_Constants](#_new_enum_constants_191)
- [Version History](#_version_history_191)
- [VK_GGP_stream_descriptor_surface](#VK_GGP_stream_descriptor_surface)
- [Other Extension Metadata](#_other_extension_metadata_191)
- [Other_Extension_Metadata](#_other_extension_metadata_191)
- [Description](#_description_191)
- [New Commands](#_new_commands_81)
- [New Structures](#_new_structures_173)
- [New Bitmasks](#_new_bitmasks_45)
- [New Enum Constants](#_new_enum_constants_192)
- [New_Enum_Constants](#_new_enum_constants_192)
- [Version History](#_version_history_192)
- [VK_GOOGLE_decorate_string](#VK_GOOGLE_decorate_string)
- [Other Extension Metadata](#_other_extension_metadata_192)
- [Other_Extension_Metadata](#_other_extension_metadata_192)
- [Description](#_description_192)
- [New Enum Constants](#_new_enum_constants_193)
- [New_Enum_Constants](#_new_enum_constants_193)
- [Version History](#_version_history_193)
- [VK_GOOGLE_display_timing](#VK_GOOGLE_display_timing)
- [Other Extension Metadata](#_other_extension_metadata_193)
- [Other_Extension_Metadata](#_other_extension_metadata_193)
- [Description](#_description_193)
- [New Commands](#_new_commands_82)
- [New Structures](#_new_structures_174)
- [New Enum Constants](#_new_enum_constants_194)
- [New_Enum_Constants](#_new_enum_constants_194)
- [Examples](#_examples_25)
- [Version History](#_version_history_194)
- [VK_GOOGLE_hlsl_functionality1](#VK_GOOGLE_hlsl_functionality1)
- [Other Extension Metadata](#_other_extension_metadata_194)
- [Other_Extension_Metadata](#_other_extension_metadata_194)
- [Description](#_description_194)
- [New Enum Constants](#_new_enum_constants_195)
- [New_Enum_Constants](#_new_enum_constants_195)
- [Version History](#_version_history_195)
- [VK_GOOGLE_surfaceless_query](#VK_GOOGLE_surfaceless_query)
- [Other Extension Metadata](#_other_extension_metadata_195)
- [Other_Extension_Metadata](#_other_extension_metadata_195)
- [Description](#_description_195)
- [New Enum Constants](#_new_enum_constants_196)
- [New_Enum_Constants](#_new_enum_constants_196)
- [Version History](#_version_history_196)
- [VK_GOOGLE_user_type](#VK_GOOGLE_user_type)
- [Other Extension Metadata](#_other_extension_metadata_196)
- [Other_Extension_Metadata](#_other_extension_metadata_196)
- [Description](#_description_196)
- [New Enum Constants](#_new_enum_constants_197)
- [New_Enum_Constants](#_new_enum_constants_197)
- [Version History](#_version_history_197)
- [VK_HUAWEI_cluster_culling_shader](#VK_HUAWEI_cluster_culling_shader)
- [Other Extension Metadata](#_other_extension_metadata_197)
- [Other_Extension_Metadata](#_other_extension_metadata_197)
- [Description](#_description_197)
- [New Commands](#_new_commands_83)
- [New Structures](#_new_structures_175)
- [New Enum Constants](#_new_enum_constants_198)
- [New_Enum_Constants](#_new_enum_constants_198)
- [New Built-In Variables](#_new_built_in_variables_5)
- [New_Built-In_Variables](#_new_built_in_variables_5)
- [New SPIR-V Capability](#_new_spir_v_capability_3)
- [New_SPIR-V_Capability](#_new_spir_v_capability_3)
- [Sample Code](#_sample_code_3)
- [Version History](#_version_history_198)
- [VK_HUAWEI_hdr_vivid](#VK_HUAWEI_hdr_vivid)
- [Other Extension Metadata](#_other_extension_metadata_198)
- [Other_Extension_Metadata](#_other_extension_metadata_198)
- [Description](#_description_198)
- [New Structures](#_new_structures_176)
- [New Enum Constants](#_new_enum_constants_199)
- [New_Enum_Constants](#_new_enum_constants_199)
- [Version History](#_version_history_199)
- [VK_HUAWEI_invocation_mask](#VK_HUAWEI_invocation_mask)
- [Other Extension Metadata](#_other_extension_metadata_199)
- [Other_Extension_Metadata](#_other_extension_metadata_199)
- [Description](#_description_199)
- [New Commands](#_new_commands_84)
- [New Structures](#_new_structures_177)
- [New Enum Constants](#_new_enum_constants_200)
- [New_Enum_Constants](#_new_enum_constants_200)
- [Examples](#_examples_26)
- [Version History](#_version_history_200)
- [VK_HUAWEI_subpass_shading](#VK_HUAWEI_subpass_shading)
- [Other Extension Metadata](#_other_extension_metadata_200)
- [Other_Extension_Metadata](#_other_extension_metadata_200)
- [Description](#_description_200)
- [New Commands](#_new_commands_85)
- [New Structures](#_new_structures_178)
- [New Enum Constants](#_new_enum_constants_201)
- [New_Enum_Constants](#_new_enum_constants_201)
- [Sample Code](#_sample_code_4)
- [Version History](#_version_history_201)
- [VK_IMG_filter_cubic](#VK_IMG_filter_cubic)
- [Other Extension Metadata](#_other_extension_metadata_201)
- [Other_Extension_Metadata](#_other_extension_metadata_201)
- [Description](#_description_201)
- [New Enum Constants](#_new_enum_constants_202)
- [New_Enum_Constants](#_new_enum_constants_202)
- [Example](#_example_3)
- [Version History](#_version_history_202)
- [VK_IMG_relaxed_line_rasterization](#VK_IMG_relaxed_line_rasterization)
- [Other Extension Metadata](#_other_extension_metadata_202)
- [Other_Extension_Metadata](#_other_extension_metadata_202)
- [Description](#_description_202)
- [New Structures](#_new_structures_179)
- [New Enum Constants](#_new_enum_constants_203)
- [New_Enum_Constants](#_new_enum_constants_203)
- [Issues](#_issues_87)
- [Version History](#_version_history_203)
- [VK_INTEL_performance_query](#VK_INTEL_performance_query)
- [Other Extension Metadata](#_other_extension_metadata_203)
- [Other_Extension_Metadata](#_other_extension_metadata_203)
- [Description](#_description_203)
- [New Object Types](#_new_object_types_14)
- [New_Object_Types](#_new_object_types_14)
- [New Commands](#_new_commands_86)
- [New Structures](#_new_structures_180)
- [New Unions](#_new_unions_6)
- [New Enums](#_new_enums_55)
- [New Enum Constants](#_new_enum_constants_204)
- [New_Enum_Constants](#_new_enum_constants_204)
- [Example Code](#_example_code_2)
- [Version History](#_version_history_204)
- [VK_INTEL_shader_integer_functions2](#VK_INTEL_shader_integer_functions2)
- [Other Extension Metadata](#_other_extension_metadata_204)
- [Other_Extension_Metadata](#_other_extension_metadata_204)
- [Description](#_description_204)
- [New Structures](#_new_structures_181)
- [New Enum Constants](#_new_enum_constants_205)
- [New_Enum_Constants](#_new_enum_constants_205)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_22)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_22)
- [Version History](#_version_history_205)
- [VK_LUNARG_direct_driver_loading](#VK_LUNARG_direct_driver_loading)
- [Other Extension Metadata](#_other_extension_metadata_205)
- [Other_Extension_Metadata](#_other_extension_metadata_205)
- [Description](#_description_205)
- [New Structures](#_new_structures_182)
- [New Function Pointers](#_new_function_pointers_3)
- [New_Function_Pointers](#_new_function_pointers_3)
- [New Enums](#_new_enums_56)
- [New Bitmasks](#_new_bitmasks_46)
- [New Enum Constants](#_new_enum_constants_206)
- [New_Enum_Constants](#_new_enum_constants_206)
- [Version History](#_version_history_206)
- [VK_MESA_image_alignment_control](#VK_MESA_image_alignment_control)
- [Other Extension Metadata](#_other_extension_metadata_206)
- [Other_Extension_Metadata](#_other_extension_metadata_206)
- [Description](#_description_206)
- [New Structures](#_new_structures_183)
- [New Enum Constants](#_new_enum_constants_207)
- [New_Enum_Constants](#_new_enum_constants_207)
- [Version History](#_version_history_207)
- [VK_MSFT_layered_driver](#VK_MSFT_layered_driver)
- [Other Extension Metadata](#_other_extension_metadata_207)
- [Other_Extension_Metadata](#_other_extension_metadata_207)
- [Description](#_description_207)
- [New Structures](#_new_structures_184)
- [New Enums](#_new_enums_57)
- [New Enum Constants](#_new_enum_constants_208)
- [New_Enum_Constants](#_new_enum_constants_208)
- [Examples](#_examples_27)
- [Version History](#_version_history_208)
- [VK_NN_vi_surface](#VK_NN_vi_surface)
- [Other Extension Metadata](#_other_extension_metadata_208)
- [Other_Extension_Metadata](#_other_extension_metadata_208)
- [Description](#_description_208)
- [New Commands](#_new_commands_87)
- [New Structures](#_new_structures_185)
- [New Bitmasks](#_new_bitmasks_47)
- [New Enum Constants](#_new_enum_constants_209)
- [New_Enum_Constants](#_new_enum_constants_209)
- [Issues](#_issues_88)
- [Version History](#_version_history_209)
- [VK_NV_acquire_winrt_display](#VK_NV_acquire_winrt_display)
- [Other Extension Metadata](#_other_extension_metadata_209)
- [Other_Extension_Metadata](#_other_extension_metadata_209)
- [Description](#_description_209)
- [New Commands](#_new_commands_88)
- [New Enum Constants](#_new_enum_constants_210)
- [New_Enum_Constants](#_new_enum_constants_210)
- [Issues](#_issues_89)
- [Version History](#_version_history_210)
- [VK_NV_clip_space_w_scaling](#VK_NV_clip_space_w_scaling)
- [Other Extension Metadata](#_other_extension_metadata_210)
- [Other_Extension_Metadata](#_other_extension_metadata_210)
- [Description](#_description_210)
- [New Commands](#_new_commands_89)
- [New Structures](#_new_structures_186)
- [New Enum Constants](#_new_enum_constants_211)
- [New_Enum_Constants](#_new_enum_constants_211)
- [Issues](#_issues_90)
- [Examples](#_examples_28)
- [Version History](#_version_history_211)
- [VK_NV_cluster_acceleration_structure](#VK_NV_cluster_acceleration_structure)
- [Other Extension Metadata](#_other_extension_metadata_211)
- [Other_Extension_Metadata](#_other_extension_metadata_211)
- [Description](#_description_211)
- [New Commands](#_new_commands_90)
- [New Structures](#_new_structures_187)
- [New Unions](#_new_unions_7)
- [New Enums](#_new_enums_58)
- [New Bitmasks](#_new_bitmasks_48)
- [New Enum Constants](#_new_enum_constants_212)
- [New_Enum_Constants](#_new_enum_constants_212)
- [New or Modified Built-In Variables](#_new_or_modified_built_in_variables_6)
- [New_or_Modified_Built-In_Variables](#_new_or_modified_built_in_variables_6)
- [New SPIR-V Capability](#_new_spir_v_capability_4)
- [New_SPIR-V_Capability](#_new_spir_v_capability_4)
- [Version History](#_version_history_212)
- [VK_NV_command_buffer_inheritance](#VK_NV_command_buffer_inheritance)
- [Other Extension Metadata](#_other_extension_metadata_212)
- [Other_Extension_Metadata](#_other_extension_metadata_212)
- [Description](#_description_212)
- [New Structures](#_new_structures_188)
- [New Enum Constants](#_new_enum_constants_213)
- [New_Enum_Constants](#_new_enum_constants_213)
- [Issues](#_issues_91)
- [Version History](#_version_history_213)
- [VK_NV_cooperative_matrix](#VK_NV_cooperative_matrix)
- [Other Extension Metadata](#_other_extension_metadata_213)
- [Other_Extension_Metadata](#_other_extension_metadata_213)
- [Description](#_description_213)
- [New Commands](#_new_commands_91)
- [New Structures](#_new_structures_189)
- [New Enums](#_new_enums_59)
- [New Enum Constants](#_new_enum_constants_214)
- [New_Enum_Constants](#_new_enum_constants_214)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_23)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_23)
- [Issues](#_issues_92)
- [Version History](#_version_history_214)
- [VK_NV_cooperative_matrix2](#VK_NV_cooperative_matrix2)
- [Other Extension Metadata](#_other_extension_metadata_214)
- [Other_Extension_Metadata](#_other_extension_metadata_214)
- [Description](#_description_214)
- [New Commands](#_new_commands_92)
- [New Structures](#_new_structures_190)
- [New Enum Constants](#_new_enum_constants_215)
- [New_Enum_Constants](#_new_enum_constants_215)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_24)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_24)
- [Issues](#_issues_93)
- [Version History](#_version_history_215)
- [VK_NV_cooperative_vector](#VK_NV_cooperative_vector)
- [Other Extension Metadata](#_other_extension_metadata_215)
- [Other_Extension_Metadata](#_other_extension_metadata_215)
- [Description](#_description_215)
- [New Commands](#_new_commands_93)
- [New Structures](#_new_structures_191)
- [New Unions](#_new_unions_8)
- [New Enums](#_new_enums_60)
- [New Enum Constants](#_new_enum_constants_216)
- [New_Enum_Constants](#_new_enum_constants_216)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_25)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_25)
- [Issues](#_issues_94)
- [Version History](#_version_history_216)
- [VK_NV_copy_memory_indirect](#VK_NV_copy_memory_indirect)
- [Other Extension Metadata](#_other_extension_metadata_216)
- [Other_Extension_Metadata](#_other_extension_metadata_216)
- [Description](#_description_216)
- [New Commands](#_new_commands_94)
- [New Structures](#_new_structures_192)
- [New Enum Constants](#_new_enum_constants_217)
- [New_Enum_Constants](#_new_enum_constants_217)
- [Version History](#_version_history_217)
- [VK_NV_corner_sampled_image](#VK_NV_corner_sampled_image)
- [Other Extension Metadata](#_other_extension_metadata_217)
- [Other_Extension_Metadata](#_other_extension_metadata_217)
- [Description](#_description_217)
- [New Structures](#_new_structures_193)
- [New Enum Constants](#_new_enum_constants_218)
- [New_Enum_Constants](#_new_enum_constants_218)
- [Issues](#_issues_95)
- [Version History](#_version_history_218)
- [VK_NV_coverage_reduction_mode](#VK_NV_coverage_reduction_mode)
- [Other Extension Metadata](#_other_extension_metadata_218)
- [Other_Extension_Metadata](#_other_extension_metadata_218)
- [Description](#_description_218)
- [New Commands](#_new_commands_95)
- [New Structures](#_new_structures_194)
- [New Enums](#_new_enums_61)
- [New Bitmasks](#_new_bitmasks_49)
- [New Enum Constants](#_new_enum_constants_219)
- [New_Enum_Constants](#_new_enum_constants_219)
- [Version History](#_version_history_219)
- [VK_NV_dedicated_allocation_image_aliasing](#VK_NV_dedicated_allocation_image_aliasing)
- [Other Extension Metadata](#_other_extension_metadata_219)
- [Other_Extension_Metadata](#_other_extension_metadata_219)
- [Description](#_description_219)
- [New Structures](#_new_structures_195)
- [New Enum Constants](#_new_enum_constants_220)
- [New_Enum_Constants](#_new_enum_constants_220)
- [Version History](#_version_history_220)
- [VK_NV_descriptor_pool_overallocation](#VK_NV_descriptor_pool_overallocation)
- [Other Extension Metadata](#_other_extension_metadata_220)
- [Other_Extension_Metadata](#_other_extension_metadata_220)
- [Description](#_description_220)
- [New Structures](#_new_structures_196)
- [New Enum Constants](#_new_enum_constants_221)
- [New_Enum_Constants](#_new_enum_constants_221)
- [Version History](#_version_history_221)
- [VK_NV_device_diagnostic_checkpoints](#VK_NV_device_diagnostic_checkpoints)
- [Other Extension Metadata](#_other_extension_metadata_221)
- [Other_Extension_Metadata](#_other_extension_metadata_221)
- [Description](#_description_221)
- [New Commands](#_new_commands_96)
- [New Structures](#_new_structures_197)
- [New Enum Constants](#_new_enum_constants_222)
- [New_Enum_Constants](#_new_enum_constants_222)
- [Version History](#_version_history_222)
- [VK_NV_device_diagnostics_config](#VK_NV_device_diagnostics_config)
- [Other Extension Metadata](#_other_extension_metadata_222)
- [Other_Extension_Metadata](#_other_extension_metadata_222)
- [Description](#_description_222)
- [New Structures](#_new_structures_198)
- [New Enums](#_new_enums_62)
- [New Bitmasks](#_new_bitmasks_50)
- [New Enum Constants](#_new_enum_constants_223)
- [New_Enum_Constants](#_new_enum_constants_223)
- [Version History](#_version_history_223)
- [VK_NV_device_generated_commands](#VK_NV_device_generated_commands)
- [Other Extension Metadata](#_other_extension_metadata_223)
- [Other_Extension_Metadata](#_other_extension_metadata_223)
- [Description](#_description_223)
- [New Object Types](#_new_object_types_15)
- [New_Object_Types](#_new_object_types_15)
- [New Commands](#_new_commands_97)
- [New Structures](#_new_structures_199)
- [New Enums](#_new_enums_63)
- [New Bitmasks](#_new_bitmasks_51)
- [New Enum Constants](#_new_enum_constants_224)
- [New_Enum_Constants](#_new_enum_constants_224)
- [Issues](#_issues_96)
- [Example Code](#_example_code_3)
- [Version History](#_version_history_224)
- [VK_NV_device_generated_commands_compute](#VK_NV_device_generated_commands_compute)
- [Other Extension Metadata](#_other_extension_metadata_224)
- [Other_Extension_Metadata](#_other_extension_metadata_224)
- [Description](#_description_224)
- [New Commands](#_new_commands_98)
- [New Structures](#_new_structures_200)
- [New Enum Constants](#_new_enum_constants_225)
- [New_Enum_Constants](#_new_enum_constants_225)
- [Version History](#_version_history_225)
- [VK_NV_display_stereo](#VK_NV_display_stereo)
- [Other Extension Metadata](#_other_extension_metadata_225)
- [Other_Extension_Metadata](#_other_extension_metadata_225)
- [Description](#_description_225)
- [New Structures](#_new_structures_201)
- [New Enums](#_new_enums_64)
- [New Enum Constants](#_new_enum_constants_226)
- [New_Enum_Constants](#_new_enum_constants_226)
- [Version History](#_version_history_226)
- [VK_NV_extended_sparse_address_space](#VK_NV_extended_sparse_address_space)
- [Other Extension Metadata](#_other_extension_metadata_226)
- [Other_Extension_Metadata](#_other_extension_metadata_226)
- [Description](#_description_226)
- [New Structures](#_new_structures_202)
- [New Enum Constants](#_new_enum_constants_227)
- [New_Enum_Constants](#_new_enum_constants_227)
- [Version History](#_version_history_227)
- [VK_NV_external_compute_queue](#VK_NV_external_compute_queue)
- [Other Extension Metadata](#_other_extension_metadata_227)
- [Other_Extension_Metadata](#_other_extension_metadata_227)
- [Description](#_description_227)
- [New Object Types](#_new_object_types_16)
- [New_Object_Types](#_new_object_types_16)
- [New Commands](#_new_commands_99)
- [New Structures](#_new_structures_203)
- [New Enum Constants](#_new_enum_constants_228)
- [New_Enum_Constants](#_new_enum_constants_228)
- [Issues](#_issues_97)
- [Version History](#_version_history_228)
- [VK_NV_external_memory_rdma](#VK_NV_external_memory_rdma)
- [Other Extension Metadata](#_other_extension_metadata_228)
- [Other_Extension_Metadata](#_other_extension_metadata_228)
- [Description](#_description_228)
- [New Base Types](#_new_base_types_5)
- [New_Base_Types](#_new_base_types_5)
- [New Commands](#_new_commands_100)
- [New Structures](#_new_structures_204)
- [New Enum Constants](#_new_enum_constants_229)
- [New_Enum_Constants](#_new_enum_constants_229)
- [Issues](#_issues_98)
- [Examples](#_examples_29)
- [Version History](#_version_history_229)
- [VK_NV_fill_rectangle](#VK_NV_fill_rectangle)
- [Other Extension Metadata](#_other_extension_metadata_229)
- [Other_Extension_Metadata](#_other_extension_metadata_229)
- [Description](#_description_229)
- [New Enum Constants](#_new_enum_constants_230)
- [New_Enum_Constants](#_new_enum_constants_230)
- [Version History](#_version_history_230)
- [VK_NV_fragment_coverage_to_color](#VK_NV_fragment_coverage_to_color)
- [Other Extension Metadata](#_other_extension_metadata_230)
- [Other_Extension_Metadata](#_other_extension_metadata_230)
- [Description](#_description_230)
- [New Structures](#_new_structures_205)
- [New Bitmasks](#_new_bitmasks_52)
- [New Enum Constants](#_new_enum_constants_231)
- [New_Enum_Constants](#_new_enum_constants_231)
- [Version History](#_version_history_231)
- [VK_NV_fragment_shading_rate_enums](#VK_NV_fragment_shading_rate_enums)
- [Other Extension Metadata](#_other_extension_metadata_231)
- [Other_Extension_Metadata](#_other_extension_metadata_231)
- [Description](#_description_231)
- [New Commands](#_new_commands_101)
- [New Structures](#_new_structures_206)
- [New Enums](#_new_enums_65)
- [New Enum Constants](#_new_enum_constants_232)
- [New_Enum_Constants](#_new_enum_constants_232)
- [Issues](#_issues_99)
- [Version History](#_version_history_232)
- [VK_NV_framebuffer_mixed_samples](#VK_NV_framebuffer_mixed_samples)
- [Other Extension Metadata](#_other_extension_metadata_232)
- [Other_Extension_Metadata](#_other_extension_metadata_232)
- [Description](#_description_232)
- [New Structures](#_new_structures_207)
- [New Enums](#_new_enums_66)
- [New Bitmasks](#_new_bitmasks_53)
- [New Enum Constants](#_new_enum_constants_233)
- [New_Enum_Constants](#_new_enum_constants_233)
- [Version History](#_version_history_233)
- [VK_NV_geometry_shader_passthrough](#VK_NV_geometry_shader_passthrough)
- [Other Extension Metadata](#_other_extension_metadata_233)
- [Other_Extension_Metadata](#_other_extension_metadata_233)
- [Description](#_description_233)
- [New Enum Constants](#_new_enum_constants_234)
- [New_Enum_Constants](#_new_enum_constants_234)
- [New Variable Decoration](#_new_variable_decoration)
- [New_Variable_Decoration](#_new_variable_decoration)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_26)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_26)
- [Issues](#_issues_100)
- [Sample Code](#_sample_code_5)
- [Version History](#_version_history_234)
- [VK_NV_inherited_viewport_scissor](#VK_NV_inherited_viewport_scissor)
- [Other Extension Metadata](#_other_extension_metadata_234)
- [Other_Extension_Metadata](#_other_extension_metadata_234)
- [Description](#_description_234)
- [New Structures](#_new_structures_208)
- [New Enum Constants](#_new_enum_constants_235)
- [New_Enum_Constants](#_new_enum_constants_235)
- [Issues](#_issues_101)
- [Version History](#_version_history_235)
- [VK_NV_linear_color_attachment](#VK_NV_linear_color_attachment)
- [Other Extension Metadata](#_other_extension_metadata_235)
- [Other_Extension_Metadata](#_other_extension_metadata_235)
- [Description](#_description_235)
- [New Structures](#_new_structures_209)
- [New Enum Constants](#_new_enum_constants_236)
- [New_Enum_Constants](#_new_enum_constants_236)
- [Version History](#_version_history_236)
- [VK_NV_low_latency](#VK_NV_low_latency)
- [Other Extension Metadata](#_other_extension_metadata_236)
- [Other_Extension_Metadata](#_other_extension_metadata_236)
- [Description](#_description_236)
- [New Structures](#_new_structures_210)
- [New Enum Constants](#_new_enum_constants_237)
- [New_Enum_Constants](#_new_enum_constants_237)
- [Issues](#_issues_102)
- [Version History](#_version_history_237)
- [VK_NV_low_latency2](#VK_NV_low_latency2)
- [Other Extension Metadata](#_other_extension_metadata_237)
- [Other_Extension_Metadata](#_other_extension_metadata_237)
- [New Commands](#_new_commands_102)
- [New Structures](#_new_structures_211)
- [New Enums](#_new_enums_67)
- [New Enum Constants](#_new_enum_constants_238)
- [New_Enum_Constants](#_new_enum_constants_238)
- [Description](#_description_237)
- [Issues](#_issues_103)
- [Version History](#_version_history_238)
- [VK_NV_memory_decompression](#VK_NV_memory_decompression)
- [Other Extension Metadata](#_other_extension_metadata_238)
- [Other_Extension_Metadata](#_other_extension_metadata_238)
- [Description](#_description_238)
- [New Commands](#_new_commands_103)
- [New Structures](#_new_structures_212)
- [New Enums](#_new_enums_68)
- [New Bitmasks](#_new_bitmasks_54)
- [New Enum Constants](#_new_enum_constants_239)
- [New_Enum_Constants](#_new_enum_constants_239)
- [Version History](#_version_history_239)
- [VK_NV_mesh_shader](#VK_NV_mesh_shader)
- [Other Extension Metadata](#_other_extension_metadata_239)
- [Other_Extension_Metadata](#_other_extension_metadata_239)
- [Description](#_description_239)
- [New Commands](#_new_commands_104)
- [New Structures](#_new_structures_213)
- [New Enum Constants](#_new_enum_constants_240)
- [New_Enum_Constants](#_new_enum_constants_240)
- [New or Modified Built-In Variables](#_new_or_modified_built_in_variables_7)
- [New_or_Modified_Built-In_Variables](#_new_or_modified_built_in_variables_7)
- [New SPIR-V Capability](#_new_spir_v_capability_5)
- [New_SPIR-V_Capability](#_new_spir_v_capability_5)
- [Issues](#_issues_104)
- [Version History](#_version_history_240)
- [VK_NV_optical_flow](#VK_NV_optical_flow)
- [Other Extension Metadata](#_other_extension_metadata_240)
- [Other_Extension_Metadata](#_other_extension_metadata_240)
- [Description](#_description_240)
- [New Object Types](#_new_object_types_17)
- [New_Object_Types](#_new_object_types_17)
- [New Commands](#_new_commands_105)
- [New Structures](#_new_structures_214)
- [New Enums](#_new_enums_69)
- [New Bitmasks](#_new_bitmasks_55)
- [New Enum Constants](#_new_enum_constants_241)
- [New_Enum_Constants](#_new_enum_constants_241)
- [Examples](#_examples_30)
- [Version History](#_version_history_241)
- [VK_NV_partitioned_acceleration_structure](#VK_NV_partitioned_acceleration_structure)
- [Other Extension Metadata](#_other_extension_metadata_241)
- [Other_Extension_Metadata](#_other_extension_metadata_241)
- [Description](#_description_241)
- [New Commands](#_new_commands_106)
- [New Structures](#_new_structures_215)
- [New Enums](#_new_enums_70)
- [New Bitmasks](#_new_bitmasks_56)
- [New Enum Constants](#_new_enum_constants_242)
- [New_Enum_Constants](#_new_enum_constants_242)
- [Version History](#_version_history_242)
- [VK_NV_per_stage_descriptor_set](#VK_NV_per_stage_descriptor_set)
- [Other Extension Metadata](#_other_extension_metadata_242)
- [Other_Extension_Metadata](#_other_extension_metadata_242)
- [Description](#_description_242)
- [New Structures](#_new_structures_216)
- [New Enum Constants](#_new_enum_constants_243)
- [New_Enum_Constants](#_new_enum_constants_243)
- [Issues](#_issues_105)
- [Version History](#_version_history_243)
- [VK_NV_present_barrier](#VK_NV_present_barrier)
- [Other Extension Metadata](#_other_extension_metadata_243)
- [Other_Extension_Metadata](#_other_extension_metadata_243)
- [Description](#_description_243)
- [New Structures](#_new_structures_217)
- [New Enum Constants](#_new_enum_constants_244)
- [New_Enum_Constants](#_new_enum_constants_244)
- [Issues](#_issues_106)
- [Version History](#_version_history_244)
- [VK_NV_raw_access_chains](#VK_NV_raw_access_chains)
- [Other Extension Metadata](#_other_extension_metadata_244)
- [Other_Extension_Metadata](#_other_extension_metadata_244)
- [Description](#_description_244)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_27)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_27)
- [Version History](#_version_history_245)
- [VK_NV_ray_tracing_invocation_reorder](#VK_NV_ray_tracing_invocation_reorder)
- [Other Extension Metadata](#_other_extension_metadata_245)
- [Other_Extension_Metadata](#_other_extension_metadata_245)
- [Description](#_description_245)
- [New Structures](#_new_structures_218)
- [New Enums](#_new_enums_71)
- [New Enum Constants](#_new_enum_constants_245)
- [New_Enum_Constants](#_new_enum_constants_245)
- [HLSL Mapping](#_hlsl_mapping)
- [Version History](#_version_history_246)
- [VK_NV_ray_tracing_linear_swept_spheres](#VK_NV_ray_tracing_linear_swept_spheres)
- [Other Extension Metadata](#_other_extension_metadata_246)
- [Other_Extension_Metadata](#_other_extension_metadata_246)
- [Description](#_description_246)
- [New Structures](#_new_structures_219)
- [New Enums](#_new_enums_72)
- [New Enum Constants](#_new_enum_constants_246)
- [New_Enum_Constants](#_new_enum_constants_246)
- [New or Modified Built-In Variables](#_new_or_modified_built_in_variables_8)
- [New_or_Modified_Built-In_Variables](#_new_or_modified_built_in_variables_8)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_28)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_28)
- [Version History](#_version_history_247)
- [VK_NV_ray_tracing_motion_blur](#VK_NV_ray_tracing_motion_blur)
- [Other Extension Metadata](#_other_extension_metadata_247)
- [Other_Extension_Metadata](#_other_extension_metadata_247)
- [Description](#_description_247)
- [New Structures](#_new_structures_220)
- [New Unions](#_new_unions_9)
- [New Enums](#_new_enums_73)
- [New Bitmasks](#_new_bitmasks_57)
- [New Enum Constants](#_new_enum_constants_247)
- [New_Enum_Constants](#_new_enum_constants_247)
- [Issues](#_issues_107)
- [Version History](#_version_history_248)
- [VK_NV_ray_tracing_validation](#VK_NV_ray_tracing_validation)
- [Other Extension Metadata](#_other_extension_metadata_248)
- [Other_Extension_Metadata](#_other_extension_metadata_248)
- [Description](#_description_248)
- [New Structures](#_new_structures_221)
- [New Enum Constants](#_new_enum_constants_248)
- [New_Enum_Constants](#_new_enum_constants_248)
- [Version History](#_version_history_249)
- [VK_NV_representative_fragment_test](#VK_NV_representative_fragment_test)
- [Other Extension Metadata](#_other_extension_metadata_249)
- [Other_Extension_Metadata](#_other_extension_metadata_249)
- [Description](#_description_249)
- [New Structures](#_new_structures_222)
- [New Enum Constants](#_new_enum_constants_249)
- [New_Enum_Constants](#_new_enum_constants_249)
- [Issues](#_issues_108)
- [Version History](#_version_history_250)
- [VK_NV_sample_mask_override_coverage](#VK_NV_sample_mask_override_coverage)
- [Other Extension Metadata](#_other_extension_metadata_250)
- [Other_Extension_Metadata](#_other_extension_metadata_250)
- [Description](#_description_250)
- [New Enum Constants](#_new_enum_constants_250)
- [New_Enum_Constants](#_new_enum_constants_250)
- [New Variable Decoration](#_new_variable_decoration_2)
- [New_Variable_Decoration](#_new_variable_decoration_2)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_29)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_29)
- [Version History](#_version_history_251)
- [VK_NV_scissor_exclusive](#VK_NV_scissor_exclusive)
- [Other Extension Metadata](#_other_extension_metadata_251)
- [Other_Extension_Metadata](#_other_extension_metadata_251)
- [Description](#_description_251)
- [New Commands](#_new_commands_107)
- [New Structures](#_new_structures_223)
- [New Enum Constants](#_new_enum_constants_251)
- [New_Enum_Constants](#_new_enum_constants_251)
- [Issues](#_issues_109)
- [Version History](#_version_history_252)
- [VK_NV_shader_atomic_float16_vector](#VK_NV_shader_atomic_float16_vector)
- [Other Extension Metadata](#_other_extension_metadata_252)
- [Other_Extension_Metadata](#_other_extension_metadata_252)
- [Description](#_description_252)
- [New Structures](#_new_structures_224)
- [New Enum Constants](#_new_enum_constants_252)
- [New_Enum_Constants](#_new_enum_constants_252)
- [Issues](#_issues_110)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_30)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_30)
- [Version History](#_version_history_253)
- [VK_NV_shader_image_footprint](#VK_NV_shader_image_footprint)
- [Other Extension Metadata](#_other_extension_metadata_253)
- [Other_Extension_Metadata](#_other_extension_metadata_253)
- [Description](#_description_253)
- [New Structures](#_new_structures_225)
- [New Enum Constants](#_new_enum_constants_253)
- [New_Enum_Constants](#_new_enum_constants_253)
- [New SPIR-V Capability](#_new_spir_v_capability_6)
- [New_SPIR-V_Capability](#_new_spir_v_capability_6)
- [Issues](#_issues_111)
- [Examples](#_examples_31)
- [Version History](#_version_history_254)
- [VK_NV_shader_sm_builtins](#VK_NV_shader_sm_builtins)
- [Other Extension Metadata](#_other_extension_metadata_254)
- [Other_Extension_Metadata](#_other_extension_metadata_254)
- [Description](#_description_254)
- [New Structures](#_new_structures_226)
- [New Enum Constants](#_new_enum_constants_254)
- [New_Enum_Constants](#_new_enum_constants_254)
- [New or Modified Built-In Variables](#_new_or_modified_built_in_variables_9)
- [New_or_Modified_Built-In_Variables](#_new_or_modified_built_in_variables_9)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_31)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_31)
- [Issues](#_issues_112)
- [Version History](#_version_history_255)
- [VK_NV_shader_subgroup_partitioned](#VK_NV_shader_subgroup_partitioned)
- [Other Extension Metadata](#_other_extension_metadata_255)
- [Other_Extension_Metadata](#_other_extension_metadata_255)
- [Description](#_description_255)
- [New Enum Constants](#_new_enum_constants_255)
- [New_Enum_Constants](#_new_enum_constants_255)
- [Version History](#_version_history_256)
- [VK_NV_shading_rate_image](#VK_NV_shading_rate_image)
- [Other Extension Metadata](#_other_extension_metadata_256)
- [Other_Extension_Metadata](#_other_extension_metadata_256)
- [Description](#_description_256)
- [New Commands](#_new_commands_108)
- [New Structures](#_new_structures_227)
- [New Enums](#_new_enums_74)
- [New Enum Constants](#_new_enum_constants_256)
- [New_Enum_Constants](#_new_enum_constants_256)
- [Issues](#_issues_113)
- [Version History](#_version_history_257)
- [VK_NV_viewport_array2](#VK_NV_viewport_array2)
- [Other Extension Metadata](#_other_extension_metadata_257)
- [Other_Extension_Metadata](#_other_extension_metadata_257)
- [Description](#_description_257)
- [New Enum Constants](#_new_enum_constants_257)
- [New_Enum_Constants](#_new_enum_constants_257)
- [New or Modified Built-In Variables](#_new_or_modified_built_in_variables_10)
- [New_or_Modified_Built-In_Variables](#_new_or_modified_built_in_variables_10)
- [New Variable Decoration](#_new_variable_decoration_3)
- [New_Variable_Decoration](#_new_variable_decoration_3)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_32)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_32)
- [Version History](#_version_history_258)
- [VK_NV_viewport_swizzle](#VK_NV_viewport_swizzle)
- [Other Extension Metadata](#_other_extension_metadata_258)
- [Other_Extension_Metadata](#_other_extension_metadata_258)
- [Description](#_description_258)
- [New Structures](#_new_structures_228)
- [New Enums](#_new_enums_75)
- [New Bitmasks](#_new_bitmasks_58)
- [New Enum Constants](#_new_enum_constants_258)
- [New_Enum_Constants](#_new_enum_constants_258)
- [Issues](#_issues_114)
- [Version History](#_version_history_259)
- [VK_NVX_binary_import](#VK_NVX_binary_import)
- [Other Extension Metadata](#_other_extension_metadata_259)
- [Other_Extension_Metadata](#_other_extension_metadata_259)
- [Description](#_description_259)
- [New Object Types](#_new_object_types_18)
- [New_Object_Types](#_new_object_types_18)
- [New Commands](#_new_commands_109)
- [New Structures](#_new_structures_229)
- [New Enum Constants](#_new_enum_constants_259)
- [New_Enum_Constants](#_new_enum_constants_259)
- [Stub API References](#_stub_api_references)
- [Stub_API_References](#_stub_api_references)
- [Version History](#_version_history_260)
- [VK_NVX_image_view_handle](#VK_NVX_image_view_handle)
- [Other Extension Metadata](#_other_extension_metadata_260)
- [Other_Extension_Metadata](#_other_extension_metadata_260)
- [Description](#_description_260)
- [New Commands](#_new_commands_110)
- [New Structures](#_new_structures_230)
- [New Enum Constants](#_new_enum_constants_260)
- [New_Enum_Constants](#_new_enum_constants_260)
- [Version History](#_version_history_261)
- [VK_NVX_multiview_per_view_attributes](#VK_NVX_multiview_per_view_attributes)
- [Other Extension Metadata](#_other_extension_metadata_261)
- [Other_Extension_Metadata](#_other_extension_metadata_261)
- [Description](#_description_261)
- [New Structures](#_new_structures_231)
- [New Enum Constants](#_new_enum_constants_261)
- [New_Enum_Constants](#_new_enum_constants_261)
- [New Built-In Variables](#_new_built_in_variables_6)
- [New_Built-In_Variables](#_new_built_in_variables_6)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_33)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_33)
- [Examples](#_examples_32)
- [Version History](#_version_history_262)
- [VK_QCOM_filter_cubic_clamp](#VK_QCOM_filter_cubic_clamp)
- [Other Extension Metadata](#_other_extension_metadata_262)
- [Other_Extension_Metadata](#_other_extension_metadata_262)
- [Description](#_description_262)
- [New Structures](#_new_structures_232)
- [New Enum Constants](#_new_enum_constants_262)
- [New_Enum_Constants](#_new_enum_constants_262)
- [Version History](#_version_history_263)
- [VK_QCOM_filter_cubic_weights](#VK_QCOM_filter_cubic_weights)
- [Other Extension Metadata](#_other_extension_metadata_263)
- [Other_Extension_Metadata](#_other_extension_metadata_263)
- [Description](#_description_263)
- [New Structures](#_new_structures_233)
- [New Enums](#_new_enums_76)
- [New Enum Constants](#_new_enum_constants_263)
- [New_Enum_Constants](#_new_enum_constants_263)
- [Version History](#_version_history_264)
- [VK_QCOM_image_processing](#VK_QCOM_image_processing)
- [Other Extension Metadata](#_other_extension_metadata_264)
- [Other_Extension_Metadata](#_other_extension_metadata_264)
- [Description](#_description_264)
- [New Structures](#_new_structures_234)
- [New Enum Constants](#_new_enum_constants_264)
- [New_Enum_Constants](#_new_enum_constants_264)
- [Version History](#_version_history_265)
- [VK_QCOM_image_processing2](#VK_QCOM_image_processing2)
- [Other Extension Metadata](#_other_extension_metadata_265)
- [Other_Extension_Metadata](#_other_extension_metadata_265)
- [Description](#_description_265)
- [New Structures](#_new_structures_235)
- [New Enums](#_new_enums_77)
- [New Enum Constants](#_new_enum_constants_265)
- [New_Enum_Constants](#_new_enum_constants_265)
- [Issues](#_issues_115)
- [Version History](#_version_history_266)
- [VK_QCOM_multiview_per_view_render_areas](#VK_QCOM_multiview_per_view_render_areas)
- [Other Extension Metadata](#_other_extension_metadata_266)
- [Other_Extension_Metadata](#_other_extension_metadata_266)
- [Description](#_description_266)
- [New Structures](#_new_structures_236)
- [New Enum Constants](#_new_enum_constants_266)
- [New_Enum_Constants](#_new_enum_constants_266)
- [Issues](#_issues_116)
- [Version History](#_version_history_267)
- [VK_QCOM_multiview_per_view_viewports](#VK_QCOM_multiview_per_view_viewports)
- [Other Extension Metadata](#_other_extension_metadata_267)
- [Other_Extension_Metadata](#_other_extension_metadata_267)
- [Description](#_description_267)
- [New Structures](#_new_structures_237)
- [New Enum Constants](#_new_enum_constants_267)
- [New_Enum_Constants](#_new_enum_constants_267)
- [Issues](#_issues_117)
- [Version History](#_version_history_268)
- [VK_QCOM_render_pass_shader_resolve](#VK_QCOM_render_pass_shader_resolve)
- [Other Extension Metadata](#_other_extension_metadata_268)
- [Other_Extension_Metadata](#_other_extension_metadata_268)
- [Description](#_description_268)
- [New Enum Constants](#_new_enum_constants_268)
- [New_Enum_Constants](#_new_enum_constants_268)
- [Issues](#_issues_118)
- [Version History](#_version_history_269)
- [VK_QCOM_render_pass_store_ops](#VK_QCOM_render_pass_store_ops)
- [Other Extension Metadata](#_other_extension_metadata_269)
- [Other_Extension_Metadata](#_other_extension_metadata_269)
- [Description](#_description_269)
- [New Enum Constants](#_new_enum_constants_269)
- [New_Enum_Constants](#_new_enum_constants_269)
- [Version History](#_version_history_270)
- [VK_QCOM_render_pass_transform](#VK_QCOM_render_pass_transform)
- [Other Extension Metadata](#_other_extension_metadata_270)
- [Other_Extension_Metadata](#_other_extension_metadata_270)
- [Description](#_description_270)
- [New Structures](#_new_structures_238)
- [New Enum Constants](#_new_enum_constants_270)
- [New_Enum_Constants](#_new_enum_constants_270)
- [Issues](#_issues_119)
- [Version History](#_version_history_271)
- [VK_QCOM_rotated_copy_commands](#VK_QCOM_rotated_copy_commands)
- [Other Extension Metadata](#_other_extension_metadata_271)
- [Other_Extension_Metadata](#_other_extension_metadata_271)
- [Description](#_description_271)
- [Issues](#_issues_120)
- [New Structures](#_new_structures_239)
- [New Enum Constants](#_new_enum_constants_271)
- [New_Enum_Constants](#_new_enum_constants_271)
- [Version History](#_version_history_272)
- [VK_QCOM_tile_memory_heap](#VK_QCOM_tile_memory_heap)
- [Other Extension Metadata](#_other_extension_metadata_272)
- [Other_Extension_Metadata](#_other_extension_metadata_272)
- [Description](#_description_272)
- [Issues](#_issues_121)
- [New Commands](#_new_commands_111)
- [New Structures](#_new_structures_240)
- [New Enum Constants](#_new_enum_constants_272)
- [New_Enum_Constants](#_new_enum_constants_272)
- [Version History](#_version_history_273)
- [VK_QCOM_tile_properties](#VK_QCOM_tile_properties)
- [Other Extension Metadata](#_other_extension_metadata_273)
- [Other_Extension_Metadata](#_other_extension_metadata_273)
- [Description](#_description_273)
- [New Commands](#_new_commands_112)
- [New Structures](#_new_structures_241)
- [New Enum Constants](#_new_enum_constants_273)
- [New_Enum_Constants](#_new_enum_constants_273)
- [Version History](#_version_history_274)
- [VK_QCOM_tile_shading](#VK_QCOM_tile_shading)
- [Other Extension Metadata](#_other_extension_metadata_274)
- [Other_Extension_Metadata](#_other_extension_metadata_274)
- [Description](#_description_274)
- [New Commands](#_new_commands_113)
- [New Structures](#_new_structures_242)
- [New Enums](#_new_enums_78)
- [New Bitmasks](#_new_bitmasks_59)
- [New Enum Constants](#_new_enum_constants_274)
- [New_Enum_Constants](#_new_enum_constants_274)
- [New or Modified Built-In Variables](#_new_or_modified_built_in_variables_11)
- [New_or_Modified_Built-In_Variables](#_new_or_modified_built_in_variables_11)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_34)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_34)
- [Issues](#_issues_122)
- [Version History](#_version_history_275)
- [VK_QCOM_ycbcr_degamma](#VK_QCOM_ycbcr_degamma)
- [Other Extension Metadata](#_other_extension_metadata_275)
- [Other_Extension_Metadata](#_other_extension_metadata_275)
- [Description](#_description_275)
- [New Structures](#_new_structures_243)
- [New Enum Constants](#_new_enum_constants_275)
- [New_Enum_Constants](#_new_enum_constants_275)
- [Issues](#_issues_123)
- [Version History](#_version_history_276)
- [VK_QNX_external_memory_screen_buffer](#VK_QNX_external_memory_screen_buffer)
- [Other Extension Metadata](#_other_extension_metadata_276)
- [Other_Extension_Metadata](#_other_extension_metadata_276)
- [Description](#_description_276)
- [New Commands](#_new_commands_114)
- [New Structures](#_new_structures_244)
- [New Enum Constants](#_new_enum_constants_276)
- [New_Enum_Constants](#_new_enum_constants_276)
- [Issues](#_issues_124)
- [Version History](#_version_history_277)
- [VK_QNX_screen_surface](#VK_QNX_screen_surface)
- [Other Extension Metadata](#_other_extension_metadata_277)
- [Other_Extension_Metadata](#_other_extension_metadata_277)
- [Description](#_description_277)
- [New Commands](#_new_commands_115)
- [New Structures](#_new_structures_245)
- [New Bitmasks](#_new_bitmasks_60)
- [New Enum Constants](#_new_enum_constants_277)
- [New_Enum_Constants](#_new_enum_constants_277)
- [Version History](#_version_history_278)
- [VK_SEC_amigo_profiling](#VK_SEC_amigo_profiling)
- [Other Extension Metadata](#_other_extension_metadata_278)
- [Other_Extension_Metadata](#_other_extension_metadata_278)
- [Description](#_description_278)
- [New Structures](#_new_structures_246)
- [New Enum Constants](#_new_enum_constants_278)
- [New_Enum_Constants](#_new_enum_constants_278)
- [Stub API References](#_stub_api_references_2)
- [Stub_API_References](#_stub_api_references_2)
- [Version History](#_version_history_279)
- [VK_VALVE_descriptor_set_host_mapping](#VK_VALVE_descriptor_set_host_mapping)
- [Other Extension Metadata](#_other_extension_metadata_279)
- [Other_Extension_Metadata](#_other_extension_metadata_279)
- [Description](#_description_279)
- [New Commands](#_new_commands_116)
- [New Structures](#_new_structures_247)
- [New Enum Constants](#_new_enum_constants_279)
- [New_Enum_Constants](#_new_enum_constants_279)
- [Stub API References](#_stub_api_references_3)
- [Stub_API_References](#_stub_api_references_3)
- [Version History](#_version_history_280)
- [List of Provisional Extensions](#provisional-extension-appendices-list)
- [List_of_Provisional_Extensions](#provisional-extension-appendices-list)
- [VK_KHR_portability_subset](#VK_KHR_portability_subset)
- [Other Extension Metadata](#_other_extension_metadata_280)
- [Other_Extension_Metadata](#_other_extension_metadata_280)
- [Description](#_description_280)
- [New Structures](#_new_structures_248)
- [New Enum Constants](#_new_enum_constants_280)
- [New_Enum_Constants](#_new_enum_constants_280)
- [Issues](#_issues_125)
- [Version History](#_version_history_281)
- [VK_AMDX_shader_enqueue](#VK_AMDX_shader_enqueue)
- [Other Extension Metadata](#_other_extension_metadata_281)
- [Other_Extension_Metadata](#_other_extension_metadata_281)
- [Description](#_description_281)
- [New Commands](#_new_commands_117)
- [New Structures](#_new_structures_249)
- [New Unions](#_new_unions_10)
- [New Enum Constants](#_new_enum_constants_281)
- [New_Enum_Constants](#_new_enum_constants_281)
- [Version History](#_version_history_282)
- [VK_NV_cuda_kernel_launch](#VK_NV_cuda_kernel_launch)
- [Other Extension Metadata](#_other_extension_metadata_282)
- [Other_Extension_Metadata](#_other_extension_metadata_282)
- [Description](#_description_282)
- [New Object Types](#_new_object_types_19)
- [New_Object_Types](#_new_object_types_19)
- [New Commands](#_new_commands_118)
- [New Structures](#_new_structures_250)
- [New Enum Constants](#_new_enum_constants_282)
- [New_Enum_Constants](#_new_enum_constants_282)
- [Issues](#_issues_126)
- [Version History](#_version_history_283)
- [VK_NV_present_metering](#VK_NV_present_metering)
- [Other Extension Metadata](#_other_extension_metadata_283)
- [Other_Extension_Metadata](#_other_extension_metadata_283)
- [Description](#_description_283)
- [New Structures](#_new_structures_251)
- [New Enum Constants](#_new_enum_constants_283)
- [New_Enum_Constants](#_new_enum_constants_283)
- [Issues](#_issues_127)
- [Version History](#_version_history_284)
- [List of Deprecated Extensions](#deprecated-extension-appendices-list)
- [List_of_Deprecated_Extensions](#deprecated-extension-appendices-list)
- [VK_KHR_16bit_storage](#VK_KHR_16bit_storage)
- [Other Extension Metadata](#_other_extension_metadata_284)
- [Other_Extension_Metadata](#_other_extension_metadata_284)
- [Description](#_description_284)
- [Promotion to Vulkan 1.1](#_promotion_to_vulkan_1_1)
- [Promotion_to_Vulkan_1.1](#_promotion_to_vulkan_1_1)
- [Promotion to Vulkan 1.4](#_promotion_to_vulkan_1_4)
- [Promotion_to_Vulkan_1.4](#_promotion_to_vulkan_1_4)
- [New Structures](#_new_structures_252)
- [New Enum Constants](#_new_enum_constants_284)
- [New_Enum_Constants](#_new_enum_constants_284)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_35)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_35)
- [Version History](#_version_history_285)
- [VK_KHR_8bit_storage](#VK_KHR_8bit_storage)
- [Other Extension Metadata](#_other_extension_metadata_285)
- [Other_Extension_Metadata](#_other_extension_metadata_285)
- [Description](#_description_285)
- [Promotion to Vulkan 1.2](#_promotion_to_vulkan_1_2)
- [Promotion_to_Vulkan_1.2](#_promotion_to_vulkan_1_2)
- [Promotion to Vulkan 1.4](#_promotion_to_vulkan_1_4_2)
- [Promotion_to_Vulkan_1.4](#_promotion_to_vulkan_1_4_2)
- [New Structures](#_new_structures_253)
- [New Enum Constants](#_new_enum_constants_285)
- [New_Enum_Constants](#_new_enum_constants_285)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_36)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_36)
- [Version History](#_version_history_286)
- [VK_KHR_bind_memory2](#VK_KHR_bind_memory2)
- [Other Extension Metadata](#_other_extension_metadata_286)
- [Other_Extension_Metadata](#_other_extension_metadata_286)
- [Description](#_description_286)
- [Promotion to Vulkan 1.1](#_promotion_to_vulkan_1_1_2)
- [Promotion_to_Vulkan_1.1](#_promotion_to_vulkan_1_1_2)
- [New Commands](#_new_commands_119)
- [New Structures](#_new_structures_254)
- [New Enum Constants](#_new_enum_constants_286)
- [New_Enum_Constants](#_new_enum_constants_286)
- [Version History](#_version_history_287)
- [VK_KHR_buffer_device_address](#VK_KHR_buffer_device_address)
- [Other Extension Metadata](#_other_extension_metadata_287)
- [Other_Extension_Metadata](#_other_extension_metadata_287)
- [Description](#_description_287)
- [Promotion to Vulkan 1.2](#_promotion_to_vulkan_1_2_2)
- [Promotion_to_Vulkan_1.2](#_promotion_to_vulkan_1_2_2)
- [Promotion to Vulkan 1.3](#_promotion_to_vulkan_1_3)
- [Promotion_to_Vulkan_1.3](#_promotion_to_vulkan_1_3)
- [New Commands](#_new_commands_120)
- [New Structures](#_new_structures_255)
- [New Enum Constants](#_new_enum_constants_287)
- [New_Enum_Constants](#_new_enum_constants_287)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_37)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_37)
- [Version History](#_version_history_288)
- [VK_KHR_copy_commands2](#VK_KHR_copy_commands2)
- [Other Extension Metadata](#_other_extension_metadata_288)
- [Other_Extension_Metadata](#_other_extension_metadata_288)
- [Description](#_description_288)
- [New Commands](#_new_commands_121)
- [New Structures](#_new_structures_256)
- [New Enum Constants](#_new_enum_constants_288)
- [New_Enum_Constants](#_new_enum_constants_288)
- [Promotion to Vulkan 1.3](#_promotion_to_vulkan_1_3_2)
- [Promotion_to_Vulkan_1.3](#_promotion_to_vulkan_1_3_2)
- [Version History](#_version_history_289)
- [VK_KHR_create_renderpass2](#VK_KHR_create_renderpass2)
- [Other Extension Metadata](#_other_extension_metadata_289)
- [Other_Extension_Metadata](#_other_extension_metadata_289)
- [Description](#_description_289)
- [Promotion to Vulkan 1.2](#_promotion_to_vulkan_1_2_3)
- [Promotion_to_Vulkan_1.2](#_promotion_to_vulkan_1_2_3)
- [New Commands](#_new_commands_122)
- [New Structures](#_new_structures_257)
- [New Enum Constants](#_new_enum_constants_289)
- [New_Enum_Constants](#_new_enum_constants_289)
- [Version History](#_version_history_290)
- [VK_KHR_dedicated_allocation](#VK_KHR_dedicated_allocation)
- [Other Extension Metadata](#_other_extension_metadata_290)
- [Other_Extension_Metadata](#_other_extension_metadata_290)
- [Description](#_description_290)
- [Promotion to Vulkan 1.1](#_promotion_to_vulkan_1_1_3)
- [Promotion_to_Vulkan_1.1](#_promotion_to_vulkan_1_1_3)
- [New Structures](#_new_structures_258)
- [New Enum Constants](#_new_enum_constants_290)
- [New_Enum_Constants](#_new_enum_constants_290)
- [Examples](#_examples_33)
- [Version History](#_version_history_291)
- [VK_KHR_depth_stencil_resolve](#VK_KHR_depth_stencil_resolve)
- [Other Extension Metadata](#_other_extension_metadata_291)
- [Other_Extension_Metadata](#_other_extension_metadata_291)
- [Description](#_description_291)
- [Promotion to Vulkan 1.2](#_promotion_to_vulkan_1_2_4)
- [Promotion_to_Vulkan_1.2](#_promotion_to_vulkan_1_2_4)
- [New Structures](#_new_structures_259)
- [New Enums](#_new_enums_79)
- [New Bitmasks](#_new_bitmasks_61)
- [New Enum Constants](#_new_enum_constants_291)
- [New_Enum_Constants](#_new_enum_constants_291)
- [Version History](#_version_history_292)
- [VK_KHR_descriptor_update_template](#VK_KHR_descriptor_update_template)
- [Other Extension Metadata](#_other_extension_metadata_292)
- [Other_Extension_Metadata](#_other_extension_metadata_292)
- [Description](#_description_292)
- [Promotion to Vulkan 1.1](#_promotion_to_vulkan_1_1_4)
- [Promotion_to_Vulkan_1.1](#_promotion_to_vulkan_1_1_4)
- [New Object Types](#_new_object_types_20)
- [New_Object_Types](#_new_object_types_20)
- [New Commands](#_new_commands_123)
- [New Structures](#_new_structures_260)
- [New Enums](#_new_enums_80)
- [New Bitmasks](#_new_bitmasks_62)
- [New Enum Constants](#_new_enum_constants_292)
- [New_Enum_Constants](#_new_enum_constants_292)
- [Version History](#_version_history_293)
- [VK_KHR_device_group](#VK_KHR_device_group)
- [Other Extension Metadata](#_other_extension_metadata_293)
- [Other_Extension_Metadata](#_other_extension_metadata_293)
- [Description](#_description_293)
- [Promotion to Vulkan 1.1](#_promotion_to_vulkan_1_1_5)
- [Promotion_to_Vulkan_1.1](#_promotion_to_vulkan_1_1_5)
- [New Commands](#_new_commands_124)
- [New Structures](#_new_structures_261)
- [New Enums](#_new_enums_81)
- [New Bitmasks](#_new_bitmasks_63)
- [New Enum Constants](#_new_enum_constants_293)
- [New_Enum_Constants](#_new_enum_constants_293)
- [New Built-in Variables](#_new_built_in_variables_7)
- [New_Built-in_Variables](#_new_built_in_variables_7)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_38)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_38)
- [Version History](#_version_history_294)
- [VK_KHR_device_group_creation](#VK_KHR_device_group_creation)
- [Other Extension Metadata](#_other_extension_metadata_294)
- [Other_Extension_Metadata](#_other_extension_metadata_294)
- [Description](#_description_294)
- [Promotion to Vulkan 1.1](#_promotion_to_vulkan_1_1_6)
- [Promotion_to_Vulkan_1.1](#_promotion_to_vulkan_1_1_6)
- [New Commands](#_new_commands_125)
- [New Structures](#_new_structures_262)
- [New Enum Constants](#_new_enum_constants_294)
- [New_Enum_Constants](#_new_enum_constants_294)
- [Examples](#_examples_34)
- [Version History](#_version_history_295)
- [VK_KHR_draw_indirect_count](#VK_KHR_draw_indirect_count)
- [Other Extension Metadata](#_other_extension_metadata_295)
- [Other_Extension_Metadata](#_other_extension_metadata_295)
- [Description](#_description_295)
- [Promotion to Vulkan 1.2](#_promotion_to_vulkan_1_2_5)
- [Promotion_to_Vulkan_1.2](#_promotion_to_vulkan_1_2_5)
- [New Commands](#_new_commands_126)
- [New Enum Constants](#_new_enum_constants_295)
- [New_Enum_Constants](#_new_enum_constants_295)
- [Version History](#_version_history_296)
- [VK_KHR_driver_properties](#VK_KHR_driver_properties)
- [Other Extension Metadata](#_other_extension_metadata_296)
- [Other_Extension_Metadata](#_other_extension_metadata_296)
- [Description](#_description_296)
- [Promotion to Vulkan 1.2](#_promotion_to_vulkan_1_2_6)
- [Promotion_to_Vulkan_1.2](#_promotion_to_vulkan_1_2_6)
- [New Structures](#_new_structures_263)
- [New Enums](#_new_enums_82)
- [New Enum Constants](#_new_enum_constants_296)
- [New_Enum_Constants](#_new_enum_constants_296)
- [Version History](#_version_history_297)
- [VK_KHR_dynamic_rendering](#VK_KHR_dynamic_rendering)
- [Other Extension Metadata](#_other_extension_metadata_297)
- [Other_Extension_Metadata](#_other_extension_metadata_297)
- [Description](#_description_297)
- [New Commands](#_new_commands_127)
- [New Structures](#_new_structures_264)
- [New Enums](#_new_enums_83)
- [New Bitmasks](#_new_bitmasks_64)
- [New Enum Constants](#_new_enum_constants_297)
- [New_Enum_Constants](#_new_enum_constants_297)
- [Promotion to Vulkan 1.3](#_promotion_to_vulkan_1_3_3)
- [Promotion_to_Vulkan_1.3](#_promotion_to_vulkan_1_3_3)
- [Version History](#_version_history_298)
- [VK_KHR_dynamic_rendering_local_read](#VK_KHR_dynamic_rendering_local_read)
- [Other Extension Metadata](#_other_extension_metadata_298)
- [Other_Extension_Metadata](#_other_extension_metadata_298)
- [Description](#_description_298)
- [New Commands](#_new_commands_128)
- [New Structures](#_new_structures_265)
- [New Enum Constants](#_new_enum_constants_298)
- [New_Enum_Constants](#_new_enum_constants_298)
- [Promotion to Vulkan 1.4](#_promotion_to_vulkan_1_4_3)
- [Promotion_to_Vulkan_1.4](#_promotion_to_vulkan_1_4_3)
- [Version History](#_version_history_299)
- [VK_KHR_external_fence](#VK_KHR_external_fence)
- [Other Extension Metadata](#_other_extension_metadata_299)
- [Other_Extension_Metadata](#_other_extension_metadata_299)
- [Description](#_description_299)
- [Promotion to Vulkan 1.1](#_promotion_to_vulkan_1_1_7)
- [Promotion_to_Vulkan_1.1](#_promotion_to_vulkan_1_1_7)
- [New Structures](#_new_structures_266)
- [New Enums](#_new_enums_84)
- [New Bitmasks](#_new_bitmasks_65)
- [New Enum Constants](#_new_enum_constants_299)
- [New_Enum_Constants](#_new_enum_constants_299)
- [Issues](#_issues_128)
- [Version History](#_version_history_300)
- [VK_KHR_external_fence_capabilities](#VK_KHR_external_fence_capabilities)
- [Other Extension Metadata](#_other_extension_metadata_300)
- [Other_Extension_Metadata](#_other_extension_metadata_300)
- [Description](#_description_300)
- [Promotion to Vulkan 1.1](#_promotion_to_vulkan_1_1_8)
- [Promotion_to_Vulkan_1.1](#_promotion_to_vulkan_1_1_8)
- [New Commands](#_new_commands_129)
- [New Structures](#_new_structures_267)
- [New Enums](#_new_enums_85)
- [New Bitmasks](#_new_bitmasks_66)
- [New Enum Constants](#_new_enum_constants_300)
- [New_Enum_Constants](#_new_enum_constants_300)
- [Version History](#_version_history_301)
- [VK_KHR_external_memory](#VK_KHR_external_memory)
- [Other Extension Metadata](#_other_extension_metadata_301)
- [Other_Extension_Metadata](#_other_extension_metadata_301)
- [Description](#_description_301)
- [Promotion to Vulkan 1.1](#_promotion_to_vulkan_1_1_9)
- [Promotion_to_Vulkan_1.1](#_promotion_to_vulkan_1_1_9)
- [New Structures](#_new_structures_268)
- [New Enum Constants](#_new_enum_constants_301)
- [New_Enum_Constants](#_new_enum_constants_301)
- [Issues](#_issues_129)
- [Version History](#_version_history_302)
- [VK_KHR_external_memory_capabilities](#VK_KHR_external_memory_capabilities)
- [Other Extension Metadata](#_other_extension_metadata_302)
- [Other_Extension_Metadata](#_other_extension_metadata_302)
- [Description](#_description_302)
- [Promotion to Vulkan 1.1](#_promotion_to_vulkan_1_1_10)
- [Promotion_to_Vulkan_1.1](#_promotion_to_vulkan_1_1_10)
- [New Commands](#_new_commands_130)
- [New Structures](#_new_structures_269)
- [New Enums](#_new_enums_86)
- [New Bitmasks](#_new_bitmasks_67)
- [New Enum Constants](#_new_enum_constants_302)
- [New_Enum_Constants](#_new_enum_constants_302)
- [Issues](#_issues_130)
- [Version History](#_version_history_303)
- [VK_KHR_external_semaphore](#VK_KHR_external_semaphore)
- [Other Extension Metadata](#_other_extension_metadata_303)
- [Other_Extension_Metadata](#_other_extension_metadata_303)
- [Description](#_description_303)
- [Promotion to Vulkan 1.1](#_promotion_to_vulkan_1_1_11)
- [Promotion_to_Vulkan_1.1](#_promotion_to_vulkan_1_1_11)
- [New Structures](#_new_structures_270)
- [New Enums](#_new_enums_87)
- [New Bitmasks](#_new_bitmasks_68)
- [New Enum Constants](#_new_enum_constants_303)
- [New_Enum_Constants](#_new_enum_constants_303)
- [Issues](#_issues_131)
- [Version History](#_version_history_304)
- [VK_KHR_external_semaphore_capabilities](#VK_KHR_external_semaphore_capabilities)
- [Other Extension Metadata](#_other_extension_metadata_304)
- [Other_Extension_Metadata](#_other_extension_metadata_304)
- [Description](#_description_304)
- [Promotion to Vulkan 1.1](#_promotion_to_vulkan_1_1_12)
- [Promotion_to_Vulkan_1.1](#_promotion_to_vulkan_1_1_12)
- [New Commands](#_new_commands_131)
- [New Structures](#_new_structures_271)
- [New Enums](#_new_enums_88)
- [New Bitmasks](#_new_bitmasks_69)
- [New Enum Constants](#_new_enum_constants_304)
- [New_Enum_Constants](#_new_enum_constants_304)
- [Version History](#_version_history_305)
- [VK_KHR_format_feature_flags2](#VK_KHR_format_feature_flags2)
- [Other Extension Metadata](#_other_extension_metadata_305)
- [Other_Extension_Metadata](#_other_extension_metadata_305)
- [Description](#_description_305)
- [New Structures](#_new_structures_272)
- [New Enums](#_new_enums_89)
- [New Bitmasks](#_new_bitmasks_70)
- [New Enum Constants](#_new_enum_constants_305)
- [New_Enum_Constants](#_new_enum_constants_305)
- [Promotion to Vulkan 1.3](#_promotion_to_vulkan_1_3_4)
- [Promotion_to_Vulkan_1.3](#_promotion_to_vulkan_1_3_4)
- [Version History](#_version_history_306)
- [VK_KHR_get_memory_requirements2](#VK_KHR_get_memory_requirements2)
- [Other Extension Metadata](#_other_extension_metadata_306)
- [Other_Extension_Metadata](#_other_extension_metadata_306)
- [Description](#_description_306)
- [Promotion to Vulkan 1.1](#_promotion_to_vulkan_1_1_13)
- [Promotion_to_Vulkan_1.1](#_promotion_to_vulkan_1_1_13)
- [New Commands](#_new_commands_132)
- [New Structures](#_new_structures_273)
- [New Enum Constants](#_new_enum_constants_306)
- [New_Enum_Constants](#_new_enum_constants_306)
- [Version History](#_version_history_307)
- [VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)
- [Other Extension Metadata](#_other_extension_metadata_307)
- [Other_Extension_Metadata](#_other_extension_metadata_307)
- [Description](#_description_307)
- [Promotion to Vulkan 1.1](#_promotion_to_vulkan_1_1_14)
- [Promotion_to_Vulkan_1.1](#_promotion_to_vulkan_1_1_14)
- [New Commands](#_new_commands_133)
- [New Structures](#_new_structures_274)
- [New Enum Constants](#_new_enum_constants_307)
- [New_Enum_Constants](#_new_enum_constants_307)
- [Examples](#_examples_35)
- [Version History](#_version_history_308)
- [VK_KHR_global_priority](#VK_KHR_global_priority)
- [Other Extension Metadata](#_other_extension_metadata_308)
- [Other_Extension_Metadata](#_other_extension_metadata_308)
- [Description](#_description_308)
- [New Structures](#_new_structures_275)
- [New Enums](#_new_enums_90)
- [New Enum Constants](#_new_enum_constants_308)
- [New_Enum_Constants](#_new_enum_constants_308)
- [Promotion to Vulkan 1.4](#_promotion_to_vulkan_1_4_4)
- [Promotion_to_Vulkan_1.4](#_promotion_to_vulkan_1_4_4)
- [Issues](#_issues_132)
- [Version History](#_version_history_309)
- [VK_KHR_image_format_list](#VK_KHR_image_format_list)
- [Other Extension Metadata](#_other_extension_metadata_309)
- [Other_Extension_Metadata](#_other_extension_metadata_309)
- [Description](#_description_309)
- [Promotion to Vulkan 1.2](#_promotion_to_vulkan_1_2_7)
- [Promotion_to_Vulkan_1.2](#_promotion_to_vulkan_1_2_7)
- [New Structures](#_new_structures_276)
- [New Enum Constants](#_new_enum_constants_309)
- [New_Enum_Constants](#_new_enum_constants_309)
- [Version History](#_version_history_310)
- [VK_KHR_imageless_framebuffer](#VK_KHR_imageless_framebuffer)
- [Other Extension Metadata](#_other_extension_metadata_310)
- [Other_Extension_Metadata](#_other_extension_metadata_310)
- [Description](#_description_310)
- [Promotion to Vulkan 1.2](#_promotion_to_vulkan_1_2_8)
- [Promotion_to_Vulkan_1.2](#_promotion_to_vulkan_1_2_8)
- [New Structures](#_new_structures_277)
- [New Enum Constants](#_new_enum_constants_310)
- [New_Enum_Constants](#_new_enum_constants_310)
- [Version History](#_version_history_311)
- [VK_KHR_index_type_uint8](#VK_KHR_index_type_uint8)
- [Other Extension Metadata](#_other_extension_metadata_311)
- [Other_Extension_Metadata](#_other_extension_metadata_311)
- [Description](#_description_311)
- [New Structures](#_new_structures_278)
- [New Enum Constants](#_new_enum_constants_311)
- [New_Enum_Constants](#_new_enum_constants_311)
- [Promotion to Vulkan 1.4](#_promotion_to_vulkan_1_4_5)
- [Promotion_to_Vulkan_1.4](#_promotion_to_vulkan_1_4_5)
- [Version History](#_version_history_312)
- [VK_KHR_line_rasterization](#VK_KHR_line_rasterization)
- [Other Extension Metadata](#_other_extension_metadata_312)
- [Other_Extension_Metadata](#_other_extension_metadata_312)
- [Description](#_description_312)
- [New Commands](#_new_commands_134)
- [New Structures](#_new_structures_279)
- [New Enums](#_new_enums_91)
- [New Enum Constants](#_new_enum_constants_312)
- [New_Enum_Constants](#_new_enum_constants_312)
- [Promotion to Vulkan 1.4](#_promotion_to_vulkan_1_4_6)
- [Promotion_to_Vulkan_1.4](#_promotion_to_vulkan_1_4_6)
- [Issues](#_issues_133)
- [Version History](#_version_history_313)
- [VK_KHR_load_store_op_none](#VK_KHR_load_store_op_none)
- [Other Extension Metadata](#_other_extension_metadata_313)
- [Other_Extension_Metadata](#_other_extension_metadata_313)
- [Description](#_description_313)
- [New Enum Constants](#_new_enum_constants_313)
- [New_Enum_Constants](#_new_enum_constants_313)
- [Promotion to Vulkan 1.4](#_promotion_to_vulkan_1_4_7)
- [Promotion_to_Vulkan_1.4](#_promotion_to_vulkan_1_4_7)
- [Version History](#_version_history_314)
- [VK_KHR_maintenance1](#VK_KHR_maintenance1)
- [Other Extension Metadata](#_other_extension_metadata_314)
- [Other_Extension_Metadata](#_other_extension_metadata_314)
- [Description](#_description_314)
- [Promotion to Vulkan 1.1](#_promotion_to_vulkan_1_1_15)
- [Promotion_to_Vulkan_1.1](#_promotion_to_vulkan_1_1_15)
- [New Commands](#_new_commands_135)
- [New Bitmasks](#_new_bitmasks_71)
- [New Enum Constants](#_new_enum_constants_314)
- [New_Enum_Constants](#_new_enum_constants_314)
- [Issues](#_issues_134)
- [Version History](#_version_history_315)
- [VK_KHR_maintenance2](#VK_KHR_maintenance2)
- [Other Extension Metadata](#_other_extension_metadata_315)
- [Other_Extension_Metadata](#_other_extension_metadata_315)
- [Description](#_description_315)
- [Input Attachment Specification](#_input_attachment_specification)
- [Input_Attachment_Specification](#_input_attachment_specification)
- [Promotion to Vulkan 1.1](#_promotion_to_vulkan_1_1_16)
- [Promotion_to_Vulkan_1.1](#_promotion_to_vulkan_1_1_16)
- [New Structures](#_new_structures_280)
- [New Enums](#_new_enums_92)
- [New Enum Constants](#_new_enum_constants_315)
- [New_Enum_Constants](#_new_enum_constants_315)
- [Input Attachment Specification Example](#_input_attachment_specification_example)
- [Input_Attachment_Specification_Example](#_input_attachment_specification_example)
- [Issues](#_issues_135)
- [Version History](#_version_history_316)
- [VK_KHR_maintenance3](#VK_KHR_maintenance3)
- [Other Extension Metadata](#_other_extension_metadata_316)
- [Other_Extension_Metadata](#_other_extension_metadata_316)
- [Description](#_description_316)
- [Promotion to Vulkan 1.1](#_promotion_to_vulkan_1_1_17)
- [Promotion_to_Vulkan_1.1](#_promotion_to_vulkan_1_1_17)
- [New Commands](#_new_commands_136)
- [New Structures](#_new_structures_281)
- [New Enum Constants](#_new_enum_constants_316)
- [New_Enum_Constants](#_new_enum_constants_316)
- [Version History](#_version_history_317)
- [VK_KHR_maintenance4](#VK_KHR_maintenance4)
- [Other Extension Metadata](#_other_extension_metadata_317)
- [Other_Extension_Metadata](#_other_extension_metadata_317)
- [Description](#_description_317)
- [New Commands](#_new_commands_137)
- [New Structures](#_new_structures_282)
- [New Enum Constants](#_new_enum_constants_317)
- [New_Enum_Constants](#_new_enum_constants_317)
- [Promotion to Vulkan 1.3](#_promotion_to_vulkan_1_3_5)
- [Promotion_to_Vulkan_1.3](#_promotion_to_vulkan_1_3_5)
- [Issues](#_issues_136)
- [Version History](#_version_history_318)
- [VK_KHR_maintenance5](#VK_KHR_maintenance5)
- [Other Extension Metadata](#_other_extension_metadata_318)
- [Other_Extension_Metadata](#_other_extension_metadata_318)
- [Description](#_description_318)
- [New Commands](#_new_commands_138)
- [New Structures](#_new_structures_283)
- [New Enums](#_new_enums_93)
- [New Bitmasks](#_new_bitmasks_72)
- [New Enum Constants](#_new_enum_constants_318)
- [New_Enum_Constants](#_new_enum_constants_318)
- [Promotion to Vulkan 1.4](#_promotion_to_vulkan_1_4_8)
- [Promotion_to_Vulkan_1.4](#_promotion_to_vulkan_1_4_8)
- [Version History](#_version_history_319)
- [VK_KHR_maintenance6](#VK_KHR_maintenance6)
- [Other Extension Metadata](#_other_extension_metadata_319)
- [Other_Extension_Metadata](#_other_extension_metadata_319)
- [Description](#_description_319)
- [New Commands](#_new_commands_139)
- [New Structures](#_new_structures_284)
- [New Enum Constants](#_new_enum_constants_319)
- [New_Enum_Constants](#_new_enum_constants_319)
- [Promotion to Vulkan 1.4](#_promotion_to_vulkan_1_4_9)
- [Promotion_to_Vulkan_1.4](#_promotion_to_vulkan_1_4_9)
- [Version History](#_version_history_320)
- [VK_KHR_map_memory2](#VK_KHR_map_memory2)
- [Other Extension Metadata](#_other_extension_metadata_320)
- [Other_Extension_Metadata](#_other_extension_metadata_320)
- [Description](#_description_320)
- [New Commands](#_new_commands_140)
- [New Structures](#_new_structures_285)
- [New Enums](#_new_enums_94)
- [New Bitmasks](#_new_bitmasks_73)
- [New Enum Constants](#_new_enum_constants_320)
- [New_Enum_Constants](#_new_enum_constants_320)
- [Promotion to Vulkan 1.4](#_promotion_to_vulkan_1_4_10)
- [Promotion_to_Vulkan_1.4](#_promotion_to_vulkan_1_4_10)
- [Version History](#_version_history_321)
- [VK_KHR_multiview](#VK_KHR_multiview)
- [Other Extension Metadata](#_other_extension_metadata_321)
- [Other_Extension_Metadata](#_other_extension_metadata_321)
- [Description](#_description_321)
- [Promotion to Vulkan 1.1](#_promotion_to_vulkan_1_1_18)
- [Promotion_to_Vulkan_1.1](#_promotion_to_vulkan_1_1_18)
- [New Structures](#_new_structures_286)
- [New Enum Constants](#_new_enum_constants_321)
- [New_Enum_Constants](#_new_enum_constants_321)
- [New Built-In Variables](#_new_built_in_variables_8)
- [New_Built-In_Variables](#_new_built_in_variables_8)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_39)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_39)
- [Version History](#_version_history_322)
- [VK_KHR_push_descriptor](#VK_KHR_push_descriptor)
- [Other Extension Metadata](#_other_extension_metadata_322)
- [Other_Extension_Metadata](#_other_extension_metadata_322)
- [Description](#_description_322)
- [New Commands](#_new_commands_141)
- [New Structures](#_new_structures_287)
- [New Enum Constants](#_new_enum_constants_322)
- [New_Enum_Constants](#_new_enum_constants_322)
- [Promotion to Vulkan 1.4](#_promotion_to_vulkan_1_4_11)
- [Promotion_to_Vulkan_1.4](#_promotion_to_vulkan_1_4_11)
- [Version History](#_version_history_323)
- [VK_KHR_relaxed_block_layout](#VK_KHR_relaxed_block_layout)
- [Other Extension Metadata](#_other_extension_metadata_323)
- [Other_Extension_Metadata](#_other_extension_metadata_323)
- [Description](#_description_323)
- [Promotion to Vulkan 1.1](#_promotion_to_vulkan_1_1_19)
- [Promotion_to_Vulkan_1.1](#_promotion_to_vulkan_1_1_19)
- [New Enum Constants](#_new_enum_constants_323)
- [New_Enum_Constants](#_new_enum_constants_323)
- [Version History](#_version_history_324)
- [VK_KHR_sampler_mirror_clamp_to_edge](#VK_KHR_sampler_mirror_clamp_to_edge)
- [Other Extension Metadata](#_other_extension_metadata_324)
- [Other_Extension_Metadata](#_other_extension_metadata_324)
- [Description](#_description_324)
- [Promotion to Vulkan 1.2](#_promotion_to_vulkan_1_2_9)
- [Promotion_to_Vulkan_1.2](#_promotion_to_vulkan_1_2_9)
- [New Enum Constants](#_new_enum_constants_324)
- [New_Enum_Constants](#_new_enum_constants_324)
- [Example](#_example_4)
- [Issues](#_issues_137)
- [Version History](#_version_history_325)
- [VK_KHR_sampler_ycbcr_conversion](#VK_KHR_sampler_ycbcr_conversion)
- [Other Extension Metadata](#_other_extension_metadata_325)
- [Other_Extension_Metadata](#_other_extension_metadata_325)
- [Description](#_description_325)
- [Promotion to Vulkan 1.1](#_promotion_to_vulkan_1_1_20)
- [Promotion_to_Vulkan_1.1](#_promotion_to_vulkan_1_1_20)
- [Promotion to Vulkan 1.4](#_promotion_to_vulkan_1_4_12)
- [Promotion_to_Vulkan_1.4](#_promotion_to_vulkan_1_4_12)
- [New Object Types](#_new_object_types_21)
- [New_Object_Types](#_new_object_types_21)
- [New Commands](#_new_commands_142)
- [New Structures](#_new_structures_288)
- [New Enums](#_new_enums_95)
- [New Enum Constants](#_new_enum_constants_325)
- [New_Enum_Constants](#_new_enum_constants_325)
- [Version History](#_version_history_326)
- [VK_KHR_separate_depth_stencil_layouts](#VK_KHR_separate_depth_stencil_layouts)
- [Other Extension Metadata](#_other_extension_metadata_326)
- [Other_Extension_Metadata](#_other_extension_metadata_326)
- [Description](#_description_326)
- [Promotion to Vulkan 1.2](#_promotion_to_vulkan_1_2_10)
- [Promotion_to_Vulkan_1.2](#_promotion_to_vulkan_1_2_10)
- [New Structures](#_new_structures_289)
- [New Enum Constants](#_new_enum_constants_326)
- [New_Enum_Constants](#_new_enum_constants_326)
- [Version History](#_version_history_327)
- [VK_KHR_shader_atomic_int64](#VK_KHR_shader_atomic_int64)
- [Other Extension Metadata](#_other_extension_metadata_327)
- [Other_Extension_Metadata](#_other_extension_metadata_327)
- [Description](#_description_327)
- [Promotion to Vulkan 1.2](#_promotion_to_vulkan_1_2_11)
- [Promotion_to_Vulkan_1.2](#_promotion_to_vulkan_1_2_11)
- [New Structures](#_new_structures_290)
- [New Enum Constants](#_new_enum_constants_327)
- [New_Enum_Constants](#_new_enum_constants_327)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_40)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_40)
- [Version History](#_version_history_328)
- [VK_KHR_shader_draw_parameters](#VK_KHR_shader_draw_parameters)
- [Other Extension Metadata](#_other_extension_metadata_328)
- [Other_Extension_Metadata](#_other_extension_metadata_328)
- [Description](#_description_328)
- [Promotion to Vulkan 1.1](#_promotion_to_vulkan_1_1_21)
- [Promotion_to_Vulkan_1.1](#_promotion_to_vulkan_1_1_21)
- [New Enum Constants](#_new_enum_constants_328)
- [New_Enum_Constants](#_new_enum_constants_328)
- [New Built-In Variables](#_new_built_in_variables_9)
- [New_Built-In_Variables](#_new_built_in_variables_9)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_41)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_41)
- [Issues](#_issues_138)
- [Version History](#_version_history_329)
- [VK_KHR_shader_expect_assume](#VK_KHR_shader_expect_assume)
- [Other Extension Metadata](#_other_extension_metadata_329)
- [Other_Extension_Metadata](#_other_extension_metadata_329)
- [Description](#_description_329)
- [New Structures](#_new_structures_291)
- [New Enum Constants](#_new_enum_constants_329)
- [New_Enum_Constants](#_new_enum_constants_329)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_42)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_42)
- [Promotion to Vulkan 1.4](#_promotion_to_vulkan_1_4_13)
- [Promotion_to_Vulkan_1.4](#_promotion_to_vulkan_1_4_13)
- [Version History](#_version_history_330)
- [VK_KHR_shader_float16_int8](#VK_KHR_shader_float16_int8)
- [Other Extension Metadata](#_other_extension_metadata_330)
- [Other_Extension_Metadata](#_other_extension_metadata_330)
- [Description](#_description_330)
- [Promotion to Vulkan 1.2](#_promotion_to_vulkan_1_2_12)
- [Promotion_to_Vulkan_1.2](#_promotion_to_vulkan_1_2_12)
- [Promotion to Vulkan 1.4](#_promotion_to_vulkan_1_4_14)
- [Promotion_to_Vulkan_1.4](#_promotion_to_vulkan_1_4_14)
- [New Structures](#_new_structures_292)
- [New Enum Constants](#_new_enum_constants_330)
- [New_Enum_Constants](#_new_enum_constants_330)
- [Version History](#_version_history_331)
- [VK_KHR_shader_float_controls](#VK_KHR_shader_float_controls)
- [Other Extension Metadata](#_other_extension_metadata_331)
- [Other_Extension_Metadata](#_other_extension_metadata_331)
- [Description](#_description_331)
- [Promotion to Vulkan 1.2](#_promotion_to_vulkan_1_2_13)
- [Promotion_to_Vulkan_1.2](#_promotion_to_vulkan_1_2_13)
- [New Structures](#_new_structures_293)
- [New Enums](#_new_enums_96)
- [New Enum Constants](#_new_enum_constants_331)
- [New_Enum_Constants](#_new_enum_constants_331)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_43)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_43)
- [Issues](#_issues_139)
- [Version 4 API Incompatibility](#VK_KHR_shader_controls_v4_incompatibility)
- [Version_4_API_Incompatibility](#VK_KHR_shader_controls_v4_incompatibility)
- [Version History](#_version_history_332)
- [VK_KHR_shader_float_controls2](#VK_KHR_shader_float_controls2)
- [Other Extension Metadata](#_other_extension_metadata_332)
- [Other_Extension_Metadata](#_other_extension_metadata_332)
- [Description](#_description_332)
- [New Structures](#_new_structures_294)
- [New Enum Constants](#_new_enum_constants_332)
- [New_Enum_Constants](#_new_enum_constants_332)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_44)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_44)
- [Promotion to Vulkan 1.4](#_promotion_to_vulkan_1_4_15)
- [Promotion_to_Vulkan_1.4](#_promotion_to_vulkan_1_4_15)
- [Version History](#_version_history_333)
- [VK_KHR_shader_integer_dot_product](#VK_KHR_shader_integer_dot_product)
- [Other Extension Metadata](#_other_extension_metadata_333)
- [Other_Extension_Metadata](#_other_extension_metadata_333)
- [Description](#_description_333)
- [New Structures](#_new_structures_295)
- [New Enum Constants](#_new_enum_constants_333)
- [New_Enum_Constants](#_new_enum_constants_333)
- [Promotion to Vulkan 1.3](#_promotion_to_vulkan_1_3_6)
- [Promotion_to_Vulkan_1.3](#_promotion_to_vulkan_1_3_6)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_45)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_45)
- [Version History](#_version_history_334)
- [VK_KHR_shader_non_semantic_info](#VK_KHR_shader_non_semantic_info)
- [Other Extension Metadata](#_other_extension_metadata_334)
- [Other_Extension_Metadata](#_other_extension_metadata_334)
- [Description](#_description_334)
- [New Enum Constants](#_new_enum_constants_334)
- [New_Enum_Constants](#_new_enum_constants_334)
- [Promotion to Vulkan 1.3](#_promotion_to_vulkan_1_3_7)
- [Promotion_to_Vulkan_1.3](#_promotion_to_vulkan_1_3_7)
- [Version History](#_version_history_335)
- [VK_KHR_shader_subgroup_extended_types](#VK_KHR_shader_subgroup_extended_types)
- [Other Extension Metadata](#_other_extension_metadata_335)
- [Other_Extension_Metadata](#_other_extension_metadata_335)
- [Description](#_description_335)
- [Promotion to Vulkan 1.2](#_promotion_to_vulkan_1_2_14)
- [Promotion_to_Vulkan_1.2](#_promotion_to_vulkan_1_2_14)
- [New Structures](#_new_structures_296)
- [New Enum Constants](#_new_enum_constants_335)
- [New_Enum_Constants](#_new_enum_constants_335)
- [Version History](#_version_history_336)
- [VK_KHR_shader_subgroup_rotate](#VK_KHR_shader_subgroup_rotate)
- [New Structures](#_new_structures_297)
- [New Enum Constants](#_new_enum_constants_336)
- [New_Enum_Constants](#_new_enum_constants_336)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_46)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_46)
- [Promotion to Vulkan 1.4](#_promotion_to_vulkan_1_4_16)
- [Promotion_to_Vulkan_1.4](#_promotion_to_vulkan_1_4_16)
- [Version History](#_version_history_337)
- [VK_KHR_shader_terminate_invocation](#VK_KHR_shader_terminate_invocation)
- [Other Extension Metadata](#_other_extension_metadata_336)
- [Other_Extension_Metadata](#_other_extension_metadata_336)
- [Description](#_description_336)
- [New Structures](#_new_structures_298)
- [New Enum Constants](#_new_enum_constants_337)
- [New_Enum_Constants](#_new_enum_constants_337)
- [Promotion to Vulkan 1.3](#_promotion_to_vulkan_1_3_8)
- [Promotion_to_Vulkan_1.3](#_promotion_to_vulkan_1_3_8)
- [Version History](#_version_history_338)
- [VK_KHR_spirv_1_4](#VK_KHR_spirv_1_4)
- [Other Extension Metadata](#_other_extension_metadata_337)
- [Other_Extension_Metadata](#_other_extension_metadata_337)
- [Description](#_description_337)
- [Promotion to Vulkan 1.2](#_promotion_to_vulkan_1_2_15)
- [Promotion_to_Vulkan_1.2](#_promotion_to_vulkan_1_2_15)
- [New Enum Constants](#_new_enum_constants_338)
- [New_Enum_Constants](#_new_enum_constants_338)
- [Issues](#_issues_140)
- [Version History](#_version_history_339)
- [VK_KHR_storage_buffer_storage_class](#VK_KHR_storage_buffer_storage_class)
- [Other Extension Metadata](#_other_extension_metadata_338)
- [Other_Extension_Metadata](#_other_extension_metadata_338)
- [Description](#_description_338)
- [Promotion to Vulkan 1.1](#_promotion_to_vulkan_1_1_22)
- [Promotion_to_Vulkan_1.1](#_promotion_to_vulkan_1_1_22)
- [New Enum Constants](#_new_enum_constants_339)
- [New_Enum_Constants](#_new_enum_constants_339)
- [Version History](#_version_history_340)
- [VK_KHR_synchronization2](#VK_KHR_synchronization2)
- [Other Extension Metadata](#_other_extension_metadata_339)
- [Other_Extension_Metadata](#_other_extension_metadata_339)
- [Description](#_description_339)
- [New Base Types](#_new_base_types_6)
- [New_Base_Types](#_new_base_types_6)
- [New Commands](#_new_commands_143)
- [New Structures](#_new_structures_299)
- [New Enums](#_new_enums_97)
- [New Bitmasks](#_new_bitmasks_74)
- [New Enum Constants](#_new_enum_constants_340)
- [New_Enum_Constants](#_new_enum_constants_340)
- [Promotion to Vulkan 1.3](#_promotion_to_vulkan_1_3_9)
- [Promotion_to_Vulkan_1.3](#_promotion_to_vulkan_1_3_9)
- [Examples](#_examples_36)
- [Version History](#_version_history_341)
- [VK_KHR_timeline_semaphore](#VK_KHR_timeline_semaphore)
- [Other Extension Metadata](#_other_extension_metadata_340)
- [Other_Extension_Metadata](#_other_extension_metadata_340)
- [Description](#_description_340)
- [Promotion to Vulkan 1.2](#_promotion_to_vulkan_1_2_16)
- [Promotion_to_Vulkan_1.2](#_promotion_to_vulkan_1_2_16)
- [New Commands](#_new_commands_144)
- [New Structures](#_new_structures_300)
- [New Enums](#_new_enums_98)
- [New Bitmasks](#_new_bitmasks_75)
- [New Enum Constants](#_new_enum_constants_341)
- [New_Enum_Constants](#_new_enum_constants_341)
- [Issues](#_issues_141)
- [Version History](#_version_history_342)
- [VK_KHR_uniform_buffer_standard_layout](#VK_KHR_uniform_buffer_standard_layout)
- [Other Extension Metadata](#_other_extension_metadata_341)
- [Other_Extension_Metadata](#_other_extension_metadata_341)
- [Description](#_description_341)
- [Promotion to Vulkan 1.2](#_promotion_to_vulkan_1_2_17)
- [Promotion_to_Vulkan_1.2](#_promotion_to_vulkan_1_2_17)
- [New Structures](#_new_structures_301)
- [New Enum Constants](#_new_enum_constants_342)
- [New_Enum_Constants](#_new_enum_constants_342)
- [Version History](#_version_history_343)
- [VK_KHR_variable_pointers](#VK_KHR_variable_pointers)
- [Other Extension Metadata](#_other_extension_metadata_342)
- [Other_Extension_Metadata](#_other_extension_metadata_342)
- [Description](#_description_342)
- [Promotion to Vulkan 1.1](#_promotion_to_vulkan_1_1_23)
- [Promotion_to_Vulkan_1.1](#_promotion_to_vulkan_1_1_23)
- [Promotion to Vulkan 1.4](#_promotion_to_vulkan_1_4_17)
- [Promotion_to_Vulkan_1.4](#_promotion_to_vulkan_1_4_17)
- [New Structures](#_new_structures_302)
- [New Enum Constants](#_new_enum_constants_343)
- [New_Enum_Constants](#_new_enum_constants_343)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_47)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_47)
- [Issues](#_issues_142)
- [Version History](#_version_history_344)
- [VK_KHR_vertex_attribute_divisor](#VK_KHR_vertex_attribute_divisor)
- [Other Extension Metadata](#_other_extension_metadata_343)
- [Other_Extension_Metadata](#_other_extension_metadata_343)
- [Description](#_description_343)
- [New Structures](#_new_structures_303)
- [New Enum Constants](#_new_enum_constants_344)
- [New_Enum_Constants](#_new_enum_constants_344)
- [Promotion to Vulkan 1.4](#_promotion_to_vulkan_1_4_18)
- [Promotion_to_Vulkan_1.4](#_promotion_to_vulkan_1_4_18)
- [Version History](#_version_history_345)
- [VK_KHR_vulkan_memory_model](#VK_KHR_vulkan_memory_model)
- [Other Extension Metadata](#_other_extension_metadata_344)
- [Other_Extension_Metadata](#_other_extension_metadata_344)
- [Description](#_description_344)
- [Promotion to Vulkan 1.2](#_promotion_to_vulkan_1_2_18)
- [Promotion_to_Vulkan_1.2](#_promotion_to_vulkan_1_2_18)
- [Promotion to Vulkan 1.3](#_promotion_to_vulkan_1_3_10)
- [Promotion_to_Vulkan_1.3](#_promotion_to_vulkan_1_3_10)
- [New Structures](#_new_structures_304)
- [New Enum Constants](#_new_enum_constants_345)
- [New_Enum_Constants](#_new_enum_constants_345)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_48)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_48)
- [Version History](#_version_history_346)
- [VK_KHR_zero_initialize_workgroup_memory](#VK_KHR_zero_initialize_workgroup_memory)
- [Other Extension Metadata](#_other_extension_metadata_345)
- [Other_Extension_Metadata](#_other_extension_metadata_345)
- [Description](#_description_345)
- [New Structures](#_new_structures_305)
- [New Enum Constants](#_new_enum_constants_346)
- [New_Enum_Constants](#_new_enum_constants_346)
- [Promotion to Vulkan 1.3](#_promotion_to_vulkan_1_3_11)
- [Promotion_to_Vulkan_1.3](#_promotion_to_vulkan_1_3_11)
- [Version History](#_version_history_347)
- [VK_EXT_4444_formats](#VK_EXT_4444_formats)
- [Other Extension Metadata](#_other_extension_metadata_346)
- [Other_Extension_Metadata](#_other_extension_metadata_346)
- [Description](#_description_346)
- [New Structures](#_new_structures_306)
- [New Enum Constants](#_new_enum_constants_347)
- [New_Enum_Constants](#_new_enum_constants_347)
- [Promotion to Vulkan 1.3](#_promotion_to_vulkan_1_3_12)
- [Promotion_to_Vulkan_1.3](#_promotion_to_vulkan_1_3_12)
- [Version History](#_version_history_348)
- [VK_EXT_buffer_device_address](#VK_EXT_buffer_device_address)
- [Other Extension Metadata](#_other_extension_metadata_347)
- [Other_Extension_Metadata](#_other_extension_metadata_347)
- [Description](#_description_347)
- [New Commands](#_new_commands_145)
- [New Structures](#_new_structures_307)
- [New Enum Constants](#_new_enum_constants_348)
- [New_Enum_Constants](#_new_enum_constants_348)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_49)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_49)
- [Issues](#_issues_143)
- [Version History](#_version_history_349)
- [VK_EXT_calibrated_timestamps](#VK_EXT_calibrated_timestamps)
- [Other Extension Metadata](#_other_extension_metadata_348)
- [Other_Extension_Metadata](#_other_extension_metadata_348)
- [Description](#_description_348)
- [Promotion to VK_KHR_calibrated_timestamps](#_promotion_to_vk_khr_calibrated_timestamps)
- [Promotion_to_VK_KHR_calibrated_timestamps](#_promotion_to_vk_khr_calibrated_timestamps)
- [New Commands](#_new_commands_146)
- [New Structures](#_new_structures_308)
- [New Enums](#_new_enums_99)
- [New Enum Constants](#_new_enum_constants_349)
- [New_Enum_Constants](#_new_enum_constants_349)
- [Version History](#_version_history_350)
- [VK_EXT_debug_marker](#VK_EXT_debug_marker)
- [Other Extension Metadata](#_other_extension_metadata_349)
- [Other_Extension_Metadata](#_other_extension_metadata_349)
- [Description](#_description_349)
- [New Commands](#_new_commands_147)
- [New Structures](#_new_structures_309)
- [New Enums](#_new_enums_100)
- [New Enum Constants](#_new_enum_constants_350)
- [New_Enum_Constants](#_new_enum_constants_350)
- [Examples](#_examples_37)
- [Issues](#_issues_144)
- [Version History](#_version_history_351)
- [VK_EXT_debug_report](#VK_EXT_debug_report)
- [Other Extension Metadata](#_other_extension_metadata_350)
- [Other_Extension_Metadata](#_other_extension_metadata_350)
- [Description](#_description_350)
- [New Object Types](#_new_object_types_22)
- [New_Object_Types](#_new_object_types_22)
- [New Commands](#_new_commands_148)
- [New Structures](#_new_structures_310)
- [New Function Pointers](#_new_function_pointers_4)
- [New_Function_Pointers](#_new_function_pointers_4)
- [New Enums](#_new_enums_101)
- [New Bitmasks](#_new_bitmasks_76)
- [New Enum Constants](#_new_enum_constants_351)
- [New_Enum_Constants](#_new_enum_constants_351)
- [Examples](#_examples_38)
- [Issues](#_issues_145)
- [Version History](#_version_history_352)
- [VK_EXT_depth_clamp_zero_one](#VK_EXT_depth_clamp_zero_one)
- [Other Extension Metadata](#_other_extension_metadata_351)
- [Other_Extension_Metadata](#_other_extension_metadata_351)
- [Description](#_description_351)
- [Promotion to VK_KHR_depth_clamp_zero_one](#_promotion_to_vk_khr_depth_clamp_zero_one)
- [Promotion_to_VK_KHR_depth_clamp_zero_one](#_promotion_to_vk_khr_depth_clamp_zero_one)
- [New Structures](#_new_structures_311)
- [New Enum Constants](#_new_enum_constants_352)
- [New_Enum_Constants](#_new_enum_constants_352)
- [Version History](#_version_history_353)
- [VK_EXT_descriptor_indexing](#VK_EXT_descriptor_indexing)
- [Other Extension Metadata](#_other_extension_metadata_352)
- [Other_Extension_Metadata](#_other_extension_metadata_352)
- [Description](#_description_352)
- [Promotion to Vulkan 1.2](#_promotion_to_vulkan_1_2_19)
- [Promotion_to_Vulkan_1.2](#_promotion_to_vulkan_1_2_19)
- [Promotion to Vulkan 1.4](#_promotion_to_vulkan_1_4_19)
- [Promotion_to_Vulkan_1.4](#_promotion_to_vulkan_1_4_19)
- [New Structures](#_new_structures_312)
- [New Enums](#_new_enums_102)
- [New Bitmasks](#_new_bitmasks_77)
- [New Enum Constants](#_new_enum_constants_353)
- [New_Enum_Constants](#_new_enum_constants_353)
- [Version History](#_version_history_354)
- [VK_EXT_extended_dynamic_state](#VK_EXT_extended_dynamic_state)
- [Other Extension Metadata](#_other_extension_metadata_353)
- [Other_Extension_Metadata](#_other_extension_metadata_353)
- [Description](#_description_353)
- [New Commands](#_new_commands_149)
- [New Structures](#_new_structures_313)
- [New Enum Constants](#_new_enum_constants_354)
- [New_Enum_Constants](#_new_enum_constants_354)
- [Promotion to Vulkan 1.3](#_promotion_to_vulkan_1_3_13)
- [Promotion_to_Vulkan_1.3](#_promotion_to_vulkan_1_3_13)
- [Issues](#_issues_146)
- [Version History](#_version_history_355)
- [VK_EXT_extended_dynamic_state2](#VK_EXT_extended_dynamic_state2)
- [Other Extension Metadata](#_other_extension_metadata_354)
- [Other_Extension_Metadata](#_other_extension_metadata_354)
- [Description](#_description_354)
- [New Commands](#_new_commands_150)
- [New Structures](#_new_structures_314)
- [New Enum Constants](#_new_enum_constants_355)
- [New_Enum_Constants](#_new_enum_constants_355)
- [Promotion to Vulkan 1.3](#_promotion_to_vulkan_1_3_14)
- [Promotion_to_Vulkan_1.3](#_promotion_to_vulkan_1_3_14)
- [Version History](#_version_history_356)
- [VK_EXT_global_priority](#VK_EXT_global_priority)
- [Other Extension Metadata](#_other_extension_metadata_355)
- [Other_Extension_Metadata](#_other_extension_metadata_355)
- [Description](#_description_355)
- [New Structures](#_new_structures_315)
- [New Enums](#_new_enums_103)
- [New Enum Constants](#_new_enum_constants_356)
- [New_Enum_Constants](#_new_enum_constants_356)
- [Version History](#_version_history_357)
- [VK_EXT_global_priority_query](#VK_EXT_global_priority_query)
- [Other Extension Metadata](#_other_extension_metadata_356)
- [Other_Extension_Metadata](#_other_extension_metadata_356)
- [Description](#_description_356)
- [New Structures](#_new_structures_316)
- [New Enum Constants](#_new_enum_constants_357)
- [New_Enum_Constants](#_new_enum_constants_357)
- [Issues](#_issues_147)
- [Version History](#_version_history_358)
- [VK_EXT_host_image_copy](#VK_EXT_host_image_copy)
- [Other Extension Metadata](#_other_extension_metadata_357)
- [Other_Extension_Metadata](#_other_extension_metadata_357)
- [Description](#_description_357)
- [New Commands](#_new_commands_151)
- [New Structures](#_new_structures_317)
- [New Enums](#_new_enums_104)
- [New Bitmasks](#_new_bitmasks_78)
- [New Enum Constants](#_new_enum_constants_358)
- [New_Enum_Constants](#_new_enum_constants_358)
- [Promotion to Vulkan 1.4](#_promotion_to_vulkan_1_4_20)
- [Promotion_to_Vulkan_1.4](#_promotion_to_vulkan_1_4_20)
- [Issues](#_issues_148)
- [Version History](#_version_history_359)
- [VK_EXT_host_query_reset](#VK_EXT_host_query_reset)
- [Other Extension Metadata](#_other_extension_metadata_358)
- [Other_Extension_Metadata](#_other_extension_metadata_358)
- [Description](#_description_358)
- [Promotion to Vulkan 1.2](#_promotion_to_vulkan_1_2_20)
- [Promotion_to_Vulkan_1.2](#_promotion_to_vulkan_1_2_20)
- [New Commands](#_new_commands_152)
- [New Structures](#_new_structures_318)
- [New Enum Constants](#_new_enum_constants_359)
- [New_Enum_Constants](#_new_enum_constants_359)
- [Version History](#_version_history_360)
- [VK_EXT_image_robustness](#VK_EXT_image_robustness)
- [Other Extension Metadata](#_other_extension_metadata_359)
- [Other_Extension_Metadata](#_other_extension_metadata_359)
- [Description](#_description_359)
- [New Structures](#_new_structures_319)
- [New Enum Constants](#_new_enum_constants_360)
- [New_Enum_Constants](#_new_enum_constants_360)
- [Promotion to Vulkan 1.3](#_promotion_to_vulkan_1_3_15)
- [Promotion_to_Vulkan_1.3](#_promotion_to_vulkan_1_3_15)
- [Issues](#_issues_149)
- [Examples](#_examples_39)
- [Version History](#_version_history_361)
- [VK_EXT_index_type_uint8](#VK_EXT_index_type_uint8)
- [Other Extension Metadata](#_other_extension_metadata_360)
- [Other_Extension_Metadata](#_other_extension_metadata_360)
- [Description](#_description_360)
- [Promotion to VK_KHR_index_type_uint8](#_promotion_to_vk_khr_index_type_uint8)
- [Promotion_to_VK_KHR_index_type_uint8](#_promotion_to_vk_khr_index_type_uint8)
- [New Structures](#_new_structures_320)
- [New Enum Constants](#_new_enum_constants_361)
- [New_Enum_Constants](#_new_enum_constants_361)
- [Version History](#_version_history_362)
- [VK_EXT_inline_uniform_block](#VK_EXT_inline_uniform_block)
- [Other Extension Metadata](#_other_extension_metadata_361)
- [Other_Extension_Metadata](#_other_extension_metadata_361)
- [Description](#_description_361)
- [New Structures](#_new_structures_321)
- [New Enum Constants](#_new_enum_constants_362)
- [New_Enum_Constants](#_new_enum_constants_362)
- [Promotion to Vulkan 1.3](#_promotion_to_vulkan_1_3_16)
- [Promotion_to_Vulkan_1.3](#_promotion_to_vulkan_1_3_16)
- [Issues](#_issues_150)
- [Version History](#_version_history_363)
- [VK_EXT_line_rasterization](#VK_EXT_line_rasterization)
- [Other Extension Metadata](#_other_extension_metadata_362)
- [Other_Extension_Metadata](#_other_extension_metadata_362)
- [Description](#_description_362)
- [Promotion to VK_KHR_line_rasterization](#_promotion_to_vk_khr_line_rasterization)
- [Promotion_to_VK_KHR_line_rasterization](#_promotion_to_vk_khr_line_rasterization)
- [New Commands](#_new_commands_153)
- [New Structures](#_new_structures_322)
- [New Enums](#_new_enums_105)
- [New Enum Constants](#_new_enum_constants_363)
- [New_Enum_Constants](#_new_enum_constants_363)
- [Issues](#_issues_151)
- [Version History](#_version_history_364)
- [VK_EXT_load_store_op_none](#VK_EXT_load_store_op_none)
- [Other Extension Metadata](#_other_extension_metadata_363)
- [Other_Extension_Metadata](#_other_extension_metadata_363)
- [Description](#_description_363)
- [Promotion to VK_KHR_load_store_op_none](#_promotion_to_vk_khr_load_store_op_none)
- [Promotion_to_VK_KHR_load_store_op_none](#_promotion_to_vk_khr_load_store_op_none)
- [New Enum Constants](#_new_enum_constants_364)
- [New_Enum_Constants](#_new_enum_constants_364)
- [Version History](#_version_history_365)
- [VK_EXT_pipeline_creation_cache_control](#VK_EXT_pipeline_creation_cache_control)
- [Other Extension Metadata](#_other_extension_metadata_364)
- [Other_Extension_Metadata](#_other_extension_metadata_364)
- [Description](#_description_364)
- [Background](#_background)
- [New Structures](#_new_structures_323)
- [New Enums](#_new_enums_106)
- [New Enum Constants](#_new_enum_constants_365)
- [New_Enum_Constants](#_new_enum_constants_365)
- [Promotion to Vulkan 1.3](#_promotion_to_vulkan_1_3_17)
- [Promotion_to_Vulkan_1.3](#_promotion_to_vulkan_1_3_17)
- [Version History](#_version_history_366)
- [VK_EXT_pipeline_creation_feedback](#VK_EXT_pipeline_creation_feedback)
- [Other Extension Metadata](#_other_extension_metadata_365)
- [Other_Extension_Metadata](#_other_extension_metadata_365)
- [Description](#_description_365)
- [New Structures](#_new_structures_324)
- [New Enums](#_new_enums_107)
- [New Bitmasks](#_new_bitmasks_79)
- [New Enum Constants](#_new_enum_constants_366)
- [New_Enum_Constants](#_new_enum_constants_366)
- [Promotion to Vulkan 1.3](#_promotion_to_vulkan_1_3_18)
- [Promotion_to_Vulkan_1.3](#_promotion_to_vulkan_1_3_18)
- [Version History](#_version_history_367)
- [VK_EXT_pipeline_protected_access](#VK_EXT_pipeline_protected_access)
- [Other Extension Metadata](#_other_extension_metadata_366)
- [Other_Extension_Metadata](#_other_extension_metadata_366)
- [Description](#_description_366)
- [New Structures](#_new_structures_325)
- [New Enum Constants](#_new_enum_constants_367)
- [New_Enum_Constants](#_new_enum_constants_367)
- [Promotion to Vulkan 1.4](#_promotion_to_vulkan_1_4_21)
- [Promotion_to_Vulkan_1.4](#_promotion_to_vulkan_1_4_21)
- [Version History](#_version_history_368)
- [VK_EXT_pipeline_robustness](#VK_EXT_pipeline_robustness)
- [Other Extension Metadata](#_other_extension_metadata_367)
- [Other_Extension_Metadata](#_other_extension_metadata_367)
- [Description](#_description_367)
- [New Structures](#_new_structures_326)
- [New Enums](#_new_enums_108)
- [New Enum Constants](#_new_enum_constants_368)
- [New_Enum_Constants](#_new_enum_constants_368)
- [Promotion to Vulkan 1.4](#_promotion_to_vulkan_1_4_22)
- [Promotion_to_Vulkan_1.4](#_promotion_to_vulkan_1_4_22)
- [Version History](#_version_history_369)
- [VK_EXT_private_data](#VK_EXT_private_data)
- [Other Extension Metadata](#_other_extension_metadata_368)
- [Other_Extension_Metadata](#_other_extension_metadata_368)
- [Description](#_description_368)
- [New Object Types](#_new_object_types_23)
- [New_Object_Types](#_new_object_types_23)
- [New Commands](#_new_commands_154)
- [New Structures](#_new_structures_327)
- [New Bitmasks](#_new_bitmasks_80)
- [New Enum Constants](#_new_enum_constants_369)
- [New_Enum_Constants](#_new_enum_constants_369)
- [Promotion to Vulkan 1.3](#_promotion_to_vulkan_1_3_19)
- [Promotion_to_Vulkan_1.3](#_promotion_to_vulkan_1_3_19)
- [Examples](#_examples_40)
- [Issues](#_issues_152)
- [Version History](#_version_history_370)
- [VK_EXT_robustness2](#VK_EXT_robustness2)
- [Other Extension Metadata](#_other_extension_metadata_369)
- [Other_Extension_Metadata](#_other_extension_metadata_369)
- [Description](#_description_369)
- [Promotion to VK_KHR_robustness2](#_promotion_to_vk_khr_robustness2)
- [Promotion_to_VK_KHR_robustness2](#_promotion_to_vk_khr_robustness2)
- [New Structures](#_new_structures_328)
- [New Enum Constants](#_new_enum_constants_370)
- [New_Enum_Constants](#_new_enum_constants_370)
- [Issues](#_issues_153)
- [Examples](#_examples_41)
- [Version History](#_version_history_371)
- [VK_EXT_sampler_filter_minmax](#VK_EXT_sampler_filter_minmax)
- [Other Extension Metadata](#_other_extension_metadata_370)
- [Other_Extension_Metadata](#_other_extension_metadata_370)
- [Description](#_description_370)
- [Promotion to Vulkan 1.2](#_promotion_to_vulkan_1_2_21)
- [Promotion_to_Vulkan_1.2](#_promotion_to_vulkan_1_2_21)
- [New Structures](#_new_structures_329)
- [New Enums](#_new_enums_109)
- [New Enum Constants](#_new_enum_constants_371)
- [New_Enum_Constants](#_new_enum_constants_371)
- [Version History](#_version_history_372)
- [VK_EXT_scalar_block_layout](#VK_EXT_scalar_block_layout)
- [Other Extension Metadata](#_other_extension_metadata_371)
- [Other_Extension_Metadata](#_other_extension_metadata_371)
- [Description](#_description_371)
- [Promotion to Vulkan 1.2](#_promotion_to_vulkan_1_2_22)
- [Promotion_to_Vulkan_1.2](#_promotion_to_vulkan_1_2_22)
- [Promotion to Vulkan 1.4](#_promotion_to_vulkan_1_4_23)
- [Promotion_to_Vulkan_1.4](#_promotion_to_vulkan_1_4_23)
- [New Structures](#_new_structures_330)
- [New Enum Constants](#_new_enum_constants_372)
- [New_Enum_Constants](#_new_enum_constants_372)
- [Version History](#_version_history_373)
- [VK_EXT_separate_stencil_usage](#VK_EXT_separate_stencil_usage)
- [Other Extension Metadata](#_other_extension_metadata_372)
- [Other_Extension_Metadata](#_other_extension_metadata_372)
- [Description](#_description_372)
- [Promotion to Vulkan 1.2](#_promotion_to_vulkan_1_2_23)
- [Promotion_to_Vulkan_1.2](#_promotion_to_vulkan_1_2_23)
- [New Structures](#_new_structures_331)
- [New Enum Constants](#_new_enum_constants_373)
- [New_Enum_Constants](#_new_enum_constants_373)
- [Version History](#_version_history_374)
- [VK_EXT_shader_demote_to_helper_invocation](#VK_EXT_shader_demote_to_helper_invocation)
- [Other Extension Metadata](#_other_extension_metadata_373)
- [Other_Extension_Metadata](#_other_extension_metadata_373)
- [Description](#_description_373)
- [New Structures](#_new_structures_332)
- [New Enum Constants](#_new_enum_constants_374)
- [New_Enum_Constants](#_new_enum_constants_374)
- [New SPIR-V Capability](#_new_spir_v_capability_7)
- [New_SPIR-V_Capability](#_new_spir_v_capability_7)
- [Promotion to Vulkan 1.3](#_promotion_to_vulkan_1_3_20)
- [Promotion_to_Vulkan_1.3](#_promotion_to_vulkan_1_3_20)
- [Version History](#_version_history_375)
- [VK_EXT_shader_subgroup_ballot](#VK_EXT_shader_subgroup_ballot)
- [Other Extension Metadata](#_other_extension_metadata_374)
- [Other_Extension_Metadata](#_other_extension_metadata_374)
- [Description](#_description_374)
- [Deprecated by Vulkan 1.2](#_deprecated_by_vulkan_1_2)
- [Deprecated_by_Vulkan_1.2](#_deprecated_by_vulkan_1_2)
- [New Enum Constants](#_new_enum_constants_375)
- [New_Enum_Constants](#_new_enum_constants_375)
- [New Built-In Variables](#_new_built_in_variables_10)
- [New_Built-In_Variables](#_new_built_in_variables_10)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_50)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_50)
- [Version History](#_version_history_376)
- [VK_EXT_shader_subgroup_vote](#VK_EXT_shader_subgroup_vote)
- [Other Extension Metadata](#_other_extension_metadata_375)
- [Other_Extension_Metadata](#_other_extension_metadata_375)
- [Description](#_description_375)
- [Deprecated by Vulkan 1.1](#_deprecated_by_vulkan_1_1)
- [Deprecated_by_Vulkan_1.1](#_deprecated_by_vulkan_1_1)
- [New Enum Constants](#_new_enum_constants_376)
- [New_Enum_Constants](#_new_enum_constants_376)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_51)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_51)
- [Version History](#_version_history_377)
- [VK_EXT_shader_viewport_index_layer](#VK_EXT_shader_viewport_index_layer)
- [Other Extension Metadata](#_other_extension_metadata_376)
- [Other_Extension_Metadata](#_other_extension_metadata_376)
- [Description](#_description_376)
- [Promotion to Vulkan 1.2](#_promotion_to_vulkan_1_2_24)
- [Promotion_to_Vulkan_1.2](#_promotion_to_vulkan_1_2_24)
- [New Enum Constants](#_new_enum_constants_377)
- [New_Enum_Constants](#_new_enum_constants_377)
- [New or Modified Built-In Variables](#_new_or_modified_built_in_variables_12)
- [New_or_Modified_Built-In_Variables](#_new_or_modified_built_in_variables_12)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_52)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_52)
- [Version History](#_version_history_378)
- [VK_EXT_subgroup_size_control](#VK_EXT_subgroup_size_control)
- [Other Extension Metadata](#_other_extension_metadata_377)
- [Other_Extension_Metadata](#_other_extension_metadata_377)
- [Description](#_description_377)
- [New Structures](#_new_structures_333)
- [New Enum Constants](#_new_enum_constants_378)
- [New_Enum_Constants](#_new_enum_constants_378)
- [Promotion to Vulkan 1.3](#_promotion_to_vulkan_1_3_21)
- [Promotion_to_Vulkan_1.3](#_promotion_to_vulkan_1_3_21)
- [Version History](#_version_history_379)
- [VK_EXT_texel_buffer_alignment](#VK_EXT_texel_buffer_alignment)
- [Other Extension Metadata](#_other_extension_metadata_378)
- [Other_Extension_Metadata](#_other_extension_metadata_378)
- [Description](#_description_378)
- [New Structures](#_new_structures_334)
- [New Enum Constants](#_new_enum_constants_379)
- [New_Enum_Constants](#_new_enum_constants_379)
- [Promotion to Vulkan 1.3](#_promotion_to_vulkan_1_3_22)
- [Promotion_to_Vulkan_1.3](#_promotion_to_vulkan_1_3_22)
- [Version History](#_version_history_380)
- [VK_EXT_texture_compression_astc_hdr](#VK_EXT_texture_compression_astc_hdr)
- [Other Extension Metadata](#_other_extension_metadata_379)
- [Other_Extension_Metadata](#_other_extension_metadata_379)
- [Description](#_description_379)
- [New Structures](#_new_structures_335)
- [New Enum Constants](#_new_enum_constants_380)
- [New_Enum_Constants](#_new_enum_constants_380)
- [Promotion to Vulkan 1.3](#_promotion_to_vulkan_1_3_23)
- [Promotion_to_Vulkan_1.3](#_promotion_to_vulkan_1_3_23)
- [Issues](#_issues_154)
- [Version History](#_version_history_381)
- [VK_EXT_tooling_info](#VK_EXT_tooling_info)
- [Other Extension Metadata](#_other_extension_metadata_380)
- [Other_Extension_Metadata](#_other_extension_metadata_380)
- [Description](#_description_380)
- [New Commands](#_new_commands_155)
- [New Structures](#_new_structures_336)
- [New Enums](#_new_enums_110)
- [New Bitmasks](#_new_bitmasks_81)
- [New Enum Constants](#_new_enum_constants_381)
- [New_Enum_Constants](#_new_enum_constants_381)
- [Promotion to Vulkan 1.3](#_promotion_to_vulkan_1_3_24)
- [Promotion_to_Vulkan_1.3](#_promotion_to_vulkan_1_3_24)
- [Examples](#_examples_42)
- [Issues](#_issues_155)
- [Version History](#_version_history_382)
- [VK_EXT_validation_features](#VK_EXT_validation_features)
- [Other Extension Metadata](#_other_extension_metadata_381)
- [Other_Extension_Metadata](#_other_extension_metadata_381)
- [Description](#_description_381)
- [Deprecation by VK_EXT_layer_settings](#_deprecation_by_vk_ext_layer_settings)
- [Deprecation_by_VK_EXT_layer_settings](#_deprecation_by_vk_ext_layer_settings)
- [New Structures](#_new_structures_337)
- [New Enums](#_new_enums_111)
- [New Enum Constants](#_new_enum_constants_382)
- [New_Enum_Constants](#_new_enum_constants_382)
- [Version History](#_version_history_383)
- [VK_EXT_validation_flags](#VK_EXT_validation_flags)
- [Other Extension Metadata](#_other_extension_metadata_382)
- [Other_Extension_Metadata](#_other_extension_metadata_382)
- [Description](#_description_382)
- [Deprecation by VK_EXT_layer_settings](#_deprecation_by_vk_ext_layer_settings_2)
- [Deprecation_by_VK_EXT_layer_settings](#_deprecation_by_vk_ext_layer_settings_2)
- [New Structures](#_new_structures_338)
- [New Enums](#_new_enums_112)
- [New Enum Constants](#_new_enum_constants_383)
- [New_Enum_Constants](#_new_enum_constants_383)
- [Version History](#_version_history_384)
- [VK_EXT_vertex_attribute_divisor](#VK_EXT_vertex_attribute_divisor)
- [Other Extension Metadata](#_other_extension_metadata_383)
- [Other_Extension_Metadata](#_other_extension_metadata_383)
- [Description](#_description_383)
- [New Structures](#_new_structures_339)
- [New Enum Constants](#_new_enum_constants_384)
- [New_Enum_Constants](#_new_enum_constants_384)
- [Issues](#_issues_156)
- [Examples](#_examples_43)
- [Version History](#_version_history_385)
- [VK_EXT_ycbcr_2plane_444_formats](#VK_EXT_ycbcr_2plane_444_formats)
- [Other Extension Metadata](#_other_extension_metadata_384)
- [Other_Extension_Metadata](#_other_extension_metadata_384)
- [Description](#_description_384)
- [New Structures](#_new_structures_340)
- [New Enum Constants](#_new_enum_constants_385)
- [New_Enum_Constants](#_new_enum_constants_385)
- [Promotion to Vulkan 1.3](#_promotion_to_vulkan_1_3_25)
- [Promotion_to_Vulkan_1.3](#_promotion_to_vulkan_1_3_25)
- [Version History](#_version_history_386)
- [VK_AMD_draw_indirect_count](#VK_AMD_draw_indirect_count)
- [Other Extension Metadata](#_other_extension_metadata_385)
- [Other_Extension_Metadata](#_other_extension_metadata_385)
- [Description](#_description_385)
- [Promotion to VK_KHR_draw_indirect_count](#_promotion_to_vk_khr_draw_indirect_count)
- [Promotion_to_VK_KHR_draw_indirect_count](#_promotion_to_vk_khr_draw_indirect_count)
- [New Commands](#_new_commands_156)
- [New Enum Constants](#_new_enum_constants_386)
- [New_Enum_Constants](#_new_enum_constants_386)
- [Version History](#_version_history_387)
- [VK_AMD_gpu_shader_half_float](#VK_AMD_gpu_shader_half_float)
- [Other Extension Metadata](#_other_extension_metadata_386)
- [Other_Extension_Metadata](#_other_extension_metadata_386)
- [Description](#_description_386)
- [Deprecation by VK_KHR_shader_float16_int8](#_deprecation_by_vk_khr_shader_float16_int8)
- [Deprecation_by_VK_KHR_shader_float16_int8](#_deprecation_by_vk_khr_shader_float16_int8)
- [New Enum Constants](#_new_enum_constants_387)
- [New_Enum_Constants](#_new_enum_constants_387)
- [Version History](#_version_history_388)
- [VK_AMD_gpu_shader_int16](#VK_AMD_gpu_shader_int16)
- [Other Extension Metadata](#_other_extension_metadata_387)
- [Other_Extension_Metadata](#_other_extension_metadata_387)
- [Description](#_description_387)
- [Deprecation by VK_KHR_shader_float16_int8](#_deprecation_by_vk_khr_shader_float16_int8_2)
- [Deprecation_by_VK_KHR_shader_float16_int8](#_deprecation_by_vk_khr_shader_float16_int8_2)
- [New Enum Constants](#_new_enum_constants_388)
- [New_Enum_Constants](#_new_enum_constants_388)
- [Version History](#_version_history_389)
- [VK_AMD_negative_viewport_height](#VK_AMD_negative_viewport_height)
- [Other Extension Metadata](#_other_extension_metadata_388)
- [Other_Extension_Metadata](#_other_extension_metadata_388)
- [Description](#_description_388)
- [Obsoletion by VK_KHR_maintenance1 and Vulkan 1.1](#_obsoletion_by_vk_khr_maintenance1_and_vulkan_1_1)
- [Obsoletion_by_VK_KHR_maintenance1_and_Vulkan_1.1](#_obsoletion_by_vk_khr_maintenance1_and_vulkan_1_1)
- [New Enum Constants](#_new_enum_constants_389)
- [New_Enum_Constants](#_new_enum_constants_389)
- [Version History](#_version_history_390)
- [VK_ARM_rasterization_order_attachment_access](#VK_ARM_rasterization_order_attachment_access)
- [Other Extension Metadata](#_other_extension_metadata_389)
- [Other_Extension_Metadata](#_other_extension_metadata_389)
- [Description](#_description_389)
- [New Structures](#_new_structures_341)
- [New Enum Constants](#_new_enum_constants_390)
- [New_Enum_Constants](#_new_enum_constants_390)
- [Issues](#_issues_157)
- [Examples](#_examples_44)
- [Version History](#_version_history_391)
- [VK_IMG_format_pvrtc](#VK_IMG_format_pvrtc)
- [Other Extension Metadata](#_other_extension_metadata_390)
- [Other_Extension_Metadata](#_other_extension_metadata_390)
- [Description](#_description_390)
- [Deprecation](#_deprecation)
- [New Enum Constants](#_new_enum_constants_391)
- [New_Enum_Constants](#_new_enum_constants_391)
- [Version History](#_version_history_392)
- [VK_MVK_ios_surface](#VK_MVK_ios_surface)
- [Other Extension Metadata](#_other_extension_metadata_391)
- [Other_Extension_Metadata](#_other_extension_metadata_391)
- [Description](#_description_391)
- [Deprecation by VK_EXT_metal_surface](#_deprecation_by_vk_ext_metal_surface)
- [Deprecation_by_VK_EXT_metal_surface](#_deprecation_by_vk_ext_metal_surface)
- [New Commands](#_new_commands_157)
- [New Structures](#_new_structures_342)
- [New Bitmasks](#_new_bitmasks_82)
- [New Enum Constants](#_new_enum_constants_392)
- [New_Enum_Constants](#_new_enum_constants_392)
- [Version History](#_version_history_393)
- [VK_MVK_macos_surface](#VK_MVK_macos_surface)
- [Other Extension Metadata](#_other_extension_metadata_392)
- [Other_Extension_Metadata](#_other_extension_metadata_392)
- [Description](#_description_392)
- [Deprecation by VK_EXT_metal_surface](#_deprecation_by_vk_ext_metal_surface_2)
- [Deprecation_by_VK_EXT_metal_surface](#_deprecation_by_vk_ext_metal_surface_2)
- [New Commands](#_new_commands_158)
- [New Structures](#_new_structures_343)
- [New Bitmasks](#_new_bitmasks_83)
- [New Enum Constants](#_new_enum_constants_393)
- [New_Enum_Constants](#_new_enum_constants_393)
- [Version History](#_version_history_394)
- [VK_NV_compute_shader_derivatives](#VK_NV_compute_shader_derivatives)
- [Other Extension Metadata](#_other_extension_metadata_393)
- [Other_Extension_Metadata](#_other_extension_metadata_393)
- [Description](#_description_393)
- [New Structures](#_new_structures_344)
- [New Enum Constants](#_new_enum_constants_394)
- [New_Enum_Constants](#_new_enum_constants_394)
- [New SPIR-V Capability](#_new_spir_v_capability_8)
- [New_SPIR-V_Capability](#_new_spir_v_capability_8)
- [Issues](#_issues_158)
- [Examples](#_examples_45)
- [Version History](#_version_history_395)
- [VK_NV_dedicated_allocation](#VK_NV_dedicated_allocation)
- [Other Extension Metadata](#_other_extension_metadata_394)
- [Other_Extension_Metadata](#_other_extension_metadata_394)
- [Description](#_description_394)
- [New Structures](#_new_structures_345)
- [New Enum Constants](#_new_enum_constants_395)
- [New_Enum_Constants](#_new_enum_constants_395)
- [Examples](#_examples_46)
- [Version History](#_version_history_396)
- [VK_NV_displacement_micromap](#VK_NV_displacement_micromap)
- [Other Extension Metadata](#_other_extension_metadata_395)
- [Other_Extension_Metadata](#_other_extension_metadata_395)
- [Description](#_description_395)
- [New Structures](#_new_structures_346)
- [New Enums](#_new_enums_113)
- [New Enum Constants](#_new_enum_constants_396)
- [New_Enum_Constants](#_new_enum_constants_396)
- [Issues](#_issues_159)
- [Version History](#_version_history_397)
- [VK_NV_external_memory](#VK_NV_external_memory)
- [Other Extension Metadata](#_other_extension_metadata_396)
- [Other_Extension_Metadata](#_other_extension_metadata_396)
- [Description](#_description_396)
- [New Structures](#_new_structures_347)
- [New Enum Constants](#_new_enum_constants_397)
- [New_Enum_Constants](#_new_enum_constants_397)
- [Issues](#_issues_160)
- [Examples](#_examples_47)
- [Version History](#_version_history_398)
- [VK_NV_external_memory_capabilities](#VK_NV_external_memory_capabilities)
- [Other Extension Metadata](#_other_extension_metadata_397)
- [Other_Extension_Metadata](#_other_extension_metadata_397)
- [Description](#_description_397)
- [New Commands](#_new_commands_159)
- [New Structures](#_new_structures_348)
- [New Enums](#_new_enums_114)
- [New Bitmasks](#_new_bitmasks_84)
- [New Enum Constants](#_new_enum_constants_398)
- [New_Enum_Constants](#_new_enum_constants_398)
- [Issues](#_issues_161)
- [Version History](#_version_history_399)
- [VK_NV_external_memory_win32](#VK_NV_external_memory_win32)
- [Other Extension Metadata](#_other_extension_metadata_398)
- [Other_Extension_Metadata](#_other_extension_metadata_398)
- [Description](#_description_398)
- [New Commands](#_new_commands_160)
- [New Structures](#_new_structures_349)
- [New Enum Constants](#_new_enum_constants_399)
- [New_Enum_Constants](#_new_enum_constants_399)
- [Issues](#_issues_162)
- [Examples](#_examples_48)
- [Version History](#_version_history_400)
- [VK_NV_fragment_shader_barycentric](#VK_NV_fragment_shader_barycentric)
- [Other Extension Metadata](#_other_extension_metadata_399)
- [Other_Extension_Metadata](#_other_extension_metadata_399)
- [Description](#_description_399)
- [Promotion to VK_KHR_fragment_shader_barycentric](#_promotion_to_vk_khr_fragment_shader_barycentric)
- [Promotion_to_VK_KHR_fragment_shader_barycentric](#_promotion_to_vk_khr_fragment_shader_barycentric)
- [New Structures](#_new_structures_350)
- [New Enum Constants](#_new_enum_constants_400)
- [New_Enum_Constants](#_new_enum_constants_400)
- [New Built-In Variables](#_new_built_in_variables_11)
- [New_Built-In_Variables](#_new_built_in_variables_11)
- [New SPIR-V Decorations](#_new_spir_v_decorations_2)
- [New_SPIR-V_Decorations](#_new_spir_v_decorations_2)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_53)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_53)
- [Issues](#_issues_163)
- [Version History](#_version_history_401)
- [VK_NV_glsl_shader](#VK_NV_glsl_shader)
- [Other Extension Metadata](#_other_extension_metadata_400)
- [Other_Extension_Metadata](#_other_extension_metadata_400)
- [Description](#_description_400)
- [Deprecation](#_deprecation_2)
- [New Enum Constants](#_new_enum_constants_401)
- [New_Enum_Constants](#_new_enum_constants_401)
- [Examples](#_examples_49)
- [Version History](#_version_history_402)
- [VK_NV_ray_tracing](#VK_NV_ray_tracing)
- [Other Extension Metadata](#_other_extension_metadata_401)
- [Other_Extension_Metadata](#_other_extension_metadata_401)
- [Description](#_description_401)
- [New Object Types](#_new_object_types_24)
- [New_Object_Types](#_new_object_types_24)
- [New Commands](#_new_commands_161)
- [New Structures](#_new_structures_351)
- [New Enums](#_new_enums_115)
- [New Bitmasks](#_new_bitmasks_85)
- [New Enum Constants](#_new_enum_constants_402)
- [New_Enum_Constants](#_new_enum_constants_402)
- [New or Modified Built-In Variables](#_new_or_modified_built_in_variables_13)
- [New_or_Modified_Built-In_Variables](#_new_or_modified_built_in_variables_13)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_54)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_54)
- [Issues](#_issues_164)
- [Sample Code](#_sample_code_6)
- [Version History](#_version_history_403)
- [VK_NV_win32_keyed_mutex](#VK_NV_win32_keyed_mutex)
- [Other Extension Metadata](#_other_extension_metadata_402)
- [Other_Extension_Metadata](#_other_extension_metadata_402)
- [Description](#_description_402)
- [New Structures](#_new_structures_352)
- [New Enum Constants](#_new_enum_constants_403)
- [New_Enum_Constants](#_new_enum_constants_403)
- [Examples](#_examples_50)
- [Version History](#_version_history_404)
- [VK_QCOM_fragment_density_map_offset](#VK_QCOM_fragment_density_map_offset)
- [Other Extension Metadata](#_other_extension_metadata_403)
- [Other_Extension_Metadata](#_other_extension_metadata_403)
- [Description](#_description_403)
- [New Structures](#_new_structures_353)
- [New Enum Constants](#_new_enum_constants_404)
- [New_Enum_Constants](#_new_enum_constants_404)
- [Version History](#_version_history_405)
- [VK_VALVE_mutable_descriptor_type](#VK_VALVE_mutable_descriptor_type)
- [Other Extension Metadata](#_other_extension_metadata_404)
- [Other_Extension_Metadata](#_other_extension_metadata_404)
- [Description](#_description_404)
- [New Structures](#_new_structures_354)
- [New Enum Constants](#_new_enum_constants_405)
- [New_Enum_Constants](#_new_enum_constants_405)
- [Version History](#_version_history_406)

## Content

Extensions to the Vulkan API **can** be defined by authors, groups of authors,
and the Khronos Vulkan
Working Group.
The online Registry of extensions is available at URL

[https://registry.khronos.org/vulkan/](https://registry.khronos.org/vulkan/)

Authors creating extensions and layers **must** follow the mandatory procedures
described in the [Vulkan Documentation and Extensions](../chapters/introduction.html#vulkan-styleguide)
document when creating extensions and layers.

The version of the Vulkan specification published
on the [Vulkan Documentation](https://docs.vulkan.org/) site and
in the Registry includes all registered and published extensions.
It is also possible to build the specification with an arbitrary set of
extensions included, and the specification you are viewing may not include
all extensions.

In the remainder of this appendix, extensions are grouped as Khronos `KHR`,
multivendor `EXT`, and then alphabetically by author ID.
Within each group, extensions are listed in alphabetical order by their
name.

Extensions which have dependencies on specific core versions or on other
extensions will list such dependencies.

For core versions, the specified version **must** be supported at runtime.
All extensions implicitly require support for Vulkan 1.0.

For a device extension, use of any device-level functionality defined by
that extension requires that any extensions that extension depends on be
enabled.

For any extension, use of any instance-level functionality defined by that
extension requires only that any extensions that extension depends on be
supported at runtime.

Some extensions define APIs which are only supported when other extensions
or core versions are supported at runtime.
Such interactions are noted as API Interactions.

**Name String**

`VK_KHR_acceleration_structure`

**Extension Type**

Device extension

**Registered Extension Number**

151

**Revision**

13

**Ratification Status**

Ratified

**Extension and Version Dependencies**

 [Vulkan Version 1.1](versions.html#versions-1.1)

 and

 [VK_EXT_descriptor_indexing](#VK_EXT_descriptor_indexing)

 and

 [VK_KHR_buffer_device_address](#VK_KHR_buffer_device_address)

 or

 [Vulkan Version 1.2](versions.html#versions-1.2)

and

[VK_KHR_deferred_host_operations](#VK_KHR_deferred_host_operations)

**API Interactions**

* 
Interacts with VK_VERSION_1_2

* 
Interacts with VK_VERSION_1_3

* 
Interacts with VK_EXT_debug_report

* 
Interacts with VK_KHR_format_feature_flags2

**Contact**

* 
Daniel Koch [dgkoch](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_acceleration_structure] @dgkoch%0A*Here describe the issue or question you have about the VK_KHR_acceleration_structure extension*)

**Last Modified Date**

2021-09-30

**Contributors**

* 
Samuel Bourasseau, Adobe

* 
Matthus Chajdas, AMD

* 
Greg Grebe, AMD

* 
Nicolai Hhnle, AMD

* 
Tobias Hector, AMD

* 
Dave Oldcorn, AMD

* 
Skyler Saleh, AMD

* 
Mathieu Robart, Arm

* 
Marius Bjorge, Arm

* 
Tom Olson, Arm

* 
Sebastian Tafuri, EA

* 
Henrik Rydgard, Embark

* 
Juan Caada, Epic Games

* 
Patrick Kelly, Epic Games

* 
Yuriy ODonnell, Epic Games

* 
Michael Doggett, Facebook/Oculus

* 
Ricardo Garcia, Igalia

* 
Andrew Garrard, Imagination

* 
Don Scorgie, Imagination

* 
Dae Kim, Imagination

* 
Joshua Barczak, Intel

* 
Slawek Grajewski, Intel

* 
Jeff Bolz, NVIDIA

* 
Pascal Gautron, NVIDIA

* 
Daniel Koch, NVIDIA

* 
Christoph Kubisch, NVIDIA

* 
Ashwin Lele, NVIDIA

* 
Robert Stepinski, NVIDIA

* 
Martin Stich, NVIDIA

* 
Nuno Subtil, NVIDIA

* 
Eric Werness, NVIDIA

* 
Jon Leech, Khronos

* 
Jeroen van Schijndel, OTOY

* 
Juul Joosten, OTOY

* 
Alex Bourd, Qualcomm

* 
Roman Larionov, Qualcomm

* 
David McAllister, Qualcomm

* 
Lewis Gordon, Samsung

* 
Ralph Potter, Samsung

* 
Jasper Bekkers, Traverse Research

* 
Jesse Barker, Unity

* 
Baldur Karlsson, Valve

In order to be efficient, rendering techniques such as ray tracing need a
quick way to identify which primitives may be intersected by a ray
traversing the geometries.
Acceleration structures are the most common way to represent the geometry
spatially sorted, in order to quickly identify such potential intersections.

This extension adds new functionalities:

* 
Acceleration structure objects and build commands

* 
Structures to describe geometry inputs to acceleration structure builds

* 
Acceleration structure copy commands

* 
[VkAccelerationStructureKHR](../chapters/resources.html#VkAccelerationStructureKHR)

* 
[vkBuildAccelerationStructuresKHR](../chapters/accelstructures.html#vkBuildAccelerationStructuresKHR)

* 
[vkCmdBuildAccelerationStructuresIndirectKHR](../chapters/accelstructures.html#vkCmdBuildAccelerationStructuresIndirectKHR)

* 
[vkCmdBuildAccelerationStructuresKHR](../chapters/accelstructures.html#vkCmdBuildAccelerationStructuresKHR)

* 
[vkCmdCopyAccelerationStructureKHR](../chapters/accelstructures.html#vkCmdCopyAccelerationStructureKHR)

* 
[vkCmdCopyAccelerationStructureToMemoryKHR](../chapters/accelstructures.html#vkCmdCopyAccelerationStructureToMemoryKHR)

* 
[vkCmdCopyMemoryToAccelerationStructureKHR](../chapters/accelstructures.html#vkCmdCopyMemoryToAccelerationStructureKHR)

* 
[vkCmdWriteAccelerationStructuresPropertiesKHR](../chapters/accelstructures.html#vkCmdWriteAccelerationStructuresPropertiesKHR)

* 
[vkCopyAccelerationStructureKHR](../chapters/accelstructures.html#vkCopyAccelerationStructureKHR)

* 
[vkCopyAccelerationStructureToMemoryKHR](../chapters/accelstructures.html#vkCopyAccelerationStructureToMemoryKHR)

* 
[vkCopyMemoryToAccelerationStructureKHR](../chapters/accelstructures.html#vkCopyMemoryToAccelerationStructureKHR)

* 
[vkCreateAccelerationStructureKHR](../chapters/resources.html#vkCreateAccelerationStructureKHR)

* 
[vkDestroyAccelerationStructureKHR](../chapters/resources.html#vkDestroyAccelerationStructureKHR)

* 
[vkGetAccelerationStructureBuildSizesKHR](../chapters/resources.html#vkGetAccelerationStructureBuildSizesKHR)

* 
[vkGetAccelerationStructureDeviceAddressKHR](../chapters/resources.html#vkGetAccelerationStructureDeviceAddressKHR)

* 
[vkGetDeviceAccelerationStructureCompatibilityKHR](../chapters/accelstructures.html#vkGetDeviceAccelerationStructureCompatibilityKHR)

* 
[vkWriteAccelerationStructuresPropertiesKHR](../chapters/accelstructures.html#vkWriteAccelerationStructuresPropertiesKHR)

* 
[VkAabbPositionsKHR](../chapters/accelstructures.html#VkAabbPositionsKHR)

* 
[VkAccelerationStructureBuildGeometryInfoKHR](../chapters/accelstructures.html#VkAccelerationStructureBuildGeometryInfoKHR)

* 
[VkAccelerationStructureBuildRangeInfoKHR](../chapters/accelstructures.html#VkAccelerationStructureBuildRangeInfoKHR)

* 
[VkAccelerationStructureBuildSizesInfoKHR](../chapters/resources.html#VkAccelerationStructureBuildSizesInfoKHR)

* 
[VkAccelerationStructureCreateInfoKHR](../chapters/resources.html#VkAccelerationStructureCreateInfoKHR)

* 
[VkAccelerationStructureDeviceAddressInfoKHR](../chapters/resources.html#VkAccelerationStructureDeviceAddressInfoKHR)

* 
[VkAccelerationStructureGeometryAabbsDataKHR](../chapters/accelstructures.html#VkAccelerationStructureGeometryAabbsDataKHR)

* 
[VkAccelerationStructureGeometryInstancesDataKHR](../chapters/accelstructures.html#VkAccelerationStructureGeometryInstancesDataKHR)

* 
[VkAccelerationStructureGeometryKHR](../chapters/accelstructures.html#VkAccelerationStructureGeometryKHR)

* 
[VkAccelerationStructureGeometryTrianglesDataKHR](../chapters/accelstructures.html#VkAccelerationStructureGeometryTrianglesDataKHR)

* 
[VkAccelerationStructureInstanceKHR](../chapters/accelstructures.html#VkAccelerationStructureInstanceKHR)

* 
[VkAccelerationStructureVersionInfoKHR](../chapters/accelstructures.html#VkAccelerationStructureVersionInfoKHR)

* 
[VkCopyAccelerationStructureInfoKHR](../chapters/accelstructures.html#VkCopyAccelerationStructureInfoKHR)

* 
[VkCopyAccelerationStructureToMemoryInfoKHR](../chapters/accelstructures.html#VkCopyAccelerationStructureToMemoryInfoKHR)

* 
[VkCopyMemoryToAccelerationStructureInfoKHR](../chapters/accelstructures.html#VkCopyMemoryToAccelerationStructureInfoKHR)

* 
[VkTransformMatrixKHR](../chapters/accelstructures.html#VkTransformMatrixKHR)

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceAccelerationStructureFeaturesKHR](../chapters/features.html#VkPhysicalDeviceAccelerationStructureFeaturesKHR)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceAccelerationStructurePropertiesKHR](../chapters/limits.html#VkPhysicalDeviceAccelerationStructurePropertiesKHR)

Extending [VkWriteDescriptorSet](../chapters/descriptorsets.html#VkWriteDescriptorSet):

* 
[VkWriteDescriptorSetAccelerationStructureKHR](../chapters/descriptorsets.html#VkWriteDescriptorSetAccelerationStructureKHR)

* 
[VkAccelerationStructureGeometryDataKHR](../chapters/accelstructures.html#VkAccelerationStructureGeometryDataKHR)

* 
[VkDeviceOrHostAddressConstKHR](../chapters/accelstructures.html#VkDeviceOrHostAddressConstKHR)

* 
[VkDeviceOrHostAddressKHR](../chapters/accelstructures.html#VkDeviceOrHostAddressKHR)

* 
[VkAccelerationStructureBuildTypeKHR](../chapters/resources.html#VkAccelerationStructureBuildTypeKHR)

* 
[VkAccelerationStructureCompatibilityKHR](../chapters/accelstructures.html#VkAccelerationStructureCompatibilityKHR)

* 
[VkAccelerationStructureCreateFlagBitsKHR](../chapters/resources.html#VkAccelerationStructureCreateFlagBitsKHR)

* 
[VkAccelerationStructureTypeKHR](../chapters/resources.html#VkAccelerationStructureTypeKHR)

* 
[VkBuildAccelerationStructureFlagBitsKHR](../chapters/resources.html#VkBuildAccelerationStructureFlagBitsKHR)

* 
[VkBuildAccelerationStructureModeKHR](../chapters/accelstructures.html#VkBuildAccelerationStructureModeKHR)

* 
[VkCopyAccelerationStructureModeKHR](../chapters/accelstructures.html#VkCopyAccelerationStructureModeKHR)

* 
[VkGeometryFlagBitsKHR](../chapters/resources.html#VkGeometryFlagBitsKHR)

* 
[VkGeometryInstanceFlagBitsKHR](../chapters/accelstructures.html#VkGeometryInstanceFlagBitsKHR)

* 
[VkGeometryTypeKHR](../chapters/resources.html#VkGeometryTypeKHR)

* 
[VkAccelerationStructureCreateFlagsKHR](../chapters/resources.html#VkAccelerationStructureCreateFlagsKHR)

* 
[VkBuildAccelerationStructureFlagsKHR](../chapters/resources.html#VkBuildAccelerationStructureFlagsKHR)

* 
[VkGeometryFlagsKHR](../chapters/resources.html#VkGeometryFlagsKHR)

* 
[VkGeometryInstanceFlagsKHR](../chapters/accelstructures.html#VkGeometryInstanceFlagsKHR)

* 
`VK_KHR_ACCELERATION_STRUCTURE_EXTENSION_NAME`

* 
`VK_KHR_ACCELERATION_STRUCTURE_SPEC_VERSION`

* 
Extending [VkAccessFlagBits](../chapters/synchronization.html#VkAccessFlagBits):

`VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR`

* 
`VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR`

Extending [VkBufferUsageFlagBits](../chapters/resources.html#VkBufferUsageFlagBits):

* 
`VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR`

* 
`VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR`

Extending [VkCopyAccelerationStructureModeKHR](../chapters/accelstructures.html#VkCopyAccelerationStructureModeKHR):

* 
`VK_COPY_ACCELERATION_STRUCTURE_MODE_DESERIALIZE_KHR`

* 
`VK_COPY_ACCELERATION_STRUCTURE_MODE_SERIALIZE_KHR`

Extending [VkDescriptorType](../chapters/descriptorsets.html#VkDescriptorType):

* 
`VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR`

Extending [VkFormatFeatureFlagBits](../chapters/formats.html#VkFormatFeatureFlagBits):

* 
`VK_FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR`

Extending [VkIndexType](../chapters/drawing.html#VkIndexType):

* 
`VK_INDEX_TYPE_NONE_KHR`

Extending [VkObjectType](../chapters/debugging.html#VkObjectType):

* 
`VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR`

Extending [VkPipelineStageFlagBits](../chapters/synchronization.html#VkPipelineStageFlagBits):

* 
`VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR`

Extending [VkQueryType](../chapters/queries.html#VkQueryType):

* 
`VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR`

* 
`VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR`

* 
`VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR`

* 
`VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR`

* 
`VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR`

* 
`VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR`

* 
`VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR`

If [VK_EXT_debug_report](#VK_EXT_debug_report) is supported:

* 
Extending [VkDebugReportObjectTypeEXT](../chapters/debugging.html#VkDebugReportObjectTypeEXT):

`VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR_EXT`

If [VK_KHR_format_feature_flags2](#VK_KHR_format_feature_flags2) or [Vulkan Version 1.3](versions.html#versions-1.3) is supported:

* 
Extending [VkFormatFeatureFlagBits2](../chapters/formats.html#VkFormatFeatureFlagBits2):

`VK_FORMAT_FEATURE_2_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR`

(1) How does this extension differ from VK_NV_ray_tracing?

**DISCUSSION**:

The following is a summary of the main functional differences between
VK_KHR_acceleration_structure and VK_NV_ray_tracing:

* 
added acceleration structure serialization / deserialization
(`VK_COPY_ACCELERATION_STRUCTURE_MODE_SERIALIZE_KHR`,
`VK_COPY_ACCELERATION_STRUCTURE_MODE_DESERIALIZE_KHR`,
[vkCmdCopyAccelerationStructureToMemoryKHR](../chapters/accelstructures.html#vkCmdCopyAccelerationStructureToMemoryKHR),
[vkCmdCopyMemoryToAccelerationStructureKHR](../chapters/accelstructures.html#vkCmdCopyMemoryToAccelerationStructureKHR))

* 
document [inactive primitives and    instances](../chapters/accelstructures.html#acceleration-structure-inactive-prims)

* 
added [VkPhysicalDeviceAccelerationStructureFeaturesKHR](../chapters/features.html#VkPhysicalDeviceAccelerationStructureFeaturesKHR) structure

* 
added indirect and batched acceleration structure builds
([vkCmdBuildAccelerationStructuresIndirectKHR](../chapters/accelstructures.html#vkCmdBuildAccelerationStructuresIndirectKHR))

* 
added [host acceleration structure](../chapters/accelstructures.html#host-acceleration-structure)
commands

* 
reworked geometry structures so they could be better shared between
device, host, and indirect builds

* 
explicitly made [VkAccelerationStructureKHR](../chapters/resources.html#VkAccelerationStructureKHR) use device addresses

* 
added acceleration structure compatibility check function
([vkGetDeviceAccelerationStructureCompatibilityKHR](../chapters/accelstructures.html#vkGetDeviceAccelerationStructureCompatibilityKHR))

* 
add parameter for requesting memory requirements for host and/or device
build

* 
added format feature for acceleration structure build vertex formats
(`VK_FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR`)

(2) Can you give a more detailed comparison of differences and similarities
between VK_NV_ray_tracing and VK_KHR_acceleration_structure?

**DISCUSSION**:

The following is a more detailed comparison of which commands, structures,
and enums are aliased, changed, or removed.

* 
Aliased functionalityenums, structures, and commands that are
considered equivalent:

[VkGeometryTypeNV](../chapters/resources.html#VkGeometryTypeNV)  [VkGeometryTypeKHR](../chapters/resources.html#VkGeometryTypeKHR)

* 
[VkAccelerationStructureTypeNV](../chapters/resources.html#VkAccelerationStructureTypeNV) 
[VkAccelerationStructureTypeKHR](../chapters/resources.html#VkAccelerationStructureTypeKHR)

* 
[VkCopyAccelerationStructureModeNV](../chapters/accelstructures.html#VkCopyAccelerationStructureModeNV) 
[VkCopyAccelerationStructureModeKHR](../chapters/accelstructures.html#VkCopyAccelerationStructureModeKHR)

* 
[VkGeometryFlagsNV](../chapters/resources.html#VkGeometryFlagsNV)  [VkGeometryFlagsKHR](../chapters/resources.html#VkGeometryFlagsKHR)

* 
[VkGeometryFlagBitsNV](../chapters/resources.html#VkGeometryFlagBitsNV)  [VkGeometryFlagBitsKHR](../chapters/resources.html#VkGeometryFlagBitsKHR)

* 
[VkGeometryInstanceFlagsNV](../chapters/accelstructures.html#VkGeometryInstanceFlagsNV)  [VkGeometryInstanceFlagsKHR](../chapters/accelstructures.html#VkGeometryInstanceFlagsKHR)

* 
[VkGeometryInstanceFlagBitsNV](../chapters/accelstructures.html#VkGeometryInstanceFlagBitsNV) 
[VkGeometryInstanceFlagBitsKHR](../chapters/accelstructures.html#VkGeometryInstanceFlagBitsKHR)

* 
[VkBuildAccelerationStructureFlagsNV](../chapters/resources.html#VkBuildAccelerationStructureFlagsNV) 
[VkBuildAccelerationStructureFlagsKHR](../chapters/resources.html#VkBuildAccelerationStructureFlagsKHR)

* 
[VkBuildAccelerationStructureFlagBitsNV](../chapters/resources.html#VkBuildAccelerationStructureFlagBitsNV) 
[VkBuildAccelerationStructureFlagBitsKHR](../chapters/resources.html#VkBuildAccelerationStructureFlagBitsKHR)

* 
[VkTransformMatrixNV](../chapters/accelstructures.html#VkTransformMatrixNV)  [VkTransformMatrixKHR](../chapters/accelstructures.html#VkTransformMatrixKHR) (added to
VK_NV_ray_tracing for descriptive purposes)

* 
[VkAabbPositionsNV](../chapters/accelstructures.html#VkAabbPositionsNV)  [VkAabbPositionsKHR](../chapters/accelstructures.html#VkAabbPositionsKHR) (added to
VK_NV_ray_tracing for descriptive purposes)

* 
[VkAccelerationStructureInstanceNV](../chapters/accelstructures.html#VkAccelerationStructureInstanceNV) 
[VkAccelerationStructureInstanceKHR](../chapters/accelstructures.html#VkAccelerationStructureInstanceKHR) (added to VK_NV_ray_tracing
for descriptive purposes)

Changed enums, structures, and commands:

* 
renamed `VK_GEOMETRY_INSTANCE_TRIANGLE_CULL_DISABLE_BIT_NV` 
`VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR` in
[VkGeometryInstanceFlagBitsKHR](../chapters/accelstructures.html#VkGeometryInstanceFlagBitsKHR)

* 
[VkGeometryTrianglesNV](../chapters/resources.html#VkGeometryTrianglesNV) 
[VkAccelerationStructureGeometryTrianglesDataKHR](../chapters/accelstructures.html#VkAccelerationStructureGeometryTrianglesDataKHR) (device or host
address instead of buffer+offset)

* 
[VkGeometryAABBNV](../chapters/resources.html#VkGeometryAABBNV) 
[VkAccelerationStructureGeometryAabbsDataKHR](../chapters/accelstructures.html#VkAccelerationStructureGeometryAabbsDataKHR) (device or host
address instead of buffer+offset)

* 
[VkGeometryDataNV](../chapters/resources.html#VkGeometryDataNV)  [VkAccelerationStructureGeometryDataKHR](../chapters/accelstructures.html#VkAccelerationStructureGeometryDataKHR)
(union of triangle/aabbs/instances)

* 
[VkGeometryNV](../chapters/resources.html#VkGeometryNV)  [VkAccelerationStructureGeometryKHR](../chapters/accelstructures.html#VkAccelerationStructureGeometryKHR) (changed
type of geometry)

* 
[VkAccelerationStructureCreateInfoNV](../chapters/resources.html#VkAccelerationStructureCreateInfoNV) 
[VkAccelerationStructureCreateInfoKHR](../chapters/resources.html#VkAccelerationStructureCreateInfoKHR) (reshuffle geometry
layout/information)

* 
[VkPhysicalDeviceRayTracingPropertiesNV](../chapters/limits.html#VkPhysicalDeviceRayTracingPropertiesNV) 
[VkPhysicalDeviceAccelerationStructurePropertiesKHR](../chapters/limits.html#VkPhysicalDeviceAccelerationStructurePropertiesKHR) (for
acceleration structure properties, renamed `maxTriangleCount` to
`maxPrimitiveCount`, added per stage and update after bind limits)
and [VkPhysicalDeviceRayTracingPipelinePropertiesKHR](../chapters/limits.html#VkPhysicalDeviceRayTracingPipelinePropertiesKHR) (for ray
tracing pipeline properties)

* 
[VkAccelerationStructureMemoryRequirementsInfoNV](../chapters/resources.html#VkAccelerationStructureMemoryRequirementsInfoNV) (deleted -
replaced by allocating on top of [VkBuffer](../chapters/resources.html#VkBuffer))

* 
[VkWriteDescriptorSetAccelerationStructureNV](../chapters/descriptorsets.html#VkWriteDescriptorSetAccelerationStructureNV) 
[VkWriteDescriptorSetAccelerationStructureKHR](../chapters/descriptorsets.html#VkWriteDescriptorSetAccelerationStructureKHR) (different
acceleration structure type)

* 
[vkCreateAccelerationStructureNV](../chapters/resources.html#vkCreateAccelerationStructureNV) 
[vkCreateAccelerationStructureKHR](../chapters/resources.html#vkCreateAccelerationStructureKHR) (device address, different
geometry layout/information)

* 
[vkGetAccelerationStructureMemoryRequirementsNV](../chapters/resources.html#vkGetAccelerationStructureMemoryRequirementsNV) (deleted -
replaced by allocating on top of [VkBuffer](../chapters/resources.html#VkBuffer))

* 
[vkCmdBuildAccelerationStructureNV](../chapters/accelstructures.html#vkCmdBuildAccelerationStructureNV) 
[vkCmdBuildAccelerationStructuresKHR](../chapters/accelstructures.html#vkCmdBuildAccelerationStructuresKHR) (params moved to structs,
layout differences)

* 
[vkCmdCopyAccelerationStructureNV](../chapters/accelstructures.html#vkCmdCopyAccelerationStructureNV) 
[vkCmdCopyAccelerationStructureKHR](../chapters/accelstructures.html#vkCmdCopyAccelerationStructureKHR) (params to struct, extendable)

* 
[vkGetAccelerationStructureHandleNV](../chapters/resources.html#vkGetAccelerationStructureHandleNV) 
[vkGetAccelerationStructureDeviceAddressKHR](../chapters/resources.html#vkGetAccelerationStructureDeviceAddressKHR) (device address
instead of handle)

* 
[VkAccelerationStructureMemoryRequirementsTypeNV](../chapters/resources.html#VkAccelerationStructureMemoryRequirementsTypeNV)  size queries
for scratch space moved to
[vkGetAccelerationStructureBuildSizesKHR](../chapters/resources.html#vkGetAccelerationStructureBuildSizesKHR)

* 
[vkDestroyAccelerationStructureNV](../chapters/resources.html#vkDestroyAccelerationStructureNV) 
[vkDestroyAccelerationStructureKHR](../chapters/resources.html#vkDestroyAccelerationStructureKHR) (different acceleration
structure types)

* 
[vkCmdWriteAccelerationStructuresPropertiesNV](../chapters/accelstructures.html#vkCmdWriteAccelerationStructuresPropertiesNV) 
[vkCmdWriteAccelerationStructuresPropertiesKHR](../chapters/accelstructures.html#vkCmdWriteAccelerationStructuresPropertiesKHR) (different
acceleration structure types)

Added enums, structures and commands:

* 
`VK_GEOMETRY_TYPE_INSTANCES_KHR` to [VkGeometryTypeKHR](../chapters/resources.html#VkGeometryTypeKHR) enum

* 
`VK_COPY_ACCELERATION_STRUCTURE_MODE_SERIALIZE_KHR`,
`VK_COPY_ACCELERATION_STRUCTURE_MODE_DESERIALIZE_KHR` to
[VkCopyAccelerationStructureModeKHR](../chapters/accelstructures.html#VkCopyAccelerationStructureModeKHR) enum

* 
[VkPhysicalDeviceAccelerationStructureFeaturesKHR](../chapters/features.html#VkPhysicalDeviceAccelerationStructureFeaturesKHR) structure

* 
[VkAccelerationStructureBuildTypeKHR](../chapters/resources.html#VkAccelerationStructureBuildTypeKHR) enum

* 
[VkBuildAccelerationStructureModeKHR](../chapters/accelstructures.html#VkBuildAccelerationStructureModeKHR) enum

* 
[VkDeviceOrHostAddressKHR](../chapters/accelstructures.html#VkDeviceOrHostAddressKHR) and [VkDeviceOrHostAddressConstKHR](../chapters/accelstructures.html#VkDeviceOrHostAddressConstKHR)
unions

* 
[VkAccelerationStructureBuildRangeInfoKHR](../chapters/accelstructures.html#VkAccelerationStructureBuildRangeInfoKHR) struct

* 
[VkAccelerationStructureGeometryInstancesDataKHR](../chapters/accelstructures.html#VkAccelerationStructureGeometryInstancesDataKHR) struct

* 
[VkAccelerationStructureDeviceAddressInfoKHR](../chapters/resources.html#VkAccelerationStructureDeviceAddressInfoKHR) struct

* 
[VkAccelerationStructureVersionInfoKHR](../chapters/accelstructures.html#VkAccelerationStructureVersionInfoKHR) struct

* 
[VkStridedDeviceAddressRegionKHR](../chapters/descriptorsets.html#VkStridedDeviceAddressRegionKHR) struct

* 
[VkCopyAccelerationStructureToMemoryInfoKHR](../chapters/accelstructures.html#VkCopyAccelerationStructureToMemoryInfoKHR) struct

* 
[VkCopyMemoryToAccelerationStructureInfoKHR](../chapters/accelstructures.html#VkCopyMemoryToAccelerationStructureInfoKHR) struct

* 
[VkCopyAccelerationStructureInfoKHR](../chapters/accelstructures.html#VkCopyAccelerationStructureInfoKHR) struct

* 
[vkBuildAccelerationStructuresKHR](../chapters/accelstructures.html#vkBuildAccelerationStructuresKHR) command (host build)

* 
[vkCopyAccelerationStructureKHR](../chapters/accelstructures.html#vkCopyAccelerationStructureKHR) command (host copy)

* 
[vkCopyAccelerationStructureToMemoryKHR](../chapters/accelstructures.html#vkCopyAccelerationStructureToMemoryKHR) (host serialize)

* 
[vkCopyMemoryToAccelerationStructureKHR](../chapters/accelstructures.html#vkCopyMemoryToAccelerationStructureKHR) (host deserialize)

* 
[vkWriteAccelerationStructuresPropertiesKHR](../chapters/accelstructures.html#vkWriteAccelerationStructuresPropertiesKHR) (host properties)

* 
[vkCmdCopyAccelerationStructureToMemoryKHR](../chapters/accelstructures.html#vkCmdCopyAccelerationStructureToMemoryKHR) (device serialize)

* 
[vkCmdCopyMemoryToAccelerationStructureKHR](../chapters/accelstructures.html#vkCmdCopyMemoryToAccelerationStructureKHR) (device deserialize)

* 
[vkGetDeviceAccelerationStructureCompatibilityKHR](../chapters/accelstructures.html#vkGetDeviceAccelerationStructureCompatibilityKHR) (serialization)

(3) What are the changes between the public provisional (VK_KHR_ray_tracing
v8) release and the internal provisional (VK_KHR_ray_tracing v9) release?

* 
added `geometryFlags` to
`VkAccelerationStructureCreateGeometryTypeInfoKHR` (later reworked
to obsolete this)

* 
added `minAccelerationStructureScratchOffsetAlignment` property to
VkPhysicalDeviceRayTracingPropertiesKHR

* 
fix naming and return enum from
[vkGetDeviceAccelerationStructureCompatibilityKHR](../chapters/accelstructures.html#vkGetDeviceAccelerationStructureCompatibilityKHR)

renamed `VkAccelerationStructureVersionKHR` to
[VkAccelerationStructureVersionInfoKHR](../chapters/accelstructures.html#VkAccelerationStructureVersionInfoKHR)

* 
renamed `VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_KHR` to
`VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR`

* 
removed `VK_ERROR_INCOMPATIBLE_VERSION_KHR`

* 
added [VkAccelerationStructureCompatibilityKHR](../chapters/accelstructures.html#VkAccelerationStructureCompatibilityKHR) enum

* 
remove return value from
[vkGetDeviceAccelerationStructureCompatibilityKHR](../chapters/accelstructures.html#vkGetDeviceAccelerationStructureCompatibilityKHR) and added return
enum parameter

Require Vulkan 1.1

added creation time capture and replay flags

* 
added [VkAccelerationStructureCreateFlagBitsKHR](../chapters/resources.html#VkAccelerationStructureCreateFlagBitsKHR) and
[VkAccelerationStructureCreateFlagsKHR](../chapters/resources.html#VkAccelerationStructureCreateFlagsKHR)

* 
renamed the `flags` member of
[VkAccelerationStructureCreateInfoKHR](../chapters/resources.html#VkAccelerationStructureCreateInfoKHR) to `buildFlags` (later
removed) and added the `createFlags` member

change [vkCmdBuildAccelerationStructuresIndirectKHR](../chapters/accelstructures.html#vkCmdBuildAccelerationStructuresIndirectKHR) to use buffer
device address for indirect parameter

make `[VK_KHR_deferred_host_operations](#VK_KHR_deferred_host_operations)` an interaction instead of
a required extension (later went back on this)

renamed `VkAccelerationStructureBuildOffsetInfoKHR` to
[VkAccelerationStructureBuildRangeInfoKHR](../chapters/accelstructures.html#VkAccelerationStructureBuildRangeInfoKHR)

* 
renamed the `ppOffsetInfos` parameter of
[vkCmdBuildAccelerationStructuresKHR](../chapters/accelstructures.html#vkCmdBuildAccelerationStructuresKHR) to `ppBuildRangeInfos`

Re-unify geometry description between build and create

* 
remove `VkAccelerationStructureCreateGeometryTypeInfoKHR` and
`VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_GEOMETRY_TYPE_INFO_KHR`

* 
added `VkAccelerationStructureCreateSizeInfoKHR` structure (later
removed)

* 
change type of the `pGeometryInfos` member of
[VkAccelerationStructureCreateInfoKHR](../chapters/resources.html#VkAccelerationStructureCreateInfoKHR) from
`VkAccelerationStructureCreateGeometryTypeInfoKHR` to
[VkAccelerationStructureGeometryKHR](../chapters/accelstructures.html#VkAccelerationStructureGeometryKHR) (later removed)

* 
added `pCreateSizeInfos` member to
[VkAccelerationStructureCreateInfoKHR](../chapters/resources.html#VkAccelerationStructureCreateInfoKHR) (later removed)

Fix ppGeometries ambiguity, add pGeometries

* 
remove `geometryArrayOfPointers` member of
VkAccelerationStructureBuildGeometryInfoKHR

* 
disambiguate two meanings of `ppGeometries` by explicitly adding
`pGeometries` to the
[VkAccelerationStructureBuildGeometryInfoKHR](../chapters/accelstructures.html#VkAccelerationStructureBuildGeometryInfoKHR) structure and require
one of them be `NULL`

added [`nullDescriptor`](../chapters/features.html#features-nullDescriptor) support for
acceleration structures

changed the `update` member of
[VkAccelerationStructureBuildGeometryInfoKHR](../chapters/accelstructures.html#VkAccelerationStructureBuildGeometryInfoKHR) from a bool to the
`mode` [VkBuildAccelerationStructureModeKHR](../chapters/accelstructures.html#VkBuildAccelerationStructureModeKHR) enum which allows
future extensibility in update types

Clarify deferred host ops for pipeline creation

* 
[VkDeferredOperationKHR](../chapters/VK_KHR_deferred_host_operations/deferred_host_operations.html#VkDeferredOperationKHR) is now a top-level parameter for
[vkBuildAccelerationStructuresKHR](../chapters/accelstructures.html#vkBuildAccelerationStructuresKHR),
[vkCreateRayTracingPipelinesKHR](../chapters/pipelines.html#vkCreateRayTracingPipelinesKHR),
[vkCopyAccelerationStructureToMemoryKHR](../chapters/accelstructures.html#vkCopyAccelerationStructureToMemoryKHR),
[vkCopyAccelerationStructureKHR](../chapters/accelstructures.html#vkCopyAccelerationStructureKHR), and
[vkCopyMemoryToAccelerationStructureKHR](../chapters/accelstructures.html#vkCopyMemoryToAccelerationStructureKHR)

* 
removed `VkDeferredOperationInfoKHR` structure

* 
change deferred host creation/return parameter behavior such that the
implementation can modify such parameters until the deferred host
operation completes

* 
`[VK_KHR_deferred_host_operations](#VK_KHR_deferred_host_operations)` is required again

Change acceleration structure build to always be sized

* 
de-alias `VkAccelerationStructureMemoryRequirementsTypeNV` and
`VkAccelerationStructureMemoryRequirementsTypeKHR`, and remove
`VkAccelerationStructureMemoryRequirementsTypeKHR`

* 
add [vkGetAccelerationStructureBuildSizesKHR](../chapters/resources.html#vkGetAccelerationStructureBuildSizesKHR) command and
[VkAccelerationStructureBuildSizesInfoKHR](../chapters/resources.html#VkAccelerationStructureBuildSizesInfoKHR) structure and
`VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR`
enum to query sizes for acceleration structures and scratch storage

* 
move size queries for scratch space to
[vkGetAccelerationStructureBuildSizesKHR](../chapters/resources.html#vkGetAccelerationStructureBuildSizesKHR)

* 
remove `compactedSize`, `buildFlags`, `maxGeometryCount`,
`pGeometryInfos`, `pCreateSizeInfos` members of
[VkAccelerationStructureCreateInfoKHR](../chapters/resources.html#VkAccelerationStructureCreateInfoKHR) and add the `size`
member

* 
add `maxVertex` member to
[VkAccelerationStructureGeometryTrianglesDataKHR](../chapters/accelstructures.html#VkAccelerationStructureGeometryTrianglesDataKHR) structure

* 
remove `VkAccelerationStructureCreateSizeInfoKHR` structure

(4) What are the changes between the internal provisional
(VK_KHR_ray_tracing v9) release and the final (VK_KHR_acceleration_structure
v11) release?

* 
refactor VK_KHR_ray_tracing into 3 extensions, enabling implementation
flexibility and decoupling ray query support from ray pipelines:

`[VK_KHR_acceleration_structure](#VK_KHR_acceleration_structure)` (for acceleration structure
operations)

* 
`[VK_KHR_ray_tracing_pipeline](#VK_KHR_ray_tracing_pipeline)` (for ray tracing pipeline and
shader stages)

* 
`[VK_KHR_ray_query](#VK_KHR_ray_query)` (for ray queries in existing shader stages)

clarify buffer usage flags for ray tracing

* 
`VK_BUFFER_USAGE_RAY_TRACING_BIT_NV` is left alone in
`[VK_NV_ray_tracing](#VK_NV_ray_tracing)` (required on `scratch` and
`instanceData`)

* 
`VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR` is added as an alias
of `VK_BUFFER_USAGE_RAY_TRACING_BIT_NV` in
`[VK_KHR_ray_tracing_pipeline](#VK_KHR_ray_tracing_pipeline)` and is required on shader binding
table buffers

* 
`VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR`
is added in `[VK_KHR_acceleration_structure](#VK_KHR_acceleration_structure)` for all vertex,
index, transform, aabb, and instance buffer data referenced by device
build commands

* 
`VK_BUFFER_USAGE_STORAGE_BUFFER_BIT` is used for `scratchData`

add max primitive counts (`ppMaxPrimitiveCounts`) to
[vkCmdBuildAccelerationStructuresIndirectKHR](../chapters/accelstructures.html#vkCmdBuildAccelerationStructuresIndirectKHR)

Allocate acceleration structures from `VkBuffers` and add a mode to
constrain the device address

* 
de-alias `VkBindAccelerationStructureMemoryInfoNV` and
`vkBindAccelerationStructureMemoryNV`, and remove
`VkBindAccelerationStructureMemoryInfoKHR`,
`VkAccelerationStructureMemoryRequirementsInfoKHR`, and
`vkGetAccelerationStructureMemoryRequirementsKHR`

* 
acceleration structures now take a [VkBuffer](../chapters/resources.html#VkBuffer) and offset at
creation time for memory placement

* 
add a new `VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR`
buffer usage for such buffers

* 
add a new `VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR` acceleration
structure type for layering

move `VK_GEOMETRY_TYPE_INSTANCES_KHR` to main enum instead of being
added via extension

make build commands more consistent - all now build multiple
acceleration structures and are named plurally
([vkCmdBuildAccelerationStructuresIndirectKHR](../chapters/accelstructures.html#vkCmdBuildAccelerationStructuresIndirectKHR),
[vkCmdBuildAccelerationStructuresKHR](../chapters/accelstructures.html#vkCmdBuildAccelerationStructuresKHR),
[vkBuildAccelerationStructuresKHR](../chapters/accelstructures.html#vkBuildAccelerationStructuresKHR))

add interactions with
`VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT` for
acceleration structures, including a new feature
(`descriptorBindingAccelerationStructureUpdateAfterBind`) and 3 new
properties (`maxPerStageDescriptorAccelerationStructures`,
`maxPerStageDescriptorUpdateAfterBindAccelerationStructures`,
`maxDescriptorSetUpdateAfterBindAccelerationStructures`)

extension is no longer provisional

define synchronization requirements for builds, traces, and copies

define synchronization requirements for AS build inputs and indirect
build buffer

(5) What is `VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR` for?

**RESOLVED**: It is primarily intended for API layering.
In DXR, the acceleration structure is basically just a buffer in a special
layout, and you do not know at creation time whether it will be used as a
top or bottom level acceleration structure.
We thus added a generic acceleration structure type whose type is unknown at
creation time, but is specified at build time instead.
Applications which are written directly for Vulkan should not use it.

* 
Revision 1, 2019-12-05 (Members of the Vulkan Ray Tracing TSG)

Internal revisions (forked from VK_NV_ray_tracing)

Revision 2, 2019-12-20 (Daniel Koch, Eric Werness)

* 
Add const version of DeviceOrHostAddress (!3515)

* 
Add VU to clarify that only handles in the current pipeline are valid
(!3518)

* 
Restore some missing VUs and add in-place update language (#1902,
!3522)

* 
rename VkAccelerationStructureInstanceKHR member from
accelerationStructure to accelerationStructureReference to better match
its type (!3523)

* 
Allow VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS for pipeline creation if
shader group handles cannot be reused (!3523)

* 
update documentation for the VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS
error code and add missing documentation for new return codes from
VK_KHR_deferred_host_operations (!3523)

* 
list new query types for VK_KHR_ray_tracing (!3523)

* 
Fix VU statements for VkAccelerationStructureGeometryKHR referring to
correct union members and update to use more current wording (!3523)

Revision 3, 2020-01-10 (Daniel Koch, Jon Leech, Christoph Kubisch)

* 
Fix 'instance of' and 'that/which contains/defines' markup issues
(!3528)

* 
factor out VK_KHR_pipeline_library as stand-alone extension (!3540)

* 
Resolve Vulkan-hpp issues (!3543)

add missing require for VkGeometryInstanceFlagsKHR

* 
de-alias VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV since
the KHR structure is no longer equivalent

* 
add len to pDataSize attribute for
vkWriteAccelerationStructuresPropertiesKHR

Revision 4, 2020-01-23 (Daniel Koch, Eric Werness)

* 
Improve vkWriteAccelerationStructuresPropertiesKHR, add return value
and VUs (#1947)

* 
Clarify language to allow multiple raygen shaders (#1959)

* 
Various editorial feedback (!3556)

* 
Add language to help deal with looped self-intersecting fans (#1901)

* 
Change vkCmdTraceRays{,Indirect}KHR args to pointers (!3559)

* 
Add scratch address validation language (#1941, !3551)

* 
Fix definition and add hierarchy information for shader call scope
(#1977, !3571)

Revision 5, 2020-02-04 (Eric Werness, Jeff Bolz, Daniel Koch)

* 
remove vestigial accelerationStructureUUID (!3582)

* 
update definition of repack instructions and improve memory model
interactions (#1910, #1913, !3584)

* 
Fix wrong sType for VkPhysicalDeviceRayTracingFeaturesKHR (#1988)

* 
Use provisional SPIR-V capabilities (#1987)

* 
require rayTraversalPrimitiveCulling if rayQuery is supported (#1927)

* 
Miss shaders do not have object parameters (!3592)

* 
Fix missing required types in XML (!3592)

* 
clarify matching conditions for update (!3592)

* 
add goal that host and device builds be similar (!3592)

* 
clarify that `maxPrimitiveCount` limit should apply to triangles
and AABBs (!3592)

* 
Require alignment for instance arrayOfPointers (!3592)

* 
Zero is a valid value for instance flags (!3592)

* 
Add some alignment VUs that got lost in refactoring (!3592)

* 
Recommend TMin epsilon rather than culling (!3592)

* 
Get angle from dot product not cross product (!3592)

* 
Clarify that AH can access the payload and attributes (!3592)

* 
Match DXR behavior for inactive primitive definition (!3592)

* 
Use a more generic term than degenerate for inactive to avoid confusion
(!3592)

Revision 6, 2020-02-20 (Daniel Koch)

* 
fix some dangling NV references (#1996)

* 
rename VkCmdTraceRaysIndirectCommandKHR to
VkTraceRaysIndirectCommandKHR (!3607)

* 
update contributor list (!3611)

* 
use uint64_t instead of VkAccelerationStructureReferenceKHR in
VkAccelerationStructureInstanceKHR (#2004)

Revision 7, 2020-02-28 (Tobias Hector)

* 
remove HitTKHR SPIR-V builtin (spirv/spirv-extensions#7)

Revision 8, 2020-03-06 (Tobias Hector, Dae Kim, Daniel Koch, Jeff Bolz,
Eric Werness)

* 
explicitly state that Tmax is updated when new closest intersection is
accepted (#2020,!3536)

* 
Made references to min and max t values consistent (!3644)

* 
finish enumerating differences relative to VK_NV_ray_tracing in issues
(1) and (2) (#1974,!3642)

* 
fix formatting in some math equations (!3642)

* 
Restrict the Hit Kind operand of `OpReportIntersectionKHR` to 7-bits
(spirv/spirv-extensions#8,!3646)

* 
Say ray tracing '**should**' be watertight (#2008,!3631)

* 
Clarify memory requirements for ray tracing buffers (#2005,!3649)

* 
Add callable size limits (#1997,!3652)

Revision 9, 2020-04-15 (Eric Werness, Daniel Koch, Tobias Hector, Joshua
Barczak)

* 
Add geometry flags to acceleration structure creation (!3672)

* 
add build scratch memory alignment
(minAccelerationStructureScratchOffsetAlignment) (#2065,!3725)

* 
fix naming and return enum from
vkGetDeviceAccelerationStructureCompatibilityKHR (#2051,!3726)

* 
require SPIR-V 1.4 (#2096,!3777)

* 
added creation time capture/replay flags (#2104,!3774)

* 
require Vulkan 1.1 (#2133,!3806)

* 
use device addresses instead of VkBuffers for ray tracing commands
(#2074,!3815)

* 
add interactions with Vulkan 1.2 and VK_KHR_vulkan_memory_model
(#2133,!3830)

* 
make VK_KHR_pipeline_library an interaction instead of required
(#2045,#2108,!3830)

* 
make VK_KHR_deferred_host_operations an interaction instead of required
(#2045,!3830)

* 
removed maxCallableSize and added explicit stack size management for
ray pipelines (#1997,!3817,!3772,!3844)

* 
improved documentation for VkAccelerationStructureVersionInfoKHR
(#2135,3835)

* 
rename VkAccelerationStructureBuildOffsetInfoKHR to
VkAccelerationStructureBuildRangeInfoKHR (#2058,!3754)

* 
Re-unify geometry description between build and create (!3754)

* 
Fix ppGeometries ambiguity, add pGeometries (#2032,!3811)

* 
add interactions with VK_EXT_robustness2 and allow nullDescriptor
support for acceleration structures (#1920,!3848)

* 
added future extensibility for AS updates (#2114,!3849)

* 
Fix VU for dispatchrays and add a limit on the size of the full grid
(#2160,!3851)

* 
Add shaderGroupHandleAlignment property (#2180,!3875)

* 
Clarify deferred host ops for pipeline creation (#2067,!3813)

* 
Change acceleration structure build to always be sized
(#2131,#2197,#2198,!3854,!3883,!3880)

Revision 10, 2020-07-03 (Mathieu Robart, Daniel Koch, Eric Werness,
Tobias Hector)

* 
Decomposition of the specification, from VK_KHR_ray_tracing to
VK_KHR_acceleration_structure (#1918,!3912)

* 
clarify buffer usage flags for ray tracing (#2181,!3939)

* 
add max primitive counts to build indirect command (#2233,!3944)

* 
Allocate acceleration structures from VkBuffers and add a mode to
constrain the device address (#2131,!3936)

* 
Move VK_GEOMETRY_TYPE_INSTANCES_KHR to main enum (#2243,!3952)

* 
make build commands more consistent (#2247,!3958)

* 
add interactions with UPDATE_AFTER_BIND (#2128,!3986)

* 
correct and expand build command VUs (!4020)

* 
fix copy command VUs (!4018)

* 
added various alignment requirements (#2229,!3943)

* 
fix valid usage for arrays of geometryCount items (#2198,!4010)

* 
define what is allowed to change on RTAS updates and relevant VUs
(#2177,!3961)

Revision 11, 2020-11-12 (Eric Werness, Josh Barczak, Daniel Koch, Tobias
Hector)

* 
de-alias NV and KHR acceleration structure types and associated
commands (#2271,!4035)

* 
specify alignment for host copy commands (#2273,!4037)

* 
document
`VK_FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR`

* 
specify that acceleration structures are non-linear (#2289,!4068)

* 
add several missing VUs for strides, vertexFormat, and indexType
(#2315,!4069)

* 
restore VUs for VkAccelerationStructureBuildGeometryInfoKHR
(#2337,!4098)

* 
ban multi-instance memory for host operations (#2324,!4102)

* 
allow dstAccelerationStructure to be null for
vkGetAccelerationStructureBuildSizesKHR (#2330,!4111)

* 
more build VU cleanup (#2138,#4130)

* 
specify host endianness for AS serialization (#2261,!4136)

* 
add invertible transform matrix VU (#1710,!4140)

* 
require geometryCount to be 1 for TLAS builds (!4145)

* 
improved validity conditions for build addresses (#4142)

* 
add single statement SPIR-V VUs, build limit VUs (!4158)

* 
document limits for vertex and aabb strides (#2390,!4184)

* 
specify that
`VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR` applies to
AS copies (#2382,#4173)

* 
define sync for AS build inputs and indirect buffer (#2407,!4208)

Revision 12, 2021-08-06 (Samuel Bourasseau)

* 
rename VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_KHR to
VK_GEOMETRY_INSTANCE_TRIANGLE_FLIP_FACING_BIT_KHR (keep previous as
alias).

* 
Clarify description and add note.

Revision 13, 2021-09-30 (Jon Leech)

* 
Add interaction with `[VK_KHR_format_feature_flags2](#VK_KHR_format_feature_flags2)` to `vk.xml`

**Name String**

`VK_KHR_android_surface`

**Extension Type**

Instance extension

**Registered Extension Number**

9

**Revision**

6

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_surface](#VK_KHR_surface)

**Contact**

* 
Jesse Hall [critsec](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_android_surface] @critsec%0A*Here describe the issue or question you have about the VK_KHR_android_surface extension*)

**Last Modified Date**

2016-01-14

**IP Status**

No known IP claims.

**Contributors**

* 
Patrick Doane, Blizzard

* 
Faith Ekstrand, Intel

* 
Ian Elliott, LunarG

* 
Courtney Goeltzenleuchter, LunarG

* 
Jesse Hall, Google

* 
James Jones, NVIDIA

* 
Antoine Labour, Google

* 
Jon Leech, Khronos

* 
David Mao, AMD

* 
Norbert Nopper, Freescale

* 
Alon Or-bach, Samsung

* 
Daniel Rakos, AMD

* 
Graham Sellers, AMD

* 
Ray Smith, ARM

* 
Jeff Vigil, Qualcomm

* 
Chia-I Wu, LunarG

The `VK_KHR_android_surface` extension is an instance extension.
It provides a mechanism to create a [VkSurfaceKHR](../chapters/VK_KHR_surface/wsi.html#VkSurfaceKHR) object (defined by
the `[VK_KHR_surface](#VK_KHR_surface)` extension) that refers to an
`ANativeWindow`, Androids native surface type.
The `ANativeWindow` represents the producer endpoint of any buffer
queue, regardless of consumer endpoint.
Common consumer endpoints for `ANativeWindows` are the system window
compositor, video encoders, and application-specific compositors importing
the images through a `SurfaceTexture`.

* 
`ANativeWindow`

* 
[vkCreateAndroidSurfaceKHR](../chapters/VK_KHR_surface/wsi.html#vkCreateAndroidSurfaceKHR)

* 
[VkAndroidSurfaceCreateInfoKHR](../chapters/VK_KHR_surface/wsi.html#VkAndroidSurfaceCreateInfoKHR)

* 
[VkAndroidSurfaceCreateFlagsKHR](../chapters/VK_KHR_surface/wsi.html#VkAndroidSurfaceCreateFlagsKHR)

* 
`VK_KHR_ANDROID_SURFACE_EXTENSION_NAME`

* 
`VK_KHR_ANDROID_SURFACE_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR`

1) Does Android need a way to query for compatibility between a particular
physical device (and queue family?) and a specific Android display?

**RESOLVED**: No.
Currently on Android, any physical device is expected to be able to present
to the system compositor, and all queue families must support the necessary
image layout transitions and synchronization operations.

* 
Revision 1, 2015-09-23 (Jesse Hall)

Initial draft.

Revision 2, 2015-10-26 (Ian Elliott)

* 
Renamed from VK_EXT_KHR_android_surface to VK_KHR_android_surface.

Revision 3, 2015-11-03 (Daniel Rakos)

* 
Added allocation callbacks to surface creation function.

Revision 4, 2015-11-10 (Jesse Hall)

* 
Removed VK_ERROR_INVALID_ANDROID_WINDOW_KHR.

Revision 5, 2015-11-28 (Daniel Rakos)

* 
Updated the surface create function to take a pCreateInfo structure.

Revision 6, 2016-01-14 (James Jones)

* 
Moved VK_ERROR_NATIVE_WINDOW_IN_USE_KHR from the VK_KHR_android_surface
to the VK_KHR_surface extension.

**Name String**

`VK_KHR_calibrated_timestamps`

**Extension Type**

Device extension

**Registered Extension Number**

544

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Contact**

* 
Daniel Rakos [aqnuep](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_calibrated_timestamps] @aqnuep%0A*Here describe the issue or question you have about the VK_KHR_calibrated_timestamps extension*)

**Extension Proposal**

[VK_EXT_calibrated_timestamps](../../../features/latest/features/proposals/VK_EXT_calibrated_timestamps.html)

**Last Modified Date**

2023-07-12

**IP Status**

No known IP claims.

**Contributors**

* 
Matthaeus G. Chajdas, AMD

* 
Alan Harrison, AMD

* 
Derrick Owens, AMD

* 
Daniel Rakos, RasterGrid

* 
Faith Ekstrand, Intel

* 
Keith Packard, Valve

This extension provides an interface to query calibrated timestamps obtained
quasi simultaneously from two time domains.

* 
[vkGetCalibratedTimestampsKHR](../chapters/synchronization.html#vkGetCalibratedTimestampsKHR)

* 
[vkGetPhysicalDeviceCalibrateableTimeDomainsKHR](../chapters/capabilities.html#vkGetPhysicalDeviceCalibrateableTimeDomainsKHR)

* 
[VkCalibratedTimestampInfoKHR](../chapters/synchronization.html#VkCalibratedTimestampInfoKHR)

* 
[VkTimeDomainKHR](../chapters/synchronization.html#VkTimeDomainKHR)

* 
`VK_KHR_CALIBRATED_TIMESTAMPS_EXTENSION_NAME`

* 
`VK_KHR_CALIBRATED_TIMESTAMPS_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_KHR`

* 
Revision 1, 2023-07-12 (Daniel Rakos)

Initial draft.

**Name String**

`VK_KHR_compute_shader_derivatives`

**Extension Type**

Device extension

**Registered Extension Number**

512

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**SPIR-V Dependencies**

* 
[SPV_KHR_compute_shader_derivatives](https://github.khronos.org/SPIRV-Registry/extensions/KHR/SPV_KHR_compute_shader_derivatives.html)

**Contact**

* 
Jean-Noe Morissette [MagicPoncho](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_compute_shader_derivatives] @MagicPoncho%0A*Here describe the issue or question you have about the VK_KHR_compute_shader_derivatives extension*)

**Extension Proposal**

[VK_KHR_compute_shader_derivatives](../../../features/latest/features/proposals/VK_KHR_compute_shader_derivatives.html)

**Last Modified Date**

2024-06-26

**IP Status**

No known IP claims.

**Interactions and External Dependencies**

* 
This extension requires
[`SPV_KHR_compute_shader_derivatives`](https://github.khronos.org/SPIRV-Registry/extensions/KHR/SPV_KHR_compute_shader_derivatives.html)

* 
This extension provides API support for
[`GL_KHR_compute_shader_derivatives`](https://github.com/KhronosGroup/GLSL/blob/main/extensions/khr/GLSL_KHR_compute_shader_derivatives.txt)

**Contributors**

* 
Jean-Noe Morissette, Epic Games

* 
Daniel Koch, NVIDIA

* 
Pat Brown, NVIDIA

* 
Stu Smith, AMD

* 
Jan-Harald Fredriksen, Arm

* 
Tobias Hector, AMD

* 
Ralph Potter, Samsung

* 
Pan Gao, Huawei

* 
Samuel (Sheng-Wen) Huang, MediaTek

* 
Graeme Leese, Broadcom

* 
Hans-Kristian Arntzen, Valve

* 
Matthew Netsh, Qualcomm

This extension adds Vulkan support for the
[`SPV_KHR_compute_shader_derivatives`](https://github.khronos.org/SPIRV-Registry/extensions/KHR/SPV_KHR_compute_shader_derivatives.html)
SPIR-V extension.

The SPIR-V extension provides two new execution modes, both of which allow
execution models with defined workgroups to use built-ins that evaluate
derivatives explicitly or implicitly.
Derivatives will be computed via differencing over a 2x2 group of shader
invocations.
The `DerivativeGroupQuadsKHR` execution mode assembles shader invocations
into 2x2 groups, where each group has x and y coordinates of the local
invocation ID of the form (2m+{0,1}, 2n+{0,1}).
The `DerivativeGroupLinearKHR` execution mode assembles shader
invocations into 2x2 groups, where each group has local invocation index
values of the form 4m+{0,1,2,3}.

The new execution modes are supported in compute shaders and optionally (see
[meshAndTaskShaderDerivatives](../chapters/limits.html#limits-meshAndTaskShaderDerivatives)) in
mesh and task shaders.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR](../chapters/features.html#VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR](../chapters/limits.html#VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR)

* 
`VK_KHR_COMPUTE_SHADER_DERIVATIVES_EXTENSION_NAME`

* 
`VK_KHR_COMPUTE_SHADER_DERIVATIVES_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_PROPERTIES_KHR`

* 
[    `ComputeDerivativeGroupQuadsKHR`](spirvenv.html#spirvenv-capabilities-table-ComputeDerivativeGroupQuadsKHR)

* 
[    `ComputeDerivativeGroupLinearKHR`](spirvenv.html#spirvenv-capabilities-table-ComputeDerivativeGroupLinearKHR)

None.

* 
Revision 1, 2023-02-27 (Jean-Noe Morissette)

Initial draft

* 
Add properties and clarify mesh and task support (Daniel Koch)

**Name String**

`VK_KHR_cooperative_matrix`

**Extension Type**

Device extension

**Registered Extension Number**

507

**Revision**

2

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**SPIR-V Dependencies**

* 
[SPV_KHR_cooperative_matrix](https://github.khronos.org/SPIRV-Registry/extensions/KHR/SPV_KHR_cooperative_matrix.html)

**Contact**

* 
Kevin Petit [kpet](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_cooperative_matrix] @kpet%0A*Here describe the issue or question you have about the VK_KHR_cooperative_matrix extension*)

**Extension Proposal**

[VK_KHR_cooperative_matrix](../../../features/latest/features/proposals/VK_KHR_cooperative_matrix.html)

**Last Modified Date**

2023-05-03

**Interactions and External Dependencies**

* 
This extension provides API support for
[`GLSL_KHR_cooperative_matrix`](https://github.com/KhronosGroup/GLSL/blob/main/extensions/khr/GLSL_KHR_cooperative_matrix.txt)

**Contributors**

* 
Jeff Bolz, NVIDIA

* 
Markus Tavenrath, NVIDIA

* 
Daniel Koch, NVIDIA

* 
Kevin Petit, Arm Ltd.

* 
Boris Zanin, AMD

This extension adds support for using cooperative matrix types in SPIR-V.
Cooperative matrix types are medium-sized matrices that are primarily
supported in compute shaders, where the storage for the matrix is spread
across all invocations in some scope (usually a subgroup) and those
invocations cooperate to efficiently perform matrix multiplies.

Cooperative matrix types are defined by the
[`SPV_KHR_cooperative_matrix`](https://github.khronos.org/SPIRV-Registry/extensions/KHR/SPV_KHR_cooperative_matrix.html)
SPIR-V extension and can be used with the
[`GLSL_KHR_cooperative_matrix`](https://github.com/KhronosGroup/GLSL/blob/main/extensions/khr/GLSL_KHR_cooperative_matrix.txt)
GLSL extension.

This extension includes support for enumerating the matrix types and
dimensions that are supported by the implementation.

* 
[vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR](../chapters/shaders.html#vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR)

* 
[VkCooperativeMatrixPropertiesKHR](../chapters/shaders.html#VkCooperativeMatrixPropertiesKHR)

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceCooperativeMatrixFeaturesKHR](../chapters/features.html#VkPhysicalDeviceCooperativeMatrixFeaturesKHR)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceCooperativeMatrixPropertiesKHR](../chapters/limits.html#VkPhysicalDeviceCooperativeMatrixPropertiesKHR)

* 
[VkComponentTypeKHR](../chapters/shaders.html#VkComponentTypeKHR)

* 
[VkScopeKHR](../chapters/shaders.html#VkScopeKHR)

* 
`VK_KHR_COOPERATIVE_MATRIX_EXTENSION_NAME`

* 
`VK_KHR_COOPERATIVE_MATRIX_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_KHR`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR`

* 
[CooperativeMatrixKHR](spirvenv.html#spirvenv-capabilities-table-CooperativeMatrixKHR)

* 
Revision 2, 2023-05-03 (Kevin Petit)

First KHR revision

Revision 1, 2019-02-05 (Jeff Bolz)

* 
NVIDIA vendor extension

**Name String**

`VK_KHR_deferred_host_operations`

**Extension Type**

Device extension

**Registered Extension Number**

269

**Revision**

4

**Ratification Status**

Ratified

**Extension and Version Dependencies**

None

**Contact**

* 
Josh Barczak [jbarczak](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_deferred_host_operations] @jbarczak%0A*Here describe the issue or question you have about the VK_KHR_deferred_host_operations extension*)

**Last Modified Date**

2020-11-12

**IP Status**

No known IP claims.

**Contributors**

* 
Joshua Barczak, Intel

* 
Jeff Bolz, NVIDIA

* 
Daniel Koch, NVIDIA

* 
Slawek Grajewski, Intel

* 
Tobias Hector, AMD

* 
Yuriy ODonnell, Epic

* 
Eric Werness, NVIDIA

* 
Baldur Karlsson, Valve

* 
Jesse Barker, Unity

* 
Contributors to VK_KHR_acceleration_structure,
VK_KHR_ray_tracing_pipeline

The `[VK_KHR_deferred_host_operations](#VK_KHR_deferred_host_operations)` extension defines the
infrastructure and usage patterns for deferrable commands, but does not
specify any commands as deferrable.
This is left to additional dependent extensions.
Commands **must** not be deferred unless the deferral is specifically allowed
by another extension which depends on
`[VK_KHR_deferred_host_operations](#VK_KHR_deferred_host_operations)`.

* 
[VkDeferredOperationKHR](../chapters/VK_KHR_deferred_host_operations/deferred_host_operations.html#VkDeferredOperationKHR)

* 
[vkCreateDeferredOperationKHR](../chapters/VK_KHR_deferred_host_operations/deferred_host_operations.html#vkCreateDeferredOperationKHR)

* 
[vkDeferredOperationJoinKHR](../chapters/VK_KHR_deferred_host_operations/deferred_host_operations.html#vkDeferredOperationJoinKHR)

* 
[vkDestroyDeferredOperationKHR](../chapters/VK_KHR_deferred_host_operations/deferred_host_operations.html#vkDestroyDeferredOperationKHR)

* 
[vkGetDeferredOperationMaxConcurrencyKHR](../chapters/VK_KHR_deferred_host_operations/deferred_host_operations.html#vkGetDeferredOperationMaxConcurrencyKHR)

* 
[vkGetDeferredOperationResultKHR](../chapters/VK_KHR_deferred_host_operations/deferred_host_operations.html#vkGetDeferredOperationResultKHR)

* 
`VK_KHR_DEFERRED_HOST_OPERATIONS_EXTENSION_NAME`

* 
`VK_KHR_DEFERRED_HOST_OPERATIONS_SPEC_VERSION`

* 
Extending [VkObjectType](../chapters/debugging.html#VkObjectType):

`VK_OBJECT_TYPE_DEFERRED_OPERATION_KHR`

Extending [VkResult](../chapters/fundamentals.html#VkResult):

* 
`VK_OPERATION_DEFERRED_KHR`

* 
`VK_OPERATION_NOT_DEFERRED_KHR`

* 
`VK_THREAD_DONE_KHR`

* 
`VK_THREAD_IDLE_KHR`

The following examples will illustrate the concept of deferrable operations
using a hypothetical example.
The command `vkDoSomethingExpensive` denotes a deferrable command.

The following example illustrates how a vulkan application might request
deferral of an expensive operation:

// create a deferred operation
VkDeferredOperationKHR hOp;
VkResult result = vkCreateDeferredOperationKHR(device, pCallbacks, &hOp);
assert(result == VK_SUCCESS);

result = vkDoSomethingExpensive(device, hOp, ...);
assert( result == VK_OPERATION_DEFERRED_KHR );

// operation was deferred.  Execute it asynchronously
std::async::launch(
    [ hOp ] ( )
    {
        vkDeferredOperationJoinKHR(device, hOp);

        result = vkGetDeferredOperationResultKHR(device, hOp);

        // deferred operation is now complete.  'result' indicates success or failure

        vkDestroyDeferredOperationKHR(device, hOp, pCallbacks);
    }
);

The following example illustrates extracting concurrency from a single
deferred operation:

// create a deferred operation
VkDeferredOperationKHR hOp;
VkResult result = vkCreateDeferredOperationKHR(device, pCallbacks, &hOp);
assert(result == VK_SUCCESS);

result = vkDoSomethingExpensive(device, hOp, ...);
assert( result == VK_OPERATION_DEFERRED_KHR );

// Query the maximum amount of concurrency and clamp to the desired maximum
uint32_t numLaunches = std::min(vkGetDeferredOperationMaxConcurrencyKHR(device, hOp), maxThreads);

std::vector > joins;

for (uint32_t i = 0; i 

The following example shows a subroutine which guarantees completion of a
deferred operation, in the presence of multiple worker threads, and returns
the result of the operation.

VkResult FinishDeferredOperation(VkDeferredOperationKHR hOp)
{
    // Attempt to join the operation until the implementation indicates that we should stop

    VkResult result = vkDeferredOperationJoinKHR(device, hOp);
    while( result == VK_THREAD_IDLE_KHR )
    {
        std::this_thread::yield();
        result = vkDeferredOperationJoinKHR(device, hOp);
    }

    switch( result )
    {
    case VK_SUCCESS:
        {
            // deferred operation has finished.  Query its result.
            result = vkGetDeferredOperationResultKHR(device, hOp);
        }
        break;

    case VK_THREAD_DONE_KHR:
        {
            // deferred operation is being wrapped up by another thread
            //  wait for that thread to finish
            do
            {
                std::this_thread::yield();
                result = vkGetDeferredOperationResultKHR(device, hOp);
            } while( result == VK_NOT_READY );
        }
        break;

    default:
        assert(false); // other conditions are illegal.
        break;
    }

    return result;
}

Should this extension have a VkPhysicalDevice*FeaturesKHR structure?

**RESOLVED**: No.
This extension does not add any functionality on its own and requires a
dependent extension to actually enable functionality and thus there is no
value in adding a feature structure.
If necessary, any dependent extension could add a feature boolean if it
wanted to indicate that it is adding optional deferral support.

* 
Revision 1, 2019-12-05 (Josh Barczak, Daniel Koch)

Initial draft.

Revision 2, 2020-03-06 (Daniel Koch, Tobias Hector)

* 
Add missing VK_OBJECT_TYPE_DEFERRED_OPERATION_KHR enum

* 
fix sample code

* 
Clarified deferred operation parameter lifetimes (#2018,!3647)

Revision 3, 2020-05-15 (Josh Barczak)

* 
Clarify behavior of vkGetDeferredOperationMaxConcurrencyKHR, allowing
it to return 0 if the operation is complete (#2036,!3850)

Revision 4, 2020-11-12 (Tobias Hector, Daniel Koch)

* 
Remove VkDeferredOperationInfoKHR and change return value semantics
when deferred host operations are in use (#2067,3813)

* 
clarify return value of vkGetDeferredOperationResultKHR (#2339,!4110)

**Name String**

`VK_KHR_depth_clamp_zero_one`

**Extension Type**

Device extension

**Registered Extension Number**

605

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Contact**

* 
Graeme Leese [gnl21](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_depth_clamp_zero_one] @gnl21%0A*Here describe the issue or question you have about the VK_KHR_depth_clamp_zero_one extension*)

**Last Modified Date**

2024-09-10

**Contributors**

* 
Graeme Leese, Broadcom

This extension is based on the `[VK_EXT_depth_clamp_zero_one](#VK_EXT_depth_clamp_zero_one)`
extension.
This extension gives defined behavior to fragment depth values which end up
outside the conventional [0, 1] range.
It can be used to ensure portability in edge cases of features like
depthBias.
The particular behavior is chosen to match OpenGL to aid porting or
emulation.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceDepthClampZeroOneFeaturesKHR](../chapters/features.html#VkPhysicalDeviceDepthClampZeroOneFeaturesKHR)

* 
`VK_KHR_DEPTH_CLAMP_ZERO_ONE_EXTENSION_NAME`

* 
`VK_KHR_DEPTH_CLAMP_ZERO_ONE_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_KHR`

* 
Revision 1, 2024-09-10 (Graeme Leese)

Internal revisions

**Name String**

`VK_KHR_display`

**Extension Type**

Instance extension

**Registered Extension Number**

3

**Revision**

23

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_surface](#VK_KHR_surface)

**Contact**

* 
James Jones [cubanismo](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_display] @cubanismo%0A*Here describe the issue or question you have about the VK_KHR_display extension*)

* 
Norbert Nopper [FslNopper](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_display] @FslNopper%0A*Here describe the issue or question you have about the VK_KHR_display extension*)

**Last Modified Date**

2017-03-13

**IP Status**

No known IP claims.

**Contributors**

* 
James Jones, NVIDIA

* 
Norbert Nopper, Freescale

* 
Jeff Vigil, Qualcomm

* 
Daniel Rakos, AMD

This extension provides the API to enumerate displays and available modes on
a given device.

* 
[VkDisplayKHR](../chapters/VK_KHR_surface/wsi.html#VkDisplayKHR)

* 
[VkDisplayModeKHR](../chapters/VK_KHR_surface/wsi.html#VkDisplayModeKHR)

* 
[vkCreateDisplayModeKHR](../chapters/VK_KHR_surface/wsi.html#vkCreateDisplayModeKHR)

* 
[vkCreateDisplayPlaneSurfaceKHR](../chapters/VK_KHR_surface/wsi.html#vkCreateDisplayPlaneSurfaceKHR)

* 
[vkGetDisplayModePropertiesKHR](../chapters/VK_KHR_surface/wsi.html#vkGetDisplayModePropertiesKHR)

* 
[vkGetDisplayPlaneCapabilitiesKHR](../chapters/VK_KHR_surface/wsi.html#vkGetDisplayPlaneCapabilitiesKHR)

* 
[vkGetDisplayPlaneSupportedDisplaysKHR](../chapters/VK_KHR_surface/wsi.html#vkGetDisplayPlaneSupportedDisplaysKHR)

* 
[vkGetPhysicalDeviceDisplayPlanePropertiesKHR](../chapters/VK_KHR_surface/wsi.html#vkGetPhysicalDeviceDisplayPlanePropertiesKHR)

* 
[vkGetPhysicalDeviceDisplayPropertiesKHR](../chapters/VK_KHR_surface/wsi.html#vkGetPhysicalDeviceDisplayPropertiesKHR)

* 
[VkDisplayModeCreateInfoKHR](../chapters/VK_KHR_surface/wsi.html#VkDisplayModeCreateInfoKHR)

* 
[VkDisplayModeParametersKHR](../chapters/VK_KHR_surface/wsi.html#VkDisplayModeParametersKHR)

* 
[VkDisplayModePropertiesKHR](../chapters/VK_KHR_surface/wsi.html#VkDisplayModePropertiesKHR)

* 
[VkDisplayPlaneCapabilitiesKHR](../chapters/VK_KHR_surface/wsi.html#VkDisplayPlaneCapabilitiesKHR)

* 
[VkDisplayPlanePropertiesKHR](../chapters/VK_KHR_surface/wsi.html#VkDisplayPlanePropertiesKHR)

* 
[VkDisplayPropertiesKHR](../chapters/VK_KHR_surface/wsi.html#VkDisplayPropertiesKHR)

* 
[VkDisplaySurfaceCreateInfoKHR](../chapters/VK_KHR_surface/wsi.html#VkDisplaySurfaceCreateInfoKHR)

* 
[VkDisplayPlaneAlphaFlagBitsKHR](../chapters/VK_KHR_surface/wsi.html#VkDisplayPlaneAlphaFlagBitsKHR)

* 
[VkDisplayModeCreateFlagsKHR](../chapters/VK_KHR_surface/wsi.html#VkDisplayModeCreateFlagsKHR)

* 
[VkDisplayPlaneAlphaFlagsKHR](../chapters/VK_KHR_surface/wsi.html#VkDisplayPlaneAlphaFlagsKHR)

* 
[VkDisplaySurfaceCreateFlagsKHR](../chapters/VK_KHR_surface/wsi.html#VkDisplaySurfaceCreateFlagsKHR)

* 
[VkSurfaceTransformFlagsKHR](../chapters/VK_KHR_surface/wsi.html#VkSurfaceTransformFlagsKHR)

* 
`VK_KHR_DISPLAY_EXTENSION_NAME`

* 
`VK_KHR_DISPLAY_SPEC_VERSION`

* 
Extending [VkObjectType](../chapters/debugging.html#VkObjectType):

`VK_OBJECT_TYPE_DISPLAY_KHR`

* 
`VK_OBJECT_TYPE_DISPLAY_MODE_KHR`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR`

1) Which properties of a mode should be fixed in the mode information vs.
settable in some other function when setting the mode? E.g., do we need to
double the size of the mode pool to include both stereo and non-stereo
modes? YUV and RGB scanout even if they both take RGB input images? BGR vs.
RGB input? etc.

**RESOLVED**: Many modern displays support at most a handful of resolutions
and timings natively.
Other modes are expected to be supported using scaling hardware on the
display engine or GPU.
Other properties, such as rotation and mirroring should not require
duplicating hardware modes just to express all combinations.
Further, these properties may be implemented on a per-display or per-overlay
granularity.

To avoid the exponential growth of modes as mutable properties are added, as
was the case with `EGLConfig`/WGL pixel formats/`GLXFBConfig`, this
specification should separate out hardware properties and configurable state
into separate objects.
Modes and overlay planes will express capabilities of the hardware, while a
separate structure will allow applications to configure scaling, rotation,
mirroring, color keys, LUT values, alpha masks, etc.
for a given swapchain independent of the mode in use.
Constraints on these settings will be established by properties of the
immutable objects.

Note the resolution of this issue may affect issue 5 as well.

2) What properties of a display itself are useful?

**RESOLVED**: This issue is too broad.
It was meant to prompt general discussion, but resolving this issue amounts
to completing this specification.
All interesting properties should be included.
The issue will remain as a placeholder since removing it would make it hard
to parse existing discussion notes that refer to issues by number.

3) How are multiple overlay planes within a display or mode enumerated?

**RESOLVED**: They are referred to by an index.
Each display will report the number of overlay planes it contains.

4) Should swapchains be created relative to a mode or a display?

**RESOLVED**: When using this extension, swapchains are created relative to a
mode and a plane.
The mode implies the display object the swapchain will present to.
If the specified mode is not the displays current mode, the new mode will
be applied when the first image is presented to the swapchain, and the
default operating system mode, if any, will be restored when the swapchain
is destroyed.

5) Should users query generic ranges from displays and construct their own
modes explicitly using those constraints rather than querying a fixed set of
modes (Most monitors only have one real mode these days, even though
many support relatively arbitrary scaling, either on the monitor side or in
the GPU display engine, making modes something of a relic/compatibility
construct).

**RESOLVED**: Expose both.
Display information structures will expose a set of predefined modes, as
well as any attributes necessary to construct a customized mode.

6) Is it fine if we return the display and display mode handles in the
structure used to query their properties?

**RESOLVED**: Yes.

7) Is there a possibility that not all displays of a device work with all of
the present queues of a device? If yes, how do we determine which displays
work with which present queues?

**RESOLVED**: No known hardware has such limitations, but determining such
limitations is supported automatically using the existing
`[VK_KHR_surface](#VK_KHR_surface)` and `[VK_KHR_swapchain](#VK_KHR_swapchain)` query mechanisms.

8) Should all presentation need to be done relative to an overlay plane, or
can a display mode + display be used alone to target an output?

**RESOLVED**: Require specifying a plane explicitly.

9) Should displays have an associated window system display, such as an
`HDC` or `Display*`?

**RESOLVED**: No.
Displays are independent of any windowing system in use on the system.
Further, neither `HDC` nor `Display*` refer to a physical display
object.

10) Are displays queried from a physical GPU or from a device instance?

**RESOLVED**: Developers prefer to query modes directly from the physical GPU
so they can use display information as an input to their device selection
algorithms prior to device creation.
This avoids the need to create placeholder device instances to enumerate
displays.

This preference must be weighed against the extra initialization that must
be done by driver vendors prior to device instance creation to support this
usage.

11) Should displays and/or modes be dispatchable objects? If functions are
to take displays, overlays, or modes as their first parameter, they must be
dispatchable objects as defined in Khronos bug 13529.
If they are not added to the list of dispatchable objects, functions
operating on them must take some higher-level object as their first
parameter.
There is no performance case against making them dispatchable objects, but
they would be the first extension objects to be dispatchable.

**RESOLVED**: Do not make displays or modes dispatchable.
They will dispatch based on their associated physical device.

12) Should hardware cursor capabilities be exposed?

**RESOLVED**: Defer.
This could be a separate extension on top of the base WSI specs.

13) How many display objects should be enumerated for "tiled" display
devices? There are ongoing design discussions among lower-level display API
authors regarding how to expose displays if they are one physical display
device to an end user, but may internally be implemented as two side-by-side
displays using the same display engine (and sometimes cabling) resources as
two physically separate display devices.

**RESOLVED**: Tiled displays will appear as a single display object in this
API.

14) Should the raw EDID data be included in the display information?

**RESOLVED**: No.
A future extension could be added which reports the EDID if necessary.
This may be complicated by the outcome of issue 13.

15) Should min and max scaling factor capabilities of overlays be exposed?

**RESOLVED**: Yes.
This is exposed indirectly by allowing applications to query the min/max
position and extent of the source and destination regions from which image
contents are fetched by the display engine when using a particular mode and
overlay pair.

16) Should devices be able to expose planes that can be moved between
displays? If so, how?

**RESOLVED**: Yes.
Applications can determine which displays a given plane supports using
[vkGetDisplayPlaneSupportedDisplaysKHR](../chapters/VK_KHR_surface/wsi.html#vkGetDisplayPlaneSupportedDisplaysKHR).

17) Should there be a way to destroy display modes? If so, does it support
destroying built in modes?

**RESOLVED**: Not in this extension.
A future extension could add this functionality.

18) What should the lifetime of display and built-in display mode objects
be?

**RESOLVED**: The lifetime of the instance.
These objects cannot be destroyed.
A future extension may be added to expose a way to destroy these objects
and/or support display hotplug.

19) Should persistent mode for smart panels be enabled/disabled at swapchain
creation time, or on a per-present basis.

**RESOLVED**: On a per-present basis.

|  | The example code for the `VK_KHR_display` and
| --- | --- |
`[VK_KHR_display_swapchain](#VK_KHR_display_swapchain)` extensions was removed from the appendix
after revision 1.0.43.
The display enumeration example code was ported to the cube demo that is
shipped with the official Khronos SDK, and is being kept up-to-date in that
location (see:
[https://github.com/KhronosGroup/Vulkan-Tools/blob/main/cube/cube.c](https://github.com/KhronosGroup/Vulkan-Tools/blob/main/cube/cube.c)). |

* 
Revision 1, 2015-02-24 (James Jones)

Initial draft

Revision 2, 2015-03-12 (Norbert Nopper)

* 
Added overlay enumeration for a display.

Revision 3, 2015-03-17 (Norbert Nopper)

* 
Fixed typos and namings as discussed in Bugzilla.

* 
Reordered and grouped functions.

* 
Added functions to query count of display, mode and overlay.

* 
Added native display handle, which may be needed on some platforms to
create a native Window.

Revision 4, 2015-03-18 (Norbert Nopper)

* 
Removed primary and virtualPostion members (see comment of James Jones
in Bugzilla).

* 
Added native overlay handle to information structure.

* 
Replaced , with ; in struct.

Revision 6, 2015-03-18 (Daniel Rakos)

* 
Added WSI extension suffix to all items.

* 
Made the whole API more Vulkanish.

* 
Replaced all functions with a single vkGetDisplayInfoKHR function to
better match the rest of the API.

* 
Made the display, display mode, and overlay objects be first class
objects, not subclasses of VkBaseObject as they do not support the
common functions anyways.

* 
Renamed *Info structures to *Properties.

* 
Removed overlayIndex field from VkOverlayProperties as there is an
implicit index already as a result of moving to a Vulkanish API.

* 
Displays are not get through device, but through physical GPU to match
the rest of the Vulkan API.
Also this is something ISVs explicitly requested.

* 
Added issue (6) and (7).

Revision 7, 2015-03-25 (James Jones)

* 
Added an issues section

* 
Added rotation and mirroring flags

Revision 8, 2015-03-25 (James Jones)

* 
Combined the duplicate issues sections introduced in last change.

* 
Added proposed resolutions to several issues.

Revision 9, 2015-04-01 (Daniel Rakos)

* 
Rebased extension against Vulkan 0.82.0

Revision 10, 2015-04-01 (James Jones)

* 
Added issues (10) and (11).

* 
Added more straw-man issue resolutions, and cleaned up the proposed
resolution for issue (4).

* 
Updated the rotation and mirroring enums to have proper bitmask
semantics.

Revision 11, 2015-04-15 (James Jones)

* 
Added proposed resolution for issues (1) and (2).

* 
Added issues (12), (13), (14), and (15)

* 
Removed pNativeHandle field from overlay structure.

* 
Fixed small compilation errors in example code.

Revision 12, 2015-07-29 (James Jones)

* 
Rewrote the guts of the extension against the latest WSI swapchain
specifications and the latest Vulkan API.

* 
Address overlay planes by their index rather than an object handle and
refer to them as planes rather than overlays to make it
slightly clearer that even a display with no overlays still has at
least one base plane that images can be displayed on.

* 
Updated most of the issues.

* 
Added an extension type section to the specification header.

* 
Reused the VK_EXT_KHR_surface surface transform enumerations rather
than redefining them here.

* 
Updated the example code to use the new semantics.

Revision 13, 2015-08-21 (Ian Elliott)

* 
Renamed this extension and all of its enumerations, types, functions,
etc.
This makes it compliant with the proposed standard for Vulkan
extensions.

* 
Switched from revision to version, including use of the
VK_MAKE_VERSION macro in the header file.

Revision 14, 2015-09-01 (James Jones)

* 
Restore single-field revision number.

Revision 15, 2015-09-08 (James Jones)

* 
Added alpha flags enum.

* 
Added premultiplied alpha support.

Revision 16, 2015-09-08 (James Jones)

* 
Added description section to the spec.

* 
Added issues 16 - 18.

Revision 17, 2015-10-02 (James Jones)

* 
Planes are now a property of the entire device rather than individual
displays.
This allows planes to be moved between multiple displays on devices
that support it.

* 
Added a function to create a VkSurfaceKHR object describing a display
plane and mode to align with the new per-platform surface creation
conventions.

* 
Removed detailed mode timing data.
It was agreed that the mode extents and refresh rate are sufficient for
current use cases.
Other information could be added back in as an extension if it is
needed in the future.

* 
Added support for smart/persistent/buffered display devices.

Revision 18, 2015-10-26 (Ian Elliott)

* 
Renamed from VK_EXT_KHR_display to VK_KHR_display.

Revision 19, 2015-11-02 (James Jones)

* 
Updated example code to match revision 17 changes.

Revision 20, 2015-11-03 (Daniel Rakos)

* 
Added allocation callbacks to creation functions.

Revision 21, 2015-11-10 (Jesse Hall)

* 
Added VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR, and use
VkDisplayPlaneAlphaFlagBitsKHR for
VkDisplayPlanePropertiesKHR::alphaMode instead of
VkDisplayPlaneAlphaFlagsKHR, since it only represents one mode.

* 
Added reserved flags bitmask to VkDisplayPlanePropertiesKHR.

* 
Use VkSurfaceTransformFlagBitsKHR instead of obsolete
VkSurfaceTransformKHR.

* 
Renamed vkGetDisplayPlaneSupportedDisplaysKHR parameters for clarity.

Revision 22, 2015-12-18 (James Jones)

* 
Added missing planeIndex parameter to
vkGetDisplayPlaneSupportedDisplaysKHR()

Revision 23, 2017-03-13 (James Jones)

* 
Closed all remaining issues.
The specification and implementations have been shipping with the
proposed resolutions for some time now.

* 
Removed the sample code and noted it has been integrated into the
official Vulkan SDK cube demo.

**Name String**

`VK_KHR_display_swapchain`

**Extension Type**

Device extension

**Registered Extension Number**

4

**Revision**

10

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_swapchain](#VK_KHR_swapchain)

and

[VK_KHR_display](#VK_KHR_display)

**Contact**

* 
James Jones [cubanismo](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_display_swapchain] @cubanismo%0A*Here describe the issue or question you have about the VK_KHR_display_swapchain extension*)

**Last Modified Date**

2017-03-13

**IP Status**

No known IP claims.

**Contributors**

* 
James Jones, NVIDIA

* 
Jeff Vigil, Qualcomm

* 
Jesse Hall, Google

This extension provides an API to create a swapchain directly on a devices
display without any underlying window system.

* 
[vkCreateSharedSwapchainsKHR](../chapters/VK_KHR_surface/wsi.html#vkCreateSharedSwapchainsKHR)

* 
Extending [VkPresentInfoKHR](../chapters/VK_KHR_surface/wsi.html#VkPresentInfoKHR):

[VkDisplayPresentInfoKHR](../chapters/VK_KHR_surface/wsi.html#VkDisplayPresentInfoKHR)

* 
`VK_KHR_DISPLAY_SWAPCHAIN_EXTENSION_NAME`

* 
`VK_KHR_DISPLAY_SWAPCHAIN_SPEC_VERSION`

* 
Extending [VkResult](../chapters/fundamentals.html#VkResult):

`VK_ERROR_INCOMPATIBLE_DISPLAY_KHR`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR`

1) Should swapchains sharing images each hold a reference to the images, or
should it be up to the application to destroy the swapchains and images in
an order that avoids the need for reference counting?

**RESOLVED**: Take a reference.
The lifetime of presentable images is already complex enough.

2) Should the `srcRect` and `dstRect` parameters be specified as
part of the presentation command, or at swapchain creation time?

**RESOLVED**: As part of the presentation command.
This allows moving and scaling the image on the screen without the need to
respecify the mode or create a new swapchain and presentable images.

3) Should `srcRect` and `dstRect` be specified as rects, or separate
offset/extent values?

**RESOLVED**: As rects.
Specifying them separately might make it easier for hardware to expose
support for one but not the other, but in such cases applications must just
take care to obey the reported capabilities and not use non-zero offsets or
extents that require scaling, as appropriate.

4) How can applications create multiple swapchains that use the same images?

**RESOLVED**: By calling [vkCreateSharedSwapchainsKHR](../chapters/VK_KHR_surface/wsi.html#vkCreateSharedSwapchainsKHR).

An earlier resolution used [vkCreateSwapchainKHR](../chapters/VK_KHR_surface/wsi.html#vkCreateSwapchainKHR), chaining multiple
[VkSwapchainCreateInfoKHR](../chapters/VK_KHR_surface/wsi.html#VkSwapchainCreateInfoKHR) structures through `pNext`.
In order to allow each swapchain to also allow other extension structs, a
level of indirection was used: [VkSwapchainCreateInfoKHR](../chapters/VK_KHR_surface/wsi.html#VkSwapchainCreateInfoKHR)::`pNext`
pointed to a different structure, which had both `sType` and `pNext`
members for additional extensions, and also had a pointer to the next
[VkSwapchainCreateInfoKHR](../chapters/VK_KHR_surface/wsi.html#VkSwapchainCreateInfoKHR) structure.
The number of swapchains to be created could only be found by walking this
linked list of alternating structures, and the `pSwapchains` out
parameter was reinterpreted to be an array of [VkSwapchainKHR](../chapters/VK_KHR_surface/wsi.html#VkSwapchainKHR) handles.

Another option considered was a method to specify a shared swapchain
when creating a new swapchain, such that groups of swapchains using the same
images could be built up one at a time.
This was deemed unusable because drivers need to know all of the displays an
image will be used on when determining which internal formats and layouts to
use for that image.

|  | The example code for the `[VK_KHR_display](#VK_KHR_display)` and
| --- | --- |
`VK_KHR_display_swapchain` extensions was removed from the appendix after
revision 1.0.43.
The display swapchain creation example code was ported to the cube demo that
is shipped with the official Khronos SDK, and is being kept up-to-date in
that location (see:
[https://github.com/KhronosGroup/Vulkan-Tools/blob/main/cube/cube.c](https://github.com/KhronosGroup/Vulkan-Tools/blob/main/cube/cube.c)). |

* 
Revision 1, 2015-07-29 (James Jones)

Initial draft

Revision 2, 2015-08-21 (Ian Elliott)

* 
Renamed this extension and all of its enumerations, types, functions,
etc.
This makes it compliant with the proposed standard for Vulkan
extensions.

* 
Switched from revision to version, including use of the
VK_MAKE_VERSION macro in the header file.

Revision 3, 2015-09-01 (James Jones)

* 
Restore single-field revision number.

Revision 4, 2015-09-08 (James Jones)

* 
Allow creating multiple swapchains that share the same images using a
single call to vkCreateSwapchainKHR().

Revision 5, 2015-09-10 (Alon Or-bach)

* 
Removed underscores from SWAP_CHAIN in two enums.

Revision 6, 2015-10-02 (James Jones)

* 
Added support for smart panels/buffered displays.

Revision 7, 2015-10-26 (Ian Elliott)

* 
Renamed from VK_EXT_KHR_display_swapchain to VK_KHR_display_swapchain.

Revision 8, 2015-11-03 (Daniel Rakos)

* 
Updated sample code based on the changes to VK_KHR_swapchain.

Revision 9, 2015-11-10 (Jesse Hall)

* 
Replaced VkDisplaySwapchainCreateInfoKHR with
vkCreateSharedSwapchainsKHR, changing resolution of issue #4.

Revision 10, 2017-03-13 (James Jones)

* 
Closed all remaining issues.
The specification and implementations have been shipping with the
proposed resolutions for some time now.

* 
Removed the sample code and noted it has been integrated into the
official Vulkan SDK cube demo.

**Name String**

`VK_KHR_external_fence_fd`

**Extension Type**

Device extension

**Registered Extension Number**

116

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_external_fence](#VK_KHR_external_fence)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Contact**

* 
Jesse Hall [critsec](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_external_fence_fd] @critsec%0A*Here describe the issue or question you have about the VK_KHR_external_fence_fd extension*)

**Last Modified Date**

2017-05-08

**IP Status**

No known IP claims.

**Contributors**

* 
Jesse Hall, Google

* 
James Jones, NVIDIA

* 
Jeff Juliano, NVIDIA

* 
Cass Everitt, Oculus

* 
Contributors to `[VK_KHR_external_semaphore_fd](#VK_KHR_external_semaphore_fd)`

An application using external memory may wish to synchronize access to that
memory using fences.
This extension enables an application to export fence payload to and import
fence payload from POSIX file descriptors.

* 
[vkGetFenceFdKHR](../chapters/synchronization.html#vkGetFenceFdKHR)

* 
[vkImportFenceFdKHR](../chapters/synchronization.html#vkImportFenceFdKHR)

* 
[VkFenceGetFdInfoKHR](../chapters/synchronization.html#VkFenceGetFdInfoKHR)

* 
[VkImportFenceFdInfoKHR](../chapters/synchronization.html#VkImportFenceFdInfoKHR)

* 
`VK_KHR_EXTERNAL_FENCE_FD_EXTENSION_NAME`

* 
`VK_KHR_EXTERNAL_FENCE_FD_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR`

This extension borrows concepts, semantics, and language from
`[VK_KHR_external_semaphore_fd](#VK_KHR_external_semaphore_fd)`.
That extensions issues apply equally to this extension.

* 
Revision 1, 2017-05-08 (Jesse Hall)

Initial revision

**Name String**

`VK_KHR_external_fence_win32`

**Extension Type**

Device extension

**Registered Extension Number**

115

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_external_fence](#VK_KHR_external_fence)

**Contact**

* 
Jesse Hall [critsec](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_external_fence_win32] @critsec%0A*Here describe the issue or question you have about the VK_KHR_external_fence_win32 extension*)

**Last Modified Date**

2017-05-08

**IP Status**

No known IP claims.

**Contributors**

* 
Jesse Hall, Google

* 
James Jones, NVIDIA

* 
Jeff Juliano, NVIDIA

* 
Cass Everitt, Oculus

* 
Contributors to `[VK_KHR_external_semaphore_win32](#VK_KHR_external_semaphore_win32)`

An application using external memory may wish to synchronize access to that
memory using fences.
This extension enables an application to export fence payload to and import
fence payload from Windows handles.

* 
[vkGetFenceWin32HandleKHR](../chapters/synchronization.html#vkGetFenceWin32HandleKHR)

* 
[vkImportFenceWin32HandleKHR](../chapters/synchronization.html#vkImportFenceWin32HandleKHR)

* 
[VkFenceGetWin32HandleInfoKHR](../chapters/synchronization.html#VkFenceGetWin32HandleInfoKHR)

* 
[VkImportFenceWin32HandleInfoKHR](../chapters/synchronization.html#VkImportFenceWin32HandleInfoKHR)

* 
Extending [VkFenceCreateInfo](../chapters/synchronization.html#VkFenceCreateInfo):

[VkExportFenceWin32HandleInfoKHR](../chapters/synchronization.html#VkExportFenceWin32HandleInfoKHR)

* 
`VK_KHR_EXTERNAL_FENCE_WIN32_EXTENSION_NAME`

* 
`VK_KHR_EXTERNAL_FENCE_WIN32_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR`

This extension borrows concepts, semantics, and language from
`[VK_KHR_external_semaphore_win32](#VK_KHR_external_semaphore_win32)`.
That extensions issues apply equally to this extension.

1) Should D3D12 fence handle types be supported, like they are for
semaphores?

**RESOLVED**: No.
Doing so would require extending the fence signal and wait operations to
provide values to signal / wait for, like `VkD3D12FenceSubmitInfoKHR`
does.
A D3D12 fence can be signaled by importing it into a [VkSemaphore](../chapters/synchronization.html#VkSemaphore)
instead of a [VkFence](../chapters/synchronization.html#VkFence), and applications can check status or wait on the
D3D12 fence using non-Vulkan APIs.
The convenience of being able to do these operations on `VkFence`
objects does not justify the extra API complexity.

* 
Revision 1, 2017-05-08 (Jesse Hall)

Initial revision

**Name String**

`VK_KHR_external_memory_fd`

**Extension Type**

Device extension

**Registered Extension Number**

75

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_external_memory](#VK_KHR_external_memory)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Contact**

* 
James Jones [cubanismo](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_external_memory_fd] @cubanismo%0A*Here describe the issue or question you have about the VK_KHR_external_memory_fd extension*)

**Last Modified Date**

2016-10-21

**IP Status**

No known IP claims.

**Contributors**

* 
James Jones, NVIDIA

* 
Jeff Juliano, NVIDIA

An application may wish to reference device memory in multiple Vulkan
logical devices or instances, in multiple processes, and/or in multiple
APIs.
This extension enables an application to export POSIX file descriptor
handles from Vulkan memory objects and to import Vulkan memory objects from
POSIX file descriptor handles exported from other Vulkan memory objects or
from similar resources in other APIs.

* 
[vkGetMemoryFdKHR](../chapters/memory.html#vkGetMemoryFdKHR)

* 
[vkGetMemoryFdPropertiesKHR](../chapters/memory.html#vkGetMemoryFdPropertiesKHR)

* 
[VkMemoryFdPropertiesKHR](../chapters/memory.html#VkMemoryFdPropertiesKHR)

* 
[VkMemoryGetFdInfoKHR](../chapters/memory.html#VkMemoryGetFdInfoKHR)

* 
Extending [VkMemoryAllocateInfo](../chapters/memory.html#VkMemoryAllocateInfo):

[VkImportMemoryFdInfoKHR](../chapters/memory.html#VkImportMemoryFdInfoKHR)

* 
`VK_KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME`

* 
`VK_KHR_EXTERNAL_MEMORY_FD_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR`

* 
`VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR`

1) Does the application need to close the file descriptor returned by
[vkGetMemoryFdKHR](../chapters/memory.html#vkGetMemoryFdKHR)?

**RESOLVED**: Yes, unless it is passed back in to a driver instance to import
the memory.
A successful get call transfers ownership of the file descriptor to the
application, and a successful import transfers it back to the driver.
Destroying the original memory object will not close the file descriptor or
remove its reference to the underlying memory resource associated with it.

2) Do drivers ever need to expose multiple file descriptors per memory
object?

**RESOLVED**: No.
This would indicate there are actually multiple memory objects, rather than
a single memory object.

3) How should the valid size and memory type for POSIX file descriptor
memory handles created outside of Vulkan be specified?

**RESOLVED**: The valid memory types are queried directly from the external
handle.
The size will be specified by future extensions that introduce such external
memory handle types.

* 
Revision 1, 2016-10-21 (James Jones)

Initial revision

**Name String**

`VK_KHR_external_memory_win32`

**Extension Type**

Device extension

**Registered Extension Number**

74

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_external_memory](#VK_KHR_external_memory)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Contact**

* 
James Jones [cubanismo](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_external_memory_win32] @cubanismo%0A*Here describe the issue or question you have about the VK_KHR_external_memory_win32 extension*)

**Last Modified Date**

2016-10-21

**IP Status**

No known IP claims.

**Contributors**

* 
James Jones, NVIDIA

* 
Jeff Juliano, NVIDIA

* 
Carsten Rohde, NVIDIA

An application may wish to reference device memory in multiple Vulkan
logical devices or instances, in multiple processes, and/or in multiple
APIs.
This extension enables an application to export Windows handles from Vulkan
memory objects and to import Vulkan memory objects from Windows handles
exported from other Vulkan memory objects or from similar resources in other
APIs.

* 
[vkGetMemoryWin32HandleKHR](../chapters/memory.html#vkGetMemoryWin32HandleKHR)

* 
[vkGetMemoryWin32HandlePropertiesKHR](../chapters/memory.html#vkGetMemoryWin32HandlePropertiesKHR)

* 
[VkMemoryGetWin32HandleInfoKHR](../chapters/memory.html#VkMemoryGetWin32HandleInfoKHR)

* 
[VkMemoryWin32HandlePropertiesKHR](../chapters/memory.html#VkMemoryWin32HandlePropertiesKHR)

* 
Extending [VkMemoryAllocateInfo](../chapters/memory.html#VkMemoryAllocateInfo):

[VkExportMemoryWin32HandleInfoKHR](../chapters/memory.html#VkExportMemoryWin32HandleInfoKHR)

* 
[VkImportMemoryWin32HandleInfoKHR](../chapters/memory.html#VkImportMemoryWin32HandleInfoKHR)

* 
`VK_KHR_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME`

* 
`VK_KHR_EXTERNAL_MEMORY_WIN32_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR`

1) Do applications need to call `CloseHandle`() on the values returned
from [vkGetMemoryWin32HandleKHR](../chapters/memory.html#vkGetMemoryWin32HandleKHR) when `handleType` is
`VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR`?

**RESOLVED**: Yes.
A successful get call transfers ownership of the handle to the application.
Destroying the memory object will not destroy the handle or the handles
reference to the underlying memory resource.
Unlike file descriptor opaque handles, win32 opaque handle ownership can not
be transferred back to a driver by an import operation.

2) Should the language regarding KMT/Windows 7 handles be moved to a
separate extension so that it can be deprecated over time?

**RESOLVED**: No.
Support for them can be deprecated by drivers if they choose, by no longer
returning them in the supported handle types of the instance level queries.

3) How should the valid size and memory type for windows memory handles
created outside of Vulkan be specified?

**RESOLVED**: The valid memory types are queried directly from the external
handle.
The size is determined by the associated image or buffer memory requirements
for external handle types that require dedicated allocations, and by the
size specified when creating the object from which the handle was exported
for other external handle types.

* 
Revision 1, 2016-10-21 (James Jones)

Initial revision

**Name String**

`VK_KHR_external_semaphore_fd`

**Extension Type**

Device extension

**Registered Extension Number**

80

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_external_semaphore](#VK_KHR_external_semaphore)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Contact**

* 
James Jones [cubanismo](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_external_semaphore_fd] @cubanismo%0A*Here describe the issue or question you have about the VK_KHR_external_semaphore_fd extension*)

**Last Modified Date**

2016-10-21

**IP Status**

No known IP claims.

**Contributors**

* 
Jesse Hall, Google

* 
James Jones, NVIDIA

* 
Jeff Juliano, NVIDIA

* 
Carsten Rohde, NVIDIA

An application using external memory may wish to synchronize access to that
memory using semaphores.
This extension enables an application to export semaphore payload to and
import semaphore payload from POSIX file descriptors.

* 
[vkGetSemaphoreFdKHR](../chapters/synchronization.html#vkGetSemaphoreFdKHR)

* 
[vkImportSemaphoreFdKHR](../chapters/synchronization.html#vkImportSemaphoreFdKHR)

* 
[VkImportSemaphoreFdInfoKHR](../chapters/synchronization.html#VkImportSemaphoreFdInfoKHR)

* 
[VkSemaphoreGetFdInfoKHR](../chapters/synchronization.html#VkSemaphoreGetFdInfoKHR)

* 
`VK_KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME`

* 
`VK_KHR_EXTERNAL_SEMAPHORE_FD_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR`

1) Does the application need to close the file descriptor returned by
[vkGetSemaphoreFdKHR](../chapters/synchronization.html#vkGetSemaphoreFdKHR)?

**RESOLVED**: Yes, unless it is passed back in to a driver instance to import
the semaphore.
A successful get call transfers ownership of the file descriptor to the
application, and a successful import transfers it back to the driver.
Destroying the original semaphore object will not close the file descriptor
or remove its reference to the underlying semaphore resource associated with
it.

* 
Revision 1, 2016-10-21 (Jesse Hall)

Initial revision

**Name String**

`VK_KHR_external_semaphore_win32`

**Extension Type**

Device extension

**Registered Extension Number**

79

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_external_semaphore](#VK_KHR_external_semaphore)

**Contact**

* 
James Jones [cubanismo](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_external_semaphore_win32] @cubanismo%0A*Here describe the issue or question you have about the VK_KHR_external_semaphore_win32 extension*)

**Last Modified Date**

2016-10-21

**IP Status**

No known IP claims.

**Contributors**

* 
James Jones, NVIDIA

* 
Jeff Juliano, NVIDIA

* 
Carsten Rohde, NVIDIA

An application using external memory may wish to synchronize access to that
memory using semaphores.
This extension enables an application to export semaphore payload to and
import semaphore payload from Windows handles.

* 
[vkGetSemaphoreWin32HandleKHR](../chapters/synchronization.html#vkGetSemaphoreWin32HandleKHR)

* 
[vkImportSemaphoreWin32HandleKHR](../chapters/synchronization.html#vkImportSemaphoreWin32HandleKHR)

* 
[VkImportSemaphoreWin32HandleInfoKHR](../chapters/synchronization.html#VkImportSemaphoreWin32HandleInfoKHR)

* 
[VkSemaphoreGetWin32HandleInfoKHR](../chapters/synchronization.html#VkSemaphoreGetWin32HandleInfoKHR)

* 
Extending [VkSemaphoreCreateInfo](../chapters/synchronization.html#VkSemaphoreCreateInfo):

[VkExportSemaphoreWin32HandleInfoKHR](../chapters/synchronization.html#VkExportSemaphoreWin32HandleInfoKHR)

Extending [VkSubmitInfo](../chapters/cmdbuffers.html#VkSubmitInfo):

* 
[VkD3D12FenceSubmitInfoKHR](../chapters/cmdbuffers.html#VkD3D12FenceSubmitInfoKHR)

* 
`VK_KHR_EXTERNAL_SEMAPHORE_WIN32_EXTENSION_NAME`

* 
`VK_KHR_EXTERNAL_SEMAPHORE_WIN32_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR`

1) Do applications need to call `CloseHandle`() on the values returned
from [vkGetSemaphoreWin32HandleKHR](../chapters/synchronization.html#vkGetSemaphoreWin32HandleKHR) when `handleType` is
`VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR`?

**RESOLVED**: Yes.
A successful get call transfers ownership of the handle to the application.
Destroying the semaphore object will not destroy the handle or the handles
reference to the underlying semaphore resource.
Unlike file descriptor opaque handles, win32 opaque handle ownership can not
be transferred back to a driver by an import operation.

2) Should the language regarding KMT/Windows 7 handles be moved to a
separate extension so that it can be deprecated over time?

**RESOLVED**: No.
Support for them can be deprecated by drivers if they choose, by no longer
returning them in the supported handle types of the instance level queries.

3) Should applications be allowed to specify additional object attributes
for shared handles?

**RESOLVED**: Yes.
Applications will be allowed to provide similar attributes to those they
would to any other handle creation API.

4) How do applications communicate the desired fence values to use with
`D3D12_FENCE`-based Vulkan semaphores?

**RESOLVED**: There are a couple of options.
The values for the signaled and reset states could be communicated up front
when creating the object and remain static for the life of the Vulkan
semaphore, or they could be specified using auxiliary structures when
submitting semaphore signal and wait operations, similar to what is done
with the keyed mutex extensions.
The latter is more flexible and consistent with the keyed mutex usage, but
the former is a much simpler API.

Since Vulkan tends to favor flexibility and consistency over simplicity, a
new structure specifying D3D12 fence acquire and release values is added to
the [vkQueueSubmit](../chapters/cmdbuffers.html#vkQueueSubmit) function.

* 
Revision 1, 2016-10-21 (James Jones)

Initial revision

**Name String**

`VK_KHR_fragment_shader_barycentric`

**Extension Type**

Device extension

**Registered Extension Number**

323

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**SPIR-V Dependencies**

* 
[SPV_KHR_fragment_shader_barycentric](https://github.khronos.org/SPIRV-Registry/extensions/KHR/SPV_KHR_fragment_shader_barycentric.html)

**Contact**

* 
Stu Smith

**Extension Proposal**

[VK_KHR_fragment_shader_barycentric](../../../features/latest/features/proposals/VK_KHR_fragment_shader_barycentric.html)

**Last Modified Date**

2022-03-10

**IP Status**

No known IP claims.

**Interactions and External Dependencies**

* 
This extension provides API support for
[`GL_EXT_fragment_shader_barycentric`](https://github.com/KhronosGroup/GLSL/blob/main/extensions/ext/GLSL_EXT_fragment_shader_barycentric.txt)

**Contributors**

* 
Stu Smith, AMD

* 
Tobias Hector, AMD

* 
Graeme Leese, Broadcom

* 
Jan-Harald Fredriksen, Arm

* 
Slawek Grajewski, Intel

* 
Pat Brown, NVIDIA

* 
Hans-Kristian Arntzen, Valve

* 
Contributors to the VK_NV_fragment_shader_barycentric specification

This extension is based on the `[VK_NV_fragment_shader_barycentric](#VK_NV_fragment_shader_barycentric)`
extension, and adds support for the following SPIR-V extension in Vulkan:

* 
[`SPV_KHR_fragment_shader_barycentric`](https://github.khronos.org/SPIRV-Registry/extensions/KHR/SPV_KHR_fragment_shader_barycentric.html)

The extension provides access to three additional fragment shader variable
decorations in SPIR-V:

* 
`PerVertexKHR`, which indicates that a fragment shader input will not
have interpolated values, but instead must be accessed with an extra
array index that identifies one of the vertices of the primitive
producing the fragment

* 
`BaryCoordKHR`, which indicates that the variable is a
three-component floating-point vector holding barycentric weights for
the fragment produced using perspective interpolation

* 
`BaryCoordNoPerspKHR`, which indicates that the variable is a
three-component floating-point vector holding barycentric weights for
the fragment produced using linear interpolation

When using GLSL source-based shader languages, the following variables from
`GL_EXT_fragment_shader_barycentric` map to these SPIR-V built-in
decorations:

* 
`in vec3 gl_BaryCoordEXT;`  `BaryCoordKHR`

* 
`in vec3 gl_BaryCoordNoPerspEXT;`  `BaryCoordNoPerspKHR`

GLSL variables declared using the `pervertexEXT` GLSL qualifier are
expected to be decorated with `PerVertexKHR` in SPIR-V.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR](../chapters/features.html#VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR](../chapters/limits.html#VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR)

* 
`VK_KHR_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION_NAME`

* 
`VK_KHR_FRAGMENT_SHADER_BARYCENTRIC_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR`

* 
[`BaryCoordKHR`](../chapters/interfaces.html#interfaces-builtin-variables-barycoordkhr)

* 
[`BaryCoordNoPerspKHR`](../chapters/interfaces.html#interfaces-builtin-variables-barycoordnoperspkhr)

* 
[`PerVertexKHR`](../chapters/shaders.html#shaders-interpolation-decorations-pervertexkhr)

* 
[    `FragmentBarycentricKHR`](spirvenv.html#spirvenv-capabilities-table-FragmentBarycentricKHR)

1) What are the interactions with MSAA and how are `BaryCoordKHR` and
`BaryCoordNoPerspKHR` interpolated?

**RESOLVED**: The inputs decorated with `BaryCoordKHR` or
`BaryCoordNoPerspKHR` **may** also be decorated with the `Centroid` or
`Sample` qualifiers to specify interpolation, like any other fragment
shader input.
If the [`shaderSampleRateInterpolationFunctions`](../chapters/features.html#features-shaderSampleRateInterpolationFunctions) feature is enabled, the
extended instructions InterpolateAtCentroid, InterpolateAtOffset, and
InterpolateAtSample from the GLSL.std.450 **may** also be used with inputs
decorated with `BaryCoordKHR` or `BaryCoordNoPerspKHR`.

* 
Revision 1, 2022-03-10 (Stu Smith)

Initial revision

**Name String**

`VK_KHR_fragment_shading_rate`

**Extension Type**

Device extension

**Registered Extension Number**

227

**Revision**

2

**Ratification Status**

Ratified

**Extension and Version Dependencies**

 [VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

 or

 [Vulkan Version 1.1](versions.html#versions-1.1)

 and

 [VK_KHR_create_renderpass2](#VK_KHR_create_renderpass2)

or

[Vulkan Version 1.2](versions.html#versions-1.2)

**API Interactions**

* 
Interacts with VK_VERSION_1_3

* 
Interacts with VK_KHR_dynamic_rendering

* 
Interacts with VK_KHR_format_feature_flags2

**SPIR-V Dependencies**

* 
[SPV_KHR_fragment_shading_rate](https://github.khronos.org/SPIRV-Registry/extensions/KHR/SPV_KHR_fragment_shading_rate.html)

**Contact**

* 
Tobias Hector [tobski](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_fragment_shading_rate] @tobski%0A*Here describe the issue or question you have about the VK_KHR_fragment_shading_rate extension*)

**Extension Proposal**

[VK_KHR_fragment_shading_rate](../../../features/latest/features/proposals/VK_KHR_fragment_shading_rate.html)

**Last Modified Date**

2021-09-30

**Interactions and External Dependencies**

* 
This extension provides API support for
[`GL_EXT_fragment_shading_rate`](https://github.com/KhronosGroup/GLSL/blob/main/extensions/ext/GLSL_EXT_fragment_shading_rate.txt)

**Contributors**

* 
Tobias Hector, AMD

* 
Guennadi Riguer, AMD

* 
Matthaeus Chajdas, AMD

* 
Pat Brown, Nvidia

* 
Matthew Netsch, Qualcomm

* 
Slawomir Grajewski, Intel

* 
Jan-Harald Fredriksen, Arm

* 
Jeff Bolz, Nvidia

* 
Arseny Kapoulkine, Roblox

* 
Contributors to the VK_NV_shading_rate_image specification

* 
Contributors to the VK_EXT_fragment_density_map specification

This extension adds the ability to change the rate at which fragments are
shaded.
Rather than the usual single fragment invocation for each pixel covered by a
primitive, multiple pixels can be shaded by a single fragment shader
invocation.

Up to three methods are available to the application to change the fragment
shading rate:

* 
[Pipeline Fragment Shading Rate](../chapters/primsrast.html#primsrast-fragment-shading-rate-pipeline), which allows the
specification of a rate per-draw.

* 
[Primitive Fragment Shading Rate](../chapters/primsrast.html#primsrast-fragment-shading-rate-primitive), which allows the
specification of a rate per primitive, specified during shading.

* 
[Attachment Fragment Shading Rate](../chapters/primsrast.html#primsrast-fragment-shading-rate-attachment), which allows the
specification of a rate per-region of the framebuffer, specified in a
specialized image attachment.

Additionally, these rates can all be specified and combined in order to
adjust the overall detail in the image at each point.

This functionality can be used to focus shading efforts where higher levels
of detail are needed in some parts of a scene compared to others.
This can be particularly useful in high resolution rendering, or for XR
contexts.

This extension also adds support for the `SPV_KHR_fragment_shading_rate`
extension which enables setting the
[primitive fragment shading rate](../chapters/primsrast.html#primsrast-fragment-shading-rate-primitive), and allows querying the final shading rate from a fragment shader.

* 
[vkCmdSetFragmentShadingRateKHR](../chapters/primsrast.html#vkCmdSetFragmentShadingRateKHR)

* 
[vkGetPhysicalDeviceFragmentShadingRatesKHR](../chapters/primsrast.html#vkGetPhysicalDeviceFragmentShadingRatesKHR)

* 
[VkPhysicalDeviceFragmentShadingRateKHR](../chapters/primsrast.html#VkPhysicalDeviceFragmentShadingRateKHR)

* 
Extending [VkGraphicsPipelineCreateInfo](../chapters/pipelines.html#VkGraphicsPipelineCreateInfo):

[VkPipelineFragmentShadingRateStateCreateInfoKHR](../chapters/primsrast.html#VkPipelineFragmentShadingRateStateCreateInfoKHR)

Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

* 
[VkPhysicalDeviceFragmentShadingRateFeaturesKHR](../chapters/features.html#VkPhysicalDeviceFragmentShadingRateFeaturesKHR)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceFragmentShadingRatePropertiesKHR](../chapters/limits.html#VkPhysicalDeviceFragmentShadingRatePropertiesKHR)

Extending [VkSubpassDescription2](../chapters/renderpass.html#VkSubpassDescription2):

* 
[VkFragmentShadingRateAttachmentInfoKHR](../chapters/renderpass.html#VkFragmentShadingRateAttachmentInfoKHR)

If [Vulkan Version 1.3](versions.html#versions-1.3) or [VK_KHR_dynamic_rendering](#VK_KHR_dynamic_rendering) is supported:

* 
Extending [VkRenderingInfo](../chapters/renderpass.html#VkRenderingInfo):

[VkRenderingFragmentShadingRateAttachmentInfoKHR](../chapters/renderpass.html#VkRenderingFragmentShadingRateAttachmentInfoKHR)

* 
[VkFragmentShadingRateCombinerOpKHR](../chapters/primsrast.html#VkFragmentShadingRateCombinerOpKHR)

* 
`VK_KHR_FRAGMENT_SHADING_RATE_EXTENSION_NAME`

* 
`VK_KHR_FRAGMENT_SHADING_RATE_SPEC_VERSION`

* 
Extending [VkAccessFlagBits](../chapters/synchronization.html#VkAccessFlagBits):

`VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR`

Extending [VkDynamicState](../chapters/pipelines.html#VkDynamicState):

* 
`VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR`

Extending [VkFormatFeatureFlagBits](../chapters/formats.html#VkFormatFeatureFlagBits):

* 
`VK_FORMAT_FEATURE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR`

Extending [VkImageLayout](../chapters/resources.html#VkImageLayout):

* 
`VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR`

Extending [VkImageUsageFlagBits](../chapters/resources.html#VkImageUsageFlagBits):

* 
`VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR`

Extending [VkPipelineStageFlagBits](../chapters/synchronization.html#VkPipelineStageFlagBits):

* 
`VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR`

* 
`VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR`

If [VK_KHR_format_feature_flags2](#VK_KHR_format_feature_flags2) or [Vulkan Version 1.3](versions.html#versions-1.3) is supported:

* 
Extending [VkFormatFeatureFlagBits2](../chapters/formats.html#VkFormatFeatureFlagBits2):

`VK_FORMAT_FEATURE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR`

If [Vulkan Version 1.3](versions.html#versions-1.3) or [VK_KHR_dynamic_rendering](#VK_KHR_dynamic_rendering) is supported:

* 
Extending [VkPipelineCreateFlagBits](../chapters/pipelines.html#VkPipelineCreateFlagBits):

`VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR`

* 
`VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR`

* 
Revision 1, 2020-05-06 (Tobias Hector)

Initial revision

Revision 2, 2021-09-30 (Jon Leech)

* 
Add interaction with `[VK_KHR_format_feature_flags2](#VK_KHR_format_feature_flags2)` to `vk.xml`

**Name String**

`VK_KHR_get_display_properties2`

**Extension Type**

Instance extension

**Registered Extension Number**

122

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_display](#VK_KHR_display)

**Contact**

* 
James Jones [cubanismo](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_get_display_properties2] @cubanismo%0A*Here describe the issue or question you have about the VK_KHR_get_display_properties2 extension*)

**Last Modified Date**

2017-02-21

**IP Status**

No known IP claims.

**Contributors**

* 
Ian Elliott, Google

* 
James Jones, NVIDIA

This extension provides new queries for device display properties and
capabilities that can be easily extended by other extensions, without
introducing any further queries.
This extension can be considered the `[VK_KHR_display](#VK_KHR_display)` equivalent of
the `[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)` extension.

* 
[vkGetDisplayModeProperties2KHR](../chapters/VK_KHR_surface/wsi.html#vkGetDisplayModeProperties2KHR)

* 
[vkGetDisplayPlaneCapabilities2KHR](../chapters/VK_KHR_surface/wsi.html#vkGetDisplayPlaneCapabilities2KHR)

* 
[vkGetPhysicalDeviceDisplayPlaneProperties2KHR](../chapters/VK_KHR_surface/wsi.html#vkGetPhysicalDeviceDisplayPlaneProperties2KHR)

* 
[vkGetPhysicalDeviceDisplayProperties2KHR](../chapters/VK_KHR_surface/wsi.html#vkGetPhysicalDeviceDisplayProperties2KHR)

* 
[VkDisplayModeProperties2KHR](../chapters/VK_KHR_surface/wsi.html#VkDisplayModeProperties2KHR)

* 
[VkDisplayPlaneCapabilities2KHR](../chapters/VK_KHR_surface/wsi.html#VkDisplayPlaneCapabilities2KHR)

* 
[VkDisplayPlaneInfo2KHR](../chapters/VK_KHR_surface/wsi.html#VkDisplayPlaneInfo2KHR)

* 
[VkDisplayPlaneProperties2KHR](../chapters/VK_KHR_surface/wsi.html#VkDisplayPlaneProperties2KHR)

* 
[VkDisplayProperties2KHR](../chapters/VK_KHR_surface/wsi.html#VkDisplayProperties2KHR)

* 
`VK_KHR_GET_DISPLAY_PROPERTIES_2_EXTENSION_NAME`

* 
`VK_KHR_GET_DISPLAY_PROPERTIES_2_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR`

* 
`VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR`

* 
`VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR`

* 
`VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR`

* 
`VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR`

1) What should this extension be named?

**RESOLVED**: `VK_KHR_get_display_properties2`.
Other alternatives:

* 
`VK_KHR_display2`

* 
One extension, combined with `VK_KHR_surface_capabilites2`.

2) Should extensible input structs be added for these new functions:

**RESOLVED**:

* 
[vkGetPhysicalDeviceDisplayProperties2KHR](../chapters/VK_KHR_surface/wsi.html#vkGetPhysicalDeviceDisplayProperties2KHR): No.
The only current input is a [VkPhysicalDevice](../chapters/devsandqueues.html#VkPhysicalDevice).
Other inputs would not make sense.

* 
[vkGetPhysicalDeviceDisplayPlaneProperties2KHR](../chapters/VK_KHR_surface/wsi.html#vkGetPhysicalDeviceDisplayPlaneProperties2KHR): No.
The only current input is a [VkPhysicalDevice](../chapters/devsandqueues.html#VkPhysicalDevice).
Other inputs would not make sense.

* 
[vkGetDisplayModeProperties2KHR](../chapters/VK_KHR_surface/wsi.html#vkGetDisplayModeProperties2KHR): No.
The only current inputs are a [VkPhysicalDevice](../chapters/devsandqueues.html#VkPhysicalDevice) and a
[VkDisplayModeKHR](../chapters/VK_KHR_surface/wsi.html#VkDisplayModeKHR).
Other inputs would not make sense.

3) Should additional display query functions be extended?

**RESOLVED**:

* 
[vkGetDisplayPlaneSupportedDisplaysKHR](../chapters/VK_KHR_surface/wsi.html#vkGetDisplayPlaneSupportedDisplaysKHR): No.
Extensions should instead extend
[vkGetDisplayPlaneCapabilitiesKHR](../chapters/VK_KHR_surface/wsi.html#vkGetDisplayPlaneCapabilitiesKHR)().

* 
Revision 1, 2017-02-21 (James Jones)

Initial draft.

**Name String**

`VK_KHR_get_surface_capabilities2`

**Extension Type**

Instance extension

**Registered Extension Number**

120

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_surface](#VK_KHR_surface)

**Contact**

* 
James Jones [cubanismo](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_get_surface_capabilities2] @cubanismo%0A*Here describe the issue or question you have about the VK_KHR_get_surface_capabilities2 extension*)

**Last Modified Date**

2017-02-27

**IP Status**

No known IP claims.

**Contributors**

* 
Ian Elliott, Google

* 
James Jones, NVIDIA

* 
Alon Or-bach, Samsung

This extension provides new queries for device surface capabilities that can
be easily extended by other extensions, without introducing any further
queries.
This extension can be considered the `[VK_KHR_surface](#VK_KHR_surface)` equivalent of
the `[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)` extension.

* 
[vkGetPhysicalDeviceSurfaceCapabilities2KHR](../chapters/VK_KHR_surface/wsi.html#vkGetPhysicalDeviceSurfaceCapabilities2KHR)

* 
[vkGetPhysicalDeviceSurfaceFormats2KHR](../chapters/VK_KHR_surface/wsi.html#vkGetPhysicalDeviceSurfaceFormats2KHR)

* 
[VkPhysicalDeviceSurfaceInfo2KHR](../chapters/VK_KHR_surface/wsi.html#VkPhysicalDeviceSurfaceInfo2KHR)

* 
[VkSurfaceCapabilities2KHR](../chapters/VK_KHR_surface/wsi.html#VkSurfaceCapabilities2KHR)

* 
[VkSurfaceFormat2KHR](../chapters/VK_KHR_surface/wsi.html#VkSurfaceFormat2KHR)

* 
`VK_KHR_GET_SURFACE_CAPABILITIES_2_EXTENSION_NAME`

* 
`VK_KHR_GET_SURFACE_CAPABILITIES_2_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR`

* 
`VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR`

* 
`VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR`

1) What should this extension be named?

**RESOLVED**: `VK_KHR_get_surface_capabilities2`.
Other alternatives:

* 
`VK_KHR_surface2`

* 
One extension, combining a separate display-specific query extension.

2) Should additional WSI query functions be extended?

**RESOLVED**:

* 
[vkGetPhysicalDeviceSurfaceCapabilitiesKHR](../chapters/VK_KHR_surface/wsi.html#vkGetPhysicalDeviceSurfaceCapabilitiesKHR): Yes.
The need for this motivated the extension.

* 
[vkGetPhysicalDeviceSurfaceSupportKHR](../chapters/VK_KHR_surface/wsi.html#vkGetPhysicalDeviceSurfaceSupportKHR): No.
Currently only has boolean output.
Extensions should instead extend
[vkGetPhysicalDeviceSurfaceCapabilities2KHR](../chapters/VK_KHR_surface/wsi.html#vkGetPhysicalDeviceSurfaceCapabilities2KHR).

* 
[vkGetPhysicalDeviceSurfaceFormatsKHR](../chapters/VK_KHR_surface/wsi.html#vkGetPhysicalDeviceSurfaceFormatsKHR): Yes.

* 
[vkGetPhysicalDeviceSurfacePresentModesKHR](../chapters/VK_KHR_surface/wsi.html#vkGetPhysicalDeviceSurfacePresentModesKHR): No.
Recent discussion concluded this introduced too much variability for
applications to deal with.
Extensions should instead extend
[vkGetPhysicalDeviceSurfaceCapabilities2KHR](../chapters/VK_KHR_surface/wsi.html#vkGetPhysicalDeviceSurfaceCapabilities2KHR).

* 
[vkGetPhysicalDeviceXlibPresentationSupportKHR](../chapters/VK_KHR_surface/wsi.html#vkGetPhysicalDeviceXlibPresentationSupportKHR): Not in this
extension.

* 
[vkGetPhysicalDeviceXcbPresentationSupportKHR](../chapters/VK_KHR_surface/wsi.html#vkGetPhysicalDeviceXcbPresentationSupportKHR): Not in this
extension.

* 
[vkGetPhysicalDeviceWaylandPresentationSupportKHR](../chapters/VK_KHR_surface/wsi.html#vkGetPhysicalDeviceWaylandPresentationSupportKHR): Not in this
extension.

* 
[vkGetPhysicalDeviceWin32PresentationSupportKHR](../chapters/VK_KHR_surface/wsi.html#vkGetPhysicalDeviceWin32PresentationSupportKHR): Not in this
extension.

* 
Revision 1, 2017-02-27 (James Jones)

Initial draft.

**Name String**

`VK_KHR_incremental_present`

**Extension Type**

Device extension

**Registered Extension Number**

85

**Revision**

2

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_swapchain](#VK_KHR_swapchain)

**Contact**

* 
Ian Elliott [ianelliottus](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_incremental_present] @ianelliottus%0A*Here describe the issue or question you have about the VK_KHR_incremental_present extension*)

**Last Modified Date**

2016-11-02

**IP Status**

No known IP claims.

**Contributors**

* 
Ian Elliott, Google

* 
Jesse Hall, Google

* 
Alon Or-bach, Samsung

* 
James Jones, NVIDIA

* 
Daniel Rakos, AMD

* 
Ray Smith, ARM

* 
Mika Isojarvi, Google

* 
Jeff Juliano, NVIDIA

* 
Jeff Bolz, NVIDIA

This device extension extends [vkQueuePresentKHR](../chapters/VK_KHR_surface/wsi.html#vkQueuePresentKHR), from the
`[VK_KHR_swapchain](#VK_KHR_swapchain)` extension, allowing an application to specify a
list of rectangular, modified regions of each image to present.
This should be used in situations where an application is only changing a
small portion of the presentable images within a swapchain, since it enables
the presentation engine to avoid wasting time presenting parts of the
surface that have not changed.

This extension is leveraged from the `EGL_KHR_swap_buffers_with_damage`
extension.

* 
[VkPresentRegionKHR](../chapters/VK_KHR_surface/wsi.html#VkPresentRegionKHR)

* 
[VkRectLayerKHR](../chapters/VK_KHR_surface/wsi.html#VkRectLayerKHR)

* 
Extending [VkPresentInfoKHR](../chapters/VK_KHR_surface/wsi.html#VkPresentInfoKHR):

[VkPresentRegionsKHR](../chapters/VK_KHR_surface/wsi.html#VkPresentRegionsKHR)

* 
`VK_KHR_INCREMENTAL_PRESENT_EXTENSION_NAME`

* 
`VK_KHR_INCREMENTAL_PRESENT_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR`

1) How should we handle steroescopic-3D swapchains? We need to add a layer
for each rectangle.
One approach is to create another structure containing the [VkRect2D](../chapters/fundamentals.html#VkRect2D)
plus layer, and have [VkPresentRegionsKHR](../chapters/VK_KHR_surface/wsi.html#VkPresentRegionsKHR) point to an array of that
struct.
Another approach is to have two parallel arrays, `pRectangles` and
`pLayers`, where `pRectangles`[i] and `pLayers`[i] must be used
together.
Which approach should we use, and if the array of a new structure, what
should that be called?

**RESOLVED**: Create a new structure, which is a [VkRect2D](../chapters/fundamentals.html#VkRect2D) plus a layer,
and will be called [VkRectLayerKHR](../chapters/VK_KHR_surface/wsi.html#VkRectLayerKHR).

2) Where is the origin of the [VkRectLayerKHR](../chapters/VK_KHR_surface/wsi.html#VkRectLayerKHR)?

**RESOLVED**: The upper left corner of the presentable image(s) of the
swapchain, per the definition of framebuffer coordinates.

3) Does the rectangular region, [VkRectLayerKHR](../chapters/VK_KHR_surface/wsi.html#VkRectLayerKHR), specify pixels of the
swapchains image(s), or of the surface?

**RESOLVED**: Of the image(s).
Some presentation engines may scale the pixels of a swapchains image(s) to
the size of the surface.
The size of the swapchains image(s) will be consistent, where the size of
the surface may vary over time.

4) What if all of the rectangles for a given swapchain contain a width
and/or height of zero?

**RESOLVED**: The application is indicating that no pixels changed since the
last present.
The presentation engine may use such a hint and not update any pixels for
the swapchain.
However, all other semantics of [vkQueuePresentKHR](../chapters/VK_KHR_surface/wsi.html#vkQueuePresentKHR) must still be
honored, including waiting for semaphores to signal.

5) When the swapchain is created with
`VkSwapchainCreateInfoKHR`::`preTransform` set to a value other than
`VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR`, should the rectangular region,
[VkRectLayerKHR](../chapters/VK_KHR_surface/wsi.html#VkRectLayerKHR), be transformed to align with the `preTransform`?

**RESOLVED**: No.
The rectangular region in [VkRectLayerKHR](../chapters/VK_KHR_surface/wsi.html#VkRectLayerKHR) should not be transformed.
As such, it may not align with the extents of the swapchains image(s).
It is the responsibility of the presentation engine to transform the
rectangular region.
This matches the behavior of the Android presentation engine, which set the
precedent.

* 
Revision 1, 2016-11-02 (Ian Elliott)

Internal revisions

Revision 2, 2021-03-18 (Ian Elliott)

* 
Clarified alignment of rectangles for presentation engines that support
transformed swapchains.

**Name String**

`VK_KHR_maintenance7`

**Extension Type**

Device extension

**Registered Extension Number**

563

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[Vulkan Version 1.1](versions.html#versions-1.1)

**Contact**

* 
Mike Blumenkrantz [zmike](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_maintenance7] @zmike%0A*Here describe the issue or question you have about the VK_KHR_maintenance7 extension*)

**Extension Proposal**

[VK_KHR_maintenance7](../../../features/latest/features/proposals/VK_KHR_maintenance7.html)

**Last Modified Date**

2024-01-30

**Interactions and External Dependencies**
**Contributors**

* 
Mike Blumenkrantz, Valve

* 
Hans-Kristian Arntzen, Valve

* 
Pan Gao, Huawei

* 
Tobias Hector, AMD

* 
Jon Leech, Khronos

* 
Daniel Story, Nintendo

* 
Shahbaz Youssefi, Google

* 
Yiwei Zhang, Google

* 
Matthew Netsch, Qualcomm

[VK_KHR_maintenance7](#VK_KHR_maintenance7) adds a collection of minor features, none of
which would warrant an entire extension of their own.

The proposed new features are as follows:

* 
Add a property query to determine if a framebuffer writes to depth or
stencil aspect does not trigger a write access in the sibling aspect.
For example, this allows sampling stencil aspect as a texture while
rendering to the sibling depth attachment and vice-versa given
appropriate image layouts.

* 
Add a way to query information regarding the underlying devices in
environments where the Vulkan implementation is provided through layered
implementations.
For example, running on Mesa/Venus, driver ID is returned as
`VK_DRIVER_ID_MESA_VENUS`, but it can be necessary to know what the
real driver under the hood is.
The new [VkPhysicalDeviceLayeredApiPropertiesKHR](../chapters/limits.html#VkPhysicalDeviceLayeredApiPropertiesKHR) structure can be
used to gather information regarding layers underneath the top-level
physical device.

* 
Promote `VK_RENDERING_CONTENTS_INLINE_BIT_EXT` and
`VK_SUBPASS_CONTENTS_INLINE_AND_SECONDARY_COMMAND_BUFFERS_EXT` to
KHR

* 
Add a limit to report the maximum total count of dynamic uniform buffers
and dynamic storage buffers that can be included in a pipeline layout.

* 
Require that for an unsigned integer query, the 32-bit result value
**must** be equal to the 32 least significant bits of the equivalent 64-bit
result value.

* 
Add query for robust access support when using fragment shading rate
attachments

* 
[VkPhysicalDeviceLayeredApiPropertiesKHR](../chapters/limits.html#VkPhysicalDeviceLayeredApiPropertiesKHR)

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceMaintenance7FeaturesKHR](../chapters/features.html#VkPhysicalDeviceMaintenance7FeaturesKHR)

Extending [VkPhysicalDeviceLayeredApiPropertiesKHR](../chapters/limits.html#VkPhysicalDeviceLayeredApiPropertiesKHR):

* 
[VkPhysicalDeviceLayeredApiVulkanPropertiesKHR](../chapters/limits.html#VkPhysicalDeviceLayeredApiVulkanPropertiesKHR)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceLayeredApiPropertiesListKHR](../chapters/limits.html#VkPhysicalDeviceLayeredApiPropertiesListKHR)

* 
[VkPhysicalDeviceMaintenance7PropertiesKHR](../chapters/limits.html#VkPhysicalDeviceMaintenance7PropertiesKHR)

* 
[VkPhysicalDeviceLayeredApiKHR](../chapters/limits.html#VkPhysicalDeviceLayeredApiKHR)

* 
`VK_KHR_MAINTENANCE_7_EXTENSION_NAME`

* 
`VK_KHR_MAINTENANCE_7_SPEC_VERSION`

* 
Extending [VkRenderingFlagBits](../chapters/renderpass.html#VkRenderingFlagBits):

`VK_RENDERING_CONTENTS_INLINE_BIT_KHR`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_KHR`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_LIST_KHR`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_VULKAN_PROPERTIES_KHR`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_FEATURES_KHR`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_PROPERTIES_KHR`

Extending [VkSubpassContents](../chapters/renderpass.html#VkSubpassContents):

* 
`VK_SUBPASS_CONTENTS_INLINE_AND_SECONDARY_COMMAND_BUFFERS_KHR`

None.

* 
Revision 1, 2024-01-30 (Jon Leech)

Initial revision

**Name String**

`VK_KHR_maintenance8`

**Extension Type**

Device extension

**Registered Extension Number**

575

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[Vulkan Version 1.1](versions.html#versions-1.1)

**Contact**

* 
Mike Blumenkrantz [zmike](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_maintenance8] @zmike%0A*Here describe the issue or question you have about the VK_KHR_maintenance8 extension*)

**Extension Proposal**

[VK_KHR_maintenance8](../../../features/latest/features/proposals/VK_KHR_maintenance8.html)

**Last Modified Date**

2025-01-07

**Interactions and External Dependencies**
**Contributors**

* 
Jon Leech, Khronos

* 
Mike Blumenkrantz, Valve

* 
Spencer Fricke, LunarG

* 
Jan-Harald Fredriksen, ARM

* 
Piers Daniell, NVIDIA

* 
Matthew Netsch, Qualcomm

* 
Ricardo Garcia, Igalia

* 
Lionel Landwerlin, Intel

* 
Rick Hammerstone, Qualcomm

* 
Daniel Story, Nintendo

* 
Hans-Kristian Arntzen, Valve

* 
Caterina Shablia, Collabora

* 
Georg Lehmann, Valve

* 
Shahbaz Youssefi, Google

* 
Tobias Hector, AMD

[VK_KHR_maintenance8](#VK_KHR_maintenance8) adds a collection of minor features, none of
which would warrant an entire extension of their own.

The new features are as follows:

* 
Allow copies between depth/stencil and matching color attachments

* 
Allow `dstCache` in `vkMergePipelineCaches` to be implicitly
synchronized.

* 
Require src/dst sync scopes to work when doing queue family ownership
transfers

* 
Support `Offset` (as an alternative to `ConstOffset`) image operand in
texture sampling and fetch operations

* 
Use the SPIR-V definition of `OpSRem` and `OpSMod`, making these
operations produce well-defined results for negative operands

* 
Loosen layer restrictions when blitting from 3D images to other image
types

* 
Add space for an additional 64 access flags for use with
VkMemoryBarrier2, VkBufferMemoryBarrier2, and VkImageMemoryBarrier2

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceMaintenance8FeaturesKHR](../chapters/features.html#VkPhysicalDeviceMaintenance8FeaturesKHR)

Extending [VkSubpassDependency2](../chapters/renderpass.html#VkSubpassDependency2), [VkBufferMemoryBarrier2](../chapters/synchronization.html#VkBufferMemoryBarrier2), [VkImageMemoryBarrier2](../chapters/synchronization.html#VkImageMemoryBarrier2):

* 
[VkMemoryBarrierAccessFlags3KHR](../chapters/synchronization.html#VkMemoryBarrierAccessFlags3KHR)

* 
[VkAccessFlagBits3KHR](../chapters/synchronization.html#VkAccessFlagBits3KHR)

* 
[VkAccessFlags3KHR](../chapters/synchronization.html#VkAccessFlags3KHR)

* 
`VK_KHR_MAINTENANCE_8_EXTENSION_NAME`

* 
`VK_KHR_MAINTENANCE_8_SPEC_VERSION`

* 
Extending [VkDependencyFlagBits](../chapters/synchronization.html#VkDependencyFlagBits):

`VK_DEPENDENCY_QUEUE_FAMILY_OWNERSHIP_TRANSFER_USE_ALL_STAGES_BIT_KHR`

Extending [VkPipelineCacheCreateFlagBits](../chapters/pipelines.html#VkPipelineCacheCreateFlagBits):

* 
`VK_PIPELINE_CACHE_CREATE_INTERNALLY_SYNCHRONIZED_MERGE_BIT_KHR`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_MEMORY_BARRIER_ACCESS_FLAGS_3_KHR`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_8_FEATURES_KHR`

None.

* 
Revision 1, 2024-06-20 (Jon Leech)

Initial revision

**Name String**

`VK_KHR_performance_query`

**Extension Type**

Device extension

**Registered Extension Number**

117

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Special Use**

* 
[Developer tools](../chapters/extensions.html#extendingvulkan-compatibility-specialuse)

**Contact**

* 
Alon Or-bach [alonorbach](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_performance_query] @alonorbach%0A*Here describe the issue or question you have about the VK_KHR_performance_query extension*)

**Last Modified Date**

2019-10-08

**IP Status**

No known IP claims.

**Contributors**

* 
Jesse Barker, Unity Technologies

* 
Kenneth Benzie, Codeplay

* 
Jan-Harald Fredriksen, ARM

* 
Jeff Leger, Qualcomm

* 
Jesse Hall, Google

* 
Tobias Hector, AMD

* 
Neil Henning, Codeplay

* 
Baldur Karlsson

* 
Lionel Landwerlin, Intel

* 
Peter Lohrmann, AMD

* 
Alon Or-bach, Samsung

* 
Daniel Rakos, AMD

* 
Niklas Smedberg, Unity Technologies

* 
Igor Ostrowski, Intel

The `VK_KHR_performance_query` extension adds a mechanism to allow querying
of performance counters for use in applications and by profiling tools.

Each queue family **may** expose counters that **can** be enabled on a queue of
that family.
We extend [VkQueryType](../chapters/queries.html#VkQueryType) to add a new query type for performance queries,
and chain a structure on [VkQueryPoolCreateInfo](../chapters/queries.html#VkQueryPoolCreateInfo) to specify the
performance queries to enable.

* 
[vkAcquireProfilingLockKHR](../chapters/queries.html#vkAcquireProfilingLockKHR)

* 
[vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR](../chapters/devsandqueues.html#vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR)

* 
[vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR](../chapters/queries.html#vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR)

* 
[vkReleaseProfilingLockKHR](../chapters/queries.html#vkReleaseProfilingLockKHR)

* 
[VkAcquireProfilingLockInfoKHR](../chapters/queries.html#VkAcquireProfilingLockInfoKHR)

* 
[VkPerformanceCounterDescriptionKHR](../chapters/devsandqueues.html#VkPerformanceCounterDescriptionKHR)

* 
[VkPerformanceCounterKHR](../chapters/devsandqueues.html#VkPerformanceCounterKHR)

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDevicePerformanceQueryFeaturesKHR](../chapters/features.html#VkPhysicalDevicePerformanceQueryFeaturesKHR)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDevicePerformanceQueryPropertiesKHR](../chapters/limits.html#VkPhysicalDevicePerformanceQueryPropertiesKHR)

Extending [VkQueryPoolCreateInfo](../chapters/queries.html#VkQueryPoolCreateInfo):

* 
[VkQueryPoolPerformanceCreateInfoKHR](../chapters/queries.html#VkQueryPoolPerformanceCreateInfoKHR)

Extending [VkSubmitInfo](../chapters/cmdbuffers.html#VkSubmitInfo), [VkSubmitInfo2](../chapters/cmdbuffers.html#VkSubmitInfo2):

* 
[VkPerformanceQuerySubmitInfoKHR](../chapters/cmdbuffers.html#VkPerformanceQuerySubmitInfoKHR)

* 
[VkPerformanceCounterResultKHR](../chapters/queries.html#VkPerformanceCounterResultKHR)

* 
[VkAcquireProfilingLockFlagBitsKHR](../chapters/queries.html#VkAcquireProfilingLockFlagBitsKHR)

* 
[VkPerformanceCounterDescriptionFlagBitsKHR](../chapters/devsandqueues.html#VkPerformanceCounterDescriptionFlagBitsKHR)

* 
[VkPerformanceCounterScopeKHR](../chapters/devsandqueues.html#VkPerformanceCounterScopeKHR)

* 
[VkPerformanceCounterStorageKHR](../chapters/devsandqueues.html#VkPerformanceCounterStorageKHR)

* 
[VkPerformanceCounterUnitKHR](../chapters/devsandqueues.html#VkPerformanceCounterUnitKHR)

* 
[VkAcquireProfilingLockFlagsKHR](../chapters/queries.html#VkAcquireProfilingLockFlagsKHR)

* 
[VkPerformanceCounterDescriptionFlagsKHR](../chapters/devsandqueues.html#VkPerformanceCounterDescriptionFlagsKHR)

* 
`VK_KHR_PERFORMANCE_QUERY_EXTENSION_NAME`

* 
`VK_KHR_PERFORMANCE_QUERY_SPEC_VERSION`

* 
Extending [VkQueryType](../chapters/queries.html#VkQueryType):

`VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR`

* 
`VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR`

* 
`VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR`

* 
`VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR`

1) Should this extension include a mechanism to begin a query in command
buffer *A* and end the query in command buffer *B*?

**RESOLVED** No - queries are tied to command buffer creation and thus have to
be encapsulated within a single command buffer.

2) Should this extension include a mechanism to begin and end queries
globally on the queue, not using the existing command buffer commands?

**RESOLVED** No - for the same reasoning as the resolution of 1).

3) Should this extension expose counters that require multiple passes?

**RESOLVED** Yes - users should re-submit a command buffer with the same
commands in it multiple times, specifying the pass to count as the query
parameter in VkPerformanceQuerySubmitInfoKHR.

4) How to handle counters across parallel workloads?

**RESOLVED** In the spirit of Vulkan, a counter description flag
`VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_BIT_KHR`
denotes that the accuracy of a counter result is affected by parallel
workloads.

5) How to handle secondary command buffers?

**RESOLVED** Secondary command buffers inherit any counter pass index
specified in the parent primary command buffer.
Note: this is no longer an issue after change from issue 10 resolution

6) What commands does the profiling lock have to be held for?

**RESOLVED** For any command buffer that is being queried with a performance
query pool, the profiling lock **must** be held while that command buffer is in
the *recording*, *executable*, or *pending state*.

7) Should we support [vkCmdCopyQueryPoolResults](../chapters/queries.html#vkCmdCopyQueryPoolResults)?

**RESOLVED** Yes.

8) Should we allow performance queries to interact with multiview?

**RESOLVED** Yes, but the performance queries must be performed once for each
pass per view.

9) Should a `queryCount > 1` be usable for performance queries?

**RESOLVED** Yes.
Some vendors will have costly performance counter query pool creation, and
would rather if a certain set of counters were to be used multiple times
that a `queryCount > 1` can be used to amortize the instantiation cost.

10) Should we introduce an indirect mechanism to set the counter pass index?

**RESOLVED** Specify the counter pass index at submit time instead, to avoid
requiring re-recording of command buffers when multiple counter passes are
needed.

The following example shows how to find what performance counters a queue
family supports, setup a query pool to record these performance counters,
how to add the query pool to the command buffer to record information, and
how to get the results from the query pool.

// A previously created physical device
VkPhysicalDevice physicalDevice;

// One of the queue families our device supports
uint32_t queueFamilyIndex;

uint32_t counterCount;

// Get the count of counters supported
vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(
  physicalDevice,
  queueFamilyIndex,
  &counterCount,
  NULL,
  NULL);

VkPerformanceCounterKHR* counters =
  malloc(sizeof(VkPerformanceCounterKHR) * counterCount);
VkPerformanceCounterDescriptionKHR* counterDescriptions =
  malloc(sizeof(VkPerformanceCounterDescriptionKHR) * counterCount);

// Get the counters supported
vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(
  physicalDevice,
  queueFamilyIndex,
  &counterCount,
  counters,
  counterDescriptions);

// Try to enable the first 8 counters
uint32_t enabledCounters[8];

const uint32_t enabledCounterCount = min(counterCount, 8));

for (uint32_t i = 0; i 

* 
Revision 1, 2019-10-08

**Name String**

`VK_KHR_pipeline_binary`

**Extension Type**

Device extension

**Registered Extension Number**

484

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_maintenance5](#VK_KHR_maintenance5)

or

[Vulkan Version 1.4](versions.html#versions-1.4)

**Contact**

* 
Stu Smith [stu-s](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_pipeline_binary] @stu-s%0A*Here describe the issue or question you have about the VK_KHR_pipeline_binary extension*)

**Extension Proposal**

[VK_KHR_pipeline_binary](../../../features/latest/features/proposals/VK_KHR_pipeline_binary.html)

**Last Modified Date**

2024-07-01

**Contributors**

* 
Stu Smith, AMD

* 
Tobias Hector, AMD

* 
Alan Harrison, AMD

* 
Maciej Jesionowski, AMD

* 
Younggwan Kim, Arm

* 
Jan-Harald Fredriksen, Arm

* 
Ting Wei, Arm

* 
Chris Glover, Google

* 
Shahbaz Youssefi, Google

* 
Jakub Kuderski, Google

* 
Piotr Byszewski, Mobica

* 
Piers Daniell, NVIDIA

* 
Ralph Potter, Samsung

* 
Matthew Netsch, Qualcomm

* 
Hans-Kristian Arntzen, Valve

* 
Samuel Pitoiset, Valve

* 
Tatsuyuki Ishi, Valve

This extension provides a method to obtain binary data associated with
individual pipelines such that applications can manage caching themselves
instead of using VkPipelineCache objects.

* 
[VkPipelineBinaryKHR](../chapters/pipelines.html#VkPipelineBinaryKHR)

* 
[vkCreatePipelineBinariesKHR](../chapters/pipelines.html#vkCreatePipelineBinariesKHR)

* 
[vkDestroyPipelineBinaryKHR](../chapters/pipelines.html#vkDestroyPipelineBinaryKHR)

* 
[vkGetPipelineBinaryDataKHR](../chapters/pipelines.html#vkGetPipelineBinaryDataKHR)

* 
[vkGetPipelineKeyKHR](../chapters/pipelines.html#vkGetPipelineKeyKHR)

* 
[vkReleaseCapturedPipelineDataKHR](../chapters/pipelines.html#vkReleaseCapturedPipelineDataKHR)

* 
[VkPipelineBinaryCreateInfoKHR](../chapters/pipelines.html#VkPipelineBinaryCreateInfoKHR)

* 
[VkPipelineBinaryDataInfoKHR](../chapters/pipelines.html#VkPipelineBinaryDataInfoKHR)

* 
[VkPipelineBinaryDataKHR](../chapters/pipelines.html#VkPipelineBinaryDataKHR)

* 
[VkPipelineBinaryHandlesInfoKHR](../chapters/pipelines.html#VkPipelineBinaryHandlesInfoKHR)

* 
[VkPipelineBinaryKeyKHR](../chapters/pipelines.html#VkPipelineBinaryKeyKHR)

* 
[VkPipelineBinaryKeysAndDataKHR](../chapters/pipelines.html#VkPipelineBinaryKeysAndDataKHR)

* 
[VkPipelineCreateInfoKHR](../chapters/pipelines.html#VkPipelineCreateInfoKHR)

* 
[VkReleaseCapturedPipelineDataInfoKHR](../chapters/pipelines.html#VkReleaseCapturedPipelineDataInfoKHR)

* 
Extending [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkDevicePipelineBinaryInternalCacheControlKHR](../chapters/devsandqueues.html#VkDevicePipelineBinaryInternalCacheControlKHR)

Extending [VkGraphicsPipelineCreateInfo](../chapters/pipelines.html#VkGraphicsPipelineCreateInfo), [VkComputePipelineCreateInfo](../chapters/pipelines.html#VkComputePipelineCreateInfo), [VkRayTracingPipelineCreateInfoKHR](../chapters/pipelines.html#VkRayTracingPipelineCreateInfoKHR):

* 
[VkPipelineBinaryInfoKHR](../chapters/pipelines.html#VkPipelineBinaryInfoKHR)

Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

* 
[VkPhysicalDevicePipelineBinaryFeaturesKHR](../chapters/features.html#VkPhysicalDevicePipelineBinaryFeaturesKHR)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDevicePipelineBinaryPropertiesKHR](../chapters/limits.html#VkPhysicalDevicePipelineBinaryPropertiesKHR)

* 
`VK_KHR_PIPELINE_BINARY_EXTENSION_NAME`

* 
`VK_KHR_PIPELINE_BINARY_SPEC_VERSION`

* 
`VK_MAX_PIPELINE_BINARY_KEY_SIZE_KHR`

* 
Extending [VkObjectType](../chapters/debugging.html#VkObjectType):

`VK_OBJECT_TYPE_PIPELINE_BINARY_KHR`

Extending [VkPipelineCreateFlagBits2](../chapters/pipelines.html#VkPipelineCreateFlagBits2):

* 
`VK_PIPELINE_CREATE_2_CAPTURE_DATA_BIT_KHR`

Extending [VkResult](../chapters/fundamentals.html#VkResult):

* 
`VK_ERROR_NOT_ENOUGH_SPACE_KHR`

* 
`VK_PIPELINE_BINARY_MISSING_KHR`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_DEVICE_PIPELINE_BINARY_INTERNAL_CACHE_CONTROL_KHR`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_FEATURES_KHR`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_PROPERTIES_KHR`

* 
`VK_STRUCTURE_TYPE_PIPELINE_BINARY_CREATE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_PIPELINE_BINARY_DATA_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_PIPELINE_BINARY_HANDLES_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_PIPELINE_BINARY_KEY_KHR`

* 
`VK_STRUCTURE_TYPE_PIPELINE_CREATE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_RELEASE_CAPTURED_PIPELINE_DATA_INFO_KHR`

* 
Revision 1, 2021-12-10 (Chris Glover)

Initial draft.

**Name String**

`VK_KHR_pipeline_executable_properties`

**Extension Type**

Device extension

**Registered Extension Number**

270

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Special Use**

* 
[Developer tools](../chapters/extensions.html#extendingvulkan-compatibility-specialuse)

**Contact**

* 
Faith Ekstrand [gfxstrand](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_pipeline_executable_properties] @gfxstrand%0A*Here describe the issue or question you have about the VK_KHR_pipeline_executable_properties extension*)

**Last Modified Date**

2019-05-28

**IP Status**

No known IP claims.

**Interactions and External Dependencies**
**Contributors**

* 
Faith Ekstrand, Intel

* 
Ian Romanick, Intel

* 
Kenneth Graunke, Intel

* 
Baldur Karlsson, Valve

* 
Jesse Hall, Google

* 
Jeff Bolz, Nvidia

* 
Piers Daniel, Nvidia

* 
Tobias Hector, AMD

* 
Jan-Harald Fredriksen, ARM

* 
Tom Olson, ARM

* 
Daniel Koch, Nvidia

* 
Spencer Fricke, Samsung

When a pipeline is created, its state and shaders are compiled into zero or
more device-specific executables, which are used when executing commands
against that pipeline.
This extension adds a mechanism to query properties and statistics about the
different executables produced by the pipeline compilation process.
This is intended to be used by debugging and performance tools to allow them
to provide more detailed information to the user.
Certain compile time shader statistics provided through this extension may
be useful to developers for debugging or performance analysis.

* 
[vkGetPipelineExecutableInternalRepresentationsKHR](../chapters/pipelines.html#vkGetPipelineExecutableInternalRepresentationsKHR)

* 
[vkGetPipelineExecutablePropertiesKHR](../chapters/pipelines.html#vkGetPipelineExecutablePropertiesKHR)

* 
[vkGetPipelineExecutableStatisticsKHR](../chapters/pipelines.html#vkGetPipelineExecutableStatisticsKHR)

* 
[VkPipelineExecutableInfoKHR](../chapters/pipelines.html#VkPipelineExecutableInfoKHR)

* 
[VkPipelineExecutableInternalRepresentationKHR](../chapters/pipelines.html#VkPipelineExecutableInternalRepresentationKHR)

* 
[VkPipelineExecutablePropertiesKHR](../chapters/pipelines.html#VkPipelineExecutablePropertiesKHR)

* 
[VkPipelineExecutableStatisticKHR](../chapters/pipelines.html#VkPipelineExecutableStatisticKHR)

* 
[VkPipelineInfoKHR](../chapters/pipelines.html#VkPipelineInfoKHR)

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR](../chapters/features.html#VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR)

* 
[VkPipelineExecutableStatisticValueKHR](../chapters/pipelines.html#VkPipelineExecutableStatisticValueKHR)

* 
[VkPipelineExecutableStatisticFormatKHR](../chapters/pipelines.html#VkPipelineExecutableStatisticFormatKHR)

* 
`VK_KHR_PIPELINE_EXECUTABLE_PROPERTIES_EXTENSION_NAME`

* 
`VK_KHR_PIPELINE_EXECUTABLE_PROPERTIES_SPEC_VERSION`

* 
Extending [VkPipelineCreateFlagBits](../chapters/pipelines.html#VkPipelineCreateFlagBits):

`VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR`

* 
`VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR`

* 
`VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR`

* 
`VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR`

* 
`VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR`

* 
`VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR`

1) What should we call the pieces of the pipeline which are produced by the
compilation process and about which you can query properties and statistics?

**RESOLVED**: Call them executables.
The name binary was used in early drafts of the extension but it was
determined that pipeline binary could have a fairly broad meaning (such
as a binary serialized form of an entire pipeline) and was too big of a
namespace for the very specific needs of this extension.

* 
Revision 1, 2019-05-28 (Faith Ekstrand)

Initial draft

**Name String**

`VK_KHR_pipeline_library`

**Extension Type**

Device extension

**Registered Extension Number**

291

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

None

**Contact**

* 
Christoph Kubisch [pixeljetstream](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_pipeline_library] @pixeljetstream%0A*Here describe the issue or question you have about the VK_KHR_pipeline_library extension*)

**Last Modified Date**

2020-01-08

**IP Status**

No known IP claims.

**Contributors**

* 
See contributors to `[VK_KHR_ray_tracing_pipeline](#VK_KHR_ray_tracing_pipeline)`

A pipeline library is a special pipeline that cannot be bound, instead it
defines a set of shaders and shader groups which can be linked into other
pipelines.
This extension defines the infrastructure for pipeline libraries, but does
not specify the creation or usage of pipeline libraries.
This is left to additional dependent extensions.

* 
Extending [VkGraphicsPipelineCreateInfo](../chapters/pipelines.html#VkGraphicsPipelineCreateInfo):

[VkPipelineLibraryCreateInfoKHR](../chapters/pipelines.html#VkPipelineLibraryCreateInfoKHR)

* 
`VK_KHR_PIPELINE_LIBRARY_EXTENSION_NAME`

* 
`VK_KHR_PIPELINE_LIBRARY_SPEC_VERSION`

* 
Extending [VkPipelineCreateFlagBits](../chapters/pipelines.html#VkPipelineCreateFlagBits):

`VK_PIPELINE_CREATE_LIBRARY_BIT_KHR`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR`

* 
Revision 1, 2020-01-08 (Christoph Kubisch)

Initial draft.

**Name String**

`VK_KHR_portability_enumeration`

**Extension Type**

Instance extension

**Registered Extension Number**

395

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

None

**Contact**

* 
Charles Giessen [charles-lunarg](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_portability_enumeration] @charles-lunarg%0A*Here describe the issue or question you have about the VK_KHR_portability_enumeration extension*)

**Last Modified Date**

2021-06-02

**IP Status**

No known IP claims.

**Interactions and External Dependencies**

* 
Interacts with `[VK_KHR_portability_subset](#VK_KHR_portability_subset)`

**Contributors**

* 
Lenny Komow, LunarG

* 
Charles Giessen, LunarG

This extension allows applications to control whether devices that expose
the `[VK_KHR_portability_subset](#VK_KHR_portability_subset)` extension are included in the results
of physical device enumeration.
Since devices which support the `[VK_KHR_portability_subset](#VK_KHR_portability_subset)` extension
are not fully conformant Vulkan implementations, the Vulkan loader does not
report those devices unless the application explicitly asks for them.
This prevents applications which may not be aware of non-conformant devices
from accidentally using them, as any device which supports the
`[VK_KHR_portability_subset](#VK_KHR_portability_subset)` extension mandates that the extension
must be enabled if that device is used.

This extension is implemented in the loader.

* 
`VK_KHR_PORTABILITY_ENUMERATION_EXTENSION_NAME`

* 
`VK_KHR_PORTABILITY_ENUMERATION_SPEC_VERSION`

* 
Extending [VkInstanceCreateFlagBits](../chapters/initialization.html#VkInstanceCreateFlagBits):

`VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR`

* 
Revision 1, 2021-06-02 (Lenny Komow)

Initial version

**Name String**

`VK_KHR_present_id`

**Extension Type**

Device extension

**Registered Extension Number**

295

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_swapchain](#VK_KHR_swapchain)

and

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Contact**

* 
Keith Packard [keithp](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_present_id] @keithp%0A*Here describe the issue or question you have about the VK_KHR_present_id extension*)

**Last Modified Date**

2019-05-15

**IP Status**

No known IP claims.

**Contributors**

* 
Keith Packard, Valve

* 
Ian Elliott, Google

* 
Alon Or-bach, Samsung

This device extension allows an application that uses the
`[VK_KHR_swapchain](#VK_KHR_swapchain)` extension to provide an identifier for present
operations on a swapchain.
An application **can** use this to reference specific present operations in
other extensions.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDevicePresentIdFeaturesKHR](../chapters/features.html#VkPhysicalDevicePresentIdFeaturesKHR)

Extending [VkPresentInfoKHR](../chapters/VK_KHR_surface/wsi.html#VkPresentInfoKHR):

* 
[VkPresentIdKHR](../chapters/VK_KHR_surface/wsi.html#VkPresentIdKHR)

* 
`VK_KHR_PRESENT_ID_EXTENSION_NAME`

* 
`VK_KHR_PRESENT_ID_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR`

* 
`VK_STRUCTURE_TYPE_PRESENT_ID_KHR`

None.

* 
Revision 1, 2019-05-15 (Keith Packard)

Initial version

**Name String**

`VK_KHR_present_wait`

**Extension Type**

Device extension

**Registered Extension Number**

249

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_swapchain](#VK_KHR_swapchain)

and

[VK_KHR_present_id](#VK_KHR_present_id)

**Contact**

* 
Keith Packard [keithp](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_present_wait] @keithp%0A*Here describe the issue or question you have about the VK_KHR_present_wait extension*)

**Last Modified Date**

2019-05-15

**IP Status**

No known IP claims.

**Contributors**

* 
Keith Packard, Valve

* 
Ian Elliott, Google

* 
Tobias Hector, AMD

* 
Daniel Stone, Collabora

This device extension allows an application that uses the
`[VK_KHR_swapchain](#VK_KHR_swapchain)` extension to wait for present operations to
complete.
An application can use this to monitor and control the pacing of the
application by managing the number of outstanding images yet to be
presented.

* 
[vkWaitForPresentKHR](../chapters/VK_KHR_surface/wsi.html#vkWaitForPresentKHR)

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDevicePresentWaitFeaturesKHR](../chapters/features.html#VkPhysicalDevicePresentWaitFeaturesKHR)

* 
`VK_KHR_PRESENT_WAIT_EXTENSION_NAME`

* 
`VK_KHR_PRESENT_WAIT_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR`

1) When does the wait finish?

**RESOLVED**.
The wait will finish when the present is visible to the user.
There is no requirement for any precise timing relationship between the
presentation of the image to the user, but implementations **should** signal
the wait as close as possible to the presentation of the first pixel in the
new image to the user.

2) Should this use fences or other existing synchronization mechanism.

**RESOLVED**.
Because display and rendering are often implemented in separate drivers,
this extension will provide a separate synchronization API.

3) Should this extension share present identification with other extensions?

**RESOLVED**.
Yes.
A new extension, VK_KHR_present_id, should be created to provide a shared
structure for presentation identifiers.

4) What happens when presentations complete out of order wrt calls to
vkQueuePresent? This could happen if the semaphores for the presentations
were ready out of order.

**OPTION A**: Require that when a PresentId is set that the driver ensure that
images are always presented in the order of calls to vkQueuePresent.

**OPTION B**: Finish both waits when the earliest present completes.
This will complete the later present wait earlier than the actual
presentation.
This should be the easiest to implement as the driver need only track the
largest present ID completed.
This is also the 'natural' consequence of interpreting the existing
vkWaitForPresentKHR specificationn.

**OPTION C**: Finish both waits when both have completed.
This will complete the earlier presentation later than the actual
presentation time.
This is allowed by the current specification as there is no precise timing
requirement for when the presentId value is updated.
This requires slightly more complexity in the driver as it will need to
track all outstanding presentId values.

* 
Revision 1, 2019-02-19 (Keith Packard)

Initial version

**Name String**

`VK_KHR_ray_query`

**Extension Type**

Device extension

**Registered Extension Number**

349

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

 [VK_KHR_spirv_1_4](#VK_KHR_spirv_1_4)

 or

 [Vulkan Version 1.2](versions.html#versions-1.2)

and

[VK_KHR_acceleration_structure](#VK_KHR_acceleration_structure)

**SPIR-V Dependencies**

* 
[SPV_KHR_ray_query](https://github.khronos.org/SPIRV-Registry/extensions/KHR/SPV_KHR_ray_query.html)

**Contact**

* 
Daniel Koch [dgkoch](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_ray_query] @dgkoch%0A*Here describe the issue or question you have about the VK_KHR_ray_query extension*)

**Last Modified Date**

2020-11-12

**Interactions and External Dependencies**

* 
This extension provides API support for
[`GLSL_EXT_ray_query`](https://github.com/KhronosGroup/GLSL/blob/main/extensions/ext/GLSL_EXT_ray_query.txt)

**Contributors**

* 
Matthus Chajdas, AMD

* 
Greg Grebe, AMD

* 
Nicolai Hhnle, AMD

* 
Tobias Hector, AMD

* 
Dave Oldcorn, AMD

* 
Skyler Saleh, AMD

* 
Mathieu Robart, Arm

* 
Marius Bjorge, Arm

* 
Tom Olson, Arm

* 
Sebastian Tafuri, EA

* 
Henrik Rydgard, Embark

* 
Juan Caada, Epic Games

* 
Patrick Kelly, Epic Games

* 
Yuriy ODonnell, Epic Games

* 
Michael Doggett, Facebook/Oculus

* 
Andrew Garrard, Imagination

* 
Don Scorgie, Imagination

* 
Dae Kim, Imagination

* 
Joshua Barczak, Intel

* 
Slawek Grajewski, Intel

* 
Jeff Bolz, NVIDIA

* 
Pascal Gautron, NVIDIA

* 
Daniel Koch, NVIDIA

* 
Christoph Kubisch, NVIDIA

* 
Ashwin Lele, NVIDIA

* 
Robert Stepinski, NVIDIA

* 
Martin Stich, NVIDIA

* 
Nuno Subtil, NVIDIA

* 
Eric Werness, NVIDIA

* 
Jon Leech, Khronos

* 
Jeroen van Schijndel, OTOY

* 
Juul Joosten, OTOY

* 
Alex Bourd, Qualcomm

* 
Roman Larionov, Qualcomm

* 
David McAllister, Qualcomm

* 
Spencer Fricke, Samsung

* 
Lewis Gordon, Samsung

* 
Ralph Potter, Samsung

* 
Jasper Bekkers, Traverse Research

* 
Jesse Barker, Unity

* 
Baldur Karlsson, Valve

Rasterization has been the dominant method to produce interactive graphics,
but increasing performance of graphics hardware has made ray tracing a
viable option for interactive rendering.
Being able to integrate ray tracing with traditional rasterization makes it
easier for applications to incrementally add ray traced effects to existing
applications or to do hybrid approaches with rasterization for primary
visibility and ray tracing for secondary queries.

Ray queries are available to all shader types, including graphics, compute
and ray tracing pipelines.
Ray queries are not able to launch additional shaders, instead returning
traversal results to the calling shader.

This extension adds support for the following SPIR-V extension in Vulkan:

* 
`SPV_KHR_ray_query`

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceRayQueryFeaturesKHR](../chapters/features.html#VkPhysicalDeviceRayQueryFeaturesKHR)

* 
`VK_KHR_RAY_QUERY_EXTENSION_NAME`

* 
`VK_KHR_RAY_QUERY_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR`

* 
[`RayQueryKHR`](spirvenv.html#spirvenv-capabilities-table-RayQueryKHR)

* 
[    `RayTraversalPrimitiveCullingKHR`](spirvenv.html#spirvenv-capabilities-table-RayTraversalPrimitiveCullingKHR)

Example of ray query in a GLSL shader, illustrating how to use ray queries
to determine whether a given position (at ray origin) is in shadow or not,
by tracing a ray towards the light, and checking for any intersections with
geometry occluding the light.

rayQueryEXT rq;

rayQueryInitializeEXT(rq, accStruct, gl_RayFlagsTerminateOnFirstHitEXT, cullMask, origin, tMin, direction, tMax);

// Traverse the acceleration structure and store information about the first intersection (if any)
rayQueryProceedEXT(rq);

if (rayQueryGetIntersectionTypeEXT(rq, true) == gl_RayQueryCommittedIntersectionNoneEXT) {
    // Not in shadow
}

(1) What are the changes between the public provisional (VK_KHR_ray_tracing
v8) release and the final (VK_KHR_acceleration_structure v11 /
VK_KHR_ray_query v1) release?

* 
refactor VK_KHR_ray_tracing into 3 extensions, enabling implementation
flexibility and decoupling ray query support from ray pipelines:

`[VK_KHR_acceleration_structure](#VK_KHR_acceleration_structure)` (for acceleration structure
operations)

* 
`[VK_KHR_ray_tracing_pipeline](#VK_KHR_ray_tracing_pipeline)` (for ray tracing pipeline and
shader stages)

* 
`[VK_KHR_ray_query](#VK_KHR_ray_query)` (for ray queries in existing shader stages)

Update SPIRV capabilities to use `RayQueryKHR`

extension is no longer provisional

* 
Revision 1, 2020-11-12 (Mathieu Robart, Daniel Koch, Andrew Garrard)

Decomposition of the specification, from VK_KHR_ray_tracing to
VK_KHR_ray_query (#1918,!3912)

* 
update to use `RayQueryKHR` SPIR-V capability

* 
add numerical limits for ray parameters (#2235,!3960)

* 
relax formula for ray intersection candidate determination
(#2322,!4080)

* 
restrict traces to TLAS (#2239,!4141)

* 
require `HitT` to be in ray interval for
`OpRayQueryGenerateIntersectionKHR` (#2359,!4146)

* 
add ray query shader stages for AS read bit (#2407,!4203)

**Name String**

`VK_KHR_ray_tracing_maintenance1`

**Extension Type**

Device extension

**Registered Extension Number**

387

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_acceleration_structure](#VK_KHR_acceleration_structure)

**API Interactions**

* 
Interacts with VK_VERSION_1_3

* 
Interacts with VK_EXT_device_generated_commands

* 
Interacts with VK_KHR_ray_tracing_pipeline

* 
Interacts with VK_KHR_synchronization2

**SPIR-V Dependencies**

* 
[SPV_KHR_ray_cull_mask](https://github.khronos.org/SPIRV-Registry/extensions/KHR/SPV_KHR_ray_cull_mask.html)

**Contact**

* 
Daniel Koch [dgkoch](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_ray_tracing_maintenance1] @dgkoch%0A*Here describe the issue or question you have about the VK_KHR_ray_tracing_maintenance1 extension*)

**Last Modified Date**

2022-02-21

**Interactions and External Dependencies**

* 
This extension provides API support for
[`GLSL_EXT_ray_cull_mask`](https://github.com/KhronosGroup/GLSL/blob/main/extensions/ext/GLSL_EXT_ray_cull_mask.txt)

* 
Interacts with `[VK_KHR_ray_tracing_pipeline](#VK_KHR_ray_tracing_pipeline)`

* 
Interacts with `[VK_KHR_synchronization2](#VK_KHR_synchronization2)`

**Contributors**

* 
Stu Smith, AMD

* 
Tobias Hector, AMD

* 
Marius Bjorge, Arm

* 
Tom Olson, Arm

* 
Yuriy ODonnell, Epic Games

* 
Yunpeng Zhu, Huawei

* 
Andrew Garrard, Imagination

* 
Dae Kim, Imagination

* 
Joshua Barczak, Intel

* 
Lionel Landwerlin, Intel

* 
Daniel Koch, NVIDIA

* 
Eric Werness, NVIDIA

* 
Spencer Fricke, Samsung

`VK_KHR_ray_tracing_maintenance1` adds a collection of minor ray tracing
features, none of which would warrant an entire extension of their own.

The new features are as follows:

* 
Adds support for the `SPV_KHR_ray_cull_mask` SPIR-V extension in Vulkan.
This extension provides access to built-in `CullMaskKHR` shader
variable which contains the value of the `OpTrace*` `Cull Mask`
parameter.
This new shader variable is accessible in the intersection, any-hit,
closest hit and miss shader stages.

* 
Adds support for a new pipeline stage and access mask built on top of
`[VK_KHR_synchronization2](#VK_KHR_synchronization2)`:

`VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR` to
specify execution of [acceleration     structure copy commands](../chapters/accelstructures.html#acceleration-structure-copying)

* 
`VK_ACCESS_2_SHADER_BINDING_TABLE_READ_BIT_KHR` to specify read
access to a [shader binding table](../chapters/raytracing.html#shader-binding-table) in any
shader pipeline stage

Adds two new acceleration structure query parameters:

* 
`VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SIZE_KHR` to query the
acceleration structure size on the device timeline

* 
`VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_BOTTOM_LEVEL_POINTERS_KHR`
to query the number of bottom level acceleration structure pointers for
serialization

Adds an optional new indirect ray tracing dispatch command,
[vkCmdTraceRaysIndirect2KHR](../chapters/raytracing.html#vkCmdTraceRaysIndirect2KHR), which sources the shader binding table
parameters as well as the dispatch dimensions from the device.
The [    `rayTracingPipelineTraceRaysIndirect2`](../chapters/features.html#features-rayTracingPipelineTraceRaysIndirect2) feature indicates whether
this functionality is supported.

If [VK_KHR_ray_tracing_pipeline](#VK_KHR_ray_tracing_pipeline) is supported:

* 
[vkCmdTraceRaysIndirect2KHR](../chapters/raytracing.html#vkCmdTraceRaysIndirect2KHR)

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR](../chapters/features.html#VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR)

If [VK_KHR_ray_tracing_pipeline](#VK_KHR_ray_tracing_pipeline) is supported:

* 
[VkTraceRaysIndirectCommand2KHR](../chapters/raytracing.html#VkTraceRaysIndirectCommand2KHR)

* 
`VK_KHR_RAY_TRACING_MAINTENANCE_1_EXTENSION_NAME`

* 
`VK_KHR_RAY_TRACING_MAINTENANCE_1_SPEC_VERSION`

* 
Extending [VkQueryType](../chapters/queries.html#VkQueryType):

`VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_BOTTOM_LEVEL_POINTERS_KHR`

* 
`VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SIZE_KHR`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR`

If [VK_KHR_synchronization2](#VK_KHR_synchronization2) or [Vulkan Version 1.3](versions.html#versions-1.3) and [VK_KHR_ray_tracing_pipeline](#VK_KHR_ray_tracing_pipeline) is supported:

* 
Extending [VkAccessFlagBits2](../chapters/synchronization.html#VkAccessFlagBits2):

`VK_ACCESS_2_SHADER_BINDING_TABLE_READ_BIT_KHR`

If [VK_EXT_device_generated_commands](#VK_EXT_device_generated_commands) is supported:

* 
Extending [VkIndirectCommandsTokenTypeEXT](../chapters/device_generated_commands/generatedcommands.html#VkIndirectCommandsTokenTypeEXT):

`VK_INDIRECT_COMMANDS_TOKEN_TYPE_TRACE_RAYS2_EXT`

If [VK_KHR_synchronization2](#VK_KHR_synchronization2) or [Vulkan Version 1.3](versions.html#versions-1.3) is supported:

* 
Extending [VkPipelineStageFlagBits2](../chapters/synchronization.html#VkPipelineStageFlagBits2):

`VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_COPY_BIT_KHR`

* 
[`CullMaskKHR`](../chapters/interfaces.html#interfaces-builtin-variables-cullmask)

* 
[`RayCullMaskKHR`](spirvenv.html#spirvenv-capabilities-table-RayCullMaskKHR)

None Yet!

* 
Revision 1, 2022-02-21 (Members of the Vulkan Ray Tracing TSG)

internal revisions

**Name String**

`VK_KHR_ray_tracing_pipeline`

**Extension Type**

Device extension

**Registered Extension Number**

348

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

 [VK_KHR_spirv_1_4](#VK_KHR_spirv_1_4)

 or

 [Vulkan Version 1.2](versions.html#versions-1.2)

and

[VK_KHR_acceleration_structure](#VK_KHR_acceleration_structure)

**API Interactions**

* 
Interacts with VK_KHR_ray_query

**SPIR-V Dependencies**

* 
[SPV_KHR_ray_tracing](https://github.khronos.org/SPIRV-Registry/extensions/KHR/SPV_KHR_ray_tracing.html)

**Contact**

* 
Daniel Koch [dgkoch](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_ray_tracing_pipeline] @dgkoch%0A*Here describe the issue or question you have about the VK_KHR_ray_tracing_pipeline extension*)

**Last Modified Date**

2020-11-12

**Interactions and External Dependencies**

* 
This extension provides API support for
[`GLSL_EXT_ray_tracing`](https://github.com/KhronosGroup/GLSL/blob/main/extensions/ext/GLSL_EXT_ray_tracing.txt)

* 
This extension interacts with [Vulkan 1.2](versions.html#versions-1.2) and
`[VK_KHR_vulkan_memory_model](#VK_KHR_vulkan_memory_model)`, adding the [    shader-call-related](memorymodel.html#shader-call-related) relation of invocations, [    shader-call-order](memorymodel.html#shader-call-order) partial order of dynamic instances of instructions,
and the [`ShaderCallKHR`](../chapters/shaders.html#shaders-scope-shadercall) scope.

* 
This extension interacts with `[VK_KHR_pipeline_library](#VK_KHR_pipeline_library)`, enabling
pipeline libraries to be used with ray tracing pipelines and enabling
usage of [VkRayTracingPipelineInterfaceCreateInfoKHR](../chapters/pipelines.html#VkRayTracingPipelineInterfaceCreateInfoKHR).

**Contributors**

* 
Matthus Chajdas, AMD

* 
Greg Grebe, AMD

* 
Nicolai Hhnle, AMD

* 
Tobias Hector, AMD

* 
Dave Oldcorn, AMD

* 
Skyler Saleh, AMD

* 
Mathieu Robart, Arm

* 
Marius Bjorge, Arm

* 
Tom Olson, Arm

* 
Sebastian Tafuri, EA

* 
Henrik Rydgard, Embark

* 
Juan Caada, Epic Games

* 
Patrick Kelly, Epic Games

* 
Yuriy ODonnell, Epic Games

* 
Michael Doggett, Facebook/Oculus

* 
Andrew Garrard, Imagination

* 
Don Scorgie, Imagination

* 
Dae Kim, Imagination

* 
Joshua Barczak, Intel

* 
Slawek Grajewski, Intel

* 
Jeff Bolz, NVIDIA

* 
Pascal Gautron, NVIDIA

* 
Daniel Koch, NVIDIA

* 
Christoph Kubisch, NVIDIA

* 
Ashwin Lele, NVIDIA

* 
Robert Stepinski, NVIDIA

* 
Martin Stich, NVIDIA

* 
Nuno Subtil, NVIDIA

* 
Eric Werness, NVIDIA

* 
Jon Leech, Khronos

* 
Jeroen van Schijndel, OTOY

* 
Juul Joosten, OTOY

* 
Alex Bourd, Qualcomm

* 
Roman Larionov, Qualcomm

* 
David McAllister, Qualcomm

* 
Spencer Fricke, Samsung

* 
Lewis Gordon, Samsung

* 
Ralph Potter, Samsung

* 
Jasper Bekkers, Traverse Research

* 
Jesse Barker, Unity

* 
Baldur Karlsson, Valve

Rasterization has been the dominant method to produce interactive graphics,
but increasing performance of graphics hardware has made ray tracing a
viable option for interactive rendering.
Being able to integrate ray tracing with traditional rasterization makes it
easier for applications to incrementally add ray traced effects to existing
applications or to do hybrid approaches with rasterization for primary
visibility and ray tracing for secondary queries.

To enable ray tracing, this extension adds a few different categories of new
functionality:

* 
A new ray tracing pipeline type with new shader domains: ray generation,
intersection, any-hit, closest hit, miss, and callable

* 
A shader binding indirection table to link shader groups with
acceleration structure items

* 
Ray tracing commands which initiate the ray pipeline traversal and
invocation of the various new shader domains depending on which
traversal conditions are met

This extension adds support for the following SPIR-V extension in Vulkan:

* 
`SPV_KHR_ray_tracing`

* 
[vkCmdSetRayTracingPipelineStackSizeKHR](../chapters/pipelines.html#vkCmdSetRayTracingPipelineStackSizeKHR)

* 
[vkCmdTraceRaysIndirectKHR](../chapters/raytracing.html#vkCmdTraceRaysIndirectKHR)

* 
[vkCmdTraceRaysKHR](../chapters/raytracing.html#vkCmdTraceRaysKHR)

* 
[vkCreateRayTracingPipelinesKHR](../chapters/pipelines.html#vkCreateRayTracingPipelinesKHR)

* 
[vkGetRayTracingCaptureReplayShaderGroupHandlesKHR](../chapters/pipelines.html#vkGetRayTracingCaptureReplayShaderGroupHandlesKHR)

* 
[vkGetRayTracingShaderGroupHandlesKHR](../chapters/pipelines.html#vkGetRayTracingShaderGroupHandlesKHR)

* 
[vkGetRayTracingShaderGroupStackSizeKHR](../chapters/pipelines.html#vkGetRayTracingShaderGroupStackSizeKHR)

* 
[VkRayTracingPipelineCreateInfoKHR](../chapters/pipelines.html#VkRayTracingPipelineCreateInfoKHR)

* 
[VkRayTracingPipelineInterfaceCreateInfoKHR](../chapters/pipelines.html#VkRayTracingPipelineInterfaceCreateInfoKHR)

* 
[VkRayTracingShaderGroupCreateInfoKHR](../chapters/pipelines.html#VkRayTracingShaderGroupCreateInfoKHR)

* 
[VkStridedDeviceAddressRegionKHR](../chapters/descriptorsets.html#VkStridedDeviceAddressRegionKHR)

* 
[VkTraceRaysIndirectCommandKHR](../chapters/raytracing.html#VkTraceRaysIndirectCommandKHR)

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceRayTracingPipelineFeaturesKHR](../chapters/features.html#VkPhysicalDeviceRayTracingPipelineFeaturesKHR)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceRayTracingPipelinePropertiesKHR](../chapters/limits.html#VkPhysicalDeviceRayTracingPipelinePropertiesKHR)

* 
[VkRayTracingShaderGroupTypeKHR](../chapters/pipelines.html#VkRayTracingShaderGroupTypeKHR)

* 
[VkShaderGroupShaderKHR](../chapters/pipelines.html#VkShaderGroupShaderKHR)

* 
`VK_KHR_RAY_TRACING_PIPELINE_EXTENSION_NAME`

* 
`VK_KHR_RAY_TRACING_PIPELINE_SPEC_VERSION`

* 
`VK_SHADER_UNUSED_KHR`

* 
Extending [VkBufferUsageFlagBits](../chapters/resources.html#VkBufferUsageFlagBits):

`VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR`

Extending [VkDynamicState](../chapters/pipelines.html#VkDynamicState):

* 
`VK_DYNAMIC_STATE_RAY_TRACING_PIPELINE_STACK_SIZE_KHR`

Extending [VkPipelineBindPoint](../chapters/pipelines.html#VkPipelineBindPoint):

* 
`VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR`

Extending [VkPipelineCreateFlagBits](../chapters/pipelines.html#VkPipelineCreateFlagBits):

* 
`VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR`

* 
`VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR`

* 
`VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR`

* 
`VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR`

* 
`VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR`

* 
`VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR`

* 
`VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR`

Extending [VkPipelineCreateFlagBits2](../chapters/pipelines.html#VkPipelineCreateFlagBits2):

* 
`VK_PIPELINE_CREATE_2_RAY_TRACING_SKIP_BUILT_IN_PRIMITIVES_BIT_KHR`

Extending [VkPipelineStageFlagBits](../chapters/synchronization.html#VkPipelineStageFlagBits):

* 
`VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR`

Extending [VkShaderStageFlagBits](../chapters/pipelines.html#VkShaderStageFlagBits):

* 
`VK_SHADER_STAGE_ANY_HIT_BIT_KHR`

* 
`VK_SHADER_STAGE_CALLABLE_BIT_KHR`

* 
`VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR`

* 
`VK_SHADER_STAGE_INTERSECTION_BIT_KHR`

* 
`VK_SHADER_STAGE_MISS_BIT_KHR`

* 
`VK_SHADER_STAGE_RAYGEN_BIT_KHR`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR`

* 
`VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR`

* 
[`LaunchIdKHR`](../chapters/interfaces.html#interfaces-builtin-variables-launchid)

* 
[`LaunchSizeKHR`](../chapters/interfaces.html#interfaces-builtin-variables-launchsize)

* 
[`WorldRayOriginKHR`](../chapters/interfaces.html#interfaces-builtin-variables-worldrayorigin)

* 
[`WorldRayDirectionKHR`](../chapters/interfaces.html#interfaces-builtin-variables-worldraydirection)

* 
[`ObjectRayOriginKHR`](../chapters/interfaces.html#interfaces-builtin-variables-objectrayorigin)

* 
[`ObjectRayDirectionKHR`](../chapters/interfaces.html#interfaces-builtin-variables-objectraydirection)

* 
[`RayTminKHR`](../chapters/interfaces.html#interfaces-builtin-variables-raytmin)

* 
[`RayTmaxKHR`](../chapters/interfaces.html#interfaces-builtin-variables-raytmax)

* 
[`InstanceCustomIndexKHR`](../chapters/interfaces.html#interfaces-builtin-variables-instancecustomindex)

* 
[`InstanceId`](../chapters/interfaces.html#interfaces-builtin-variables-instanceid)

* 
[`ObjectToWorldKHR`](../chapters/interfaces.html#interfaces-builtin-variables-objecttoworld)

* 
[`WorldToObjectKHR`](../chapters/interfaces.html#interfaces-builtin-variables-worldtoobject)

* 
[`HitKindKHR`](../chapters/interfaces.html#interfaces-builtin-variables-hitkind)

* 
[`IncomingRayFlagsKHR`](../chapters/interfaces.html#interfaces-builtin-variables-incomingrayflags)

* 
[`RayGeometryIndexKHR`](../chapters/interfaces.html#interfaces-builtin-variables-raygeometryindex)

* 
(modified)`PrimitiveId`

* 
[`RayTracingKHR`](spirvenv.html#spirvenv-capabilities-table-RayTracingKHR)

* 
[    `RayTraversalPrimitiveCullingKHR`](spirvenv.html#spirvenv-capabilities-table-RayTraversalPrimitiveCullingKHR)

(1) How does this extension differ from VK_NV_ray_tracing?

**DISCUSSION**:

The following is a summary of the main functional differences between
VK_KHR_ray_tracing_pipeline and VK_NV_ray_tracing:

* 
added support for indirect ray tracing ([vkCmdTraceRaysIndirectKHR](../chapters/raytracing.html#vkCmdTraceRaysIndirectKHR))

* 
uses SPV_KHR_ray_tracing instead of SPV_NV_ray_tracing

refer to KHR SPIR-V enums instead of NV SPIR-V enums (which are
functionally equivalent and aliased to the same values).

* 
added `RayGeometryIndexKHR` built-in

removed vkCompileDeferredNV compilation functionality and replaced with
[deferred host operations](../chapters/VK_KHR_deferred_host_operations/deferred_host_operations.html#deferred-host-operations) interactions for
ray tracing

added [VkPhysicalDeviceRayTracingPipelineFeaturesKHR](../chapters/features.html#VkPhysicalDeviceRayTracingPipelineFeaturesKHR) structure

extended [VkPhysicalDeviceRayTracingPipelinePropertiesKHR](../chapters/limits.html#VkPhysicalDeviceRayTracingPipelinePropertiesKHR) structure

* 
renamed `maxRecursionDepth` to `maxRayRecursionDepth` and it
has a minimum of 1 instead of 31

* 
require `shaderGroupHandleSize` to be 32 bytes

* 
added `maxRayDispatchInvocationCount`,
`shaderGroupHandleAlignment` and `maxRayHitAttributeSize`

reworked geometry structures so they could be better shared between
device, host, and indirect builds

changed SBT parameters to a structure and added size
([VkStridedDeviceAddressRegionKHR](../chapters/descriptorsets.html#VkStridedDeviceAddressRegionKHR))

add parameter for requesting memory requirements for host and/or device
build

added [pipeline library](../chapters/pipelines.html#pipelines-library) support for ray tracing

added [watertightness guarantees](../chapters/raytraversal.html#ray-traversal-watertight)

added no-null-shader pipeline flags
(`VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_*_SHADERS_BIT_KHR`)

added [memory model interactions](../chapters/raytracing.html#ray-tracing-shader-call) with ray
tracing and define how subgroups work and can be repacked

(2) Can you give a more detailed comparison of differences and similarities
between VK_NV_ray_tracing and VK_KHR_ray_tracing_pipeline?

**DISCUSSION**:

The following is a more detailed comparison of which commands, structures,
and enums are aliased, changed, or removed.

* 
Aliased functionalityenums, structures, and commands that are
considered equivalent:

[VkRayTracingShaderGroupTypeNV](../chapters/pipelines.html#VkRayTracingShaderGroupTypeNV) 
[VkRayTracingShaderGroupTypeKHR](../chapters/pipelines.html#VkRayTracingShaderGroupTypeKHR)

* 
[vkGetRayTracingShaderGroupHandlesNV](../chapters/pipelines.html#vkGetRayTracingShaderGroupHandlesNV) 
[vkGetRayTracingShaderGroupHandlesKHR](../chapters/pipelines.html#vkGetRayTracingShaderGroupHandlesKHR)

Changed enums, structures, and commands:

* 
[VkRayTracingShaderGroupCreateInfoNV](../chapters/pipelines.html#VkRayTracingShaderGroupCreateInfoNV) 
[VkRayTracingShaderGroupCreateInfoKHR](../chapters/pipelines.html#VkRayTracingShaderGroupCreateInfoKHR) (added
`pShaderGroupCaptureReplayHandle`)

* 
[VkRayTracingPipelineCreateInfoNV](../chapters/pipelines.html#VkRayTracingPipelineCreateInfoNV) 
[VkRayTracingPipelineCreateInfoKHR](../chapters/pipelines.html#VkRayTracingPipelineCreateInfoKHR) (changed type of `pGroups`,
added `libraries`, `pLibraryInterface`, and
`pDynamicState`)

* 
[VkPhysicalDeviceRayTracingPropertiesNV](../chapters/limits.html#VkPhysicalDeviceRayTracingPropertiesNV) 
[VkPhysicalDeviceRayTracingPipelinePropertiesKHR](../chapters/limits.html#VkPhysicalDeviceRayTracingPipelinePropertiesKHR) (renamed
`maxTriangleCount` to `maxPrimitiveCount`, added
`shaderGroupHandleCaptureReplaySize`)

* 
[vkCmdTraceRaysNV](../chapters/raytracing.html#vkCmdTraceRaysNV)  [vkCmdTraceRaysKHR](../chapters/raytracing.html#vkCmdTraceRaysKHR) (params to struct)

* 
[vkCreateRayTracingPipelinesNV](../chapters/pipelines.html#vkCreateRayTracingPipelinesNV) 
[vkCreateRayTracingPipelinesKHR](../chapters/pipelines.html#vkCreateRayTracingPipelinesKHR) (different struct, changed
functionality)

Added enums, structures and commands:

* 
`VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR`
`VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR`,
`VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR`,
`VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR`,
`VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR`,
`VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR` to
[VkPipelineCreateFlagBits](../chapters/pipelines.html#VkPipelineCreateFlagBits)

* 
[VkPhysicalDeviceRayTracingPipelineFeaturesKHR](../chapters/features.html#VkPhysicalDeviceRayTracingPipelineFeaturesKHR) structure

* 
[VkDeviceOrHostAddressKHR](../chapters/accelstructures.html#VkDeviceOrHostAddressKHR) and [VkDeviceOrHostAddressConstKHR](../chapters/accelstructures.html#VkDeviceOrHostAddressConstKHR)
unions

* 
[VkPipelineLibraryCreateInfoKHR](../chapters/pipelines.html#VkPipelineLibraryCreateInfoKHR) struct

* 
[VkRayTracingPipelineInterfaceCreateInfoKHR](../chapters/pipelines.html#VkRayTracingPipelineInterfaceCreateInfoKHR) struct

* 
[VkStridedDeviceAddressRegionKHR](../chapters/descriptorsets.html#VkStridedDeviceAddressRegionKHR) struct

* 
[vkCmdTraceRaysIndirectKHR](../chapters/raytracing.html#vkCmdTraceRaysIndirectKHR) command and
[VkTraceRaysIndirectCommandKHR](../chapters/raytracing.html#VkTraceRaysIndirectCommandKHR) struct

* 
[vkGetRayTracingCaptureReplayShaderGroupHandlesKHR](../chapters/pipelines.html#vkGetRayTracingCaptureReplayShaderGroupHandlesKHR) (shader group
capture/replay)

* 
[vkCmdSetRayTracingPipelineStackSizeKHR](../chapters/pipelines.html#vkCmdSetRayTracingPipelineStackSizeKHR) and
[vkGetRayTracingShaderGroupStackSizeKHR](../chapters/pipelines.html#vkGetRayTracingShaderGroupStackSizeKHR) commands for stack size
control

Functionality removed:

* 
`VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV`

* 
[vkCompileDeferredNV](../chapters/pipelines.html#vkCompileDeferredNV) command (replaced with
`[VK_KHR_deferred_host_operations](#VK_KHR_deferred_host_operations)`)

(3) What are the changes between the public provisional (VK_KHR_ray_tracing
v8) release and the internal provisional (VK_KHR_ray_tracing v9) release?

* 
Require Vulkan 1.1 and SPIR-V 1.4

* 
Added interactions with Vulkan 1.2 and
`[VK_KHR_vulkan_memory_model](#VK_KHR_vulkan_memory_model)`

* 
added creation time capture and replay flags

added
`VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR`
to [VkPipelineCreateFlagBits](../chapters/pipelines.html#VkPipelineCreateFlagBits)

replace `VkStridedBufferRegionKHR` with
[VkStridedDeviceAddressRegionKHR](../chapters/descriptorsets.html#VkStridedDeviceAddressRegionKHR) and change
[vkCmdTraceRaysKHR](../chapters/raytracing.html#vkCmdTraceRaysKHR), [vkCmdTraceRaysIndirectKHR](../chapters/raytracing.html#vkCmdTraceRaysIndirectKHR), to take these
for the shader binding table and use device addresses instead of
buffers.

require the shader binding table buffers to have the
`VK_BUFFER_USAGE_RAY_TRACING_BIT_KHR` set

make `[VK_KHR_pipeline_library](#VK_KHR_pipeline_library)` an interaction instead of required
extension

rename the `libraries` member of
[VkRayTracingPipelineCreateInfoKHR](../chapters/pipelines.html#VkRayTracingPipelineCreateInfoKHR) to `pLibraryInfo` and make
it a pointer

make `[VK_KHR_deferred_host_operations](#VK_KHR_deferred_host_operations)` an interaction instead of
a required extension (later went back on this)

added explicit stack size management for ray tracing pipelines

* 
removed the `maxCallableSize` member of
[VkRayTracingPipelineInterfaceCreateInfoKHR](../chapters/pipelines.html#VkRayTracingPipelineInterfaceCreateInfoKHR)

* 
added the `pDynamicState` member to
[VkRayTracingPipelineCreateInfoKHR](../chapters/pipelines.html#VkRayTracingPipelineCreateInfoKHR)

* 
added `VK_DYNAMIC_STATE_RAY_TRACING_PIPELINE_STACK_SIZE_KHR`
dynamic state for ray tracing pipelines

* 
added [vkGetRayTracingShaderGroupStackSizeKHR](../chapters/pipelines.html#vkGetRayTracingShaderGroupStackSizeKHR) and
[vkCmdSetRayTracingPipelineStackSizeKHR](../chapters/pipelines.html#vkCmdSetRayTracingPipelineStackSizeKHR) commands

* 
added [VkShaderGroupShaderKHR](../chapters/pipelines.html#VkShaderGroupShaderKHR) enum

Added `maxRayDispatchInvocationCount` limit to
[VkPhysicalDeviceRayTracingPipelinePropertiesKHR](../chapters/limits.html#VkPhysicalDeviceRayTracingPipelinePropertiesKHR)

Added `shaderGroupHandleAlignment` property to
[VkPhysicalDeviceRayTracingPipelinePropertiesKHR](../chapters/limits.html#VkPhysicalDeviceRayTracingPipelinePropertiesKHR)

Added `maxRayHitAttributeSize` property to
[VkPhysicalDeviceRayTracingPipelinePropertiesKHR](../chapters/limits.html#VkPhysicalDeviceRayTracingPipelinePropertiesKHR)

Clarify deferred host ops for pipeline creation

* 
[VkDeferredOperationKHR](../chapters/VK_KHR_deferred_host_operations/deferred_host_operations.html#VkDeferredOperationKHR) is now a top-level parameter for
[vkCreateRayTracingPipelinesKHR](../chapters/pipelines.html#vkCreateRayTracingPipelinesKHR)

* 
removed `VkDeferredOperationInfoKHR` structure

* 
change deferred host creation/return parameter behavior such that the
implementation can modify such parameters until the deferred host
operation completes

* 
`[VK_KHR_deferred_host_operations](#VK_KHR_deferred_host_operations)` is required again

(4) What are the changes between the internal provisional
(VK_KHR_ray_tracing v9) release and the final (VK_KHR_acceleration_structure
v11 / VK_KHR_ray_tracing_pipeline v1) release?

* 
refactor VK_KHR_ray_tracing into 3 extensions, enabling implementation
flexibility and decoupling ray query support from ray pipelines:

`[VK_KHR_acceleration_structure](#VK_KHR_acceleration_structure)` (for acceleration structure
operations)

* 
`[VK_KHR_ray_tracing_pipeline](#VK_KHR_ray_tracing_pipeline)` (for ray tracing pipeline and
shader stages)

* 
`[VK_KHR_ray_query](#VK_KHR_ray_query)` (for ray queries in existing shader stages)

Require `Volatile` for the following builtins in the ray generation,
closest hit, miss, intersection, and callable shader stages:

* 
`SubgroupSize`, `SubgroupLocalInvocationId`, `SubgroupEqMask`,
`SubgroupGeMask`, `SubgroupGtMask`, `SubgroupLeMask`,
`SubgroupLtMask`

* 
`SMIDNV`, `WarpIDNV`

clarify buffer usage flags for ray tracing

* 
`VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR` is added as an alias
of `VK_BUFFER_USAGE_RAY_TRACING_BIT_NV` and is required on shader
binding table buffers

* 
`VK_BUFFER_USAGE_STORAGE_BUFFER_BIT` is used in
`[VK_KHR_acceleration_structure](#VK_KHR_acceleration_structure)` for `scratchData`

rename `maxRecursionDepth` to `maxRayPipelineRecursionDepth`
(pipeline creation) and `maxRayRecursionDepth` (limit) to reduce
confusion

Add queryable `maxRayHitAttributeSize` limit and rename members of
[VkRayTracingPipelineInterfaceCreateInfoKHR](../chapters/pipelines.html#VkRayTracingPipelineInterfaceCreateInfoKHR) to
`maxPipelineRayPayloadSize` and `maxPipelineRayHitAttributeSize`
for clarity

Update SPIRV capabilities to use `RayTracingKHR`

extension is no longer provisional

define synchronization requirements for indirect trace rays and indirect
buffer

(5) This extension adds gl_InstanceID for the intersection, any-hit, and
closest hit shaders, but in KHR_vulkan_glsl, gl_InstanceID is replaced with
gl_InstanceIndex.
Which should be used for Vulkan in this extension?

**RESOLVED**: This extension uses gl_InstanceID and maps it to `InstanceId`
in SPIR-V.
It is acknowledged that this is different than other shader stages in
Vulkan.
There are two main reasons for the difference here:

* 
symmetry with gl_PrimitiveID which is also available in these shaders

* 
there is no baseInstance relevant for these shaders, and so ID makes
it more obvious that this is zero-based.

(6) Why is `[VK_KHR_pipeline_library](#VK_KHR_pipeline_library)` an interaction instead of a
required dependency, particularly when the Feature Requirements section
says it is required to be supported anyhow?

**RESOLVED**: If the `[VK_KHR_pipeline_library](#VK_KHR_pipeline_library)` extension were a
required dependency, then every application would need to enable the
extension whether or not they actually want to use the pipeline library
functionality.
Developers found this to be annoying and unfriendly behavior.
We do wish to require all **implementations** to support it though, and thus
it is listed in the feature requirements section.

Example ray generation GLSL shader

#version 450 core
#extension GL_EXT_ray_tracing : require
layout(set = 0, binding = 0, rgba8) uniform image2D image;
layout(set = 0, binding = 1) uniform accelerationStructureEXT as;
layout(location = 0) rayPayloadEXT float payload;

void main()
{
   vec4 col = vec4(0, 0, 0, 1);

   vec3 origin = vec3(float(gl_LaunchIDEXT.x)/float(gl_LaunchSizeEXT.x), float(gl_LaunchIDEXT.y)/float(gl_LaunchSizeEXT.y), 1.0);
   vec3 dir = vec3(0.0, 0.0, -1.0);

   traceRayEXT(as, 0, 0xff, 0, 1, 0, origin, 0.0, dir, 1000.0, 0);

   col.y = payload;

   imageStore(image, ivec2(gl_LaunchIDEXT.xy), col);
}

* 
Revision 1, 2020-11-12 (Mathieu Robart, Daniel Koch, Eric Werness,
Tobias Hector)

Decomposition of the specification, from VK_KHR_ray_tracing to
VK_KHR_ray_tracing_pipeline (#1918,!3912)

* 
require certain subgroup and sm_shader_builtin shader builtins to be
decorated as volatile in the ray generation, closest hit, miss,
intersection, and callable stages (#1924,!3903,!3954)

* 
clarify buffer usage flags for ray tracing (#2181,!3939)

* 
rename maxRecursionDepth to maxRayPipelineRecursionDepth and
maxRayRecursionDepth (#2203,!3937)

* 
add queryable maxRayHitAttributeSize and rename members of
VkRayTracingPipelineInterfaceCreateInfoKHR (#2102,!3966)

* 
update to use `RayTracingKHR` SPIR-V capability

* 
add VUs for matching hit group type against geometry type (#2245,!3994)

* 
require `RayTMaxKHR` be volatile in intersection shaders
(#2268,!4030)

* 
add numerical limits for ray parameters (#2235,!3960)

* 
fix SBT indexing rules for device addresses (#2308,!4079)

* 
relax formula for ray intersection candidate determination
(#2322,!4080)

* 
add more details on `ShaderRecordBufferKHR` variables (#2230,!4083)

* 
clarify valid bits for `InstanceCustomIndexKHR` (GLSL/GLSL#19,!4128)

* 
allow at most one `IncomingRayPayloadKHR`,
`IncomingCallableDataKHR`, and `HitAttributeKHR` (!4129)

* 
add minimum for maxShaderGroupStride (#2353,!4131)

* 
require VK_KHR_pipeline_library extension to be supported (#2348,!4135)

* 
clarify meaning of 'geometry index' (#2272,!4137)

* 
restrict traces to TLAS (#2239,!4141)

* 
add note about maxPipelineRayPayloadSize (#2383,!4172)

* 
do not require raygen shader in pipeline libraries (!4185)

* 
define sync for indirect trace rays and indirect buffer (#2407,!4208)

**Name String**

`VK_KHR_ray_tracing_position_fetch`

**Extension Type**

Device extension

**Registered Extension Number**

482

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_acceleration_structure](#VK_KHR_acceleration_structure)

**SPIR-V Dependencies**

* 
[SPV_KHR_ray_tracing_position_fetch](https://github.khronos.org/SPIRV-Registry/extensions/KHR/SPV_KHR_ray_tracing_position_fetch.html)

**Contact**

* 
Eric Werness

**Extension Proposal**

[VK_KHR_ray_tracing_position_fetch](../../../features/latest/features/proposals/VK_KHR_ray_tracing_position_fetch.html)

**Last Modified Date**

2023-02-17

**Interactions and External Dependencies**

* 
This extension provides API support for
[`GLSL_EXT_ray_tracing_position_fetch`](https://github.com/KhronosGroup/GLSL/blob/main/extensions/ext/GLSL_EXT_ray_tracing_position_fetch.txt)

* 
Interacts with `[VK_KHR_ray_tracing_pipeline](#VK_KHR_ray_tracing_pipeline)`

* 
Interacts with `[VK_KHR_ray_query](#VK_KHR_ray_query)`

**Contributors**

* 
Eric Werness, NVIDIA

* 
Stu Smith, AMD

* 
Yuriy ODonnell, Epic Games

* 
Ralph Potter, Samsung

* 
Joshua Barczak, Intel

* 
Lionel Landwerlin, Intel

* 
Andrew Garrard, Imagination Technologies

* 
Alex Bourd, Qualcomm

* 
Yunpeng Zhu, Huawei Technologies

* 
Marius Bjorge, Arm

* 
Daniel Koch, NVIDIA

`VK_KHR_ray_tracing_position_fetch` adds the ability to fetch the vertex
positions in the shader from a hit triangle as stored in the acceleration
structure.

An application adds
`VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DATA_ACCESS_KHR` to the
acceleration structure at build time.
Then, if the hit is a triangle geometry, the shader (any-hit or closest hit
for ray pipelines or using ray query) **can** fetch the three, three-component
vertex positions in object space, of the triangle which was hit.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR](../chapters/features.html#VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR)

* 
`VK_KHR_RAY_TRACING_POSITION_FETCH_EXTENSION_NAME`

* 
`VK_KHR_RAY_TRACING_POSITION_FETCH_SPEC_VERSION`

* 
Extending [VkBuildAccelerationStructureFlagBitsKHR](../chapters/resources.html#VkBuildAccelerationStructureFlagBitsKHR):

`VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DATA_ACCESS_KHR`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR`

* 
[`HitTriangleVertexPositionsKHR`](../chapters/interfaces.html#interfaces-builtin-variables-hittrianglevertexpositions)

* 
[RayTracingPositionFetchKHR](spirvenv.html#spirvenv-capabilities-table-RayTracingPositionFetchKHR)

* 
[RayQueryPositionFetchKHR](spirvenv.html#spirvenv-capabilities-table-RayQueryPositionFetchKHR)

None Yet!

* 
Revision 1, 2023-02-17 (Eric Werness)

internal revisions

**Name String**

`VK_KHR_robustness2`

**Extension Type**

Device extension

**Registered Extension Number**

613

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Contact**

* 
Piers Daniell [pdaniell-nv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_robustness2] @pdaniell-nv%0A*Here describe the issue or question you have about the VK_KHR_robustness2 extension*)

**Last Modified Date**

2025-01-10

**IP Status**

No known IP claims.

**Contributors**

* 
Liam Middlebrook, NVIDIA

* 
Jeff Bolz, NVIDIA

This extension is based on the `[VK_EXT_robustness2](#VK_EXT_robustness2)` extension.
This extension adds stricter requirements for how out of bounds reads and
writes are handled.
Most accesses **must** be tightly bounds-checked, out of bounds writes **must** be
discarded, out of bound reads **must** return zero.
Rather than allowing multiple possible (0,0,0,x) vectors, the out of
bounds values are treated as zero, and then missing components are inserted
based on the format as described in [Conversion to RGBA](../chapters/textures.html#textures-conversion-to-rgba) and [vertex input attribute extraction](../chapters/fxvertex.html#fxvertex-input-extraction).

These additional requirements **may** be expensive on some implementations, and
should only be enabled when truly necessary.

This extension also adds support for null descriptors, where
[VK_NULL_HANDLE](boilerplate.html#VK_NULL_HANDLE) **can** be used instead of a valid handle.
Accesses to null descriptors have well-defined behavior, and do not rely on
robustness.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceRobustness2FeaturesKHR](../chapters/features.html#VkPhysicalDeviceRobustness2FeaturesKHR)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceRobustness2PropertiesKHR](../chapters/limits.html#VkPhysicalDeviceRobustness2PropertiesKHR)

* 
`VK_KHR_ROBUSTNESS_2_EXTENSION_NAME`

* 
`VK_KHR_ROBUSTNESS_2_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_KHR`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_KHR`

Why do
[VkPhysicalDeviceRobustness2PropertiesKHR](../chapters/limits.html#VkPhysicalDeviceRobustness2PropertiesKHR)::`robustUniformBufferAccessSizeAlignment`
and
[VkPhysicalDeviceRobustness2PropertiesKHR](../chapters/limits.html#VkPhysicalDeviceRobustness2PropertiesKHR)::`robustStorageBufferAccessSizeAlignment`
exist?

**RESOLVED**: Some implementations cannot efficiently tightly bounds-check all
buffer accesses.
Rather, the size of the bound range is padded to some power of two multiple,
up to 256 bytes for uniform buffers and up to 4 bytes for storage buffers,
and that padded size is bounds-checked.
This is sufficient to implement D3D-like behavior, because D3D only allows
binding whole uniform buffers or ranges that are a multiple of 256 bytes,
and D3D raw and structured buffers only support 32-bit accesses.

* 
Revision 1, 2025-01-10 (Piers Daniell)

Internal revisions

**Name String**

`VK_KHR_shader_bfloat16`

**Extension Type**

Device extension

**Registered Extension Number**

142

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**API Interactions**

* 
Interacts with VK_KHR_cooperative_matrix

**SPIR-V Dependencies**

* 
[SPV_KHR_bfloat16](https://github.khronos.org/SPIRV-Registry/extensions/KHR/SPV_KHR_bfloat16.html)

**Contact**

* 
Tobias Hector [tobski](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_shader_bfloat16] @tobski%0A*Here describe the issue or question you have about the VK_KHR_shader_bfloat16 extension*)

**Extension Proposal**

[VK_KHR_shader_bfloat16](../../../features/latest/features/proposals/VK_KHR_shader_bfloat16.html)

**Last Modified Date**

2024-04-09

**IP Status**

No known IP claims.

**Contributors**

* 
Tobias Hector, AMD

* 
Stu Smith, AMD

* 
Jeff Bolz, Nvidia

* 
Kvin Petit, Arm

* 
David Neto, Google

* 
Graeme Leese, Broadcom

* 
Ruihao Zhang, Qualcomm

* 
Mark Sheppard, Imagination

* 
Ben Ashbaugh, Intel

* 
Dmitry Sidorov, Intel

* 
Victor Mustya, Intel

This extension enables support for bfloat16 (brain float) operations in
shaders as defined in `SPV_KHR_bfloat16`.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceShaderBfloat16FeaturesKHR](../chapters/features.html#VkPhysicalDeviceShaderBfloat16FeaturesKHR)

* 
`VK_KHR_SHADER_BFLOAT16_EXTENSION_NAME`

* 
`VK_KHR_SHADER_BFLOAT16_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_BFLOAT16_FEATURES_KHR`

If [VK_KHR_cooperative_matrix](#VK_KHR_cooperative_matrix) is supported:

* 
Extending [VkComponentTypeKHR](../chapters/shaders.html#VkComponentTypeKHR):

`VK_COMPONENT_TYPE_BFLOAT16_KHR`

* 
[BFloat16TypeKHR](spirvenv.html#spirvenv-capabilities-table-BFloat16TypeKHR)

* 
[BFloat16DotProductKHR](spirvenv.html#spirvenv-capabilities-table-BFloat16DotProductKHR)

* 
[BFloat16CooperativeMatrixKHR](spirvenv.html#spirvenv-capabilities-table-BFloat16CooperativeMatrixKHR)

* 
Revision 1, 2024-04-09 (Stu Smith)

Initial draft

**Name String**

`VK_KHR_shader_clock`

**Extension Type**

Device extension

**Registered Extension Number**

182

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**SPIR-V Dependencies**

* 
[SPV_KHR_shader_clock](https://github.khronos.org/SPIRV-Registry/extensions/KHR/SPV_KHR_shader_clock.html)

**Contact**

* 
Aaron Hagan [ahagan](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_shader_clock] @ahagan%0A*Here describe the issue or question you have about the VK_KHR_shader_clock extension*)

**Last Modified Date**

2019-4-25

**IP Status**

No known IP claims.

**Interactions and External Dependencies**

* 
This extension provides API support for
[`GL_ARB_shader_clock`](https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_clock.txt) and
[`GL_EXT_shader_realtime_clock`](https://github.com/KhronosGroup/GLSL/blob/main/extensions/ext/GL_EXT_shader_realtime_clock.txt)

**Contributors**

* 
Aaron Hagan, AMD

* 
Daniel Koch, NVIDIA

This extension advertises the SPIR-V `ShaderClockKHR` capability for
Vulkan, which allows a shader to query a real-time or monotonically
incrementing counter at the subgroup level or across the device level.
The two valid SPIR-V scopes for `OpReadClockKHR` are `Subgroup` and
`Device`.

When using GLSL source-based shading languages, the `clockRealtime*EXT`()
timing functions map to the `OpReadClockKHR` instruction with a scope of
`Device`, and the `clock*ARB`() timing functions map to the
`OpReadClockKHR` instruction with a scope of `Subgroup`.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceShaderClockFeaturesKHR](../chapters/features.html#VkPhysicalDeviceShaderClockFeaturesKHR)

* 
`VK_KHR_SHADER_CLOCK_EXTENSION_NAME`

* 
`VK_KHR_SHADER_CLOCK_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR`

* 
[`ShaderClockKHR`](spirvenv.html#spirvenv-capabilities-table-ShaderClockKHR)

* 
Revision 1, 2019-4-25 (Aaron Hagan)

Initial revision

**Name String**

`VK_KHR_shader_maximal_reconvergence`

**Extension Type**

Device extension

**Registered Extension Number**

435

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[Vulkan Version 1.1](versions.html#versions-1.1)

**SPIR-V Dependencies**

* 
[SPV_KHR_maximal_reconvergence](https://github.khronos.org/SPIRV-Registry/extensions/KHR/SPV_KHR_maximal_reconvergence.html)

**Contact**

* 
Alan Baker [alan-baker](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_shader_maximal_reconvergence] @alan-baker%0A*Here describe the issue or question you have about the VK_KHR_shader_maximal_reconvergence extension*)

**Extension Proposal**

[VK_KHR_shader_maximal_reconvergence](../../../features/latest/features/proposals/VK_KHR_shader_maximal_reconvergence.html)

**Last Modified Date**

2021-11-12

**IP Status**

No known IP claims.

**Interactions and External Dependencies**

* 
Requires SPIR-V 1.3.

* 
This extension requires
[`SPV_KHR_maximal_reconvergence`](https://github.khronos.org/SPIRV-Registry/extensions/KHR/SPV_KHR_maximal_reconvergence.html)

**Contributors**

* 
Alan Baker, Google

This extension allows the use of the `SPV_KHR_maximal_reconvergence` SPIR-V
extension in shader modules.
`SPV_KHR_maximal_reconvergence` provides stronger guarantees that diverged
subgroups will reconverge.
These guarantees should match shader author intuition about divergence and
reconvergence of invocations based on the structure of the code in the HLL.

Developers should utilize this extension if they require stronger guarantees
about reconvergence than either the core spec or
SPV_KHR_subgroup_uniform_control_flow.
This extension will define the rules that govern how invocations diverge and
reconverge in a way that should match developer intuition.
It allows robust programs to be written relying on subgroup operations and
other tangled instructions.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR](../chapters/features.html#VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR)

* 
`VK_KHR_SHADER_MAXIMAL_RECONVERGENCE_EXTENSION_NAME`

* 
`VK_KHR_SHADER_MAXIMAL_RECONVERGENCE_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR`

* 
Revision 1, 2021-11-12 (Alan Baker)

Internal draft version

**Name String**

`VK_KHR_shader_quad_control`

**Extension Type**

Device extension

**Registered Extension Number**

236

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

 [Vulkan Version 1.1](versions.html#versions-1.1)

 and

 [VK_KHR_vulkan_memory_model](#VK_KHR_vulkan_memory_model)

 or

 [Vulkan Version 1.2](versions.html#versions-1.2)

and

[VK_KHR_shader_maximal_reconvergence](#VK_KHR_shader_maximal_reconvergence)

**SPIR-V Dependencies**

* 
[SPV_KHR_quad_control](https://github.khronos.org/SPIRV-Registry/extensions/KHR/SPV_KHR_quad_control.html)

**Contact**

* 
Tobias Hector [tobski](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_shader_quad_control] @tobski%0A*Here describe the issue or question you have about the VK_KHR_shader_quad_control extension*)

**Extension Proposal**

[VK_KHR_shader_quad_control](../../../features/latest/features/proposals/VK_KHR_shader_quad_control.html)

**Last Modified Date**

2023-11-01

**IP Status**

No known IP claims.

**Contributors**

* 
Tobias Hector, AMD

* 
Bill Licea-Kane, Qualcomm

* 
Graeme Leese, Broadcom

* 
Jan-Harald Fredriksen, Arm

* 
Nicolai Hhnle, AMD

* 
Jeff Bolz, NVidia

* 
Alan Baker, Google

* 
Hans-Kristian Arntzen, Valve

This extension adds new quad any/all operations, requires that derivatives
are well-defined in quad-uniform control flow, and adds the ability to
require helper invocations participate in group operations.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceShaderQuadControlFeaturesKHR](../chapters/features.html#VkPhysicalDeviceShaderQuadControlFeaturesKHR)

* 
`VK_KHR_SHADER_QUAD_CONTROL_EXTENSION_NAME`

* 
`VK_KHR_SHADER_QUAD_CONTROL_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR`

* 
[QuadControlKHR](spirvenv.html#spirvenv-capabilities-table-QuadControlKHR)

* 
Revision 1, 2023-11-01 (Tobias Hector)

Initial draft

**Name String**

`VK_KHR_shader_relaxed_extended_instruction`

**Extension Type**

Device extension

**Registered Extension Number**

559

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

None

**SPIR-V Dependencies**

* 
[SPV_KHR_relaxed_extended_instruction](https://github.khronos.org/SPIRV-Registry/extensions/KHR/SPV_KHR_relaxed_extended_instruction.html)

**Contact**

* 
Nathan Gaur [Keenuts](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_shader_relaxed_extended_instruction] @Keenuts%0A*Here describe the issue or question you have about the VK_KHR_shader_relaxed_extended_instruction extension*)

**Extension Proposal**

[VK_KHR_shader_relaxed_extended_instruction](../../../features/latest/features/proposals/VK_KHR_shader_relaxed_extended_instruction.html)

**Last Modified Date**

2024-01-24

**IP Status**

No known IP claims.

**Contributors**

* 
Alan Baker, Google LLC

* 
Nathan Gaur, Google LLC

This extension allows the use of the `SPV_KHR_relaxed_extended_instruction`
extension in SPIR-V shader modules.

It adds a new SPIR-V instruction, which allows some usage of forward
references in non-semantic instruction sets.
This extensions interacts with the `SPV_KHR_non_semantic_info` extension,
hence with `VK_KHR_shader_non_semantic_info`.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR](../chapters/features.html#VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR)

* 
`VK_KHR_SHADER_RELAXED_EXTENDED_INSTRUCTION_EXTENSION_NAME`

* 
`VK_KHR_SHADER_RELAXED_EXTENDED_INSTRUCTION_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_RELAXED_EXTENDED_INSTRUCTION_FEATURES_KHR`

* 
Revision 1, 2024-01-24 (Nathan Gaur)

Initial revision

**Name String**

`VK_KHR_shader_subgroup_uniform_control_flow`

**Extension Type**

Device extension

**Registered Extension Number**

324

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[Vulkan Version 1.1](versions.html#versions-1.1)

**SPIR-V Dependencies**

* 
[SPV_KHR_subgroup_uniform_control_flow](https://github.khronos.org/SPIRV-Registry/extensions/KHR/SPV_KHR_subgroup_uniform_control_flow.html)

**Contact**

* 
Alan Baker [alan-baker](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_shader_subgroup_uniform_control_flow] @alan-baker%0A*Here describe the issue or question you have about the VK_KHR_shader_subgroup_uniform_control_flow extension*)

**Last Modified Date**

2020-08-27

**IP Status**

No known IP claims.

**Interactions and External Dependencies**

* 
Requires SPIR-V 1.3.

* 
This extension provides API support for
[`GL_EXT_subgroupuniform_qualifier`](https://github.com/KhronosGroup/GLSL/blob/main/extensions/ext/GL_EXT_subgroupuniform_qualifier.txt)

**Contributors**

* 
Alan Baker, Google

* 
Jeff Bolz, NVIDIA

This extension allows the use of the `SPV_KHR_subgroup_uniform_control_flow`
SPIR-V extension in shader modules.
`SPV_KHR_subgroup_uniform_control_flow` provides stronger guarantees that
diverged subgroups will reconverge.

Developers should utilize this extension if they use subgroup operations to
reduce the work performed by a uniform subgroup.
This extension will guarantee that uniform subgroup will reconverge in the
same manner as invocation groups (see Uniform Control Flow in the
[Khronos SPIR-V Specification](../chapters/introduction.html#spirv-spec)).

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR](../chapters/features.html#VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR)

* 
`VK_KHR_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_EXTENSION_NAME`

* 
`VK_KHR_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR`

* 
Revision 1, 2020-08-27 (Alan Baker)

Internal draft version

**Name String**

`VK_KHR_shared_presentable_image`

**Extension Type**

Device extension

**Registered Extension Number**

112

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_swapchain](#VK_KHR_swapchain)

and

[VK_KHR_get_surface_capabilities2](#VK_KHR_get_surface_capabilities2)

and

 [VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

 or

 [Vulkan Version 1.1](versions.html#versions-1.1)

**Contact**

* 
Alon Or-bach [alonorbach](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_shared_presentable_image] @alonorbach%0A*Here describe the issue or question you have about the VK_KHR_shared_presentable_image extension*)

**Last Modified Date**

2017-03-20

**IP Status**

No known IP claims.

**Contributors**

* 
Alon Or-bach, Samsung Electronics

* 
Ian Elliott, Google

* 
Jesse Hall, Google

* 
Pablo Ceballos, Google

* 
Chris Forbes, Google

* 
Jeff Juliano, NVIDIA

* 
James Jones, NVIDIA

* 
Daniel Rakos, AMD

* 
Tobias Hector, Imagination Technologies

* 
Graham Connor, Imagination Technologies

* 
Michael Worcester, Imagination Technologies

* 
Cass Everitt, Oculus

* 
Johannes Van Waveren, Oculus

This extension extends `[VK_KHR_swapchain](#VK_KHR_swapchain)` to enable creation of a
shared presentable image.
This allows the application to use the image while the presention engine is
accessing it, in order to reduce the latency between rendering and
presentation.

* 
[vkGetSwapchainStatusKHR](../chapters/VK_KHR_surface/wsi.html#vkGetSwapchainStatusKHR)

* 
Extending [VkSurfaceCapabilities2KHR](../chapters/VK_KHR_surface/wsi.html#VkSurfaceCapabilities2KHR):

[VkSharedPresentSurfaceCapabilitiesKHR](../chapters/VK_KHR_surface/wsi.html#VkSharedPresentSurfaceCapabilitiesKHR)

* 
`VK_KHR_SHARED_PRESENTABLE_IMAGE_EXTENSION_NAME`

* 
`VK_KHR_SHARED_PRESENTABLE_IMAGE_SPEC_VERSION`

* 
Extending [VkImageLayout](../chapters/resources.html#VkImageLayout):

`VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR`

Extending [VkPresentModeKHR](../chapters/VK_KHR_surface/wsi.html#VkPresentModeKHR):

* 
`VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR`

* 
`VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR`

1) Should we allow a Vulkan WSI swapchain to toggle between normal usage and
shared presentation usage?

**RESOLVED**: No.
WSI swapchains are typically recreated with new properties instead of having
their properties changed.
This can also save resources, assuming that fewer images are needed for
shared presentation, and assuming that most VR applications do not need to
switch between normal and shared usage.

2) Should we have a query for determining how the presentation engine
refresh is triggered?

**RESOLVED**: Yes.
This is done via which presentation modes a surface supports.

3) Should the object representing a shared presentable image be an extension
of a [VkSwapchainKHR](../chapters/VK_KHR_surface/wsi.html#VkSwapchainKHR) or a separate object?

**RESOLVED**: Extension of a swapchain due to overlap in creation properties
and to allow common functionality between shared and normal presentable
images and swapchains.

4) What should we call the extension and the new structures it creates?

**RESOLVED**: Shared presentable image / shared present.

5) Should the `minImageCount` and `presentMode` values of the
[VkSwapchainCreateInfoKHR](../chapters/VK_KHR_surface/wsi.html#VkSwapchainCreateInfoKHR) be ignored, or required to be compatible
values?

**RESOLVED**: `minImageCount` must be 1, and `presentMode` should be
set to either `VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR` or
`VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR`.

6) What should the layout of the shared presentable image be?

**RESOLVED**: After acquiring the shared presentable image, the application
must transition it to the `VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR` layout
prior to it being used.
After this initial transition, any image usage that was requested during
swapchain creation **can** be performed on the image without layout transitions
being performed.

7) Do we need a new API for the trigger to refresh new content?

**RESOLVED**: [vkQueuePresentKHR](../chapters/VK_KHR_surface/wsi.html#vkQueuePresentKHR) to act as API to trigger a refresh, as
will allow combination with other compatible extensions to
[vkQueuePresentKHR](../chapters/VK_KHR_surface/wsi.html#vkQueuePresentKHR).

8) How should an application detect a `VK_ERROR_OUT_OF_DATE_KHR` error
on a swapchain using the `VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR`
present mode?

**RESOLVED**: Introduce [vkGetSwapchainStatusKHR](../chapters/VK_KHR_surface/wsi.html#vkGetSwapchainStatusKHR) to allow applications to
query the status of a swapchain using a shared presentation mode.

9) What should subsequent calls to [vkQueuePresentKHR](../chapters/VK_KHR_surface/wsi.html#vkQueuePresentKHR) for
`VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR` swapchains be defined to
do?

**RESOLVED**: State that implementations may use it as a hint for updated
content.

10) Can the ownership of a shared presentable image be transferred to a
different queue?

**RESOLVED**: No.
It is not possible to transfer ownership of a shared presentable image
obtained from a swapchain created using `VK_SHARING_MODE_EXCLUSIVE`
after it has been presented.

11) How should [vkQueueSubmit](../chapters/cmdbuffers.html#vkQueueSubmit) behave if a command buffer uses an image
from a `VK_ERROR_OUT_OF_DATE_KHR` swapchain?

**RESOLVED**: [vkQueueSubmit](../chapters/cmdbuffers.html#vkQueueSubmit) is expected to return the
`VK_ERROR_DEVICE_LOST` error.

12) Can Vulkan provide any guarantee on the order of rendering, to enable
beam chasing?

**RESOLVED**: This could be achieved via use of render passes to ensure strip
rendering.

* 
Revision 1, 2017-03-20 (Alon Or-bach)

Internal revisions

**Name String**

`VK_KHR_surface`

**Extension Type**

Instance extension

**Registered Extension Number**

1

**Revision**

25

**Ratification Status**

Ratified

**Extension and Version Dependencies**

None

**Contact**

* 
James Jones [cubanismo](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_surface] @cubanismo%0A*Here describe the issue or question you have about the VK_KHR_surface extension*)

* 
Ian Elliott [ianelliottus](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_surface] @ianelliottus%0A*Here describe the issue or question you have about the VK_KHR_surface extension*)

**Last Modified Date**

2016-08-25

**IP Status**

No known IP claims.

**Contributors**

* 
Patrick Doane, Blizzard

* 
Ian Elliott, LunarG

* 
Jesse Hall, Google

* 
James Jones, NVIDIA

* 
David Mao, AMD

* 
Norbert Nopper, Freescale

* 
Alon Or-bach, Samsung

* 
Daniel Rakos, AMD

* 
Graham Sellers, AMD

* 
Jeff Vigil, Qualcomm

* 
Chia-I Wu, LunarG

* 
Faith Ekstrand, Intel

The `VK_KHR_surface` extension is an instance extension.
It introduces [VkSurfaceKHR](../chapters/VK_KHR_surface/wsi.html#VkSurfaceKHR) objects, which abstract native platform
surface or window objects for use with Vulkan.
It also provides a way to determine whether a queue family in a physical
device supports presenting to particular surface.

Separate extensions for each platform provide the mechanisms for creating
[VkSurfaceKHR](../chapters/VK_KHR_surface/wsi.html#VkSurfaceKHR) objects, but once created they may be used in this and
other platform-independent extensions, in particular the
`[VK_KHR_swapchain](#VK_KHR_swapchain)` extension.

* 
[VkSurfaceKHR](../chapters/VK_KHR_surface/wsi.html#VkSurfaceKHR)

* 
[vkDestroySurfaceKHR](../chapters/VK_KHR_surface/wsi.html#vkDestroySurfaceKHR)

* 
[vkGetPhysicalDeviceSurfaceCapabilitiesKHR](../chapters/VK_KHR_surface/wsi.html#vkGetPhysicalDeviceSurfaceCapabilitiesKHR)

* 
[vkGetPhysicalDeviceSurfaceFormatsKHR](../chapters/VK_KHR_surface/wsi.html#vkGetPhysicalDeviceSurfaceFormatsKHR)

* 
[vkGetPhysicalDeviceSurfacePresentModesKHR](../chapters/VK_KHR_surface/wsi.html#vkGetPhysicalDeviceSurfacePresentModesKHR)

* 
[vkGetPhysicalDeviceSurfaceSupportKHR](../chapters/VK_KHR_surface/wsi.html#vkGetPhysicalDeviceSurfaceSupportKHR)

* 
[VkSurfaceCapabilitiesKHR](../chapters/VK_KHR_surface/wsi.html#VkSurfaceCapabilitiesKHR)

* 
[VkSurfaceFormatKHR](../chapters/VK_KHR_surface/wsi.html#VkSurfaceFormatKHR)

* 
[VkColorSpaceKHR](../chapters/VK_KHR_surface/wsi.html#VkColorSpaceKHR)

* 
[VkCompositeAlphaFlagBitsKHR](../chapters/VK_KHR_surface/wsi.html#VkCompositeAlphaFlagBitsKHR)

* 
[VkPresentModeKHR](../chapters/VK_KHR_surface/wsi.html#VkPresentModeKHR)

* 
[VkSurfaceTransformFlagBitsKHR](../chapters/VK_KHR_surface/wsi.html#VkSurfaceTransformFlagBitsKHR)

* 
[VkCompositeAlphaFlagsKHR](../chapters/VK_KHR_surface/wsi.html#VkCompositeAlphaFlagsKHR)

* 
`VK_KHR_SURFACE_EXTENSION_NAME`

* 
`VK_KHR_SURFACE_SPEC_VERSION`

* 
Extending [VkObjectType](../chapters/debugging.html#VkObjectType):

`VK_OBJECT_TYPE_SURFACE_KHR`

Extending [VkResult](../chapters/fundamentals.html#VkResult):

* 
`VK_ERROR_NATIVE_WINDOW_IN_USE_KHR`

* 
`VK_ERROR_SURFACE_LOST_KHR`

|  | The example code for the `VK_KHR_surface` and `[VK_KHR_swapchain](#VK_KHR_swapchain)`
| --- | --- |
extensions was removed from the appendix after revision 1.0.29.
This WSI example code was ported to the cube demo that is shipped with the
official Khronos SDK, and is being kept up-to-date in that location (see:
[https://github.com/KhronosGroup/Vulkan-Tools/blob/main/cube/cube.c](https://github.com/KhronosGroup/Vulkan-Tools/blob/main/cube/cube.c)). |

1) Should this extension include a method to query whether a physical device
supports presenting to a specific window or native surface on a given
platform?

**RESOLVED**: Yes.
Without this, applications would need to create a device instance to
determine whether a particular window can be presented to.
Knowing that a device supports presentation to a platform in general is not
sufficient, as a single machine might support multiple seats, or instances
of the platform that each use different underlying physical devices.
Additionally, on some platforms, such as the X Window System, different
drivers and devices might be used for different windows depending on which
section of the desktop they exist on.

2) Should the [vkGetPhysicalDeviceSurfaceCapabilitiesKHR](../chapters/VK_KHR_surface/wsi.html#vkGetPhysicalDeviceSurfaceCapabilitiesKHR),
[vkGetPhysicalDeviceSurfaceFormatsKHR](../chapters/VK_KHR_surface/wsi.html#vkGetPhysicalDeviceSurfaceFormatsKHR), and
[vkGetPhysicalDeviceSurfacePresentModesKHR](../chapters/VK_KHR_surface/wsi.html#vkGetPhysicalDeviceSurfacePresentModesKHR) functions be in this
extension and operate on physical devices, rather than being in
`[VK_KHR_swapchain](#VK_KHR_swapchain)` (i.e. device extension) and being dependent on
[VkDevice](../chapters/devsandqueues.html#VkDevice)?

**RESOLVED**: Yes.
While it might be useful to depend on `VkDevice` (and therefore on
enabled extensions and features) for the queries, Vulkan was released only
with the [VkPhysicalDevice](../chapters/devsandqueues.html#VkPhysicalDevice) versions.
Many cases can be resolved by a Valid Usage statement, and/or by a separate
`pNext` chain version of the query structure specific to a given
extension or parameters, via extensible versions of the queries:
[vkGetPhysicalDeviceSurfacePresentModes2EXT](../chapters/VK_KHR_surface/wsi.html#vkGetPhysicalDeviceSurfacePresentModes2EXT),
[vkGetPhysicalDeviceSurfaceCapabilities2KHR](../chapters/VK_KHR_surface/wsi.html#vkGetPhysicalDeviceSurfaceCapabilities2KHR), and
[vkGetPhysicalDeviceSurfaceFormats2KHR](../chapters/VK_KHR_surface/wsi.html#vkGetPhysicalDeviceSurfaceFormats2KHR).

3) Should Vulkan support Xlib or XCB as the API for accessing the X Window
System platform?

**RESOLVED**: Both.
XCB is a more modern and efficient API, but Xlib usage is deeply ingrained
in many applications and likely will remain in use for the foreseeable
future.
Not all drivers necessarily need to support both, but including both as
options in the core specification will probably encourage support, which
should in turn ease adoption of the Vulkan API in older codebases.
Additionally, the performance improvements possible with XCB likely will not
have a measurable impact on the performance of Vulkan presentation and other
minimal window system interactions defined here.

4) Should the GBM platform be included in the list of platform enums?

**RESOLVED**: Deferred, and will be addressed with a platform-specific
extension to be written in the future.

* 
Revision 1, 2015-05-20 (James Jones)

Initial draft, based on LunarG KHR spec, other KHR specs, patches
attached to bugs.

Revision 2, 2015-05-22 (Ian Elliott)

* 
Created initial Description section.

* 
Removed query for whether a platform requires the use of a queue for
presentation, since it was decided that presentation will always be
modeled as being part of the queue.

* 
Fixed typos and other minor mistakes.

Revision 3, 2015-05-26 (Ian Elliott)

* 
Improved the Description section.

Revision 4, 2015-05-27 (James Jones)

* 
Fixed compilation errors in example code.

Revision 5, 2015-06-01 (James Jones)

* 
Added issues 1 and 2 and made related spec updates.

Revision 6, 2015-06-01 (James Jones)

* 
Merged the platform type mappings table previously removed from
VK_KHR_swapchain with the platform description table in this spec.

* 
Added issues 3 and 4 documenting choices made when building the initial
list of native platforms supported.

Revision 7, 2015-06-11 (Ian Elliott)

* 
Updated table 1 per input from the KHR TSG.

* 
Updated issue 4 (GBM) per discussion with Daniel Stone.
He will create a platform-specific extension sometime in the future.

Revision 8, 2015-06-17 (James Jones)

* 
Updated enum-extending values using new convention.

* 
Fixed the value of VK_SURFACE_PLATFORM_INFO_TYPE_SUPPORTED_KHR.

Revision 9, 2015-06-17 (James Jones)

* 
Rebased on Vulkan API version 126.

Revision 10, 2015-06-18 (James Jones)

* 
Marked issues 2 and 3 resolved.

Revision 11, 2015-06-23 (Ian Elliott)

* 
Examples now show use of function pointers for extension functions.

* 
Eliminated extraneous whitespace.

Revision 12, 2015-07-07 (Daniel Rakos)

* 
Added error section describing when each error is expected to be
reported.

* 
Replaced the term queue node index with queue family index in
the spec as that is the agreed term to be used in the latest version of
the core header and spec.

* 
Replaced bool32_t with VkBool32.

Revision 13, 2015-08-06 (Daniel Rakos)

* 
Updated spec against latest core API header version.

Revision 14, 2015-08-20 (Ian Elliott)

* 
Renamed this extension and all of its enumerations, types, functions,
etc.
This makes it compliant with the proposed standard for Vulkan
extensions.

* 
Switched from revision to version, including use of the
VK_MAKE_VERSION macro in the header file.

* 
Did miscellaneous cleanup, etc.

Revision 15, 2015-08-20 (Ian Elliottporting a 2015-07-29 change from
James Jones)

* 
Moved the surface transform enums here from VK_WSI_swapchain so they
could be reused by VK_WSI_display.

Revision 16, 2015-09-01 (James Jones)

* 
Restore single-field revision number.

Revision 17, 2015-09-01 (James Jones)

* 
Fix example code compilation errors.

Revision 18, 2015-09-26 (Jesse Hall)

* 
Replaced VkSurfaceDescriptionKHR with the VkSurfaceKHR object, which is
created via layered extensions.
Added VkDestroySurfaceKHR.

Revision 19, 2015-09-28 (Jesse Hall)

* 
Renamed from VK_EXT_KHR_swapchain to VK_EXT_KHR_surface.

Revision 20, 2015-09-30 (Jeff Vigil)

* 
Add error result VK_ERROR_SURFACE_LOST_KHR.

Revision 21, 2015-10-15 (Daniel Rakos)

* 
Updated the resolution of issue #2 and include the surface capability
queries in this extension.

* 
Renamed SurfaceProperties to SurfaceCapabilities as it better reflects
that the values returned are the capabilities of the surface on a
particular device.

* 
Other minor cleanup and consistency changes.

Revision 22, 2015-10-26 (Ian Elliott)

* 
Renamed from VK_EXT_KHR_surface to VK_KHR_surface.

Revision 23, 2015-11-03 (Daniel Rakos)

* 
Added allocation callbacks to vkDestroySurfaceKHR.

Revision 24, 2015-11-10 (Jesse Hall)

* 
Removed VkSurfaceTransformKHR.
Use VkSurfaceTransformFlagBitsKHR instead.

* 
Rename VkSurfaceCapabilitiesKHR member maxImageArraySize to
maxImageArrayLayers.

Revision 25, 2016-01-14 (James Jones)

* 
Moved VK_ERROR_NATIVE_WINDOW_IN_USE_KHR from the VK_KHR_android_surface
to the VK_KHR_surface extension.

2016-08-23 (Ian Elliott)

* 
Update the example code, to not have so many characters per line, and
to split out a new example to show how to obtain function pointers.

2016-08-25 (Ian Elliott)

* 
A note was added at the beginning of the example code, stating that it
will be removed from future versions of the appendix.

**Name String**

`VK_KHR_surface_protected_capabilities`

**Extension Type**

Instance extension

**Registered Extension Number**

240

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[Vulkan Version 1.1](versions.html#versions-1.1)

and

[VK_KHR_get_surface_capabilities2](#VK_KHR_get_surface_capabilities2)

**Contact**

* 
Sandeep Shinde [sashinde](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_surface_protected_capabilities] @sashinde%0A*Here describe the issue or question you have about the VK_KHR_surface_protected_capabilities extension*)

**Last Modified Date**

2018-12-18

**IP Status**

No known IP claims.

**Contributors**

* 
Sandeep Shinde, NVIDIA

* 
James Jones, NVIDIA

* 
Daniel Koch, NVIDIA

This extension extends [VkSurfaceCapabilities2KHR](../chapters/VK_KHR_surface/wsi.html#VkSurfaceCapabilities2KHR), providing
applications a way to query whether swapchains **can** be created with the
`VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR` flag set.

Vulkan 1.1 added (optional) support for protect memory and protected
resources including buffers (`VK_BUFFER_CREATE_PROTECTED_BIT`), images
(`VK_IMAGE_CREATE_PROTECTED_BIT`), and swapchains
(`VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR`).
However, on implementations which support multiple windowing systems, not
all window systems **may** be able to provide a protected display path.

This extension provides a way to query if a protected swapchain created for
a surface (and thus a specific windowing system) **can** be displayed on
screen.
It extends the existing [VkSurfaceCapabilities2KHR](../chapters/VK_KHR_surface/wsi.html#VkSurfaceCapabilities2KHR) structure with a new
[VkSurfaceProtectedCapabilitiesKHR](../chapters/VK_KHR_surface/wsi.html#VkSurfaceProtectedCapabilitiesKHR) structure from which the application
**can** obtain information about support for protected swapchain creation
through [vkGetPhysicalDeviceSurfaceCapabilities2KHR](../chapters/VK_KHR_surface/wsi.html#vkGetPhysicalDeviceSurfaceCapabilities2KHR).

* 
Extending [VkSurfaceCapabilities2KHR](../chapters/VK_KHR_surface/wsi.html#VkSurfaceCapabilities2KHR):

[VkSurfaceProtectedCapabilitiesKHR](../chapters/VK_KHR_surface/wsi.html#VkSurfaceProtectedCapabilitiesKHR)

* 
`VK_KHR_SURFACE_PROTECTED_CAPABILITIES_EXTENSION_NAME`

* 
`VK_KHR_SURFACE_PROTECTED_CAPABILITIES_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR`

* 
Revision 1, 2018-12-18 (Sandeep Shinde, Daniel Koch)

Internal revisions.

**Name String**

`VK_KHR_swapchain`

**Extension Type**

Device extension

**Registered Extension Number**

2

**Revision**

70

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_surface](#VK_KHR_surface)

**API Interactions**

* 
Interacts with VK_VERSION_1_1

**Contact**

* 
James Jones [cubanismo](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_swapchain] @cubanismo%0A*Here describe the issue or question you have about the VK_KHR_swapchain extension*)

* 
Ian Elliott [ianelliottus](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_swapchain] @ianelliottus%0A*Here describe the issue or question you have about the VK_KHR_swapchain extension*)

**Last Modified Date**

2017-10-06

**IP Status**

No known IP claims.

**Interactions and External Dependencies**

* 
Interacts with Vulkan 1.1

**Contributors**

* 
Patrick Doane, Blizzard

* 
Ian Elliott, LunarG

* 
Jesse Hall, Google

* 
Mathias Heyer, NVIDIA

* 
James Jones, NVIDIA

* 
David Mao, AMD

* 
Norbert Nopper, Freescale

* 
Alon Or-bach, Samsung

* 
Daniel Rakos, AMD

* 
Graham Sellers, AMD

* 
Jeff Vigil, Qualcomm

* 
Chia-I Wu, LunarG

* 
Faith Ekstrand, Intel

* 
Matthaeus G. Chajdas, AMD

* 
Ray Smith, ARM

The `VK_KHR_swapchain` extension is the device-level companion to the
`[VK_KHR_surface](#VK_KHR_surface)` extension.
It introduces [VkSwapchainKHR](../chapters/VK_KHR_surface/wsi.html#VkSwapchainKHR) objects, which provide the ability to
present rendering results to a surface.

* 
[VkSwapchainKHR](../chapters/VK_KHR_surface/wsi.html#VkSwapchainKHR)

* 
[vkAcquireNextImageKHR](../chapters/VK_KHR_surface/wsi.html#vkAcquireNextImageKHR)

* 
[vkCreateSwapchainKHR](../chapters/VK_KHR_surface/wsi.html#vkCreateSwapchainKHR)

* 
[vkDestroySwapchainKHR](../chapters/VK_KHR_surface/wsi.html#vkDestroySwapchainKHR)

* 
[vkGetSwapchainImagesKHR](../chapters/VK_KHR_surface/wsi.html#vkGetSwapchainImagesKHR)

* 
[vkQueuePresentKHR](../chapters/VK_KHR_surface/wsi.html#vkQueuePresentKHR)

If [Vulkan Version 1.1](versions.html#versions-1.1) is supported:

* 
[vkAcquireNextImage2KHR](../chapters/VK_KHR_surface/wsi.html#vkAcquireNextImage2KHR)

* 
[vkGetDeviceGroupPresentCapabilitiesKHR](../chapters/VK_KHR_surface/wsi.html#vkGetDeviceGroupPresentCapabilitiesKHR)

* 
[vkGetDeviceGroupSurfacePresentModesKHR](../chapters/VK_KHR_surface/wsi.html#vkGetDeviceGroupSurfacePresentModesKHR)

* 
[vkGetPhysicalDevicePresentRectanglesKHR](../chapters/VK_KHR_surface/wsi.html#vkGetPhysicalDevicePresentRectanglesKHR)

* 
[VkPresentInfoKHR](../chapters/VK_KHR_surface/wsi.html#VkPresentInfoKHR)

* 
[VkSwapchainCreateInfoKHR](../chapters/VK_KHR_surface/wsi.html#VkSwapchainCreateInfoKHR)

If [Vulkan Version 1.1](versions.html#versions-1.1) is supported:

* 
[VkAcquireNextImageInfoKHR](../chapters/VK_KHR_surface/wsi.html#VkAcquireNextImageInfoKHR)

* 
[VkDeviceGroupPresentCapabilitiesKHR](../chapters/VK_KHR_surface/wsi.html#VkDeviceGroupPresentCapabilitiesKHR)

* 
Extending [VkBindImageMemoryInfo](../chapters/resources.html#VkBindImageMemoryInfo):

[VkBindImageMemorySwapchainInfoKHR](../chapters/resources.html#VkBindImageMemorySwapchainInfoKHR)

Extending [VkImageCreateInfo](../chapters/resources.html#VkImageCreateInfo):

* 
[VkImageSwapchainCreateInfoKHR](../chapters/resources.html#VkImageSwapchainCreateInfoKHR)

Extending [VkPresentInfoKHR](../chapters/VK_KHR_surface/wsi.html#VkPresentInfoKHR):

* 
[VkDeviceGroupPresentInfoKHR](../chapters/VK_KHR_surface/wsi.html#VkDeviceGroupPresentInfoKHR)

Extending [VkSwapchainCreateInfoKHR](../chapters/VK_KHR_surface/wsi.html#VkSwapchainCreateInfoKHR):

* 
[VkDeviceGroupSwapchainCreateInfoKHR](../chapters/VK_KHR_surface/wsi.html#VkDeviceGroupSwapchainCreateInfoKHR)

* 
[VkSwapchainCreateFlagBitsKHR](../chapters/VK_KHR_surface/wsi.html#VkSwapchainCreateFlagBitsKHR)

If [Vulkan Version 1.1](versions.html#versions-1.1) is supported:

* 
[VkDeviceGroupPresentModeFlagBitsKHR](../chapters/VK_KHR_surface/wsi.html#VkDeviceGroupPresentModeFlagBitsKHR)

* 
[VkSwapchainCreateFlagsKHR](../chapters/VK_KHR_surface/wsi.html#VkSwapchainCreateFlagsKHR)

If [Vulkan Version 1.1](versions.html#versions-1.1) is supported:

* 
[VkDeviceGroupPresentModeFlagsKHR](../chapters/VK_KHR_surface/wsi.html#VkDeviceGroupPresentModeFlagsKHR)

* 
`VK_KHR_SWAPCHAIN_EXTENSION_NAME`

* 
`VK_KHR_SWAPCHAIN_SPEC_VERSION`

* 
Extending [VkImageLayout](../chapters/resources.html#VkImageLayout):

`VK_IMAGE_LAYOUT_PRESENT_SRC_KHR`

Extending [VkObjectType](../chapters/debugging.html#VkObjectType):

* 
`VK_OBJECT_TYPE_SWAPCHAIN_KHR`

Extending [VkResult](../chapters/fundamentals.html#VkResult):

* 
`VK_ERROR_OUT_OF_DATE_KHR`

* 
`VK_SUBOPTIMAL_KHR`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PRESENT_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR`

If [Vulkan Version 1.1](versions.html#versions-1.1) is supported:

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR`

* 
`VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR`

Extending [VkSwapchainCreateFlagBitsKHR](../chapters/VK_KHR_surface/wsi.html#VkSwapchainCreateFlagBitsKHR):

* 
`VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR`

* 
`VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR`

1) Does this extension allow the application to specify the memory backing
of the presentable images?

**RESOLVED**: No.
Unlike standard images, the implementation will allocate the memory backing
of the presentable image.

2) What operations are allowed on presentable images?

**RESOLVED**: This is determined by the image usage flags specified when
creating the presentable images swapchain.

3) Does this extension support MSAA presentable images?

**RESOLVED**: No.
Presentable images are always single-sampled.
Multi-sampled rendering must use regular images.
To present the rendering results the application must manually resolve the
multi- sampled image to a single-sampled presentable image prior to
presentation.

4) Does this extension support stereo/multi-view presentable images?

**RESOLVED**: Yes.
The number of views associated with a presentable image is determined by the
`imageArrayLayers` specified when creating a swapchain.
All presentable images in a given swapchain use the same array size.

5) Are the layers of stereo presentable images half-sized?

**RESOLVED**: No.
The image extents always match those requested by the application.

6) Do the present and acquire next image commands operate on a
queue? If not, do they need to include explicit semaphore objects to
interlock them with queue operations?

**RESOLVED**: The present command operates on a queue.
The image ownership operation it represents happens in order with other
operations on the queue, so no explicit semaphore object is required to
synchronize its actions.

Applications may want to acquire the next image in separate threads from
those in which they manage their queue, or in multiple threads.
To make such usage easier, the acquire next image command takes a semaphore
to signal as a method of explicit synchronization.
The application must later queue a wait for this semaphore before queuing
execution of any commands using the image.

7) Does [vkAcquireNextImageKHR](../chapters/VK_KHR_surface/wsi.html#vkAcquireNextImageKHR) block if no images are available?

**RESOLVED**: The command takes a timeout parameter.
Special values for the timeout are 0, which makes the call a non-blocking
operation, and `UINT64_MAX`, which blocks indefinitely.
Values in between will block for up to the specified time.
The call will return when an image becomes available or an error occurs.
It may, but is not required to, return before the specified timeout expires
if the swapchain becomes out of date.

8) Can multiple presents be queued using one [vkQueuePresentKHR](../chapters/VK_KHR_surface/wsi.html#vkQueuePresentKHR) call?

**RESOLVED**: Yes.
[VkPresentInfoKHR](../chapters/VK_KHR_surface/wsi.html#VkPresentInfoKHR) contains a list of swapchains and corresponding image
indices that will be presented.
When supported, all presentations queued with a single
[vkQueuePresentKHR](../chapters/VK_KHR_surface/wsi.html#vkQueuePresentKHR) call will be applied atomically as one operation.
The same swapchain must not appear in the list more than once.
Later extensions may provide applications stronger guarantees of atomicity
for such present operations, and/or allow them to query whether atomic
presentation of a particular group of swapchains is possible.

9) How do the presentation and acquire next image functions notify the
application the targeted surface has changed?

**RESOLVED**: Two new result codes are introduced for this purpose:

* 
`VK_SUBOPTIMAL_KHR` - Presentation will still succeed, subject to
the window resize behavior, but the swapchain is no longer configured
optimally for the surface it targets.
Applications should query updated surface information and recreate their
swapchain at the next convenient opportunity.

* 
`VK_ERROR_OUT_OF_DATE_KHR` - Failure.
The swapchain is no longer compatible with the surface it targets.
The application must query updated surface information and recreate the
swapchain before presentation will succeed.

These can be returned by both [vkAcquireNextImageKHR](../chapters/VK_KHR_surface/wsi.html#vkAcquireNextImageKHR) and
[vkQueuePresentKHR](../chapters/VK_KHR_surface/wsi.html#vkQueuePresentKHR).

10) Does the [vkAcquireNextImageKHR](../chapters/VK_KHR_surface/wsi.html#vkAcquireNextImageKHR) command return a semaphore to the
application via an output parameter, or accept a semaphore to signal from
the application as an object handle parameter?

**RESOLVED**: Accept a semaphore to signal as an object handle.
This avoids the need to specify whether the application must destroy the
semaphore or whether it is owned by the swapchain, and if the latter, what
its lifetime is and whether it can be reused for other operations once it is
received from [vkAcquireNextImageKHR](../chapters/VK_KHR_surface/wsi.html#vkAcquireNextImageKHR).

11) What types of swapchain queuing behavior should be exposed? Options
include swap interval specification, mailbox/most recent vs. FIFO queue
management, targeting specific vertical blank intervals or absolute times
for a given present operation, and probably others.
For some of these, whether they are specified at swapchain creation time or
as per-present parameters needs to be decided as well.

**RESOLVED**: The base swapchain extension will expose 3 possible behaviors
(of which, FIFO will always be supported):

* 
Immediate present: Does not wait for vertical blanking period to update
the current image, likely resulting in visible tearing.
No internal queue is used.
Present requests are applied immediately.

* 
Mailbox queue: Waits for the next vertical blanking period to update the
current image.
No tearing should be observed.
An internal single-entry queue is used to hold pending presentation
requests.
If the queue is full when a new presentation request is received, the
new request replaces the existing entry, and any images associated with
the prior entry become available for reuse by the application.

* 
FIFO queue: Waits for the next vertical blanking period to update the
current image.
No tearing should be observed.
An internal queue containing `numSwapchainImages` - 1 entries
is used to hold pending presentation requests.
New requests are appended to the end of the queue, and one request is
removed from the beginning of the queue and processed during each
vertical blanking period in which the queue is non-empty

Not all surfaces will support all of these modes, so the modes supported
will be returned using a surface information query.
All surfaces must support the FIFO queue mode.
Applications must choose one of these modes up front when creating a
swapchain.
Switching modes can be accomplished by recreating the swapchain.

12) Can `VK_PRESENT_MODE_MAILBOX_KHR` provide non-blocking guarantees
for [vkAcquireNextImageKHR](../chapters/VK_KHR_surface/wsi.html#vkAcquireNextImageKHR)? If so, what is the proper criteria?

**RESOLVED**: Yes.
The difficulty is not immediately obvious here.
Naively, if at least 3 images are requested, mailbox mode should always have
an image available for the application if the application does not own any
images when the call to [vkAcquireNextImageKHR](../chapters/VK_KHR_surface/wsi.html#vkAcquireNextImageKHR) was made.
However, some presentation engines may have more than one current image,
and would still need to block in some cases.
The right requirement appears to be that if the application allocates the
surfaces minimum number of images + 1 then it is guaranteed non-blocking
behavior when it does not currently own any images.

13) Is there a way to create and initialize a new swapchain for a surface
that has generated a `VK_SUBOPTIMAL_KHR` return code while still using
the old swapchain?

**RESOLVED**: Not as part of this specification.
This could be useful to allow the application to create an optimal
replacement swapchain and rebuild all its command buffers using it in a
background thread at a low priority while continuing to use the
suboptimal swapchain in the main thread.
It could probably use the same atomic replace semantics proposed for
recreating direct-to-device swapchains without incurring a mode switch.
However, after discussion, it was determined some platforms probably could
not support concurrent swapchains for the same surface though, so this will
be left out of the base KHR extensions.
A future extension could add this for platforms where it is supported.

14) Should there be a special value for
[VkSurfaceCapabilitiesKHR](../chapters/VK_KHR_surface/wsi.html#VkSurfaceCapabilitiesKHR)::`maxImageCount` to indicate there are no
practical limits on the number of images in a swapchain?

**RESOLVED**: Yes.
There will often be cases where there is no practical limit to the number of
images in a swapchain other than the amount of available resources (i.e.,
memory) in the system.
Trying to derive a hard limit from things like memory size is prone to
failure.
It is better in such cases to leave it to applications to figure such soft
limits out via trial/failure iterations.

15) Should there be a special value for
[VkSurfaceCapabilitiesKHR](../chapters/VK_KHR_surface/wsi.html#VkSurfaceCapabilitiesKHR)::`currentExtent` to indicate the size of
the platform surface is **undefined**?

**RESOLVED**: Yes.
On some platforms (Wayland, for example), the surface size is defined by the
images presented to it rather than the other way around.

16) Should there be a special value for
[VkSurfaceCapabilitiesKHR](../chapters/VK_KHR_surface/wsi.html#VkSurfaceCapabilitiesKHR)::`maxImageExtent` to indicate there is no
practical limit on the surface size?

**RESOLVED**: No.
It seems unlikely such a system would exist.
0 could be used to indicate the platform places no limits on the extents
beyond those imposed by Vulkan for normal images, but this query could just
as easily return those same limits, so a special unlimited value does
not seem useful for this field.

17) How should surface rotation and mirroring be exposed to applications?
How do they specify rotation and mirroring transforms applied prior to
presentation?

**RESOLVED**: Applications can query both the supported and current transforms
of a surface.
Both are specified relative to the devices natural display rotation and
direction.
The supported transforms indicate which orientations the presentation engine
accepts images in.
For example, a presentation engine that does not support transforming
surfaces as part of presentation, and which is presenting to a surface that
is displayed with a 90-degree rotation, would return only one supported
transform bit: `VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR`.
Applications must transform their rendering by the transform they specify
when creating the swapchain in `preTransform` field.

18) Can surfaces ever not support `VK_MIRROR_NONE`? Can they support
vertical and horizontal mirroring simultaneously? Relatedly, should
`VK_MIRROR_NONE`[_BIT] be zero, or bit one, and should applications be
allowed to specify multiple pre and current mirror transform bits, or
exactly one?

**RESOLVED**: Since some platforms may not support presenting with a transform
other than the native windows current transform, and prerotation/mirroring
are specified relative to the devices natural rotation and direction,
rather than relative to the surfaces current rotation and direction, it is
necessary to express lack of support for no mirroring.
To allow this, the `MIRROR_NONE` enum must occupy a bit in the flags.
Since `MIRROR_NONE` must be a bit in the bitmask rather than a bitmask
with no values set, allowing more than one bit to be set in the bitmask
would make it possible to describe **undefined** transforms such as
`VK_MIRROR_NONE_BIT` | `VK_MIRROR_HORIZONTAL_BIT`, or a transform
that includes both no mirroring and horizontal mirroring
simultaneously.
Therefore, it is desirable to allow specifying all supported mirroring
transforms using only one bit.
The question then becomes, should there be a
`VK_MIRROR_HORIZONTAL_AND_VERTICAL_BIT` to represent a simultaneous
horizontal and vertical mirror transform? However, such a transform is
equivalent to a 180 degree rotation, so presentation engines and
applications that wish to support or use such a transform can express it
through rotation instead.
Therefore, 3 exclusive bits are sufficient to express all needed mirroring
transforms.

19) Should support for sRGB be required?

**RESOLVED**: In the advent of UHD and HDR display devices, proper color space
information is vital to the display pipeline represented by the swapchain.
The application can discover the supported format/color-space pairs and
select a pair most suited to its rendering needs.
Currently only the sRGB color space is supported, future extensions may
provide support for more color spaces.
See issues 23 and 24.

20) Is there a mechanism to modify or replace an existing swapchain with one
targeting the same surface?

**RESOLVED**: Yes.
This is described above in the text.

21) Should there be a way to set prerotation and mirroring using native APIs
when presenting using a Vulkan swapchain?

**RESOLVED**: Yes.
The transforms that can be expressed in this extension are a subset of those
possible on native platforms.
If a platform exposes a method to specify the transform of presented images
for a given surface using native methods and exposes more transforms or
other properties for surfaces than Vulkan supports, it might be impossible,
difficult, or inconvenient to set some of those properties using Vulkan KHR
extensions and some using the native interfaces.
To avoid overwriting properties set using native commands when presenting
using a Vulkan swapchain, the application can set the pretransform to
inherit, in which case the current native properties will be used, or if
none are available, a platform-specific default will be used.
Platforms that do not specify a reasonable default or do not provide native
mechanisms to specify such transforms should not include the inherit bits in
the `supportedTransforms` bitmask they return in
[VkSurfaceCapabilitiesKHR](../chapters/VK_KHR_surface/wsi.html#VkSurfaceCapabilitiesKHR).

22) Should the content of presentable images be clipped by objects obscuring
their target surface?

**RESOLVED**: Applications can choose which behavior they prefer.
Allowing the content to be clipped could enable more efficient presentation
methods on some platforms, but some applications might rely on the content
of presentable images to perform techniques such as partial updates or
motion blurs.

23) What is the purpose of specifying a [VkColorSpaceKHR](../chapters/VK_KHR_surface/wsi.html#VkColorSpaceKHR) along with
[VkFormat](../chapters/formats.html#VkFormat) when creating a swapchain?

**RESOLVED**: While Vulkan itself is color space agnostic (e.g. even the
meaning of R, G, B and A can be freely defined by the rendering
application), the swapchain eventually will have to present the images on a
display device with specific color reproduction characteristics.
If any color space transformations are necessary before an image can be
displayed, the color space of the presented image must be known to the
swapchain.
A swapchain will only support a restricted set of color format and -space
pairs.
This set can be discovered via [vkGetPhysicalDeviceSurfaceFormatsKHR](../chapters/VK_KHR_surface/wsi.html#vkGetPhysicalDeviceSurfaceFormatsKHR).
As it can be expected that most display devices support the sRGB color
space, at least one format/color-space pair has to be exposed, where the
color space is `VK_COLOR_SPACE_SRGB_NONLINEAR_KHR`.

24) How are sRGB formats and the sRGB color space related?

**RESOLVED**: While Vulkan exposes a number of SRGB texture formats, using
such formats does not guarantee working in a specific color space.
It merely means that the hardware can directly support applying the
non-linear transfer functions defined by the sRGB standard color space when
reading from or writing to images of those formats.
Still, it is unlikely that a swapchain will expose a `*_SRGB` format
along with any color space other than
`VK_COLOR_SPACE_SRGB_NONLINEAR_KHR`.

On the other hand, non-`*_SRGB` formats will be very likely exposed in
pair with a SRGB color space.
This means, the hardware will not apply any transfer function when reading
from or writing to such images, yet they will still be presented on a device
with sRGB display characteristics.
In this case the application is responsible for applying the transfer
function, for instance by using shader math.

25) How are the lifetimes of surfaces and swapchains targeting them related?

**RESOLVED**: A surface must outlive any swapchains targeting it.
A [VkSurfaceKHR](../chapters/VK_KHR_surface/wsi.html#VkSurfaceKHR) owns the binding of the native window to the Vulkan
driver.

26) How can the application control the way the alpha component of swapchain
images is treated by the presentation engine during compositing?

**RESOLVED**: We should add new enum values to allow the application to
negotiate with the presentation engine on how to treat image alpha values
during the compositing process.
Since not all platforms can practically control this through the Vulkan
driver, a value of `VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR` is provided like
for surface transforms.

27) Is [vkCreateSwapchainKHR](../chapters/VK_KHR_surface/wsi.html#vkCreateSwapchainKHR) the right function to return
`VK_ERROR_NATIVE_WINDOW_IN_USE_KHR`, or should the various
platform-specific [VkSurfaceKHR](../chapters/VK_KHR_surface/wsi.html#VkSurfaceKHR) factory functions catch this error
earlier?

**RESOLVED**: For most platforms, the [VkSurfaceKHR](../chapters/VK_KHR_surface/wsi.html#VkSurfaceKHR) structure is a simple
container holding the data that identifies a native window or other object
representing a surface on a particular platform.
For the surface factory functions to return this error, they would likely
need to register a reference on the native objects with the native display
server somehow, and ensure no other such references exist.
Surfaces were not intended to be that heavyweight.

Swapchains are intended to be the objects that directly manipulate native
windows and communicate with the native presentation mechanisms.
Swapchains will already need to communicate with the native display server
to negotiate allocation and/or presentation of presentable images for a
native surface.
Therefore, it makes more sense for swapchain creation to be the point at
which native object exclusivity is enforced.
Platforms may choose to enforce further restrictions on the number of
[VkSurfaceKHR](../chapters/VK_KHR_surface/wsi.html#VkSurfaceKHR) objects that may be created for the same native window if
such a requirement makes sense on a particular platform, but a global
requirement is only sensible at the swapchain level.

|  | The example code for the `[VK_KHR_surface](#VK_KHR_surface)` and `VK_KHR_swapchain`
| --- | --- |
extensions was removed from the appendix after revision 1.0.29.
This WSI example code was ported to the cube demo that is shipped with the
official Khronos SDK, and is being kept up-to-date in that location (see:
[https://github.com/KhronosGroup/Vulkan-Tools/blob/main/cube/cube.c](https://github.com/KhronosGroup/Vulkan-Tools/blob/main/cube/cube.c)). |

* 
Revision 1, 2015-05-20 (James Jones)

Initial draft, based on LunarG KHR spec, other KHR specs, patches
attached to bugs.

Revision 2, 2015-05-22 (Ian Elliott)

* 
Made many agreed-upon changes from 2015-05-21 KHR TSG meeting.
This includes using only a queue for presentation, and having an
explicit function to acquire the next image.

* 
Fixed typos and other minor mistakes.

Revision 3, 2015-05-26 (Ian Elliott)

* 
Improved the Description section.

* 
Added or resolved issues that were found in improving the Description.
For example, pSurfaceDescription is used consistently, instead of
sometimes using pSurface.

Revision 4, 2015-05-27 (James Jones)

* 
Fixed some grammatical errors and typos

* 
Filled in the description of imageUseFlags when creating a swapchain.

* 
Added a description of swapInterval.

* 
Replaced the paragraph describing the order of operations on a queue
for image ownership and presentation.

Revision 5, 2015-05-27 (James Jones)

* 
Imported relevant issues from the (abandoned)
vk_wsi_persistent_swapchain_images extension.

* 
Added issues 6 and 7, regarding behavior of the acquire next image and
present commands with respect to queues.

* 
Updated spec language and examples to align with proposed resolutions
to issues 6 and 7.

Revision 6, 2015-05-27 (James Jones)

* 
Added issue 8, regarding atomic presentation of multiple swapchains

* 
Updated spec language and examples to align with proposed resolution to
issue 8.

Revision 7, 2015-05-27 (James Jones)

* 
Fixed compilation errors in example code, and made related spec fixes.

Revision 8, 2015-05-27 (James Jones)

* 
Added issue 9, and the related VK_SUBOPTIMAL_KHR result code.

* 
Renamed VK_OUT_OF_DATE_KHR to VK_ERROR_OUT_OF_DATE_KHR.

Revision 9, 2015-05-27 (James Jones)

* 
Added inline proposed resolutions (marked with [JRJ]) to some XXX
questions/issues.
These should be moved to the issues section in a subsequent update if
the proposals are adopted.

Revision 10, 2015-05-28 (James Jones)

* 
Converted vkAcquireNextImageKHR back to a non-queue operation that uses
a VkSemaphore object for explicit synchronization.

* 
Added issue 10 to determine whether vkAcquireNextImageKHR generates or
returns semaphores, or whether it operates on a semaphore provided by
the application.

Revision 11, 2015-05-28 (James Jones)

* 
Marked issues 6, 7, and 8 resolved.

* 
Renamed VkSurfaceCapabilityPropertiesKHR to VkSurfacePropertiesKHR to
better convey the mutable nature of the information it contains.

Revision 12, 2015-05-28 (James Jones)

* 
Added issue 11 with a proposed resolution, and the related issue 12.

* 
Updated various sections of the spec to match the proposed resolution
to issue 11.

Revision 13, 2015-06-01 (James Jones)

* 
Moved some structures to VK_EXT_KHR_swap_chain to resolve the
specifications issues 1 and 2.

Revision 14, 2015-06-01 (James Jones)

* 
Added code for example 4 demonstrating how an application might make
use of the two different present and acquire next image KHR result
codes.

* 
Added issue 13.

Revision 15, 2015-06-01 (James Jones)

* 
Added issues 14 - 16 and related spec language.

* 
Fixed some spelling errors.

* 
Added language describing the meaningful return values for
vkAcquireNextImageKHR and vkQueuePresentKHR.

Revision 16, 2015-06-02 (James Jones)

* 
Added issues 17 and 18, as well as related spec language.

* 
Removed some erroneous text added by mistake in the last update.

Revision 17, 2015-06-15 (Ian Elliott)

* 
Changed special value from -1 to 0 so that the data types can
be unsigned.

Revision 18, 2015-06-15 (Ian Elliott)

* 
Clarified the values of VkSurfacePropertiesKHR::minImageCount and the
timeout parameter of the vkAcquireNextImageKHR function.

Revision 19, 2015-06-17 (James Jones)

* 
Misc.
cleanup.
Removed resolved inline issues and fixed typos.

* 
Fixed clarification of VkSurfacePropertiesKHR::minImageCount made in
version 18.

* 
Added a brief Image Ownership definition to the list of terms used
in the spec.

Revision 20, 2015-06-17 (James Jones)

* 
Updated enum-extending values using new convention.

Revision 21, 2015-06-17 (James Jones)

* 
Added language describing how to use
VK_IMAGE_LAYOUT_PRESENT_SOURCE_KHR.

* 
Cleaned up an XXX comment regarding the description of which queues
vkQueuePresentKHR can be used on.

Revision 22, 2015-06-17 (James Jones)

* 
Rebased on Vulkan API version 126.

Revision 23, 2015-06-18 (James Jones)

* 
Updated language for issue 12 to read as a proposed resolution.

* 
Marked issues 11, 12, 13, 16, and 17 resolved.

* 
Temporarily added links to the relevant bugs under the remaining
unresolved issues.

* 
Added issues 19 and 20 as well as proposed resolutions.

Revision 24, 2015-06-19 (Ian Elliott)

* 
Changed special value for VkSurfacePropertiesKHR::currentExtent back to
-1 from 0.
This value will never need to be unsigned, and 0 is actually a
legal value.

Revision 25, 2015-06-23 (Ian Elliott)

* 
Examples now show use of function pointers for extension functions.

* 
Eliminated extraneous whitespace.

Revision 26, 2015-06-25 (Ian Elliott)

* 
Resolved Issues 9 & 10 per KHR TSG meeting.

Revision 27, 2015-06-25 (James Jones)

* 
Added oldSwapchain member to VkSwapchainCreateInfoKHR.

Revision 28, 2015-06-25 (James Jones)

* 
Added the inherit bits to the rotation and mirroring flags and the
associated issue 21.

Revision 29, 2015-06-25 (James Jones)

* 
Added the clipped flag to VkSwapchainCreateInfoKHR, and the
associated issue 22.

* 
Specified that presenting an image does not modify it.

Revision 30, 2015-06-25 (James Jones)

* 
Added language to the spec that clarifies the behavior of
vkCreateSwapchainKHR() when the oldSwapchain field of
VkSwapchainCreateInfoKHR is not NULL.

Revision 31, 2015-06-26 (Ian Elliott)

* 
Example of new VkSwapchainCreateInfoKHR members, oldSwapchain and
clipped.

* 
Example of using VkSurfacePropertiesKHR::{min|max}ImageCount to set
VkSwapchainCreateInfoKHR::minImageCount.

* 
Rename vkGetSurfaceInfoKHR()'s 4th parameter to pDataSize, for
consistency with other functions.

* 
Add macro with C-string name of extension (just to header file).

Revision 32, 2015-06-26 (James Jones)

* 
Minor adjustments to the language describing the behavior of
oldSwapchain

* 
Fixed the version date on my previous two updates.

Revision 33, 2015-06-26 (Jesse Hall)

* 
Add usage flags to VkSwapchainCreateInfoKHR

Revision 34, 2015-06-26 (Ian Elliott)

* 
Rename vkQueuePresentKHR()'s 2nd parameter to pPresentInfo, for
consistency with other functions.

Revision 35, 2015-06-26 (Faith Ekstrand)

* 
Merged the VkRotationFlagBitsKHR and VkMirrorFlagBitsKHR enums into a
single VkSurfaceTransformFlagBitsKHR enum.

Revision 36, 2015-06-26 (Faith Ekstrand)

* 
Added a VkSurfaceTransformKHR enum that is not a bitmask.
Each value in VkSurfaceTransformKHR corresponds directly to one of the
bits in VkSurfaceTransformFlagBitsKHR so transforming from one to the
other is easy.
Having a separate enum means that currentTransform and preTransform are
now unambiguous by definition.

Revision 37, 2015-06-29 (Ian Elliott)

* 
Corrected one of the signatures of vkAcquireNextImageKHR, which had the
last two parameters switched from what it is elsewhere in the
specification and header files.

Revision 38, 2015-06-30 (Ian Elliott)

* 
Corrected a typo in description of the vkGetSwapchainInfoKHR()
function.

* 
Corrected a typo in header file comment for VkPresentInfoKHR::sType.

Revision 39, 2015-07-07 (Daniel Rakos)

* 
Added error section describing when each error is expected to be
reported.

* 
Replaced bool32_t with VkBool32.

Revision 40, 2015-07-10 (Ian Elliott)

* 
Updated to work with version 138 of the `vulkan.h` header.
This includes declaring the VkSwapchainKHR type using the new
VK_DEFINE_NONDISP_HANDLE macro, and no longer extending VkObjectType
(which was eliminated).

Revision 41 2015-07-09 (Mathias Heyer)

* 
Added color space language.

Revision 42, 2015-07-10 (Daniel Rakos)

* 
Updated query mechanism to reflect the convention changes done in the
core spec.

* 
Removed queue from the name of
VK_STRUCTURE_TYPE_QUEUE_PRESENT_INFO_KHR to be consistent with the
established naming convention.

* 
Removed reference to the no longer existing VkObjectType enum.

Revision 43, 2015-07-17 (Daniel Rakos)

* 
Added support for concurrent sharing of swapchain images across queue
families.

* 
Updated sample code based on recent changes

Revision 44, 2015-07-27 (Ian Elliott)

* 
Noted that support for VK_PRESENT_MODE_FIFO_KHR is required.
That is ICDs may optionally support IMMEDIATE and MAILBOX, but must
support FIFO.

Revision 45, 2015-08-07 (Ian Elliott)

* 
Corrected a typo in spec file (type and variable name had wrong case
for the imageColorSpace member of the VkSwapchainCreateInfoKHR struct).

* 
Corrected a typo in header file (last parameter in
PFN_vkGetSurfacePropertiesKHR was missing KHR at the end of type:
VkSurfacePropertiesKHR).

Revision 46, 2015-08-20 (Ian Elliott)

* 
Renamed this extension and all of its enumerations, types, functions,
etc.
This makes it compliant with the proposed standard for Vulkan
extensions.

* 
Switched from revision to version, including use of the
VK_MAKE_VERSION macro in the header file.

* 
Made improvements to several descriptions.

* 
Changed the status of several issues from PROPOSED to RESOLVED, leaving
no unresolved issues.

* 
Resolved several TODOs, did miscellaneous cleanup, etc.

Revision 47, 2015-08-20 (Ian Elliottporting a 2015-07-29 change from
James Jones)

* 
Moved the surface transform enums to VK_WSI_swapchain so they could be
reused by VK_WSI_display.

Revision 48, 2015-09-01 (James Jones)

* 
Various minor cleanups.

Revision 49, 2015-09-01 (James Jones)

* 
Restore single-field revision number.

Revision 50, 2015-09-01 (James Jones)

* 
Update Example #4 to include code that illustrates how to use the
oldSwapchain field.

Revision 51, 2015-09-01 (James Jones)

* 
Fix example code compilation errors.

Revision 52, 2015-09-08 (Matthaeus G. Chajdas)

* 
Corrected a typo.

Revision 53, 2015-09-10 (Alon Or-bach)

* 
Removed underscore from SWAP_CHAIN left in
VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR.

Revision 54, 2015-09-11 (Jesse Hall)

* 
Described the execution and memory coherence requirements for image
transitions to and from VK_IMAGE_LAYOUT_PRESENT_SOURCE_KHR.

Revision 55, 2015-09-11 (Ray Smith)

* 
Added errors for destroying and binding memory to presentable images

Revision 56, 2015-09-18 (James Jones)

* 
Added fence argument to vkAcquireNextImageKHR

* 
Added example of how to meter a host thread based on presentation rate.

Revision 57, 2015-09-26 (Jesse Hall)

* 
Replace VkSurfaceDescriptionKHR with VkSurfaceKHR.

* 
Added issue 25 with agreed resolution.

Revision 58, 2015-09-28 (Jesse Hall)

* 
Renamed from VK_EXT_KHR_device_swapchain to VK_EXT_KHR_swapchain.

Revision 59, 2015-09-29 (Ian Elliott)

* 
Changed vkDestroySwapchainKHR() to return void.

Revision 60, 2015-10-01 (Jeff Vigil)

* 
Added error result VK_ERROR_SURFACE_LOST_KHR.

Revision 61, 2015-10-05 (Faith Ekstrand)

* 
Added the VkCompositeAlpha enum and corresponding structure fields.

Revision 62, 2015-10-12 (Daniel Rakos)

* 
Added VK_PRESENT_MODE_FIFO_RELAXED_KHR.

Revision 63, 2015-10-15 (Daniel Rakos)

* 
Moved surface capability queries to VK_EXT_KHR_surface.

Revision 64, 2015-10-26 (Ian Elliott)

* 
Renamed from VK_EXT_KHR_swapchain to VK_KHR_swapchain.

Revision 65, 2015-10-28 (Ian Elliott)

* 
Added optional pResult member to VkPresentInfoKHR, so that
per-swapchain results can be obtained from vkQueuePresentKHR().

Revision 66, 2015-11-03 (Daniel Rakos)

* 
Added allocation callbacks to create and destroy functions.

* 
Updated resource transition language.

* 
Updated sample code.

Revision 67, 2015-11-10 (Jesse Hall)

* 
Add reserved flags bitmask to VkSwapchainCreateInfoKHR.

* 
Modify naming and member ordering to match API style conventions, and
so the VkSwapchainCreateInfoKHR image property members mirror
corresponding VkImageCreateInfo members but with an 'image' prefix.

* 
Make VkPresentInfoKHR::pResults non-const; it is an output array
parameter.

* 
Make pPresentInfo parameter to vkQueuePresentKHR const.

Revision 68, 2016-04-05 (Ian Elliott)

* 
Moved the validity include for vkAcquireNextImage to be in its
proper place, after the prototype and list of parameters.

* 
Clarified language about presentable images, including how they are
acquired, when applications can and cannot use them, etc.
As part of this, removed language about ownership of presentable
images, and replaced it with more-consistent language about presentable
images being acquired by the application.

2016-08-23 (Ian Elliott)

* 
Update the example code, to use the final API command names, to not
have so many characters per line, and to split out a new example to
show how to obtain function pointers.
This code is more similar to the LunarG cube demo program.

2016-08-25 (Ian Elliott)

* 
A note was added at the beginning of the example code, stating that it
will be removed from future versions of the appendix.

Revision 69, 2017-09-07 (Tobias Hector)

* 
Added interactions with Vulkan 1.1

Revision 70, 2017-10-06 (Ian Elliott)

* 
Corrected interactions with Vulkan 1.1

**Name String**

`VK_KHR_swapchain_mutable_format`

**Extension Type**

Device extension

**Registered Extension Number**

201

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_swapchain](#VK_KHR_swapchain)

and

 [VK_KHR_maintenance2](#VK_KHR_maintenance2)

 or

 [Vulkan Version 1.1](versions.html#versions-1.1)

and

 [VK_KHR_image_format_list](#VK_KHR_image_format_list)

 or

 [Vulkan Version 1.2](versions.html#versions-1.2)

**Contact**

* 
Daniel Rakos [drakos-amd](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_swapchain_mutable_format] @drakos-amd%0A*Here describe the issue or question you have about the VK_KHR_swapchain_mutable_format extension*)

**Last Modified Date**

2018-03-28

**IP Status**

No known IP claims.

**Contributors**

* 
Faith Ekstrand, Intel

* 
Jan-Harald Fredriksen, ARM

* 
Jesse Hall, Google

* 
Daniel Rakos, AMD

* 
Ray Smith, ARM

This extension allows processing of swapchain images as different formats to
that used by the window system, which is particularly useful for switching
between sRGB and linear RGB formats.

It adds a new swapchain creation flag that enables creating image views from
presentable images with a different format than the one used to create the
swapchain.

* 
`VK_KHR_SWAPCHAIN_MUTABLE_FORMAT_EXTENSION_NAME`

* 
`VK_KHR_SWAPCHAIN_MUTABLE_FORMAT_SPEC_VERSION`

* 
Extending [VkSwapchainCreateFlagBitsKHR](../chapters/VK_KHR_surface/wsi.html#VkSwapchainCreateFlagBitsKHR):

`VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR`

1) Are there any new capabilities needed?

**RESOLVED**: No.
It is expected that all implementations exposing this extension support
swapchain image format mutability.

2) Do we need a separate `VK_SWAPCHAIN_CREATE_EXTENDED_USAGE_BIT_KHR`?

**RESOLVED**: No.
This extension requires `VK_KHR_maintenance2` and presentable images of
swapchains created with `VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR` are
created internally in a way equivalent to specifying both
`VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT` and
`VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR`.

3) Do we need a separate structure to allow specifying an image format list
for swapchains?

**RESOLVED**: No.
We simply use the same [VkImageFormatListCreateInfoKHR](../chapters/resources.html#VkImageFormatListCreateInfoKHR) structure
introduced by `VK_KHR_image_format_list`.
The structure is required to be included in the `pNext` chain of
[VkSwapchainCreateInfoKHR](../chapters/VK_KHR_surface/wsi.html#VkSwapchainCreateInfoKHR) for swapchains created with
`VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR`.

* 
Revision 1, 2018-03-28 (Daniel Rakos)

Internal revisions.

**Name String**

`VK_KHR_video_decode_av1`

**Extension Type**

Device extension

**Registered Extension Number**

513

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_video_decode_queue](#VK_KHR_video_decode_queue)

**Contact**

* 
Daniel Rakos [aqnuep](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_video_decode_av1] @aqnuep%0A*Here describe the issue or question you have about the VK_KHR_video_decode_av1 extension*)

**Extension Proposal**

[VK_KHR_video_decode_av1](../../../features/latest/features/proposals/VK_KHR_video_decode_av1.html)

**Last Modified Date**

2024-01-02

**IP Status**

No known IP claims.

**Contributors**

* 
Ahmed Abdelkhalek, AMD

* 
Benjamin Cheng, AMD

* 
Ho Hin Lau, AMD

* 
Lynne Iribarren, Independent

* 
David Airlie, Red Hat, Inc.

* 
Ping Liu, Intel

* 
Srinath Kumarapuram, NVIDIA

* 
Vassili Nikolaev, NVIDIA

* 
Tony Zlatinski, NVIDIA

* 
Charlie Turner, Igalia

* 
Daniel Almeida, Collabora

* 
Nicolas Dufresne, Collabora

* 
Daniel Rakos, RasterGrid

This extension builds upon the `[VK_KHR_video_decode_queue](#VK_KHR_video_decode_queue)` extension
by adding support for decoding elementary video stream sequences compliant
with the AV1 video compression standard.

* 
Extending [VkVideoCapabilitiesKHR](../chapters/videocoding.html#VkVideoCapabilitiesKHR):

[VkVideoDecodeAV1CapabilitiesKHR](../chapters/videocoding.html#VkVideoDecodeAV1CapabilitiesKHR)

Extending [VkVideoDecodeInfoKHR](../chapters/videocoding.html#VkVideoDecodeInfoKHR):

* 
[VkVideoDecodeAV1PictureInfoKHR](../chapters/videocoding.html#VkVideoDecodeAV1PictureInfoKHR)

Extending [VkVideoProfileInfoKHR](../chapters/videocoding.html#VkVideoProfileInfoKHR), [VkQueryPoolCreateInfo](../chapters/queries.html#VkQueryPoolCreateInfo):

* 
[VkVideoDecodeAV1ProfileInfoKHR](../chapters/videocoding.html#VkVideoDecodeAV1ProfileInfoKHR)

Extending [VkVideoReferenceSlotInfoKHR](../chapters/videocoding.html#VkVideoReferenceSlotInfoKHR):

* 
[VkVideoDecodeAV1DpbSlotInfoKHR](../chapters/videocoding.html#VkVideoDecodeAV1DpbSlotInfoKHR)

Extending [VkVideoSessionParametersCreateInfoKHR](../chapters/videocoding.html#VkVideoSessionParametersCreateInfoKHR):

* 
[VkVideoDecodeAV1SessionParametersCreateInfoKHR](../chapters/videocoding.html#VkVideoDecodeAV1SessionParametersCreateInfoKHR)

* 
`VK_KHR_VIDEO_DECODE_AV1_EXTENSION_NAME`

* 
`VK_KHR_VIDEO_DECODE_AV1_SPEC_VERSION`

* 
`VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_CAPABILITIES_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_DPB_SLOT_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PICTURE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PROFILE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR`

Extending [VkVideoCodecOperationFlagBitsKHR](../chapters/videocoding.html#VkVideoCodecOperationFlagBitsKHR):

* 
`VK_VIDEO_CODEC_OPERATION_DECODE_AV1_BIT_KHR`

* 
Revision 1, 2024-01-02 (Daniel Rakos)

Internal revisions

**Name String**

`VK_KHR_video_decode_h264`

**Extension Type**

Device extension

**Registered Extension Number**

41

**Revision**

9

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_video_decode_queue](#VK_KHR_video_decode_queue)

**Contact**

* 
[peter.fang@amd.com](mailto:peter.fang@amd.com)

**Extension Proposal**

[VK_KHR_video_decode_h264](../../../features/latest/features/proposals/VK_KHR_video_decode_h264.html)

**Last Modified Date**

2023-12-05

**IP Status**

No known IP claims.

**Contributors**

* 
Ahmed Abdelkhalek, AMD

* 
Chunbo Chen, Intel

* 
HoHin Lau, AMD

* 
Jake Beju, AMD

* 
Peter Fang, AMD

* 
Ping Liu, Intel

* 
Srinath Kumarapuram, NVIDIA

* 
Tony Zlatinski, NVIDIA

* 
Daniel Rakos, RasterGrid

This extension builds upon the `[VK_KHR_video_decode_queue](#VK_KHR_video_decode_queue)` extension
by adding support for decoding elementary video stream sequences compliant
with the H.264/AVC video compression standard.

|  | This extension was promoted to `KHR` from the provisional extension
| --- | --- |
`VK_EXT_video_decode_h264`. |

* 
Extending [VkVideoCapabilitiesKHR](../chapters/videocoding.html#VkVideoCapabilitiesKHR):

[VkVideoDecodeH264CapabilitiesKHR](../chapters/videocoding.html#VkVideoDecodeH264CapabilitiesKHR)

Extending [VkVideoDecodeInfoKHR](../chapters/videocoding.html#VkVideoDecodeInfoKHR):

* 
[VkVideoDecodeH264PictureInfoKHR](../chapters/videocoding.html#VkVideoDecodeH264PictureInfoKHR)

Extending [VkVideoProfileInfoKHR](../chapters/videocoding.html#VkVideoProfileInfoKHR), [VkQueryPoolCreateInfo](../chapters/queries.html#VkQueryPoolCreateInfo):

* 
[VkVideoDecodeH264ProfileInfoKHR](../chapters/videocoding.html#VkVideoDecodeH264ProfileInfoKHR)

Extending [VkVideoReferenceSlotInfoKHR](../chapters/videocoding.html#VkVideoReferenceSlotInfoKHR):

* 
[VkVideoDecodeH264DpbSlotInfoKHR](../chapters/videocoding.html#VkVideoDecodeH264DpbSlotInfoKHR)

Extending [VkVideoSessionParametersCreateInfoKHR](../chapters/videocoding.html#VkVideoSessionParametersCreateInfoKHR):

* 
[VkVideoDecodeH264SessionParametersCreateInfoKHR](../chapters/videocoding.html#VkVideoDecodeH264SessionParametersCreateInfoKHR)

Extending [VkVideoSessionParametersUpdateInfoKHR](../chapters/videocoding.html#VkVideoSessionParametersUpdateInfoKHR):

* 
[VkVideoDecodeH264SessionParametersAddInfoKHR](../chapters/videocoding.html#VkVideoDecodeH264SessionParametersAddInfoKHR)

* 
[VkVideoDecodeH264PictureLayoutFlagBitsKHR](../chapters/videocoding.html#VkVideoDecodeH264PictureLayoutFlagBitsKHR)

* 
[VkVideoDecodeH264PictureLayoutFlagsKHR](../chapters/videocoding.html#VkVideoDecodeH264PictureLayoutFlagsKHR)

* 
`VK_KHR_VIDEO_DECODE_H264_EXTENSION_NAME`

* 
`VK_KHR_VIDEO_DECODE_H264_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR`

Extending [VkVideoCodecOperationFlagBitsKHR](../chapters/videocoding.html#VkVideoCodecOperationFlagBitsKHR):

* 
`VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR`

* 
Revision 1, 2018-6-11 (Peter Fang)

Initial draft

Revision 2, March 29 2021 (Tony Zlatinski)

* 
Spec and API Updates

Revision 3, August 1 2021 (Srinath Kumarapuram)

* 
Rename `VkVideoDecodeH264FieldLayoutFlagsEXT` to
`VkVideoDecodeH264PictureLayoutFlagsEXT`,
`VkVideoDecodeH264FieldLayoutFlagBitsEXT` to
`VkVideoDecodeH264PictureLayoutFlagBitsEXT` (along with the names of
enumerants it defines), and `VkVideoDecodeH264ProfileEXT.fieldLayout`
to `VkVideoDecodeH264ProfileEXT.pictureLayout`, following Vulkan naming
conventions.

Revision 4, 2022-03-16 (Ahmed Abdelkhalek)

* 
Relocate Std header version reporting/requesting from this extension to
VK_KHR_video_queue extension.

* 
Remove the now empty VkVideoDecodeH264SessionCreateInfoEXT.

Revision 5, 2022-03-31 (Ahmed Abdelkhalek)

* 
Use type StdVideoH264Level for VkVideoDecodeH264Capabilities.maxLevel

Revision 6, 2022-08-09 (Daniel Rakos)

* 
Rename `VkVideoDecodeH264ProfileEXT` to
`VkVideoDecodeH264ProfileInfoEXT`

* 
Rename `VkVideoDecodeH264MvcEXT` to `VkVideoDecodeH264MvcInfoEXT`

Revision 7, 2022-09-18 (Daniel Rakos)

* 
Change type of `VkVideoDecodeH264ProfileInfoEXT::pictureLayout` to
`VkVideoDecodeH264PictureLayoutFlagBitsEXT`

* 
Remove MVC support and related `VkVideoDecodeH264MvcInfoEXT` structure

* 
Rename `spsStdCount`, `pSpsStd`, `ppsStdCount`, and `pPpsStd` to
`stdSPSCount`, `pStdSPSs`, `stdPPSCount`, and `pStdPPSs`, respectively,
in `VkVideoDecodeH264SessionParametersAddInfoEXT`

* 
Rename `maxSpsStdCount` and `maxPpsStdCount` to `maxStdSPSCount` and
`maxStdPPSCount`, respectively, in
`VkVideoDecodeH264SessionParametersCreateInfoEXT`

* 
Rename `slicesCount` and `pSlicesDataOffsets` to `sliceCount` and
`pSliceOffsets`, respectively, in `VkVideoDecodeH264PictureInfoEXT`

Revision 8, 2022-09-29 (Daniel Rakos)

* 
Change extension from `EXT` to `KHR`

* 
Extension is no longer provisional

Revision 9, 2023-12-05 (Daniel Rakos)

* 
Condition reference picture setup based on the value of
`StdVideoDecodeH264PictureInfo::flags.is_reference`

**Name String**

`VK_KHR_video_decode_h265`

**Extension Type**

Device extension

**Registered Extension Number**

188

**Revision**

8

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_video_decode_queue](#VK_KHR_video_decode_queue)

**Contact**

* 
[peter.fang@amd.com](mailto:peter.fang@amd.com)

**Extension Proposal**

[VK_KHR_video_decode_h265](../../../features/latest/features/proposals/VK_KHR_video_decode_h265.html)

**Last Modified Date**

2023-12-05

**IP Status**

No known IP claims.

**Contributors**

* 
Ahmed Abdelkhalek, AMD

* 
HoHin Lau, AMD

* 
Jake Beju, AMD

* 
Peter Fang, AMD

* 
Ping Liu, Intel

* 
Srinath Kumarapuram, NVIDIA

* 
Tony Zlatinski, NVIDIA

* 
Daniel Rakos, RasterGrid

This extension builds upon the `[VK_KHR_video_decode_queue](#VK_KHR_video_decode_queue)` extension
by adding support for decoding elementary video stream sequences compliant
with the H.265/HEVC video compression standard.

|  | This extension was promoted to `KHR` from the provisional extension
| --- | --- |
`VK_EXT_video_decode_h265`. |

* 
Extending [VkVideoCapabilitiesKHR](../chapters/videocoding.html#VkVideoCapabilitiesKHR):

[VkVideoDecodeH265CapabilitiesKHR](../chapters/videocoding.html#VkVideoDecodeH265CapabilitiesKHR)

Extending [VkVideoDecodeInfoKHR](../chapters/videocoding.html#VkVideoDecodeInfoKHR):

* 
[VkVideoDecodeH265PictureInfoKHR](../chapters/videocoding.html#VkVideoDecodeH265PictureInfoKHR)

Extending [VkVideoProfileInfoKHR](../chapters/videocoding.html#VkVideoProfileInfoKHR), [VkQueryPoolCreateInfo](../chapters/queries.html#VkQueryPoolCreateInfo):

* 
[VkVideoDecodeH265ProfileInfoKHR](../chapters/videocoding.html#VkVideoDecodeH265ProfileInfoKHR)

Extending [VkVideoReferenceSlotInfoKHR](../chapters/videocoding.html#VkVideoReferenceSlotInfoKHR):

* 
[VkVideoDecodeH265DpbSlotInfoKHR](../chapters/videocoding.html#VkVideoDecodeH265DpbSlotInfoKHR)

Extending [VkVideoSessionParametersCreateInfoKHR](../chapters/videocoding.html#VkVideoSessionParametersCreateInfoKHR):

* 
[VkVideoDecodeH265SessionParametersCreateInfoKHR](../chapters/videocoding.html#VkVideoDecodeH265SessionParametersCreateInfoKHR)

Extending [VkVideoSessionParametersUpdateInfoKHR](../chapters/videocoding.html#VkVideoSessionParametersUpdateInfoKHR):

* 
[VkVideoDecodeH265SessionParametersAddInfoKHR](../chapters/videocoding.html#VkVideoDecodeH265SessionParametersAddInfoKHR)

* 
`VK_KHR_VIDEO_DECODE_H265_EXTENSION_NAME`

* 
`VK_KHR_VIDEO_DECODE_H265_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR`

Extending [VkVideoCodecOperationFlagBitsKHR](../chapters/videocoding.html#VkVideoCodecOperationFlagBitsKHR):

* 
`VK_VIDEO_CODEC_OPERATION_DECODE_H265_BIT_KHR`

* 
Revision 1, 2018-6-11 (Peter Fang)

Initial draft

Revision 1.6, March 29 2021 (Tony Zlatinski)

* 
Spec and API updates.

Revision 2, 2022-03-16 (Ahmed Abdelkhalek)

* 
Relocate Std header version reporting/requesting from this extension to
VK_KHR_video_queue extension.

* 
Remove the now empty VkVideoDecodeH265SessionCreateInfoEXT.

Revision 3, 2022-03-31 (Ahmed Abdelkhalek)

* 
Use type StdVideoH265Level for VkVideoDecodeH265Capabilities.maxLevel

Revision 4, 2022-08-09 (Daniel Rakos)

* 
Rename `VkVideoDecodeH265ProfileEXT` to
`VkVideoDecodeH265ProfileInfoEXT`

Revision 5, 2022-09-18 (Daniel Rakos)

* 
Rename `vpsStdCount`, `pVpsStd`, `spsStdCount`, `pSpsStd`,
`ppsStdCount`, and `pPpsStd` to `stdVPSCount`, `pStdVPSs`,
`stdSPSCount`, `pStdSPSs`, `stdPPSCount`, and `pStdPPSs`, respectively,
in `VkVideoDecodeH265SessionParametersAddInfoEXT`

* 
Rename `maxVpsStdCount`, `maxSpsStdCount`, and `maxPpsStdCount` to
`maxStdVPSCount`, `maxStdSPSCount` and `maxStdPPSCount`, respectively,
in `VkVideoDecodeH265SessionParametersCreateInfoEXT`

* 
Rename `slicesCount` and `pSlicesDataOffsets` to `sliceCount` and
`pSliceOffsets`, respectively, in `VkVideoDecodeH265PictureInfoEXT`

Revision 6, 2022-11-14 (Daniel Rakos)

* 
Rename `slice` to `sliceSegment` in the APIs for better clarity

Revision 7, 2022-11-14 (Daniel Rakos)

* 
Change extension from `EXT` to `KHR`

* 
Extension is no longer provisional

Revision 8, 2023-12-05 (Daniel Rakos)

* 
Condition reference picture setup based on the value of
`StdVideoDecodeH265PictureInfo::flags.IsReference`

**Name String**

`VK_KHR_video_decode_queue`

**Extension Type**

Device extension

**Registered Extension Number**

25

**Revision**

8

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_video_queue](#VK_KHR_video_queue)

and

 [VK_KHR_synchronization2](#VK_KHR_synchronization2)

 or

 [Vulkan Version 1.3](versions.html#versions-1.3)

**API Interactions**

* 
Interacts with VK_VERSION_1_3

* 
Interacts with VK_KHR_format_feature_flags2

**Contact**

* 
[jake.beju@amd.com](mailto:jake.beju@amd.com)

**Extension Proposal**

[VK_KHR_video_decode_queue](../../../features/latest/features/proposals/VK_KHR_video_decode_queue.html)

**Last Modified Date**

2023-12-05

**IP Status**

No known IP claims.

**Contributors**

* 
Ahmed Abdelkhalek, AMD

* 
Jake Beju, AMD

* 
Olivier Lapicque, NVIDIA

* 
Peter Fang, AMD

* 
Piers Daniell, NVIDIA

* 
Srinath Kumarapuram, NVIDIA

* 
Tony Zlatinski, NVIDIA

* 
Daniel Rakos, RasterGrid

This extension builds upon the `[VK_KHR_video_queue](#VK_KHR_video_queue)` extension by
adding common APIs specific to video decoding and thus enabling
implementations to expose queue families supporting video decode operations.

More specifically, it adds video decode specific capabilities and a new
command buffer command that allows recording video decode operations against
a video session.

This extension is to be used in conjunction with other codec specific video
decode extensions that enable decoding video sequences of specific video
compression standards.

* 
[vkCmdDecodeVideoKHR](../chapters/videocoding.html#vkCmdDecodeVideoKHR)

* 
[VkVideoDecodeInfoKHR](../chapters/videocoding.html#VkVideoDecodeInfoKHR)

* 
Extending [VkVideoCapabilitiesKHR](../chapters/videocoding.html#VkVideoCapabilitiesKHR):

[VkVideoDecodeCapabilitiesKHR](../chapters/videocoding.html#VkVideoDecodeCapabilitiesKHR)

Extending [VkVideoProfileInfoKHR](../chapters/videocoding.html#VkVideoProfileInfoKHR), [VkQueryPoolCreateInfo](../chapters/queries.html#VkQueryPoolCreateInfo):

* 
[VkVideoDecodeUsageInfoKHR](../chapters/videocoding.html#VkVideoDecodeUsageInfoKHR)

* 
[VkVideoDecodeCapabilityFlagBitsKHR](../chapters/videocoding.html#VkVideoDecodeCapabilityFlagBitsKHR)

* 
[VkVideoDecodeUsageFlagBitsKHR](../chapters/videocoding.html#VkVideoDecodeUsageFlagBitsKHR)

* 
[VkVideoDecodeCapabilityFlagsKHR](../chapters/videocoding.html#VkVideoDecodeCapabilityFlagsKHR)

* 
[VkVideoDecodeFlagsKHR](../chapters/videocoding.html#VkVideoDecodeFlagsKHR)

* 
[VkVideoDecodeUsageFlagsKHR](../chapters/videocoding.html#VkVideoDecodeUsageFlagsKHR)

* 
`VK_KHR_VIDEO_DECODE_QUEUE_EXTENSION_NAME`

* 
`VK_KHR_VIDEO_DECODE_QUEUE_SPEC_VERSION`

* 
Extending [VkAccessFlagBits2](../chapters/synchronization.html#VkAccessFlagBits2):

`VK_ACCESS_2_VIDEO_DECODE_READ_BIT_KHR`

* 
`VK_ACCESS_2_VIDEO_DECODE_WRITE_BIT_KHR`

Extending [VkBufferUsageFlagBits](../chapters/resources.html#VkBufferUsageFlagBits):

* 
`VK_BUFFER_USAGE_VIDEO_DECODE_DST_BIT_KHR`

* 
`VK_BUFFER_USAGE_VIDEO_DECODE_SRC_BIT_KHR`

Extending [VkFormatFeatureFlagBits](../chapters/formats.html#VkFormatFeatureFlagBits):

* 
`VK_FORMAT_FEATURE_VIDEO_DECODE_DPB_BIT_KHR`

* 
`VK_FORMAT_FEATURE_VIDEO_DECODE_OUTPUT_BIT_KHR`

Extending [VkImageLayout](../chapters/resources.html#VkImageLayout):

* 
`VK_IMAGE_LAYOUT_VIDEO_DECODE_DPB_KHR`

* 
`VK_IMAGE_LAYOUT_VIDEO_DECODE_DST_KHR`

* 
`VK_IMAGE_LAYOUT_VIDEO_DECODE_SRC_KHR`

Extending [VkImageUsageFlagBits](../chapters/resources.html#VkImageUsageFlagBits):

* 
`VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR`

* 
`VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR`

* 
`VK_IMAGE_USAGE_VIDEO_DECODE_SRC_BIT_KHR`

Extending [VkPipelineStageFlagBits2](../chapters/synchronization.html#VkPipelineStageFlagBits2):

* 
`VK_PIPELINE_STAGE_2_VIDEO_DECODE_BIT_KHR`

Extending [VkQueueFlagBits](../chapters/devsandqueues.html#VkQueueFlagBits):

* 
`VK_QUEUE_VIDEO_DECODE_BIT_KHR`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR`

If [VK_KHR_format_feature_flags2](#VK_KHR_format_feature_flags2) or [Vulkan Version 1.3](versions.html#versions-1.3) is supported:

* 
Extending [VkFormatFeatureFlagBits2](../chapters/formats.html#VkFormatFeatureFlagBits2):

`VK_FORMAT_FEATURE_2_VIDEO_DECODE_DPB_BIT_KHR`

* 
`VK_FORMAT_FEATURE_2_VIDEO_DECODE_OUTPUT_BIT_KHR`

* 
Revision 1, 2018-6-11 (Peter Fang)

Initial draft

Revision 1.5, Nov 09 2018 (Tony Zlatinski)

* 
API Updates

Revision 1.6, Jan 08 2020 (Tony Zlatinski)

* 
API unify with the video_encode_queue spec

Revision 1.7, March 29 2021 (Tony Zlatinski)

* 
Spec and API updates.

Revision 2, September 30 2021 (Jon Leech)

* 
Add interaction with `[VK_KHR_format_feature_flags2](#VK_KHR_format_feature_flags2)` to `vk.xml`

Revision 3, 2022-02-25 (Ahmed Abdelkhalek)

* 
Add VkVideoDecodeCapabilitiesKHR with new flags to report support for
decode DPB and output coinciding in the same image, or in distinct
images.

Revision 4, 2022-03-31 (Ahmed Abdelkhalek)

* 
Remove redundant VkVideoDecodeInfoKHR.coded{Offset|Extent}

Revision 5, 2022-07-18 (Daniel Rakos)

* 
Remove `VkVideoDecodeFlagBitsKHR` as it contains no defined flags for
now

Revision 6, 2022-08-12 (Daniel Rakos)

* 
Add VkVideoDecodeUsageInfoKHR structure and related flags

Revision 7, 2022-09-29 (Daniel Rakos)

* 
Extension is no longer provisional

Revision 8, 2023-12-05 (Daniel Rakos)

* 
Require the specification of a reconstructed picture in all cases,
except when the video session was created with no DPB slots to match
shipping implementations

* 
Make DPB slot activation behavior codec-specific to continue allowing
application control over reference picture setup now that a
reconstructed picture is always mandatory

**Name String**

`VK_KHR_video_encode_av1`

**Extension Type**

Device extension

**Registered Extension Number**

514

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_video_encode_queue](#VK_KHR_video_encode_queue)

**Contact**

* 
Daniel Rakos [aqnuep](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_video_encode_av1] @aqnuep%0A*Here describe the issue or question you have about the VK_KHR_video_encode_av1 extension*)

**Extension Proposal**

[VK_KHR_video_encode_av1](../../../features/latest/features/proposals/VK_KHR_video_encode_av1.html)

**Last Modified Date**

2024-09-23

**IP Status**

No known IP claims.

**Contributors**

* 
Ahmed Abdelkhalek, AMD

* 
Benjamin Cheng, AMD

* 
Ho Hin Lau, AMD

* 
Lynne Iribarren, Independent

* 
David Airlie, Red Hat, Inc.

* 
Ping Liu, Intel

* 
Srinath Kumarapuram, NVIDIA

* 
Vassili Nikolaev, NVIDIA

* 
Tony Zlatinski, NVIDIA

* 
Konda Raju, NVIDIA

* 
Charlie Turner, Igalia

* 
Daniel Almeida, Collabora

* 
Nicolas Dufresne, Collabora

* 
Daniel Rakos, RasterGrid

This extension builds upon the `[VK_KHR_video_encode_queue](#VK_KHR_video_encode_queue)` extension
by adding support for encoding elementary video stream sequences compliant
with the AV1 video compression standard.

* 
[VkVideoEncodeAV1FrameSizeKHR](../chapters/videocoding.html#VkVideoEncodeAV1FrameSizeKHR)

* 
[VkVideoEncodeAV1QIndexKHR](../chapters/videocoding.html#VkVideoEncodeAV1QIndexKHR)

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceVideoEncodeAV1FeaturesKHR](../chapters/features.html#VkPhysicalDeviceVideoEncodeAV1FeaturesKHR)

Extending [VkVideoBeginCodingInfoKHR](../chapters/videocoding.html#VkVideoBeginCodingInfoKHR):

* 
[VkVideoEncodeAV1GopRemainingFrameInfoKHR](../chapters/videocoding.html#VkVideoEncodeAV1GopRemainingFrameInfoKHR)

Extending [VkVideoCapabilitiesKHR](../chapters/videocoding.html#VkVideoCapabilitiesKHR):

* 
[VkVideoEncodeAV1CapabilitiesKHR](../chapters/videocoding.html#VkVideoEncodeAV1CapabilitiesKHR)

Extending [VkVideoCodingControlInfoKHR](../chapters/videocoding.html#VkVideoCodingControlInfoKHR), [VkVideoBeginCodingInfoKHR](../chapters/videocoding.html#VkVideoBeginCodingInfoKHR):

* 
[VkVideoEncodeAV1RateControlInfoKHR](../chapters/videocoding.html#VkVideoEncodeAV1RateControlInfoKHR)

Extending [VkVideoEncodeInfoKHR](../chapters/videocoding.html#VkVideoEncodeInfoKHR):

* 
[VkVideoEncodeAV1PictureInfoKHR](../chapters/videocoding.html#VkVideoEncodeAV1PictureInfoKHR)

Extending [VkVideoEncodeQualityLevelPropertiesKHR](../chapters/videocoding.html#VkVideoEncodeQualityLevelPropertiesKHR):

* 
[VkVideoEncodeAV1QualityLevelPropertiesKHR](../chapters/videocoding.html#VkVideoEncodeAV1QualityLevelPropertiesKHR)

Extending [VkVideoEncodeRateControlLayerInfoKHR](../chapters/videocoding.html#VkVideoEncodeRateControlLayerInfoKHR):

* 
[VkVideoEncodeAV1RateControlLayerInfoKHR](../chapters/videocoding.html#VkVideoEncodeAV1RateControlLayerInfoKHR)

Extending [VkVideoProfileInfoKHR](../chapters/videocoding.html#VkVideoProfileInfoKHR), [VkQueryPoolCreateInfo](../chapters/queries.html#VkQueryPoolCreateInfo):

* 
[VkVideoEncodeAV1ProfileInfoKHR](../chapters/videocoding.html#VkVideoEncodeAV1ProfileInfoKHR)

Extending [VkVideoReferenceSlotInfoKHR](../chapters/videocoding.html#VkVideoReferenceSlotInfoKHR):

* 
[VkVideoEncodeAV1DpbSlotInfoKHR](../chapters/videocoding.html#VkVideoEncodeAV1DpbSlotInfoKHR)

Extending [VkVideoSessionCreateInfoKHR](../chapters/videocoding.html#VkVideoSessionCreateInfoKHR):

* 
[VkVideoEncodeAV1SessionCreateInfoKHR](../chapters/videocoding.html#VkVideoEncodeAV1SessionCreateInfoKHR)

Extending [VkVideoSessionParametersCreateInfoKHR](../chapters/videocoding.html#VkVideoSessionParametersCreateInfoKHR):

* 
[VkVideoEncodeAV1SessionParametersCreateInfoKHR](../chapters/videocoding.html#VkVideoEncodeAV1SessionParametersCreateInfoKHR)

* 
[VkVideoEncodeAV1CapabilityFlagBitsKHR](../chapters/videocoding.html#VkVideoEncodeAV1CapabilityFlagBitsKHR)

* 
[VkVideoEncodeAV1PredictionModeKHR](../chapters/videocoding.html#VkVideoEncodeAV1PredictionModeKHR)

* 
[VkVideoEncodeAV1RateControlFlagBitsKHR](../chapters/videocoding.html#VkVideoEncodeAV1RateControlFlagBitsKHR)

* 
[VkVideoEncodeAV1RateControlGroupKHR](../chapters/videocoding.html#VkVideoEncodeAV1RateControlGroupKHR)

* 
[VkVideoEncodeAV1StdFlagBitsKHR](../chapters/videocoding.html#VkVideoEncodeAV1StdFlagBitsKHR)

* 
[VkVideoEncodeAV1SuperblockSizeFlagBitsKHR](../chapters/videocoding.html#VkVideoEncodeAV1SuperblockSizeFlagBitsKHR)

* 
[VkVideoEncodeAV1CapabilityFlagsKHR](../chapters/videocoding.html#VkVideoEncodeAV1CapabilityFlagsKHR)

* 
[VkVideoEncodeAV1RateControlFlagsKHR](../chapters/videocoding.html#VkVideoEncodeAV1RateControlFlagsKHR)

* 
[VkVideoEncodeAV1StdFlagsKHR](../chapters/videocoding.html#VkVideoEncodeAV1StdFlagsKHR)

* 
[VkVideoEncodeAV1SuperblockSizeFlagsKHR](../chapters/videocoding.html#VkVideoEncodeAV1SuperblockSizeFlagsKHR)

* 
`VK_KHR_VIDEO_ENCODE_AV1_EXTENSION_NAME`

* 
`VK_KHR_VIDEO_ENCODE_AV1_SPEC_VERSION`

* 
`VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_AV1_FEATURES_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_CAPABILITIES_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_DPB_SLOT_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_GOP_REMAINING_FRAME_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PICTURE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PROFILE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUALITY_LEVEL_PROPERTIES_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_LAYER_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_CREATE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR`

Extending [VkVideoCodecOperationFlagBitsKHR](../chapters/videocoding.html#VkVideoCodecOperationFlagBitsKHR):

* 
`VK_VIDEO_CODEC_OPERATION_ENCODE_AV1_BIT_KHR`

* 
Revision 1, 2024-09-23 (Daniel Rakos)

Internal revisions

**Name String**

`VK_KHR_video_encode_h264`

**Extension Type**

Device extension

**Registered Extension Number**

39

**Revision**

14

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_video_encode_queue](#VK_KHR_video_encode_queue)

**Contact**

* 
Ahmed Abdelkhalek [aabdelkh](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_video_encode_h264] @aabdelkh%0A*Here describe the issue or question you have about the VK_KHR_video_encode_h264 extension*)

**Extension Proposal**

[VK_KHR_video_encode_h264](../../../features/latest/features/proposals/VK_KHR_video_encode_h264.html)

**Last Modified Date**

2023-12-05

**IP Status**

No known IP claims.

**Contributors**

* 
Ahmed Abdelkhalek, AMD

* 
George Hao, AMD

* 
Jake Beju, AMD

* 
Peter Fang, AMD

* 
Ping Liu, Intel

* 
Srinath Kumarapuram, NVIDIA

* 
Tony Zlatinski, NVIDIA

* 
Ravi Chaudhary, NVIDIA

* 
Yang Liu, AMD

* 
Daniel Rakos, RasterGrid

* 
Aidan Fabius, Core Avionics & Industrial Inc.

* 
Lynne Iribarren, Independent

This extension builds upon the `[VK_KHR_video_encode_queue](#VK_KHR_video_encode_queue)` extension
by adding support for encoding elementary video stream sequences compliant
with the H.264/AVC video compression standard.

|  | This extension was promoted to `KHR` from the provisional extension
| --- | --- |
`VK_EXT_video_encode_h264`. |

* 
[VkVideoEncodeH264FrameSizeKHR](../chapters/videocoding.html#VkVideoEncodeH264FrameSizeKHR)

* 
[VkVideoEncodeH264NaluSliceInfoKHR](../chapters/videocoding.html#VkVideoEncodeH264NaluSliceInfoKHR)

* 
[VkVideoEncodeH264QpKHR](../chapters/videocoding.html#VkVideoEncodeH264QpKHR)

* 
Extending [VkVideoBeginCodingInfoKHR](../chapters/videocoding.html#VkVideoBeginCodingInfoKHR):

[VkVideoEncodeH264GopRemainingFrameInfoKHR](../chapters/videocoding.html#VkVideoEncodeH264GopRemainingFrameInfoKHR)

Extending [VkVideoCapabilitiesKHR](../chapters/videocoding.html#VkVideoCapabilitiesKHR):

* 
[VkVideoEncodeH264CapabilitiesKHR](../chapters/videocoding.html#VkVideoEncodeH264CapabilitiesKHR)

Extending [VkVideoCodingControlInfoKHR](../chapters/videocoding.html#VkVideoCodingControlInfoKHR), [VkVideoBeginCodingInfoKHR](../chapters/videocoding.html#VkVideoBeginCodingInfoKHR):

* 
[VkVideoEncodeH264RateControlInfoKHR](../chapters/videocoding.html#VkVideoEncodeH264RateControlInfoKHR)

Extending [VkVideoEncodeInfoKHR](../chapters/videocoding.html#VkVideoEncodeInfoKHR):

* 
[VkVideoEncodeH264PictureInfoKHR](../chapters/videocoding.html#VkVideoEncodeH264PictureInfoKHR)

Extending [VkVideoEncodeQualityLevelPropertiesKHR](../chapters/videocoding.html#VkVideoEncodeQualityLevelPropertiesKHR):

* 
[VkVideoEncodeH264QualityLevelPropertiesKHR](../chapters/videocoding.html#VkVideoEncodeH264QualityLevelPropertiesKHR)

Extending [VkVideoEncodeRateControlLayerInfoKHR](../chapters/videocoding.html#VkVideoEncodeRateControlLayerInfoKHR):

* 
[VkVideoEncodeH264RateControlLayerInfoKHR](../chapters/videocoding.html#VkVideoEncodeH264RateControlLayerInfoKHR)

Extending [VkVideoEncodeSessionParametersFeedbackInfoKHR](../chapters/videocoding.html#VkVideoEncodeSessionParametersFeedbackInfoKHR):

* 
[VkVideoEncodeH264SessionParametersFeedbackInfoKHR](../chapters/videocoding.html#VkVideoEncodeH264SessionParametersFeedbackInfoKHR)

Extending [VkVideoEncodeSessionParametersGetInfoKHR](../chapters/videocoding.html#VkVideoEncodeSessionParametersGetInfoKHR):

* 
[VkVideoEncodeH264SessionParametersGetInfoKHR](../chapters/videocoding.html#VkVideoEncodeH264SessionParametersGetInfoKHR)

Extending [VkVideoProfileInfoKHR](../chapters/videocoding.html#VkVideoProfileInfoKHR), [VkQueryPoolCreateInfo](../chapters/queries.html#VkQueryPoolCreateInfo):

* 
[VkVideoEncodeH264ProfileInfoKHR](../chapters/videocoding.html#VkVideoEncodeH264ProfileInfoKHR)

Extending [VkVideoReferenceSlotInfoKHR](../chapters/videocoding.html#VkVideoReferenceSlotInfoKHR):

* 
[VkVideoEncodeH264DpbSlotInfoKHR](../chapters/videocoding.html#VkVideoEncodeH264DpbSlotInfoKHR)

Extending [VkVideoSessionCreateInfoKHR](../chapters/videocoding.html#VkVideoSessionCreateInfoKHR):

* 
[VkVideoEncodeH264SessionCreateInfoKHR](../chapters/videocoding.html#VkVideoEncodeH264SessionCreateInfoKHR)

Extending [VkVideoSessionParametersCreateInfoKHR](../chapters/videocoding.html#VkVideoSessionParametersCreateInfoKHR):

* 
[VkVideoEncodeH264SessionParametersCreateInfoKHR](../chapters/videocoding.html#VkVideoEncodeH264SessionParametersCreateInfoKHR)

Extending [VkVideoSessionParametersUpdateInfoKHR](../chapters/videocoding.html#VkVideoSessionParametersUpdateInfoKHR):

* 
[VkVideoEncodeH264SessionParametersAddInfoKHR](../chapters/videocoding.html#VkVideoEncodeH264SessionParametersAddInfoKHR)

* 
[VkVideoEncodeH264CapabilityFlagBitsKHR](../chapters/videocoding.html#VkVideoEncodeH264CapabilityFlagBitsKHR)

* 
[VkVideoEncodeH264RateControlFlagBitsKHR](../chapters/videocoding.html#VkVideoEncodeH264RateControlFlagBitsKHR)

* 
[VkVideoEncodeH264StdFlagBitsKHR](../chapters/videocoding.html#VkVideoEncodeH264StdFlagBitsKHR)

* 
[VkVideoEncodeH264CapabilityFlagsKHR](../chapters/videocoding.html#VkVideoEncodeH264CapabilityFlagsKHR)

* 
[VkVideoEncodeH264RateControlFlagsKHR](../chapters/videocoding.html#VkVideoEncodeH264RateControlFlagsKHR)

* 
[VkVideoEncodeH264StdFlagsKHR](../chapters/videocoding.html#VkVideoEncodeH264StdFlagsKHR)

* 
`VK_KHR_VIDEO_ENCODE_H264_EXTENSION_NAME`

* 
`VK_KHR_VIDEO_ENCODE_H264_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_GOP_REMAINING_FRAME_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_NALU_SLICE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PICTURE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUALITY_LEVEL_PROPERTIES_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_CREATE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_FEEDBACK_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_GET_INFO_KHR`

Extending [VkVideoCodecOperationFlagBitsKHR](../chapters/videocoding.html#VkVideoCodecOperationFlagBitsKHR):

* 
`VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_KHR`

* 
Revision 0, 2018-7-23 (Ahmed Abdelkhalek)

Initial draft

Revision 0.5, 2020-02-13 (Tony Zlatinski)

* 
General Spec cleanup

* 
Added DPB structures

* 
Change the VCL frame encode structure

* 
Added a common Non-VCL Picture Paramarameters structure

Revision 1, 2021-03-29 (Tony Zlatinski)

* 
Spec and API updates

Revision 2, August 1 2021 (Srinath Kumarapuram)

* 
Rename `VkVideoEncodeH264CapabilitiesFlagsEXT` to
`VkVideoEncodeH264CapabilityFlagsEXT` and
`VkVideoEncodeH264CapabilitiesFlagsEXT` to
`VkVideoEncodeH264CapabilityFlagsEXT`, following Vulkan naming
conventions.

Revision 3, 2021-12-08 (Ahmed Abdelkhalek)

* 
Rate control updates

Revision 4, 2022-02-04 (Ahmed Abdelkhalek)

* 
Align VkVideoEncodeH264VclFrameInfoEXT structure to similar one in
VK_EXT_video_encode_h265 extension

Revision 5, 2022-02-10 (Ahmed Abdelkhalek)

* 
Updates to encode capability interface

Revision 6, 2022-03-16 (Ahmed Abdelkhalek)

* 
Relocate Std header version reporting/requesting from this extension to
VK_KHR_video_queue extension.

* 
Remove redundant maxPictureSizeInMbs from
VkVideoEncodeH264SessionCreateInfoEXT.

* 
Remove the now empty VkVideoEncodeH264SessionCreateInfoEXT.

Revision 7, 2022-04-06 (Ahmed Abdelkhalek)

* 
Add capability flag to report support to use B frame in L1 reference
list.

* 
Add capability flag to report support for disabling SPS
direct_8x8_inference_flag.

Revision 8, 2022-07-18 (Daniel Rakos)

* 
Replace `VkVideoEncodeH264RateControlStructureFlagBitsEXT` bit enum
with `VkVideoEncodeH264RateControlStructureEXT` enum

* 
Rename `VkVideoEncodeH264ProfileEXT` to
`VkVideoEncodeH264ProfileInfoEXT`

* 
Rename `VkVideoEncodeH264ReferenceListsEXT` to
`VkVideoEncodeH264ReferenceListsInfoEXT`

* 
Rename `VkVideoEncodeH264EmitPictureParametersEXT` to
`VkVideoEncodeH264EmitPictureParametersInfoEXT`

* 
Rename `VkVideoEncodeH264NaluSliceEXT` to
`VkVideoEncodeH264NaluSliceInfoEXT`

Revision 9, 2022-09-18 (Daniel Rakos)

* 
Rename `spsStdCount`, `pSpsStd`, `ppsStdCount`, and `pPpsStd` to
`stdSPSCount`, `pStdSPSs`, `stdPPSCount`, and `pStdPPSs`, respectively,
in `VkVideoEncodeH264SessionParametersAddInfoEXT`

* 
Rename `maxSpsStdCount` and `maxPpsStdCount` to `maxStdSPSCount` and
`maxStdPPSCount`, respectively, in
`VkVideoEncodeH264SessionParametersCreateInfoEXT`

Revision 10, 2023-03-06 (Daniel Rakos)

* 
Removed `VkVideoEncodeH264EmitPictureParametersInfoEXT`

* 
Changed member types in `VkVideoEncodeH264CapabilitiesEXT` and
`VkVideoEncodeH264ReferenceListsInfoEXT` from `uint8_t` to `uint32_t`

* 
Changed the type of
`VkVideoEncodeH264RateControlInfoEXT::temporalLayerCount` and
`VkVideoEncodeH264RateControlLayerInfoEXT::temporalLayerId` from
`uint8_t` to `uint32_t`

* 
Removed `VkVideoEncodeH264InputModeFlagsEXT` and
`VkVideoEncodeH264OutputModeFlagsEXT` as we only support
frame-in-frame-out mode for now

* 
Rename `pCurrentPictureInfo` in `VkVideoEncodeH264VclFrameInfoEXT` to
`pStdPictureInfo`

* 
Rename `pSliceHeaderStd` in `VkVideoEncodeH264NaluSliceInfoEXT` to
`pStdSliceHeader`

* 
Rename `pReferenceFinalLists` in `VkVideoEncodeH264VclFrameInfoEXT` and
`VkVideoEncodeH264NaluSliceInfoEXT` to `pStdReferenceFinalLists`

* 
Removed the `slotIndex` member of `VkVideoEncodeH264DpbSlotInfoEXT` and
changed it to be chained to `VkVideoReferenceSlotInfoKHR`

* 
Replaced `VkVideoEncodeH264ReferenceListsInfoEXT` with the new Video
Std header structure `StdVideoEncodeH264ReferenceLists` that also
includes data previously part of the now removed
`StdVideoEncodeH264RefMemMgmtCtrlOperations` structure

* 
Added new capability flag
`VK_VIDEO_ENCODE_H264_CAPABILITY_DIFFERENT_REFERENCE_FINAL_LISTS_BIT_EXT`

Revision 11, 2023-05-22 (Daniel Rakos)

* 
Renamed `VkVideoEncodeH264VclFrameInfoEXT` to
`VkVideoEncodeH264PictureInfoEXT`

* 
Added `VkVideoEncodeH264PictureInfoEXT::generatePrefixNalu` and
`VK_VIDEO_ENCODE_H264_CAPABILITY_GENERATE_PREFIX_NALU_BIT_EXT` to
enable the generation of H.264 prefix NALUs when supported by the
implementation

* 
Removed `VkVideoEncodeH264RateControlLayerInfoEXT::temporalLayerId`

* 
Added `expectDyadicTemporalLayerPattern` capability

* 
Added the `VkVideoEncodeH264SessionParametersGetInfoEXT` structure to
identify the H.264 parameter sets to retrieve encoded parameter data
for, and the `VkVideoEncodeH264SessionParametersFeedbackInfoEXT`
structure to retrieve H.264 parameter set override information when
using the new `vkGetEncodedVideoSessionParametersKHR` command

* 
Added `VkVideoEncodeH264NaluSliceInfoEXT::constantQp` to specify
per-slice constant QP when rate control mode is
`VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DISABLED_BIT_KHR`

* 
Added `VkVideoEncodeH264QualityLevelPropertiesEXT` for retrieving H.264
specific quality level recommendations

* 
Replaced `VkVideoEncodeH264RateControlStructureEXT` enum with the flags
type `VkVideoEncodeH264RateControlFlagsEXT` and bits defined in
`VkVideoEncodeH264RateControlFlagBitsEXT` and added HRD compliance flag

* 
Removed `useInitialRcQp` and `initialRcQp` members of
`VkVideoEncodeH264RateControlLayerInfoEXT`

* 
Added `prefersGopRemainingFrames` and `requiresGopRemainingFrames`, and
the new `VkVideoEncodeH264GopRemainingFrameInfoEXT` structure to allow
specifying remaining frames of each type in the rate control GOP

* 
Added `maxTemporalLayers`, `maxQp`, and `minQp` capabilities

* 
Added `maxLevelIdc` capability and new
`VkVideoEncodeH264SessionCreateInfoEXT` structure to specify upper
bounds on the H.264 level of the produced video bitstream

* 
Moved capability flags specific to codec syntax restrictions from
`VkVideoEncodeH264CapabilityFlagsEXT` to the new
`VkVideoEncodeH264StdFlagsEXT` which is now included as a separate
`stdSyntaxFlags` member in `VkVideoEncodeH264CapabilitiesEXT`

* 
Removed codec syntax override values from
`VkVideoEncodeH264CapabilitiesEXT`

* 
Removed `VkVideoEncodeH264NaluSliceInfoEXT::mbCount` and
`VK_VIDEO_ENCODE_H264_CAPABILITY_SLICE_MB_COUNT_BIT_EXT`

* 
Replaced
`VK_VIDEO_ENCODE_H264_CAPABILITY_MULTIPLE_SLICES_PER_FRAME_BIT_EXT`
with the new `maxSliceCount` capability

* 
Removed capability flag
`VK_VIDEO_ENCODE_H264_CAPABILITY_DIFFERENT_REFERENCE_FINAL_LISTS_BIT_EXT`
and removed `pStdReferenceFinalLists` members from the
`VkVideoEncodeH264PictureInfoEXT` and
`VkVideoEncodeH264NaluSliceInfoEXT` structures as reference lists info
is now included in `pStdPictureInfo`

* 
Added capability flag
`VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L0_LIST_BIT_EXT`

Revision 12, 2023-07-19 (Daniel Rakos)

* 
Added video std capability flags
`VK_VIDEO_ENCODE_H264_STD_SLICE_QP_DELTA_BIT_EXT` and
`VK_VIDEO_ENCODE_H264_STD_DIFFERENT_SLICE_QP_DELTA_BIT_EXT`

* 
Fixed optionality of the array members of
`VkVideoEncodeH264SessionParametersAddInfoEXT`

* 
Fixed optionality of `VkVideoEncodeH264RateControlInfoEXT::flags`

Revision 13, 2023-09-04 (Daniel Rakos)

* 
Change extension from `EXT` to `KHR`

* 
Extension is no longer provisional

Revision 14, 2023-12-05 (Daniel Rakos)

* 
Condition reference picture setup based on the value of
`StdVideoEncodeH264PictureInfo::flags.is_reference`

**Name String**

`VK_KHR_video_encode_h265`

**Extension Type**

Device extension

**Registered Extension Number**

40

**Revision**

14

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_video_encode_queue](#VK_KHR_video_encode_queue)

**Contact**

* 
Ahmed Abdelkhalek [aabdelkh](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_video_encode_h265] @aabdelkh%0A*Here describe the issue or question you have about the VK_KHR_video_encode_h265 extension*)

**Extension Proposal**

[VK_KHR_video_encode_h265](../../../features/latest/features/proposals/VK_KHR_video_encode_h265.html)

**Last Modified Date**

2023-12-05

**IP Status**

No known IP claims.

**Contributors**

* 
Ahmed Abdelkhalek, AMD

* 
George Hao, AMD

* 
Jake Beju, AMD

* 
Chunbo Chen, Intel

* 
Ping Liu, Intel

* 
Srinath Kumarapuram, NVIDIA

* 
Tony Zlatinski, NVIDIA

* 
Ravi Chaudhary, NVIDIA

* 
Daniel Rakos, RasterGrid

* 
Aidan Fabius, Core Avionics & Industrial Inc.

* 
Lynne Iribarren, Independent

This extension builds upon the `[VK_KHR_video_encode_queue](#VK_KHR_video_encode_queue)` extension
by adding support for encoding elementary video stream sequences compliant
with the H.265/HEVC video compression standard.

|  | This extension was promoted to `KHR` from the provisional extension
| --- | --- |
`VK_EXT_video_encode_h265`. |

* 
[VkVideoEncodeH265FrameSizeKHR](../chapters/videocoding.html#VkVideoEncodeH265FrameSizeKHR)

* 
[VkVideoEncodeH265NaluSliceSegmentInfoKHR](../chapters/videocoding.html#VkVideoEncodeH265NaluSliceSegmentInfoKHR)

* 
[VkVideoEncodeH265QpKHR](../chapters/videocoding.html#VkVideoEncodeH265QpKHR)

* 
Extending [VkVideoBeginCodingInfoKHR](../chapters/videocoding.html#VkVideoBeginCodingInfoKHR):

[VkVideoEncodeH265GopRemainingFrameInfoKHR](../chapters/videocoding.html#VkVideoEncodeH265GopRemainingFrameInfoKHR)

Extending [VkVideoCapabilitiesKHR](../chapters/videocoding.html#VkVideoCapabilitiesKHR):

* 
[VkVideoEncodeH265CapabilitiesKHR](../chapters/videocoding.html#VkVideoEncodeH265CapabilitiesKHR)

Extending [VkVideoCodingControlInfoKHR](../chapters/videocoding.html#VkVideoCodingControlInfoKHR), [VkVideoBeginCodingInfoKHR](../chapters/videocoding.html#VkVideoBeginCodingInfoKHR):

* 
[VkVideoEncodeH265RateControlInfoKHR](../chapters/videocoding.html#VkVideoEncodeH265RateControlInfoKHR)

Extending [VkVideoEncodeInfoKHR](../chapters/videocoding.html#VkVideoEncodeInfoKHR):

* 
[VkVideoEncodeH265PictureInfoKHR](../chapters/videocoding.html#VkVideoEncodeH265PictureInfoKHR)

Extending [VkVideoEncodeQualityLevelPropertiesKHR](../chapters/videocoding.html#VkVideoEncodeQualityLevelPropertiesKHR):

* 
[VkVideoEncodeH265QualityLevelPropertiesKHR](../chapters/videocoding.html#VkVideoEncodeH265QualityLevelPropertiesKHR)

Extending [VkVideoEncodeRateControlLayerInfoKHR](../chapters/videocoding.html#VkVideoEncodeRateControlLayerInfoKHR):

* 
[VkVideoEncodeH265RateControlLayerInfoKHR](../chapters/videocoding.html#VkVideoEncodeH265RateControlLayerInfoKHR)

Extending [VkVideoEncodeSessionParametersFeedbackInfoKHR](../chapters/videocoding.html#VkVideoEncodeSessionParametersFeedbackInfoKHR):

* 
[VkVideoEncodeH265SessionParametersFeedbackInfoKHR](../chapters/videocoding.html#VkVideoEncodeH265SessionParametersFeedbackInfoKHR)

Extending [VkVideoEncodeSessionParametersGetInfoKHR](../chapters/videocoding.html#VkVideoEncodeSessionParametersGetInfoKHR):

* 
[VkVideoEncodeH265SessionParametersGetInfoKHR](../chapters/videocoding.html#VkVideoEncodeH265SessionParametersGetInfoKHR)

Extending [VkVideoProfileInfoKHR](../chapters/videocoding.html#VkVideoProfileInfoKHR), [VkQueryPoolCreateInfo](../chapters/queries.html#VkQueryPoolCreateInfo):

* 
[VkVideoEncodeH265ProfileInfoKHR](../chapters/videocoding.html#VkVideoEncodeH265ProfileInfoKHR)

Extending [VkVideoReferenceSlotInfoKHR](../chapters/videocoding.html#VkVideoReferenceSlotInfoKHR):

* 
[VkVideoEncodeH265DpbSlotInfoKHR](../chapters/videocoding.html#VkVideoEncodeH265DpbSlotInfoKHR)

Extending [VkVideoSessionCreateInfoKHR](../chapters/videocoding.html#VkVideoSessionCreateInfoKHR):

* 
[VkVideoEncodeH265SessionCreateInfoKHR](../chapters/videocoding.html#VkVideoEncodeH265SessionCreateInfoKHR)

Extending [VkVideoSessionParametersCreateInfoKHR](../chapters/videocoding.html#VkVideoSessionParametersCreateInfoKHR):

* 
[VkVideoEncodeH265SessionParametersCreateInfoKHR](../chapters/videocoding.html#VkVideoEncodeH265SessionParametersCreateInfoKHR)

Extending [VkVideoSessionParametersUpdateInfoKHR](../chapters/videocoding.html#VkVideoSessionParametersUpdateInfoKHR):

* 
[VkVideoEncodeH265SessionParametersAddInfoKHR](../chapters/videocoding.html#VkVideoEncodeH265SessionParametersAddInfoKHR)

* 
[VkVideoEncodeH265CapabilityFlagBitsKHR](../chapters/videocoding.html#VkVideoEncodeH265CapabilityFlagBitsKHR)

* 
[VkVideoEncodeH265CtbSizeFlagBitsKHR](../chapters/videocoding.html#VkVideoEncodeH265CtbSizeFlagBitsKHR)

* 
[VkVideoEncodeH265RateControlFlagBitsKHR](../chapters/videocoding.html#VkVideoEncodeH265RateControlFlagBitsKHR)

* 
[VkVideoEncodeH265StdFlagBitsKHR](../chapters/videocoding.html#VkVideoEncodeH265StdFlagBitsKHR)

* 
[VkVideoEncodeH265TransformBlockSizeFlagBitsKHR](../chapters/videocoding.html#VkVideoEncodeH265TransformBlockSizeFlagBitsKHR)

* 
[VkVideoEncodeH265CapabilityFlagsKHR](../chapters/videocoding.html#VkVideoEncodeH265CapabilityFlagsKHR)

* 
[VkVideoEncodeH265CtbSizeFlagsKHR](../chapters/videocoding.html#VkVideoEncodeH265CtbSizeFlagsKHR)

* 
[VkVideoEncodeH265RateControlFlagsKHR](../chapters/videocoding.html#VkVideoEncodeH265RateControlFlagsKHR)

* 
[VkVideoEncodeH265StdFlagsKHR](../chapters/videocoding.html#VkVideoEncodeH265StdFlagsKHR)

* 
[VkVideoEncodeH265TransformBlockSizeFlagsKHR](../chapters/videocoding.html#VkVideoEncodeH265TransformBlockSizeFlagsKHR)

* 
`VK_KHR_VIDEO_ENCODE_H265_EXTENSION_NAME`

* 
`VK_KHR_VIDEO_ENCODE_H265_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_CAPABILITIES_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_GOP_REMAINING_FRAME_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_NALU_SLICE_SEGMENT_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PICTURE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUALITY_LEVEL_PROPERTIES_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_LAYER_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_CREATE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_FEEDBACK_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_GET_INFO_KHR`

Extending [VkVideoCodecOperationFlagBitsKHR](../chapters/videocoding.html#VkVideoCodecOperationFlagBitsKHR):

* 
`VK_VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_KHR`

* 
Revision 0, 2019-11-14 (Ahmed Abdelkhalek)

Initial draft

Revision 0.5, 2020-02-13 (Tony Zlatinski)

* 
General Spec cleanup

* 
Added DPB structures

* 
Change the VCL frame encode structure

* 
Added a common Non-VCL Picture Paramarameters structure

Revision 2, Oct 10 2021 (Srinath Kumarapuram)

* 
Vulkan Video Encode h.265 update and spec edits

Revision 3, 2021-12-08 (Ahmed Abdelkhalek)

* 
Rate control updates

Revision 4, 2022-01-11 (Ahmed Abdelkhalek)

* 
Replace occurrences of slice by slice segment and rename
structures/enums to reflect this.

Revision 5, 2022-02-10 (Ahmed Abdelkhalek)

* 
Updates to encode capability interface

Revision 6, 2022-03-16 (Ahmed Abdelkhalek)

* 
Relocate Std header version reporting/requesting from this extension to
VK_KHR_video_queue extension.

* 
Remove the now empty VkVideoEncodeH265SessionCreateInfoEXT.

Revision 7, 2022-03-24 (Ahmed Abdelkhalek)

* 
Add capability flags to report support to disable transform skip and
support to use B frame in L1 reference list.

Revision 8, 2022-07-18 (Daniel Rakos)

* 
Replace `VkVideoEncodeH265RateControlStructureFlagBitsEXT` bit enum
with `VkVideoEncodeH265RateControlStructureEXT` enum

* 
Rename `VkVideoEncodeH265ProfileEXT` to
`VkVideoEncodeH265ProfileInfoEXT`

* 
Rename `VkVideoEncodeH265ReferenceListsEXT` to
`VkVideoEncodeH265ReferenceListsInfoEXT`

* 
Rename `VkVideoEncodeH265EmitPictureParametersEXT` to
`VkVideoEncodeH265EmitPictureParametersInfoEXT`

* 
Rename `VkVideoEncodeH265NaluSliceSegmentEXT` to
`VkVideoEncodeH265NaluSliceSegmentInfoEXT`

Revision 9, 2022-09-18 (Daniel Rakos)

* 
Rename `vpsStdCount`, `pVpsStd`, `spsStdCount`, `pSpsStd`,
`ppsStdCount`, and `pPpsStd` to `stdVPSCount`, `pStdVPSs`,
`stdSPSCount`, `pStdSPSs`, `stdPPSCount`, and `pStdPPSs`, respectively,
in `VkVideoEncodeH265SessionParametersAddInfoEXT`

* 
Rename `maxVpsStdCount`, `maxSpsStdCount`, and `maxPpsStdCount` to
`maxStdVPSCount`, `maxStdSPSCount` and `maxStdPPSCount`, respectively,
in `VkVideoEncodeH265SessionParametersCreateInfoEXT`

Revision 10, 2023-03-06 (Daniel Rakos)

* 
Removed `VkVideoEncodeH265EmitPictureParametersInfoEXT`

* 
Changed member types in `VkVideoEncodeH265CapabilitiesEXT` and
`VkVideoEncodeH265ReferenceListsInfoEXT` from `uint8_t` to `uint32_t`

* 
Changed the type of
`VkVideoEncodeH265RateControlInfoEXT::subLayerCount` and
`VkVideoEncodeH265RateControlLayerInfoEXT::temporalId` from `uint8_t`
to `uint32_t`

* 
Removed `VkVideoEncodeH265InputModeFlagsEXT` and
`VkVideoEncodeH265OutputModeFlagsEXT` as we only support
frame-in-frame-out mode for now

* 
Rename `pCurrentPictureInfo` in `VkVideoEncodeH265VclFrameInfoEXT` to
`pStdPictureInfo`

* 
Rename `pSliceSegmentHeaderStd` in
`VkVideoEncodeH265NaluSliceSegmentInfoEXT` to `pStdSliceSegmentHeader`

* 
Rename `pReferenceFinalLists` in `VkVideoEncodeH265VclFrameInfoEXT` and
`VkVideoEncodeH265NaluSliceSegmentInfoEXT` to `pStdReferenceFinalLists`

* 
Removed the `slotIndex` member of `VkVideoEncodeH265DpbSlotInfoEXT` and
changed it to be chained to `VkVideoReferenceSlotInfoKHR`

* 
Replaced `VkVideoEncodeH265ReferenceListsInfoEXT` with the new Video
Std header structure `StdVideoEncodeH265ReferenceLists`

* 
Added new capability flag
`VK_VIDEO_ENCODE_H265_CAPABILITY_DIFFERENT_REFERENCE_FINAL_LISTS_BIT_EXT`

Revision 11, 2023-05-26 (Daniel Rakos)

* 
Renamed `VkVideoEncodeH265VclFrameInfoEXT` to
`VkVideoEncodeH265PictureInfoEXT`

* 
Removed `VkVideoEncodeH265RateControlLayerInfoEXT::temporalId`

* 
Added `expectDyadicTemporalSubLayerPattern` capability

* 
Added the `VkVideoEncodeH265SessionParametersGetInfoEXT` structure to
identify the H.265 parameter sets to retrieve encoded parameter data
for, and the `VkVideoEncodeH265SessionParametersFeedbackInfoEXT`
structure to retrieve H.265 parameter set override information when
using the new `vkGetEncodedVideoSessionParametersKHR` command

* 
Added `VkVideoEncodeH265NaluSliceSegmentInfoEXT::constantQp` to specify
per-slice segment constant QP when rate control mode is
`VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DISABLED_BIT_KHR`

* 
Added `VkVideoEncodeH265QualityLevelPropertiesEXT` for retrieving H.265
specific quality level recommendations

* 
Replaced `VkVideoEncodeH265RateControlStructureEXT` enum with the flags
type `VkVideoEncodeH265RateControlFlagsEXT` and bits defined in
`VkVideoEncodeH265RateControlFlagBitsEXT` and added HRD compliance flag

* 
Removed `useInitialRcQp` and `initialRcQp` members of
`VkVideoEncodeH265RateControlLayerInfoEXT`

* 
Added `prefersGopRemainingFrames` and `requiresGopRemainingFrames`, and
the new `VkVideoEncodeH265GopRemainingFrameInfoEXT` structure to allow
specifying remaining frames of each type in the rate control GOP

* 
Renamed `maxSubLayersCount` capability to `maxSubLayerCount`

* 
Added `maxQp`, and `minQp` capabilities

* 
Added `maxLevelIdc` capability and new
`VkVideoEncodeH265SessionCreateInfoEXT` structure to specify upper
bounds on the H.265 level of the produced video bitstream

* 
Moved capability flags specific to codec syntax restrictions from
`VkVideoEncodeH265CapabilityFlagsEXT` to the new
`VkVideoEncodeH265StdFlagsEXT` which is now included as a separate
`stdSyntaxFlags` member in `VkVideoEncodeH265CapabilitiesEXT`

* 
Added `std` prefix to codec syntax capabilities in
`VkVideoEncodeH265CapabilitiesEXT`

* 
Removed `VkVideoEncodeH265NaluSliceSegmentInfoEXT::ctbCount` and
`VK_VIDEO_ENCODE_H265_CAPABILITY_SLICE_SEGMENT_CTB_COUNT_BIT_EXT`

* 
Replaced
`VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_SLICE_SEGMENTS_PER_FRAME_BIT_EXT`
with the new `maxSliceSegmentCount` capability

* 
Added `maxTiles` capability

* 
Removed codec syntax min/max capabilities from
`VkVideoEncodeH265CapabilitiesEXT`

* 
Removed capability flag
`VK_VIDEO_ENCODE_H265_CAPABILITY_DIFFERENT_REFERENCE_FINAL_LISTS_BIT_EXT`
and removed `pStdReferenceFinalLists` members from the
`VkVideoEncodeH265PictureInfoEXT` and
`VkVideoEncodeH265NaluSliceSegmentInfoEXT` structures as reference
lists info is now included in `pStdPictureInfo`

* 
Added capability flag
`VK_VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L0_LIST_BIT_EXT`

Revision 12, 2023-07-19 (Daniel Rakos)

* 
Added video std capability flags
`VK_VIDEO_ENCODE_H265_STD_SLICE_QP_DELTA_BIT_EXT` and
`VK_VIDEO_ENCODE_H265_STD_DIFFERENT_SLICE_QP_DELTA_BIT_EXT`

* 
Fixed optionality of the array members of
`VkVideoEncodeH265SessionParametersAddInfoEXT`

* 
Fixed optionality of `VkVideoEncodeH265RateControlInfoEXT::flags`

Revision 13, 2023-09-04 (Daniel Rakos)

* 
Change extension from `EXT` to `KHR`

* 
Extension is no longer provisional

Revision 14, 2023-12-05 (Daniel Rakos)

* 
Condition reference picture setup based on the value of
`StdVideoEncodeH265PictureInfo::flags.is_reference`

**Name String**

`VK_KHR_video_encode_quantization_map`

**Extension Type**

Device extension

**Registered Extension Number**

554

**Revision**

2

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_video_encode_queue](#VK_KHR_video_encode_queue)

and

 [VK_KHR_format_feature_flags2](#VK_KHR_format_feature_flags2)

 or

 [Vulkan Version 1.3](versions.html#versions-1.3)

**API Interactions**

* 
Interacts with VK_KHR_video_encode_av1

* 
Interacts with VK_KHR_video_encode_h264

* 
Interacts with VK_KHR_video_encode_h265

**Contact**

* 
Ahmed Abdelkhalek [aabdelkh](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_video_encode_quantization_map] @aabdelkh%0A*Here describe the issue or question you have about the VK_KHR_video_encode_quantization_map extension*)

**Extension Proposal**

[VK_KHR_video_encode_quantization_map](../../../features/latest/features/proposals/VK_KHR_video_encode_quantization_map.html)

**Last Modified Date**

2024-09-23

**IP Status**

No known IP claims.

**Contributors**

* 
Ahmed Abdelkhalek, AMD

* 
Benjamin Cheng, AMD

* 
Srinath Kumarapuram, NVIDIA

* 
Tony Zlatinski, NVIDIA

* 
Ping Liu, Intel

* 
Daniel Rakos, RasterGrid

* 
Lynne Iribarren, Independent

This extension builds upon the `[VK_KHR_video_encode_queue](#VK_KHR_video_encode_queue)` extension
by enabling fine grained control of codec-specific quantization parameters
in video encode operations.

More specifically, it adds support for quantization maps:

* 
Quantization delta maps to directly control the relative value of
quantization parameter values on a per-block basis for all rate control
modes (including when rate control is disabled).

* 
Emphasis maps to indirectly control the relative quantization parameter
values on a per-block basis when rate control is not disabled and the
rate control mode is not configured to the implementation-defined
default mode.

This extension is to be used in conjunction with other codec specific video
encode extensions that specify the codec specific quantization parameters
these maps control.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR](../chapters/features.html#VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR)

Extending [VkVideoCapabilitiesKHR](../chapters/videocoding.html#VkVideoCapabilitiesKHR):

* 
[VkVideoEncodeQuantizationMapCapabilitiesKHR](../chapters/videocoding.html#VkVideoEncodeQuantizationMapCapabilitiesKHR)

Extending [VkVideoEncodeInfoKHR](../chapters/videocoding.html#VkVideoEncodeInfoKHR):

* 
[VkVideoEncodeQuantizationMapInfoKHR](../chapters/videocoding.html#VkVideoEncodeQuantizationMapInfoKHR)

Extending [VkVideoFormatPropertiesKHR](../chapters/videocoding.html#VkVideoFormatPropertiesKHR):

* 
[VkVideoFormatQuantizationMapPropertiesKHR](../chapters/videocoding.html#VkVideoFormatQuantizationMapPropertiesKHR)

Extending [VkVideoSessionParametersCreateInfoKHR](../chapters/videocoding.html#VkVideoSessionParametersCreateInfoKHR):

* 
[VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR](../chapters/videocoding.html#VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR)

If [VK_KHR_video_encode_av1](#VK_KHR_video_encode_av1) is supported:

* 
Extending [VkVideoCapabilitiesKHR](../chapters/videocoding.html#VkVideoCapabilitiesKHR):

[VkVideoEncodeAV1QuantizationMapCapabilitiesKHR](../chapters/videocoding.html#VkVideoEncodeAV1QuantizationMapCapabilitiesKHR)

Extending [VkVideoFormatPropertiesKHR](../chapters/videocoding.html#VkVideoFormatPropertiesKHR):

* 
[VkVideoFormatAV1QuantizationMapPropertiesKHR](../chapters/videocoding.html#VkVideoFormatAV1QuantizationMapPropertiesKHR)

If [VK_KHR_video_encode_h264](#VK_KHR_video_encode_h264) is supported:

* 
Extending [VkVideoCapabilitiesKHR](../chapters/videocoding.html#VkVideoCapabilitiesKHR):

[VkVideoEncodeH264QuantizationMapCapabilitiesKHR](../chapters/videocoding.html#VkVideoEncodeH264QuantizationMapCapabilitiesKHR)

If [VK_KHR_video_encode_h265](#VK_KHR_video_encode_h265) is supported:

* 
Extending [VkVideoCapabilitiesKHR](../chapters/videocoding.html#VkVideoCapabilitiesKHR):

[VkVideoEncodeH265QuantizationMapCapabilitiesKHR](../chapters/videocoding.html#VkVideoEncodeH265QuantizationMapCapabilitiesKHR)

Extending [VkVideoFormatPropertiesKHR](../chapters/videocoding.html#VkVideoFormatPropertiesKHR):

* 
[VkVideoFormatH265QuantizationMapPropertiesKHR](../chapters/videocoding.html#VkVideoFormatH265QuantizationMapPropertiesKHR)

* 
[VkVideoEncodeFlagBitsKHR](../chapters/videocoding.html#VkVideoEncodeFlagBitsKHR)

* 
[VkVideoSessionParametersCreateFlagBitsKHR](../chapters/videocoding.html#VkVideoSessionParametersCreateFlagBitsKHR)

* 
`VK_KHR_VIDEO_ENCODE_QUANTIZATION_MAP_EXTENSION_NAME`

* 
`VK_KHR_VIDEO_ENCODE_QUANTIZATION_MAP_SPEC_VERSION`

* 
Extending [VkFormatFeatureFlagBits2](../chapters/formats.html#VkFormatFeatureFlagBits2):

`VK_FORMAT_FEATURE_2_VIDEO_ENCODE_EMPHASIS_MAP_BIT_KHR`

* 
`VK_FORMAT_FEATURE_2_VIDEO_ENCODE_QUANTIZATION_DELTA_MAP_BIT_KHR`

Extending [VkImageLayout](../chapters/resources.html#VkImageLayout):

* 
`VK_IMAGE_LAYOUT_VIDEO_ENCODE_QUANTIZATION_MAP_KHR`

Extending [VkImageUsageFlagBits](../chapters/resources.html#VkImageUsageFlagBits):

* 
`VK_IMAGE_USAGE_VIDEO_ENCODE_EMPHASIS_MAP_BIT_KHR`

* 
`VK_IMAGE_USAGE_VIDEO_ENCODE_QUANTIZATION_DELTA_MAP_BIT_KHR`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUANTIZATION_MAP_FEATURES_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_CAPABILITIES_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_SESSION_PARAMETERS_CREATE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_FORMAT_QUANTIZATION_MAP_PROPERTIES_KHR`

Extending [VkVideoEncodeCapabilityFlagBitsKHR](../chapters/videocoding.html#VkVideoEncodeCapabilityFlagBitsKHR):

* 
`VK_VIDEO_ENCODE_CAPABILITY_EMPHASIS_MAP_BIT_KHR`

* 
`VK_VIDEO_ENCODE_CAPABILITY_QUANTIZATION_DELTA_MAP_BIT_KHR`

Extending [VkVideoEncodeFlagBitsKHR](../chapters/videocoding.html#VkVideoEncodeFlagBitsKHR):

* 
`VK_VIDEO_ENCODE_WITH_EMPHASIS_MAP_BIT_KHR`

* 
`VK_VIDEO_ENCODE_WITH_QUANTIZATION_DELTA_MAP_BIT_KHR`

Extending [VkVideoSessionCreateFlagBitsKHR](../chapters/videocoding.html#VkVideoSessionCreateFlagBitsKHR):

* 
`VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_EMPHASIS_MAP_BIT_KHR`

* 
`VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_QUANTIZATION_DELTA_MAP_BIT_KHR`

Extending [VkVideoSessionParametersCreateFlagBitsKHR](../chapters/videocoding.html#VkVideoSessionParametersCreateFlagBitsKHR):

* 
`VK_VIDEO_SESSION_PARAMETERS_CREATE_QUANTIZATION_MAP_COMPATIBLE_BIT_KHR`

If [VK_KHR_video_encode_av1](#VK_KHR_video_encode_av1) is supported:

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUANTIZATION_MAP_CAPABILITIES_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_FORMAT_AV1_QUANTIZATION_MAP_PROPERTIES_KHR`

If [VK_KHR_video_encode_h264](#VK_KHR_video_encode_h264) is supported:

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUANTIZATION_MAP_CAPABILITIES_KHR`

Extending [VkVideoEncodeH264CapabilityFlagBitsKHR](../chapters/videocoding.html#VkVideoEncodeH264CapabilityFlagBitsKHR):

* 
`VK_VIDEO_ENCODE_H264_CAPABILITY_MB_QP_DIFF_WRAPAROUND_BIT_KHR`

If [VK_KHR_video_encode_h265](#VK_KHR_video_encode_h265) is supported:

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUANTIZATION_MAP_CAPABILITIES_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_FORMAT_H265_QUANTIZATION_MAP_PROPERTIES_KHR`

Extending [VkVideoEncodeH265CapabilityFlagBitsKHR](../chapters/videocoding.html#VkVideoEncodeH265CapabilityFlagBitsKHR):

* 
`VK_VIDEO_ENCODE_H265_CAPABILITY_CU_QP_DIFF_WRAPAROUND_BIT_KHR`

* 
Revision 1, 2024-08-21 (Daniel Rakos)

Internal revisions

Revision 2, 2024-09-23 (Daniel Rakos)

* 
Added interactions with VK_KHR_video_encode_av1

**Name String**

`VK_KHR_video_encode_queue`

**Extension Type**

Device extension

**Registered Extension Number**

300

**Revision**

12

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_video_queue](#VK_KHR_video_queue)

and

 [VK_KHR_synchronization2](#VK_KHR_synchronization2)

 or

 [Vulkan Version 1.3](versions.html#versions-1.3)

**API Interactions**

* 
Interacts with VK_VERSION_1_3

* 
Interacts with VK_KHR_format_feature_flags2

**Contact**

* 
Ahmed Abdelkhalek [aabdelkh](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_video_encode_queue] @aabdelkh%0A*Here describe the issue or question you have about the VK_KHR_video_encode_queue extension*)

**Extension Proposal**

[VK_KHR_video_encode_queue](../../../features/latest/features/proposals/VK_KHR_video_encode_queue.html)

**Last Modified Date**

2023-12-05

**IP Status**

No known IP claims.

**Contributors**

* 
Ahmed Abdelkhalek, AMD

* 
Damien Kessler, NVIDIA

* 
George Hao, AMD

* 
Jake Beju, AMD

* 
Peter Fang, AMD

* 
Piers Daniell, NVIDIA

* 
Srinath Kumarapuram, NVIDIA

* 
Thomas J. Meier, NVIDIA

* 
Tony Zlatinski, NVIDIA

* 
Ravi Chaudhary, NVIDIA

* 
Yang Liu, AMD

* 
Daniel Rakos, RasterGrid

* 
Ping Liu, Intel

* 
Aidan Fabius, Core Avionics & Industrial Inc.

* 
Lynne Iribarren, Independent

This extension builds upon the `[VK_KHR_video_queue](#VK_KHR_video_queue)` extension by
adding common APIs specific to video encoding and thus enabling
implementations to expose queue families supporting video encode operations.

More specifically, it adds video encode specific capabilities and a new
command buffer command that allows recording video encode operations against
a video session.

This extension is to be used in conjunction with other codec specific video
encode extensions that enable encoding video sequences of specific video
compression standards.

* 
[vkCmdEncodeVideoKHR](../chapters/videocoding.html#vkCmdEncodeVideoKHR)

* 
[vkGetEncodedVideoSessionParametersKHR](../chapters/videocoding.html#vkGetEncodedVideoSessionParametersKHR)

* 
[vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR](../chapters/videocoding.html#vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR)

* 
[VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR](../chapters/videocoding.html#VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR)

* 
[VkVideoEncodeInfoKHR](../chapters/videocoding.html#VkVideoEncodeInfoKHR)

* 
[VkVideoEncodeQualityLevelPropertiesKHR](../chapters/videocoding.html#VkVideoEncodeQualityLevelPropertiesKHR)

* 
[VkVideoEncodeRateControlLayerInfoKHR](../chapters/videocoding.html#VkVideoEncodeRateControlLayerInfoKHR)

* 
[VkVideoEncodeSessionParametersFeedbackInfoKHR](../chapters/videocoding.html#VkVideoEncodeSessionParametersFeedbackInfoKHR)

* 
[VkVideoEncodeSessionParametersGetInfoKHR](../chapters/videocoding.html#VkVideoEncodeSessionParametersGetInfoKHR)

* 
Extending [VkQueryPoolCreateInfo](../chapters/queries.html#VkQueryPoolCreateInfo):

[VkQueryPoolVideoEncodeFeedbackCreateInfoKHR](../chapters/queries.html#VkQueryPoolVideoEncodeFeedbackCreateInfoKHR)

Extending [VkVideoCapabilitiesKHR](../chapters/videocoding.html#VkVideoCapabilitiesKHR):

* 
[VkVideoEncodeCapabilitiesKHR](../chapters/videocoding.html#VkVideoEncodeCapabilitiesKHR)

Extending [VkVideoCodingControlInfoKHR](../chapters/videocoding.html#VkVideoCodingControlInfoKHR), [VkVideoBeginCodingInfoKHR](../chapters/videocoding.html#VkVideoBeginCodingInfoKHR):

* 
[VkVideoEncodeRateControlInfoKHR](../chapters/videocoding.html#VkVideoEncodeRateControlInfoKHR)

Extending [VkVideoCodingControlInfoKHR](../chapters/videocoding.html#VkVideoCodingControlInfoKHR), [VkVideoSessionParametersCreateInfoKHR](../chapters/videocoding.html#VkVideoSessionParametersCreateInfoKHR):

* 
[VkVideoEncodeQualityLevelInfoKHR](../chapters/videocoding.html#VkVideoEncodeQualityLevelInfoKHR)

Extending [VkVideoProfileInfoKHR](../chapters/videocoding.html#VkVideoProfileInfoKHR), [VkQueryPoolCreateInfo](../chapters/queries.html#VkQueryPoolCreateInfo):

* 
[VkVideoEncodeUsageInfoKHR](../chapters/videocoding.html#VkVideoEncodeUsageInfoKHR)

* 
[VkVideoEncodeCapabilityFlagBitsKHR](../chapters/videocoding.html#VkVideoEncodeCapabilityFlagBitsKHR)

* 
[VkVideoEncodeContentFlagBitsKHR](../chapters/videocoding.html#VkVideoEncodeContentFlagBitsKHR)

* 
[VkVideoEncodeFeedbackFlagBitsKHR](../chapters/queries.html#VkVideoEncodeFeedbackFlagBitsKHR)

* 
[VkVideoEncodeRateControlModeFlagBitsKHR](../chapters/videocoding.html#VkVideoEncodeRateControlModeFlagBitsKHR)

* 
[VkVideoEncodeTuningModeKHR](../chapters/videocoding.html#VkVideoEncodeTuningModeKHR)

* 
[VkVideoEncodeUsageFlagBitsKHR](../chapters/videocoding.html#VkVideoEncodeUsageFlagBitsKHR)

* 
[VkVideoEncodeCapabilityFlagsKHR](../chapters/videocoding.html#VkVideoEncodeCapabilityFlagsKHR)

* 
[VkVideoEncodeContentFlagsKHR](../chapters/videocoding.html#VkVideoEncodeContentFlagsKHR)

* 
[VkVideoEncodeFeedbackFlagsKHR](../chapters/queries.html#VkVideoEncodeFeedbackFlagsKHR)

* 
[VkVideoEncodeFlagsKHR](../chapters/videocoding.html#VkVideoEncodeFlagsKHR)

* 
[VkVideoEncodeRateControlFlagsKHR](../chapters/videocoding.html#VkVideoEncodeRateControlFlagsKHR)

* 
[VkVideoEncodeRateControlModeFlagsKHR](../chapters/videocoding.html#VkVideoEncodeRateControlModeFlagsKHR)

* 
[VkVideoEncodeUsageFlagsKHR](../chapters/videocoding.html#VkVideoEncodeUsageFlagsKHR)

* 
`VK_KHR_VIDEO_ENCODE_QUEUE_EXTENSION_NAME`

* 
`VK_KHR_VIDEO_ENCODE_QUEUE_SPEC_VERSION`

* 
Extending [VkAccessFlagBits2](../chapters/synchronization.html#VkAccessFlagBits2):

`VK_ACCESS_2_VIDEO_ENCODE_READ_BIT_KHR`

* 
`VK_ACCESS_2_VIDEO_ENCODE_WRITE_BIT_KHR`

Extending [VkBufferUsageFlagBits](../chapters/resources.html#VkBufferUsageFlagBits):

* 
`VK_BUFFER_USAGE_VIDEO_ENCODE_DST_BIT_KHR`

* 
`VK_BUFFER_USAGE_VIDEO_ENCODE_SRC_BIT_KHR`

Extending [VkFormatFeatureFlagBits](../chapters/formats.html#VkFormatFeatureFlagBits):

* 
`VK_FORMAT_FEATURE_VIDEO_ENCODE_DPB_BIT_KHR`

* 
`VK_FORMAT_FEATURE_VIDEO_ENCODE_INPUT_BIT_KHR`

Extending [VkImageLayout](../chapters/resources.html#VkImageLayout):

* 
`VK_IMAGE_LAYOUT_VIDEO_ENCODE_DPB_KHR`

* 
`VK_IMAGE_LAYOUT_VIDEO_ENCODE_DST_KHR`

* 
`VK_IMAGE_LAYOUT_VIDEO_ENCODE_SRC_KHR`

Extending [VkImageUsageFlagBits](../chapters/resources.html#VkImageUsageFlagBits):

* 
`VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR`

* 
`VK_IMAGE_USAGE_VIDEO_ENCODE_DST_BIT_KHR`

* 
`VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR`

Extending [VkPipelineStageFlagBits2](../chapters/synchronization.html#VkPipelineStageFlagBits2):

* 
`VK_PIPELINE_STAGE_2_VIDEO_ENCODE_BIT_KHR`

Extending [VkQueryResultStatusKHR](../chapters/queries.html#VkQueryResultStatusKHR):

* 
`VK_QUERY_RESULT_STATUS_INSUFFICIENT_BITSTREAM_BUFFER_RANGE_KHR`

Extending [VkQueryType](../chapters/queries.html#VkQueryType):

* 
`VK_QUERY_TYPE_VIDEO_ENCODE_FEEDBACK_KHR`

Extending [VkQueueFlagBits](../chapters/devsandqueues.html#VkQueueFlagBits):

* 
`VK_QUEUE_VIDEO_ENCODE_BIT_KHR`

Extending [VkResult](../chapters/fundamentals.html#VkResult):

* 
`VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_QUERY_POOL_VIDEO_ENCODE_FEEDBACK_CREATE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_PROPERTIES_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_FEEDBACK_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_GET_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR`

Extending [VkVideoCodingControlFlagBitsKHR](../chapters/videocoding.html#VkVideoCodingControlFlagBitsKHR):

* 
`VK_VIDEO_CODING_CONTROL_ENCODE_QUALITY_LEVEL_BIT_KHR`

* 
`VK_VIDEO_CODING_CONTROL_ENCODE_RATE_CONTROL_BIT_KHR`

Extending [VkVideoSessionCreateFlagBitsKHR](../chapters/videocoding.html#VkVideoSessionCreateFlagBitsKHR):

* 
`VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_PARAMETER_OPTIMIZATIONS_BIT_KHR`

If [VK_KHR_format_feature_flags2](#VK_KHR_format_feature_flags2) or [Vulkan Version 1.3](versions.html#versions-1.3) is supported:

* 
Extending [VkFormatFeatureFlagBits2](../chapters/formats.html#VkFormatFeatureFlagBits2):

`VK_FORMAT_FEATURE_2_VIDEO_ENCODE_DPB_BIT_KHR`

* 
`VK_FORMAT_FEATURE_2_VIDEO_ENCODE_INPUT_BIT_KHR`

* 
Revision 1, 2018-07-23 (Ahmed Abdelkhalek)

Initial draft

Revision 1.1, 10/29/2019 (Tony Zlatinski)

* 
Updated the reserved spec tokens and renamed VkVideoEncoderKHR to
VkVideoSessionKHR

Revision 1.6, Jan 08 2020 (Tony Zlatinski)

* 
API unify with the video_decode_queue spec

Revision 2, March 29 2021 (Tony Zlatinski)

* 
Spec and API updates.

Revision 3, 2021-09-30 (Jon Leech)

* 
Add interaction with `[VK_KHR_format_feature_flags2](#VK_KHR_format_feature_flags2)` to `vk.xml`

Revision 4, 2022-02-10 (Ahmed Abdelkhalek)

* 
Updates to encode capability interface

Revision 5, 2022-03-31 (Ahmed Abdelkhalek)

* 
Remove redundant VkVideoEncodeInfoKHR.codedExtent

Revision 6, 2022-07-18 (Daniel Rakos)

* 
Remove `VkVideoEncodeRateControlFlagBitsKHR` and
`VkVideoEncodeFlagBitsKHR` as they contain no defined flags for now

* 
Add `VK_VIDEO_CODING_CONTROL_ENCODE_RATE_CONTROL_BIT_KHR` and
`VK_VIDEO_CODING_CONTROL_ENCODE_RATE_CONTROL_LAYER_BIT_KHR` to indicate
rate control and rate control layer change requests, respectively, in
video coding control operations

Revision 7, 2022-08-12 (Daniel Rakos)

* 
Add VkVideoEncodeUsageInfoKHR structure and related flags

Revision 8, 2023-03-06 (Daniel Rakos)

* 
Replace `VK_QUERY_TYPE_VIDEO_ENCODE_BITSTREAM_BUFFER_RANGE_KHR` queries
with more generic `VK_QUERY_TYPE_VIDEO_ENCODE_FEEDBACK_KHR` queries
that can be extended in the future with more feedback values

* 
Rename `dstBitstreamBuffer`, `dstBitstreamBufferOffset`, and
`dstBitstreamBufferMaxRange` in `VkVideoEncodeInfoKHR` to `dstBuffer`,
`dstBufferOffset`, and `dstBufferRange`, respectively, for consistency
with the naming convention in the video decode extensions

* 
Change the type of `rateControlLayerCount` and `qualityLevelCount` in
`VkVideoEncodeCapabilitiesKHR` from `uint8_t` to `uint32_t` and rename
them to `maxRateControlLayers` and `maxQualityLevels`, respectively

* 
Change the type of `averageBitrate` and `maxBitrate` in
`VkVideoEncodeRateControlLayerInfoKHR`` from `uint32_t` to `uint64_t`

* 
Fixed the definition of rate control flag bits and added the new
`VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DEFAULT_KHR` constant to indicate
implementation-specific automatic rate control

* 
Change the type of `VkVideoEncodeRateControlInfoKHR::layerCount` from
`uint8_t` to `uint32_t`

* 
Rename `pLayerConfigs` to `pLayers` in
`VkVideoEncodeRateControlInfoKHR`

Revision 9, 2023-03-28 (Daniel Rakos)

* 
Removed `VK_VIDEO_CODING_CONTROL_ENCODE_RATE_CONTROL_LAYER_BIT_KHR` and
the ability to change the state of individual rate control layers

* 
Added new `VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_HAS_OVERRIDES_BIT_KHR`
flag to video encode feedback queries

* 
Added new video session create flag
`VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_PARAMETER_OPTIMIZATIONS_BIT_KHR`
to opt-in to video session and encoding parameter optimizations

* 
Added the `vkGetEncodedVideoSessionParametersKHR` command to enable
retrieving encoded video session parameter data

* 
Moved `virtualBufferSizeInMs` and `initialVirtualBufferSizeInMs` from
`VkVideoEncodeRateControlLayerInfoKHR` to
`VkVideoEncodeRateControlInfoKHR`

* 
Added `maxBitrate` capability

* 
Renamed `inputImageDataFillAlignment` capability to
`encodeInputPictureGranularity` to better reflect its purpose

* 
Added new `vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR`
command and related structures to enable querying recommended settings
for video encode quality levels

* 
Added `VK_VIDEO_CODING_CONTROL_ENCODE_QUALITY_LEVEL_BIT_KHR` flag and
`VkVideoEncodeQualityLevelInfoKHR` structure to allow controlling video
encode quality level and removed `qualityLevel` from the encode
operation parameters

Revision 10, 2023-07-19 (Daniel Rakos)

* 
Added `VK_QUERY_RESULT_STATUS_INSUFFICIENT_BITSTREAM_BUFFER_RANGE_KHR`
query result status code and the related capability flag
`VK_VIDEO_ENCODE_CAPABILITY_INSUFFICIENT_BITSTREAM_BUFFER_RANGE_DETECTION_BIT_KHR`

Revision 11, 2023-09-04 (Daniel Rakos)

* 
Extension is no longer provisional

Revision 12, 2023-12-05 (Daniel Rakos)

* 
Require the specification of a reconstructed picture in all cases,
except when the video session was created with no DPB slots to match
shipping implementations

* 
Make DPB slot activation behavior codec-specific to continue allowing
application control over reference picture setup now that a
reconstructed picture is always mandatory

**Name String**

`VK_KHR_video_maintenance1`

**Extension Type**

Device extension

**Registered Extension Number**

516

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_video_queue](#VK_KHR_video_queue)

**Contact**

* 
Daniel Rakos [aqnuep](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_video_maintenance1] @aqnuep%0A*Here describe the issue or question you have about the VK_KHR_video_maintenance1 extension*)

**Extension Proposal**

[VK_KHR_video_maintenance1](../../../features/latest/features/proposals/VK_KHR_video_maintenance1.html)

**Last Modified Date**

2023-07-27

**IP Status**

No known IP claims.

**Contributors**

* 
Ahmed Abdelkhalek, AMD

* 
Aidan Fabius, Core Avionics & Industrial Inc.

* 
Ping Liu, Intel

* 
Lynne Iribarren, Independent

* 
Srinath Kumarapuram, NVIDIA

* 
Tony Zlatinski, NVIDIA

* 
Daniel Rakos, RasterGrid

`VK_KHR_video_maintenance1` adds a collection of minor video coding
features, none of which would warrant an entire extension of their own.

The new features are as follows:

* 
Allow creating buffers that can be used in video coding operations,
independent of the used video profile, using the new buffer creation
flag `VK_BUFFER_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR`.

* 
Allow creating images that can be used as decode output or encode input
pictures, independent of the used video profile, using the new image
creation flag `VK_IMAGE_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR`.

* 
Allow specifying queries used by video coding operations as part of the
video coding command parameters, instead of using begin/end query when
the video session is created using the new video session creation flag
`VK_VIDEO_SESSION_CREATE_INLINE_QUERIES_BIT_KHR`.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceVideoMaintenance1FeaturesKHR](../chapters/features.html#VkPhysicalDeviceVideoMaintenance1FeaturesKHR)

Extending [VkVideoDecodeInfoKHR](../chapters/videocoding.html#VkVideoDecodeInfoKHR), [VkVideoEncodeInfoKHR](../chapters/videocoding.html#VkVideoEncodeInfoKHR):

* 
[VkVideoInlineQueryInfoKHR](../chapters/videocoding.html#VkVideoInlineQueryInfoKHR)

* 
`VK_KHR_VIDEO_MAINTENANCE_1_EXTENSION_NAME`

* 
`VK_KHR_VIDEO_MAINTENANCE_1_SPEC_VERSION`

* 
Extending [VkBufferCreateFlagBits](../chapters/resources.html#VkBufferCreateFlagBits):

`VK_BUFFER_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR`

Extending [VkImageCreateFlagBits](../chapters/resources.html#VkImageCreateFlagBits):

* 
`VK_IMAGE_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_1_FEATURES_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_INLINE_QUERY_INFO_KHR`

Extending [VkVideoSessionCreateFlagBitsKHR](../chapters/videocoding.html#VkVideoSessionCreateFlagBitsKHR):

* 
`VK_VIDEO_SESSION_CREATE_INLINE_QUERIES_BIT_KHR`

* 
Revision 1, 2023-07-27 (Daniel Rakos)

internal revisions

**Name String**

`VK_KHR_video_maintenance2`

**Extension Type**

Device extension

**Registered Extension Number**

587

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_video_queue](#VK_KHR_video_queue)

**API Interactions**

* 
Interacts with VK_KHR_video_decode_av1

* 
Interacts with VK_KHR_video_decode_h264

* 
Interacts with VK_KHR_video_decode_h265

* 
Interacts with VK_KHR_video_decode_queue

**Contact**

* 
Daniel Rakos [aqnuep](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_video_maintenance2] @aqnuep%0A*Here describe the issue or question you have about the VK_KHR_video_maintenance2 extension*)

**Extension Proposal**

[VK_KHR_video_maintenance2](../../../features/latest/features/proposals/VK_KHR_video_maintenance2.html)

**Last Modified Date**

2024-10-14

**IP Status**

No known IP claims.

**Contributors**

* 
Ahmed Abdelkhalek, AMD

* 
Benjamin Cheng, AMD

* 
Aidan Fabius, Core Avionics & Industrial Inc.

* 
Ping Liu, Intel

* 
Lynne Iribarren, Independent

* 
Srinath Kumarapuram, NVIDIA

* 
Tony Zlatinski, NVIDIA

* 
Daniel Rakos, RasterGrid

`VK_KHR_video_maintenance2` adds a collection of minor video coding
features, none of which would warrant an entire extension of their own.

The new features are as follows:

* 
Allow video coding control commands (such as video session reset) to be
issued without the need for a bound video session parameters object for
video decode operations that would otherwise require the use of video
session parameters objects.

* 
Allow applications to specify codec-specific parameter sets inline for
each decode operation instead of having to construct video session
parameters objects.

* 
Require support for
`VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DISABLED_BIT_KHR` in all
applicable video encode profiles.

* 
Provide additional guarantees on Video Std parameters that the encoder
implementation will not override.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceVideoMaintenance2FeaturesKHR](../chapters/features.html#VkPhysicalDeviceVideoMaintenance2FeaturesKHR)

If [VK_KHR_video_decode_av1](#VK_KHR_video_decode_av1) is supported:

* 
Extending [VkVideoDecodeInfoKHR](../chapters/videocoding.html#VkVideoDecodeInfoKHR):

[VkVideoDecodeAV1InlineSessionParametersInfoKHR](../chapters/videocoding.html#VkVideoDecodeAV1InlineSessionParametersInfoKHR)

If [VK_KHR_video_decode_h264](#VK_KHR_video_decode_h264) is supported:

* 
Extending [VkVideoDecodeInfoKHR](../chapters/videocoding.html#VkVideoDecodeInfoKHR):

[VkVideoDecodeH264InlineSessionParametersInfoKHR](../chapters/videocoding.html#VkVideoDecodeH264InlineSessionParametersInfoKHR)

If [VK_KHR_video_decode_h265](#VK_KHR_video_decode_h265) is supported:

* 
Extending [VkVideoDecodeInfoKHR](../chapters/videocoding.html#VkVideoDecodeInfoKHR):

[VkVideoDecodeH265InlineSessionParametersInfoKHR](../chapters/videocoding.html#VkVideoDecodeH265InlineSessionParametersInfoKHR)

* 
`VK_KHR_VIDEO_MAINTENANCE_2_EXTENSION_NAME`

* 
`VK_KHR_VIDEO_MAINTENANCE_2_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_2_FEATURES_KHR`

If [VK_KHR_video_decode_av1](#VK_KHR_video_decode_av1) is supported:

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_INLINE_SESSION_PARAMETERS_INFO_KHR`

If [VK_KHR_video_decode_h264](#VK_KHR_video_decode_h264) is supported:

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_INLINE_SESSION_PARAMETERS_INFO_KHR`

If [VK_KHR_video_decode_h265](#VK_KHR_video_decode_h265) is supported:

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_INLINE_SESSION_PARAMETERS_INFO_KHR`

If [VK_KHR_video_decode_queue](#VK_KHR_video_decode_queue) is supported:

* 
Extending [VkVideoSessionCreateFlagBitsKHR](../chapters/videocoding.html#VkVideoSessionCreateFlagBitsKHR):

`VK_VIDEO_SESSION_CREATE_INLINE_SESSION_PARAMETERS_BIT_KHR`

* 
Revision 1, 2024-10-14 (Daniel Rakos)

internal revisions

**Name String**

`VK_KHR_video_queue`

**Extension Type**

Device extension

**Registered Extension Number**

24

**Revision**

8

**Ratification Status**

Ratified

**Extension and Version Dependencies**

 [Vulkan Version 1.1](versions.html#versions-1.1)

 and

 [VK_KHR_synchronization2](#VK_KHR_synchronization2)

or

[Vulkan Version 1.3](versions.html#versions-1.3)

**Contact**

* 
Tony Zlatinski [tzlatinski](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_video_queue] @tzlatinski%0A*Here describe the issue or question you have about the VK_KHR_video_queue extension*)

**Extension Proposal**

[VK_KHR_video_queue](../../../features/latest/features/proposals/VK_KHR_video_queue.html)

**Last Modified Date**

2022-09-29

**IP Status**

No known IP claims.

**Contributors**

* 
Ahmed Abdelkhalek, AMD

* 
George Hao, AMD

* 
Jake Beju, AMD

* 
Piers Daniell, NVIDIA

* 
Srinath Kumarapuram, NVIDIA

* 
Tobias Hector, AMD

* 
Tony Zlatinski, NVIDIA

* 
Daniel Rakos, RasterGrid

This extension provides common APIs to enable exposing queue families with
support for video codec operations by introducing the following new object
types and related functionalities:

* 
Video session objects that represent and maintain the state needed to
perform video codec operations.

* 
Video session parameters objects that act as a container for codec
specific parameters.

In addition, it also introduces query commands that allow applications to
determine video coding related capabilities, and command buffer commands
that enable recording video coding operations against a video session.

This extension is to be used in conjunction with other extensions that
enable specific video coding operations.

* 
[VkVideoSessionKHR](../chapters/videocoding.html#VkVideoSessionKHR)

* 
[VkVideoSessionParametersKHR](../chapters/videocoding.html#VkVideoSessionParametersKHR)

* 
[vkBindVideoSessionMemoryKHR](../chapters/videocoding.html#vkBindVideoSessionMemoryKHR)

* 
[vkCmdBeginVideoCodingKHR](../chapters/videocoding.html#vkCmdBeginVideoCodingKHR)

* 
[vkCmdControlVideoCodingKHR](../chapters/videocoding.html#vkCmdControlVideoCodingKHR)

* 
[vkCmdEndVideoCodingKHR](../chapters/videocoding.html#vkCmdEndVideoCodingKHR)

* 
[vkCreateVideoSessionKHR](../chapters/videocoding.html#vkCreateVideoSessionKHR)

* 
[vkCreateVideoSessionParametersKHR](../chapters/videocoding.html#vkCreateVideoSessionParametersKHR)

* 
[vkDestroyVideoSessionKHR](../chapters/videocoding.html#vkDestroyVideoSessionKHR)

* 
[vkDestroyVideoSessionParametersKHR](../chapters/videocoding.html#vkDestroyVideoSessionParametersKHR)

* 
[vkGetPhysicalDeviceVideoCapabilitiesKHR](../chapters/videocoding.html#vkGetPhysicalDeviceVideoCapabilitiesKHR)

* 
[vkGetPhysicalDeviceVideoFormatPropertiesKHR](../chapters/videocoding.html#vkGetPhysicalDeviceVideoFormatPropertiesKHR)

* 
[vkGetVideoSessionMemoryRequirementsKHR](../chapters/videocoding.html#vkGetVideoSessionMemoryRequirementsKHR)

* 
[vkUpdateVideoSessionParametersKHR](../chapters/videocoding.html#vkUpdateVideoSessionParametersKHR)

* 
[VkBindVideoSessionMemoryInfoKHR](../chapters/videocoding.html#VkBindVideoSessionMemoryInfoKHR)

* 
[VkPhysicalDeviceVideoFormatInfoKHR](../chapters/videocoding.html#VkPhysicalDeviceVideoFormatInfoKHR)

* 
[VkVideoBeginCodingInfoKHR](../chapters/videocoding.html#VkVideoBeginCodingInfoKHR)

* 
[VkVideoCapabilitiesKHR](../chapters/videocoding.html#VkVideoCapabilitiesKHR)

* 
[VkVideoCodingControlInfoKHR](../chapters/videocoding.html#VkVideoCodingControlInfoKHR)

* 
[VkVideoEndCodingInfoKHR](../chapters/videocoding.html#VkVideoEndCodingInfoKHR)

* 
[VkVideoFormatPropertiesKHR](../chapters/videocoding.html#VkVideoFormatPropertiesKHR)

* 
[VkVideoPictureResourceInfoKHR](../chapters/videocoding.html#VkVideoPictureResourceInfoKHR)

* 
[VkVideoReferenceSlotInfoKHR](../chapters/videocoding.html#VkVideoReferenceSlotInfoKHR)

* 
[VkVideoSessionCreateInfoKHR](../chapters/videocoding.html#VkVideoSessionCreateInfoKHR)

* 
[VkVideoSessionMemoryRequirementsKHR](../chapters/videocoding.html#VkVideoSessionMemoryRequirementsKHR)

* 
[VkVideoSessionParametersCreateInfoKHR](../chapters/videocoding.html#VkVideoSessionParametersCreateInfoKHR)

* 
[VkVideoSessionParametersUpdateInfoKHR](../chapters/videocoding.html#VkVideoSessionParametersUpdateInfoKHR)

* 
Extending [VkPhysicalDeviceImageFormatInfo2](../chapters/capabilities.html#VkPhysicalDeviceImageFormatInfo2), [VkPhysicalDeviceVideoFormatInfoKHR](../chapters/videocoding.html#VkPhysicalDeviceVideoFormatInfoKHR), [VkImageCreateInfo](../chapters/resources.html#VkImageCreateInfo), [VkBufferCreateInfo](../chapters/resources.html#VkBufferCreateInfo):

[VkVideoProfileListInfoKHR](../chapters/videocoding.html#VkVideoProfileListInfoKHR)

Extending [VkQueryPoolCreateInfo](../chapters/queries.html#VkQueryPoolCreateInfo):

* 
[VkVideoProfileInfoKHR](../chapters/videocoding.html#VkVideoProfileInfoKHR)

Extending [VkQueueFamilyProperties2](../chapters/devsandqueues.html#VkQueueFamilyProperties2):

* 
[VkQueueFamilyQueryResultStatusPropertiesKHR](../chapters/devsandqueues.html#VkQueueFamilyQueryResultStatusPropertiesKHR)

* 
[VkQueueFamilyVideoPropertiesKHR](../chapters/devsandqueues.html#VkQueueFamilyVideoPropertiesKHR)

* 
[VkQueryResultStatusKHR](../chapters/queries.html#VkQueryResultStatusKHR)

* 
[VkVideoCapabilityFlagBitsKHR](../chapters/videocoding.html#VkVideoCapabilityFlagBitsKHR)

* 
[VkVideoChromaSubsamplingFlagBitsKHR](../chapters/videocoding.html#VkVideoChromaSubsamplingFlagBitsKHR)

* 
[VkVideoCodecOperationFlagBitsKHR](../chapters/videocoding.html#VkVideoCodecOperationFlagBitsKHR)

* 
[VkVideoCodingControlFlagBitsKHR](../chapters/videocoding.html#VkVideoCodingControlFlagBitsKHR)

* 
[VkVideoComponentBitDepthFlagBitsKHR](../chapters/videocoding.html#VkVideoComponentBitDepthFlagBitsKHR)

* 
[VkVideoSessionCreateFlagBitsKHR](../chapters/videocoding.html#VkVideoSessionCreateFlagBitsKHR)

* 
[VkVideoBeginCodingFlagsKHR](../chapters/videocoding.html#VkVideoBeginCodingFlagsKHR)

* 
[VkVideoCapabilityFlagsKHR](../chapters/videocoding.html#VkVideoCapabilityFlagsKHR)

* 
[VkVideoChromaSubsamplingFlagsKHR](../chapters/videocoding.html#VkVideoChromaSubsamplingFlagsKHR)

* 
[VkVideoCodecOperationFlagsKHR](../chapters/videocoding.html#VkVideoCodecOperationFlagsKHR)

* 
[VkVideoCodingControlFlagsKHR](../chapters/videocoding.html#VkVideoCodingControlFlagsKHR)

* 
[VkVideoComponentBitDepthFlagsKHR](../chapters/videocoding.html#VkVideoComponentBitDepthFlagsKHR)

* 
[VkVideoEndCodingFlagsKHR](../chapters/videocoding.html#VkVideoEndCodingFlagsKHR)

* 
[VkVideoSessionCreateFlagsKHR](../chapters/videocoding.html#VkVideoSessionCreateFlagsKHR)

* 
[VkVideoSessionParametersCreateFlagsKHR](../chapters/videocoding.html#VkVideoSessionParametersCreateFlagsKHR)

* 
`VK_KHR_VIDEO_QUEUE_EXTENSION_NAME`

* 
`VK_KHR_VIDEO_QUEUE_SPEC_VERSION`

* 
Extending [VkObjectType](../chapters/debugging.html#VkObjectType):

`VK_OBJECT_TYPE_VIDEO_SESSION_KHR`

* 
`VK_OBJECT_TYPE_VIDEO_SESSION_PARAMETERS_KHR`

Extending [VkQueryResultFlagBits](../chapters/queries.html#VkQueryResultFlagBits):

* 
`VK_QUERY_RESULT_WITH_STATUS_BIT_KHR`

Extending [VkQueryType](../chapters/queries.html#VkQueryType):

* 
`VK_QUERY_TYPE_RESULT_STATUS_ONLY_KHR`

Extending [VkResult](../chapters/fundamentals.html#VkResult):

* 
`VK_ERROR_IMAGE_USAGE_NOT_SUPPORTED_KHR`

* 
`VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR`

* 
`VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR`

* 
`VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR`

* 
`VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR`

* 
`VK_ERROR_VIDEO_STD_VERSION_NOT_SUPPORTED_KHR`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_BIND_VIDEO_SESSION_MEMORY_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR`

* 
`VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR`

* 
Revision 0.1, 2019-11-21 (Tony Zlatinski)

Initial draft

Revision 0.2, 2019-11-27 (Tony Zlatinski)

* 
Make vulkan video core common between decode and encode

Revision 1, March 29 2021 (Tony Zlatinski)

* 
Spec and API updates.

Revision 2, August 1 2021 (Srinath Kumarapuram)

* 
Rename `VkVideoCapabilitiesFlagBitsKHR` to
`VkVideoCapabilityFlagBitsKHR` (along with the names of enumerants it
defines) and `VkVideoCapabilitiesFlagsKHR` to
`VkVideoCapabilityFlagsKHR`, following Vulkan naming conventions.

Revision 3, 2022-03-16 (Ahmed Abdelkhalek)

* 
Relocate Std header version reporting/requesting from codec-operation
specific extensions to this extension.

* 
Make Std header versions codec-operation specific instead of only
codec-specific.

Revision 4, 2022-05-30 (Daniel Rakos)

* 
Refactor the video format query APIs and related language

* 
Extend VkResult with video-specific error codes

Revision 5, 2022-08-11 (Daniel Rakos)

* 
Add `VkVideoSessionParametersCreateFlagsKHR`

* 
Remove `VkVideoCodingQualityPresetFlagsKHR`

* 
Rename `VkQueueFamilyQueryResultStatusProperties2KHR` to
`VkQueueFamilyQueryResultStatusPropertiesKHR`

* 
Rename `VkVideoQueueFamilyProperties2KHR` to
`VkQueueFamilyVideoPropertiesKHR`

* 
Rename `VkVideoProfileKHR` to `VkVideoProfileInfoKHR`

* 
Rename `VkVideoProfilesKHR` to `VkVideoProfileListInfoKHR`

* 
Rename `VkVideoGetMemoryPropertiesKHR` to
`VkVideoSessionMemoryRequirementsKHR`

* 
Rename `VkVideoBindMemoryKHR` to `VkBindVideoSessionMemoryInfoKHR`

* 
Fix `pNext` constness of `VkPhysicalDeviceVideoFormatInfoKHR` and
`VkVideoSessionMemoryRequirementsKHR`

* 
Fix incorrectly named value enums in bit enum types
`VkVideoCodecOperationFlagBitsKHR` and
`VkVideoChromaSubsamplingFlagBitsKHR`

* 
Remove unnecessary default values from
`VkVideoSessionCreateFlagBitsKHR` and `VkVideoCodingControlFlagBitsKHR`

* 
Eliminate nested pointer in `VkVideoSessionMemoryRequirementsKHR`

* 
Rename `VkVideoPictureResourceKHR` to `VkVideoPictureResourceInfoKHR`

* 
Rename `VkVideoReferenceSlotKHR` to `VkVideoReferenceSlotInfoKHR`

Revision 6, 2022-09-18 (Daniel Rakos)

* 
Rename the `maxReferencePicturesSlotsCount` and
`maxReferencePicturesActiveCount` fields of `VkVideoCapabilitiesKHR`
and `VkVideoSessionCreateInfoKHR` to `maxDpbSlots` and
`maxActiveReferencePictures`, respectively, to clarify their meaning

* 
Rename `capabilityFlags` to `flags` in `VkVideoCapabilitiesKHR`

* 
Rename `videoPictureExtentGranularity` to `pictureAccessGranularity` in
`VkVideoCapabilitiesKHR`

* 
Rename `minExtent` and `maxExtent` to `minCodedExtent` and
`maxCodedExtent`, respectively, in `VkVideoCapabilitiesKHR`

* 
Rename `referencePicturesFormat` to `referencePictureFormat` in
`VkVideoSessionCreateInfoKHR`

Revision 7, 2022-09-26 (Daniel Rakos)

* 
Change type of `VkVideoReferenceSlotInfoKHR::slotIndex` from `int8_t`
to `int32_t`

Revision 8, 2022-09-29 (Daniel Rakos)

* 
Extension is no longer provisional

**Name String**

`VK_KHR_wayland_surface`

**Extension Type**

Instance extension

**Registered Extension Number**

7

**Revision**

6

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_surface](#VK_KHR_surface)

**Contact**

* 
Jesse Hall [critsec](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_wayland_surface] @critsec%0A*Here describe the issue or question you have about the VK_KHR_wayland_surface extension*)

* 
Ian Elliott [ianelliottus](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_wayland_surface] @ianelliottus%0A*Here describe the issue or question you have about the VK_KHR_wayland_surface extension*)

**Last Modified Date**

2015-11-28

**IP Status**

No known IP claims.

**Contributors**

* 
Patrick Doane, Blizzard

* 
Faith Ekstrand, Intel

* 
Ian Elliott, LunarG

* 
Courtney Goeltzenleuchter, LunarG

* 
Jesse Hall, Google

* 
James Jones, NVIDIA

* 
Antoine Labour, Google

* 
Jon Leech, Khronos

* 
David Mao, AMD

* 
Norbert Nopper, Freescale

* 
Alon Or-bach, Samsung

* 
Daniel Rakos, AMD

* 
Graham Sellers, AMD

* 
Ray Smith, ARM

* 
Jeff Vigil, Qualcomm

* 
Chia-I Wu, LunarG

The `VK_KHR_wayland_surface` extension is an instance extension.
It provides a mechanism to create a [VkSurfaceKHR](../chapters/VK_KHR_surface/wsi.html#VkSurfaceKHR) object (defined by
the `[VK_KHR_surface](#VK_KHR_surface)` extension) that refers to a Wayland
`wl_surface`, as well as a query to determine support for rendering to a
Wayland compositor.

* 
[vkCreateWaylandSurfaceKHR](../chapters/VK_KHR_surface/wsi.html#vkCreateWaylandSurfaceKHR)

* 
[vkGetPhysicalDeviceWaylandPresentationSupportKHR](../chapters/VK_KHR_surface/wsi.html#vkGetPhysicalDeviceWaylandPresentationSupportKHR)

* 
[VkWaylandSurfaceCreateInfoKHR](../chapters/VK_KHR_surface/wsi.html#VkWaylandSurfaceCreateInfoKHR)

* 
[VkWaylandSurfaceCreateFlagsKHR](../chapters/VK_KHR_surface/wsi.html#VkWaylandSurfaceCreateFlagsKHR)

* 
`VK_KHR_WAYLAND_SURFACE_EXTENSION_NAME`

* 
`VK_KHR_WAYLAND_SURFACE_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR`

1) Does Wayland need a way to query for compatibility between a particular
physical device and a specific Wayland display? This would be a more general
query than [vkGetPhysicalDeviceSurfaceSupportKHR](../chapters/VK_KHR_surface/wsi.html#vkGetPhysicalDeviceSurfaceSupportKHR): if the
Wayland-specific query returned `VK_TRUE` for a ([VkPhysicalDevice](../chapters/devsandqueues.html#VkPhysicalDevice),
`struct wl_display*`) pair, then the physical device could be assumed to
support presentation to any [VkSurfaceKHR](../chapters/VK_KHR_surface/wsi.html#VkSurfaceKHR) for surfaces on the display.

**RESOLVED**: Yes.
[vkGetPhysicalDeviceWaylandPresentationSupportKHR](../chapters/VK_KHR_surface/wsi.html#vkGetPhysicalDeviceWaylandPresentationSupportKHR) was added to address
this issue.

2) Should we require surfaces created with [vkCreateWaylandSurfaceKHR](../chapters/VK_KHR_surface/wsi.html#vkCreateWaylandSurfaceKHR)
to support the `VK_PRESENT_MODE_MAILBOX_KHR` present mode?

**RESOLVED**: Yes.
Wayland is an inherently mailbox window system and mailbox support is
required for some Wayland compositor interactions to work as expected.
While handling these interactions may be possible with
`VK_PRESENT_MODE_FIFO_KHR`, it is much more difficult to do without
deadlock and requiring all Wayland applications to be able to support
implementations which only support `VK_PRESENT_MODE_FIFO_KHR` would be
an onerous restriction on application developers.

* 
Revision 1, 2015-09-23 (Jesse Hall)

Initial draft, based on the previous contents of VK_EXT_KHR_swapchain
(later renamed VK_EXT_KHR_surface).

Revision 2, 2015-10-02 (James Jones)

* 
Added vkGetPhysicalDeviceWaylandPresentationSupportKHR() to resolve
issue #1.

* 
Adjusted wording of issue #1 to match the agreed-upon solution.

* 
Renamed window parameters to surface to match Wayland
conventions.

Revision 3, 2015-10-26 (Ian Elliott)

* 
Renamed from VK_EXT_KHR_wayland_surface to VK_KHR_wayland_surface.

Revision 4, 2015-11-03 (Daniel Rakos)

* 
Added allocation callbacks to vkCreateWaylandSurfaceKHR.

Revision 5, 2015-11-28 (Daniel Rakos)

* 
Updated the surface create function to take a pCreateInfo structure.

Revision 6, 2017-02-08 (Faith Ekstrand)

* 
Added the requirement that implementations support
`VK_PRESENT_MODE_MAILBOX_KHR`.

* 
Added wording about interactions between [vkQueuePresentKHR](../chapters/VK_KHR_surface/wsi.html#vkQueuePresentKHR) and
the Wayland requests sent to the compositor.

**Name String**

`VK_KHR_win32_keyed_mutex`

**Extension Type**

Device extension

**Registered Extension Number**

76

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_external_memory_win32](#VK_KHR_external_memory_win32)

**Contact**

* 
Carsten Rohde [crohde](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_win32_keyed_mutex] @crohde%0A*Here describe the issue or question you have about the VK_KHR_win32_keyed_mutex extension*)

**Last Modified Date**

2016-10-21

**IP Status**

No known IP claims.

**Contributors**

* 
James Jones, NVIDIA

* 
Jeff Juliano, NVIDIA

* 
Carsten Rohde, NVIDIA

Applications that wish to import Direct3D 11 memory objects into the Vulkan
API may wish to use the native keyed mutex mechanism to synchronize access
to the memory between Vulkan and Direct3D.
This extension provides a way for an application to access the keyed mutex
associated with an imported Vulkan memory object when submitting command
buffers to a queue.

* 
Extending [VkSubmitInfo](../chapters/cmdbuffers.html#VkSubmitInfo), [VkSubmitInfo2](../chapters/cmdbuffers.html#VkSubmitInfo2):

[VkWin32KeyedMutexAcquireReleaseInfoKHR](../chapters/cmdbuffers.html#VkWin32KeyedMutexAcquireReleaseInfoKHR)

* 
`VK_KHR_WIN32_KEYED_MUTEX_EXTENSION_NAME`

* 
`VK_KHR_WIN32_KEYED_MUTEX_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR`

* 
Revision 1, 2016-10-21 (James Jones)

Initial revision

**Name String**

`VK_KHR_win32_surface`

**Extension Type**

Instance extension

**Registered Extension Number**

10

**Revision**

6

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_surface](#VK_KHR_surface)

**Contact**

* 
Jesse Hall [critsec](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_win32_surface] @critsec%0A*Here describe the issue or question you have about the VK_KHR_win32_surface extension*)

* 
Ian Elliott [ianelliottus](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_win32_surface] @ianelliottus%0A*Here describe the issue or question you have about the VK_KHR_win32_surface extension*)

**Last Modified Date**

2017-04-24

**IP Status**

No known IP claims.

**Contributors**

* 
Patrick Doane, Blizzard

* 
Faith Ekstrand, Intel

* 
Ian Elliott, LunarG

* 
Courtney Goeltzenleuchter, LunarG

* 
Jesse Hall, Google

* 
James Jones, NVIDIA

* 
Antoine Labour, Google

* 
Jon Leech, Khronos

* 
David Mao, AMD

* 
Norbert Nopper, Freescale

* 
Alon Or-bach, Samsung

* 
Daniel Rakos, AMD

* 
Graham Sellers, AMD

* 
Ray Smith, ARM

* 
Jeff Vigil, Qualcomm

* 
Chia-I Wu, LunarG

The `VK_KHR_win32_surface` extension is an instance extension.
It provides a mechanism to create a [VkSurfaceKHR](../chapters/VK_KHR_surface/wsi.html#VkSurfaceKHR) object (defined by
the `[VK_KHR_surface](#VK_KHR_surface)` extension) that refers to a Win32 `HWND`, as
well as a query to determine support for rendering to the windows desktop.

* 
[vkCreateWin32SurfaceKHR](../chapters/VK_KHR_surface/wsi.html#vkCreateWin32SurfaceKHR)

* 
[vkGetPhysicalDeviceWin32PresentationSupportKHR](../chapters/VK_KHR_surface/wsi.html#vkGetPhysicalDeviceWin32PresentationSupportKHR)

* 
[VkWin32SurfaceCreateInfoKHR](../chapters/VK_KHR_surface/wsi.html#VkWin32SurfaceCreateInfoKHR)

* 
[VkWin32SurfaceCreateFlagsKHR](../chapters/VK_KHR_surface/wsi.html#VkWin32SurfaceCreateFlagsKHR)

* 
`VK_KHR_WIN32_SURFACE_EXTENSION_NAME`

* 
`VK_KHR_WIN32_SURFACE_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR`

1) Does Win32 need a way to query for compatibility between a particular
physical device and a specific screen? Compatibility between a physical
device and a window generally only depends on what screen the window is on.
However, there is not an obvious way to identify a screen without already
having a window on the screen.

**RESOLVED**: No.
While it may be useful, there is not a clear way to do this on Win32.
However, a method was added to query support for presenting to the windows
desktop as a whole.

2) If a native window object (`HWND`) is used by one graphics API, and
then is later used by a different graphics API (one of which is Vulkan), can
these uses interfere with each other?

**RESOLVED**: Yes.

Uses of a window object by multiple graphics APIs results in **undefined**
behavior.
Such behavior may succeed when using one Vulkan implementation but fail when
using a different Vulkan implementation.
Potential failures include:

* 
Creating then destroying a flip presentation model DXGI swapchain on a
window object can prevent [vkCreateSwapchainKHR](../chapters/VK_KHR_surface/wsi.html#vkCreateSwapchainKHR) from succeeding on
the same window object.

* 
Creating then destroying a [VkSwapchainKHR](../chapters/VK_KHR_surface/wsi.html#VkSwapchainKHR) on a window object can
prevent creation of a bitblt model DXGI swapchain on the same window
object.

* 
Creating then destroying a [VkSwapchainKHR](../chapters/VK_KHR_surface/wsi.html#VkSwapchainKHR) on a window object can
effectively `SetPixelFormat` to a different format than the format
chosen by an OpenGL application.

* 
Creating then destroying a [VkSwapchainKHR](../chapters/VK_KHR_surface/wsi.html#VkSwapchainKHR) on a window object on
one [VkPhysicalDevice](../chapters/devsandqueues.html#VkPhysicalDevice) can prevent [vkCreateSwapchainKHR](../chapters/VK_KHR_surface/wsi.html#vkCreateSwapchainKHR) from
succeeding on the same window object, but on a different
[VkPhysicalDevice](../chapters/devsandqueues.html#VkPhysicalDevice) that is associated with a different Vulkan ICD.

In all cases the problem can be worked around by creating a new window
object.

Technical details include:

* 
Creating a DXGI swapchain over a window object can alter the object for
the remainder of its lifetime.
The alteration persists even after the DXGI swapchain has been
destroyed.
This alteration can make it impossible for a conformant Vulkan
implementation to create a [VkSwapchainKHR](../chapters/VK_KHR_surface/wsi.html#VkSwapchainKHR) over the same window
object.
Mention of this alteration can be found in the remarks section of the
MSDN documentation for `DXGI_SWAP_EFFECT`.

* 
Calling GDIs `SetPixelFormat` (needed by OpenGLs WGL layer) on a
window object alters the object for the remainder of its lifetime.
The MSDN documentation for `SetPixelFormat` explains that a window
objects pixel format can be set only one time.

* 
Creating a [VkSwapchainKHR](../chapters/VK_KHR_surface/wsi.html#VkSwapchainKHR) over a window object can alter the
object for its remaining lifetime.
Either of the above alterations may occur as a side effect of
[vkCreateSwapchainKHR](../chapters/VK_KHR_surface/wsi.html#vkCreateSwapchainKHR).

* 
Revision 1, 2015-09-23 (Jesse Hall)

Initial draft, based on the previous contents of VK_EXT_KHR_swapchain
(later renamed VK_EXT_KHR_surface).

Revision 2, 2015-10-02 (James Jones)

* 
Added presentation support query for win32 desktops.

Revision 3, 2015-10-26 (Ian Elliott)

* 
Renamed from VK_EXT_KHR_win32_surface to VK_KHR_win32_surface.

Revision 4, 2015-11-03 (Daniel Rakos)

* 
Added allocation callbacks to vkCreateWin32SurfaceKHR.

Revision 5, 2015-11-28 (Daniel Rakos)

* 
Updated the surface create function to take a pCreateInfo structure.

Revision 6, 2017-04-24 (Jeff Juliano)

* 
Add issue 2 addressing reuse of a native window object in a different
Graphics API, or by a different Vulkan ICD.

**Name String**

`VK_KHR_workgroup_memory_explicit_layout`

**Extension Type**

Device extension

**Registered Extension Number**

337

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**SPIR-V Dependencies**

* 
[SPV_KHR_workgroup_memory_explicit_layout](https://github.khronos.org/SPIRV-Registry/extensions/KHR/SPV_KHR_workgroup_memory_explicit_layout.html)

**Contact**

* 
Caio Marcelo de Oliveira Filho [cmarcelo](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_workgroup_memory_explicit_layout] @cmarcelo%0A*Here describe the issue or question you have about the VK_KHR_workgroup_memory_explicit_layout extension*)

**Last Modified Date**

2020-06-01

**IP Status**

No known IP claims.

**Interactions and External Dependencies**

* 
This extension provides API support for
[`GL_EXT_shared_memory_block`](https://github.com/KhronosGroup/GLSL/blob/main/extensions/ext/GL_EXT_shared_memory_block.txt)

**Contributors**

* 
Caio Marcelo de Oliveira Filho, Intel

* 
Jeff Bolz, NVIDIA

* 
Graeme Leese, Broadcom

* 
Faith Ekstrand, Intel

* 
Daniel Koch, NVIDIA

This extension adds Vulkan support for the
[`SPV_KHR_workgroup_memory_explicit_layout`](https://github.khronos.org/SPIRV-Registry/extensions/KHR/SPV_KHR_workgroup_memory_explicit_layout.html)
SPIR-V extension, which allows shaders to explicitly define the layout of
`Workgroup` storage class memory and create aliases between variables
from that storage class in a compute shader.

The aliasing feature allows different views on the same data, so the
shader can bulk copy data from another storage class using one type (e.g. an
array of large vectors), and then use the data with a more specific type.
It also enables reducing the amount of workgroup memory consumed by allowing
the shader to alias data whose lifetimes do not overlap.

The explicit layout support and some form of aliasing is also required for
layering OpenCL on top of Vulkan.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR](../chapters/features.html#VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR)

* 
`VK_KHR_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_EXTENSION_NAME`

* 
`VK_KHR_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR`

* 
[    `WorkgroupMemoryExplicitLayoutKHR`](spirvenv.html#spirvenv-capabilities-table-WorkgroupMemoryExplicitLayoutKHR)

* 
[    `WorkgroupMemoryExplicitLayout8BitAccessKHR`](spirvenv.html#spirvenv-capabilities-table-WorkgroupMemoryExplicitLayout8BitAccessKHR)

* 
[    `WorkgroupMemoryExplicitLayout16BitAccessKHR`](spirvenv.html#spirvenv-capabilities-table-WorkgroupMemoryExplicitLayout16BitAccessKHR)

* 
Revision 1, 2020-06-01 (Caio Marcelo de Oliveira Filho)

Initial version

**Name String**

`VK_KHR_xcb_surface`

**Extension Type**

Instance extension

**Registered Extension Number**

6

**Revision**

6

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_surface](#VK_KHR_surface)

**Contact**

* 
Jesse Hall [critsec](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_xcb_surface] @critsec%0A*Here describe the issue or question you have about the VK_KHR_xcb_surface extension*)

* 
Ian Elliott [ianelliottus](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_xcb_surface] @ianelliottus%0A*Here describe the issue or question you have about the VK_KHR_xcb_surface extension*)

**Last Modified Date**

2015-11-28

**IP Status**

No known IP claims.

**Contributors**

* 
Patrick Doane, Blizzard

* 
Faith Ekstrand, Intel

* 
Ian Elliott, LunarG

* 
Courtney Goeltzenleuchter, LunarG

* 
Jesse Hall, Google

* 
James Jones, NVIDIA

* 
Antoine Labour, Google

* 
Jon Leech, Khronos

* 
David Mao, AMD

* 
Norbert Nopper, Freescale

* 
Alon Or-bach, Samsung

* 
Daniel Rakos, AMD

* 
Graham Sellers, AMD

* 
Ray Smith, ARM

* 
Jeff Vigil, Qualcomm

* 
Chia-I Wu, LunarG

The `VK_KHR_xcb_surface` extension is an instance extension.
It provides a mechanism to create a [VkSurfaceKHR](../chapters/VK_KHR_surface/wsi.html#VkSurfaceKHR) object (defined by
the `[VK_KHR_surface](#VK_KHR_surface)` extension) that refers to an X11 `Window`,
using the XCB client-side library, as well as a query to determine support
for rendering via XCB.

* 
[vkCreateXcbSurfaceKHR](../chapters/VK_KHR_surface/wsi.html#vkCreateXcbSurfaceKHR)

* 
[vkGetPhysicalDeviceXcbPresentationSupportKHR](../chapters/VK_KHR_surface/wsi.html#vkGetPhysicalDeviceXcbPresentationSupportKHR)

* 
[VkXcbSurfaceCreateInfoKHR](../chapters/VK_KHR_surface/wsi.html#VkXcbSurfaceCreateInfoKHR)

* 
[VkXcbSurfaceCreateFlagsKHR](../chapters/VK_KHR_surface/wsi.html#VkXcbSurfaceCreateFlagsKHR)

* 
`VK_KHR_XCB_SURFACE_EXTENSION_NAME`

* 
`VK_KHR_XCB_SURFACE_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR`

1) Does XCB need a way to query for compatibility between a particular
physical device and a specific screen? This would be a more general query
than [vkGetPhysicalDeviceSurfaceSupportKHR](../chapters/VK_KHR_surface/wsi.html#vkGetPhysicalDeviceSurfaceSupportKHR): If it returned
`VK_TRUE`, then the physical device could be assumed to support
presentation to any window on that screen.

**RESOLVED**: Yes, this is needed for toolkits that want to create a
[VkDevice](../chapters/devsandqueues.html#VkDevice) before creating a window.
To ensure the query is reliable, it must be made against a particular X
visual rather than the screen in general.

* 
Revision 1, 2015-09-23 (Jesse Hall)

Initial draft, based on the previous contents of VK_EXT_KHR_swapchain
(later renamed VK_EXT_KHR_surface).

Revision 2, 2015-10-02 (James Jones)

* 
Added presentation support query for an (xcb_connection_t*,
xcb_visualid_t) pair.

* 
Removed root parameter from CreateXcbSurfaceKHR(), as it is
redundant when a window on the same screen is specified as well.

* 
Adjusted wording of issue #1 and added agreed upon resolution.

Revision 3, 2015-10-14 (Ian Elliott)

* 
Removed root parameter from CreateXcbSurfaceKHR() in one more
place.

Revision 4, 2015-10-26 (Ian Elliott)

* 
Renamed from VK_EXT_KHR_xcb_surface to VK_KHR_xcb_surface.

Revision 5, 2015-10-23 (Daniel Rakos)

* 
Added allocation callbacks to vkCreateXcbSurfaceKHR.

Revision 6, 2015-11-28 (Daniel Rakos)

* 
Updated the surface create function to take a pCreateInfo structure.

**Name String**

`VK_KHR_xlib_surface`

**Extension Type**

Instance extension

**Registered Extension Number**

5

**Revision**

6

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_surface](#VK_KHR_surface)

**Contact**

* 
Jesse Hall [critsec](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_xlib_surface] @critsec%0A*Here describe the issue or question you have about the VK_KHR_xlib_surface extension*)

* 
Ian Elliott [ianelliottus](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_xlib_surface] @ianelliottus%0A*Here describe the issue or question you have about the VK_KHR_xlib_surface extension*)

**Last Modified Date**

2015-11-28

**IP Status**

No known IP claims.

**Contributors**

* 
Patrick Doane, Blizzard

* 
Faith Ekstrand, Intel

* 
Ian Elliott, LunarG

* 
Courtney Goeltzenleuchter, LunarG

* 
Jesse Hall, Google

* 
James Jones, NVIDIA

* 
Antoine Labour, Google

* 
Jon Leech, Khronos

* 
David Mao, AMD

* 
Norbert Nopper, Freescale

* 
Alon Or-bach, Samsung

* 
Daniel Rakos, AMD

* 
Graham Sellers, AMD

* 
Ray Smith, ARM

* 
Jeff Vigil, Qualcomm

* 
Chia-I Wu, LunarG

The `VK_KHR_xlib_surface` extension is an instance extension.
It provides a mechanism to create a [VkSurfaceKHR](../chapters/VK_KHR_surface/wsi.html#VkSurfaceKHR) object (defined by
the `[VK_KHR_surface](#VK_KHR_surface)` extension) that refers to an X11 `Window`,
using the Xlib client-side library, as well as a query to determine support
for rendering via Xlib.

* 
[vkCreateXlibSurfaceKHR](../chapters/VK_KHR_surface/wsi.html#vkCreateXlibSurfaceKHR)

* 
[vkGetPhysicalDeviceXlibPresentationSupportKHR](../chapters/VK_KHR_surface/wsi.html#vkGetPhysicalDeviceXlibPresentationSupportKHR)

* 
[VkXlibSurfaceCreateInfoKHR](../chapters/VK_KHR_surface/wsi.html#VkXlibSurfaceCreateInfoKHR)

* 
[VkXlibSurfaceCreateFlagsKHR](../chapters/VK_KHR_surface/wsi.html#VkXlibSurfaceCreateFlagsKHR)

* 
`VK_KHR_XLIB_SURFACE_EXTENSION_NAME`

* 
`VK_KHR_XLIB_SURFACE_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR`

1) Does X11 need a way to query for compatibility between a particular
physical device and a specific screen? This would be a more general query
than [vkGetPhysicalDeviceSurfaceSupportKHR](../chapters/VK_KHR_surface/wsi.html#vkGetPhysicalDeviceSurfaceSupportKHR); if it returned
`VK_TRUE`, then the physical device could be assumed to support
presentation to any window on that screen.

**RESOLVED**: Yes, this is needed for toolkits that want to create a
[VkDevice](../chapters/devsandqueues.html#VkDevice) before creating a window.
To ensure the query is reliable, it must be made against a particular X
visual rather than the screen in general.

* 
Revision 1, 2015-09-23 (Jesse Hall)

Initial draft, based on the previous contents of VK_EXT_KHR_swapchain
(later renamed VK_EXT_KHR_surface).

Revision 2, 2015-10-02 (James Jones)

* 
Added presentation support query for (Display*, VisualID) pair.

* 
Removed root parameter from CreateXlibSurfaceKHR(), as it is
redundant when a window on the same screen is specified as well.

* 
Added appropriate X errors.

* 
Adjusted wording of issue #1 and added agreed upon resolution.

Revision 3, 2015-10-14 (Ian Elliott)

* 
Renamed this extension from VK_EXT_KHR_x11_surface to
VK_EXT_KHR_xlib_surface.

Revision 4, 2015-10-26 (Ian Elliott)

* 
Renamed from VK_EXT_KHR_xlib_surface to VK_KHR_xlib_surface.

Revision 5, 2015-11-03 (Daniel Rakos)

* 
Added allocation callbacks to vkCreateXlibSurfaceKHR.

Revision 6, 2015-11-28 (Daniel Rakos)

* 
Updated the surface create function to take a pCreateInfo structure.

**Name String**

`VK_EXT_acquire_drm_display`

**Extension Type**

Instance extension

**Registered Extension Number**

286

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_EXT_direct_mode_display](#VK_EXT_direct_mode_display)

**Contact**

* 
Drew DeVault [sir@cmpwn.com](mailto:sir@cmpwn.com)

**Last Modified Date**

2021-06-09

**IP Status**

No known IP claims.

**Contributors**

* 
Simon Zeni, Status Holdings, Ltd.

This extension allows an application to take exclusive control of a display
using the Direct Rendering Manager (DRM) interface.
When acquired, the display will be under full control of the application
until the display is either released or the connector is unplugged.

* 
[vkAcquireDrmDisplayEXT](../chapters/VK_KHR_surface/wsi.html#vkAcquireDrmDisplayEXT)

* 
[vkGetDrmDisplayEXT](../chapters/VK_KHR_surface/wsi.html#vkGetDrmDisplayEXT)

* 
`VK_EXT_ACQUIRE_DRM_DISPLAY_EXTENSION_NAME`

* 
`VK_EXT_ACQUIRE_DRM_DISPLAY_SPEC_VERSION`

None.

* 
Revision 1, 2021-05-11 (Simon Zeni)

Initial draft

**Name String**

`VK_EXT_acquire_xlib_display`

**Extension Type**

Instance extension

**Registered Extension Number**

90

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_EXT_direct_mode_display](#VK_EXT_direct_mode_display)

**Contact**

* 
James Jones [cubanismo](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_acquire_xlib_display] @cubanismo%0A*Here describe the issue or question you have about the VK_EXT_acquire_xlib_display extension*)

**Last Modified Date**

2016-12-13

**IP Status**

No known IP claims.

**Contributors**

* 
Dave Airlie, Red Hat

* 
Pierre Boudier, NVIDIA

* 
James Jones, NVIDIA

* 
Damien Leone, NVIDIA

* 
Pierre-Loup Griffais, Valve

* 
Liam Middlebrook, NVIDIA

* 
Daniel Vetter, Intel

This extension allows an application to take exclusive control on a display
currently associated with an X11 screen.
When control is acquired, the display will be deassociated from the X11
screen until control is released or the specified display connection is
closed.
Essentially, the X11 screen will behave as if the monitor has been unplugged
until control is released.

* 
[vkAcquireXlibDisplayEXT](../chapters/VK_KHR_surface/wsi.html#vkAcquireXlibDisplayEXT)

* 
[vkGetRandROutputDisplayEXT](../chapters/VK_KHR_surface/wsi.html#vkGetRandROutputDisplayEXT)

* 
`VK_EXT_ACQUIRE_XLIB_DISPLAY_EXTENSION_NAME`

* 
`VK_EXT_ACQUIRE_XLIB_DISPLAY_SPEC_VERSION`

1) Should [vkAcquireXlibDisplayEXT](../chapters/VK_KHR_surface/wsi.html#vkAcquireXlibDisplayEXT) take an RandR display ID, or a
Vulkan display handle as input?

**RESOLVED**: A Vulkan display handle.
Otherwise there would be no way to specify handles to displays that had been
prevented from being included in the X11 display list by some native
platform or vendor-specific mechanism.

2) How does an application figure out which RandR display corresponds to a
Vulkan display?

**RESOLVED**: A new function, [vkGetRandROutputDisplayEXT](../chapters/VK_KHR_surface/wsi.html#vkGetRandROutputDisplayEXT), is introduced
for this purpose.

3) Should [vkGetRandROutputDisplayEXT](../chapters/VK_KHR_surface/wsi.html#vkGetRandROutputDisplayEXT) be part of this extension, or a
general Vulkan / RandR or Vulkan / Xlib extension?

**RESOLVED**: To avoid yet another extension, include it in this extension.

* 
Revision 1, 2016-12-13 (James Jones)

Initial draft

**Name String**

`VK_EXT_astc_decode_mode`

**Extension Type**

Device extension

**Registered Extension Number**

68

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Contact**

* 
Jan-Harald Fredriksen [janharaldfredriksen-arm](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_astc_decode_mode] @janharaldfredriksen-arm%0A*Here describe the issue or question you have about the VK_EXT_astc_decode_mode extension*)

**Last Modified Date**

2018-08-07

**Contributors**

* 
Jan-Harald Fredriksen, Arm

The existing specification requires that low dynamic range (LDR) ASTC
textures are decompressed to FP16 values per component.
In many cases, decompressing LDR textures to a lower precision intermediate
result gives acceptable image quality.
Source material for LDR textures is typically authored as 8-bit UNORM
values, so decoding to FP16 values adds little value.
On the other hand, reducing precision of the decoded result reduces the size
of the decompressed data, potentially improving texture cache performance
and saving power.

The goal of this extension is to enable this efficiency gain on existing
ASTC texture data.
This is achieved by giving the application the ability to select the
intermediate decoding precision.

Three decoding options are provided:

* 
Decode to `VK_FORMAT_R16G16B16A16_SFLOAT` precision: This is the
default, and matches the required behavior in the core API.

* 
Decode to `VK_FORMAT_R8G8B8A8_UNORM` precision: This is provided as
an option in LDR mode.

* 
Decode to `VK_FORMAT_E5B9G9R9_UFLOAT_PACK32` precision: This is
provided as an option in both LDR and HDR mode.
In this mode, negative values cannot be represented and are clamped to
zero.
The alpha component is ignored, and the results are as if alpha was 1.0.
This decode mode is optional and support can be queried via the physical
device properties.

* 
Extending [VkImageViewCreateInfo](../chapters/resources.html#VkImageViewCreateInfo):

[VkImageViewASTCDecodeModeEXT](../chapters/resources.html#VkImageViewASTCDecodeModeEXT)

Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

* 
[VkPhysicalDeviceASTCDecodeFeaturesEXT](../chapters/features.html#VkPhysicalDeviceASTCDecodeFeaturesEXT)

* 
`VK_EXT_ASTC_DECODE_MODE_EXTENSION_NAME`

* 
`VK_EXT_ASTC_DECODE_MODE_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT`

1) Are implementations allowed to decode at a higher precision than what is
requested?

RESOLUTION: No.
If we allow this, then this extension could be exposed on all
implementations that support ASTC.
But developers would have no way of knowing what precision was actually
used, and thus whether the image quality is sufficient at reduced
precision.

2) Should the decode mode be image view state and/or sampler state?

RESOLUTION: Image view state only.
Some implementations treat the different decode modes as different
texture formats.

Create an image view that decodes to `VK_FORMAT_R8G8B8A8_UNORM`
precision:

    VkImageViewASTCDecodeModeEXT decodeMode =
    {
        .sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT,
        .pNext = NULL,
        .decodeMode = VK_FORMAT_R8G8B8A8_UNORM
    };

    VkImageViewCreateInfo createInfo =
    {
        .sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO,
        .pNext = &decodeMode,
        // flags, image, viewType set to application-desired values
        .format = VK_FORMAT_ASTC_8x8_UNORM_BLOCK,
        // components, subresourceRange set to application-desired values
    };

    VkImageView imageView;
    VkResult result = vkCreateImageView(
        device,
        &createInfo,
        NULL,
        &imageView);

* 
Revision 1, 2018-08-07 (Jan-Harald Fredriksen)

Initial revision

**Name String**

`VK_EXT_attachment_feedback_loop_dynamic_state`

**Extension Type**

Device extension

**Registered Extension Number**

525

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

 [VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

 or

 [Vulkan Version 1.1](versions.html#versions-1.1)

and

[VK_EXT_attachment_feedback_loop_layout](#VK_EXT_attachment_feedback_loop_layout)

**Special Uses**

* 
[OpenGL / ES support](../chapters/extensions.html#extendingvulkan-compatibility-specialuse)

* 
[D3D support](../chapters/extensions.html#extendingvulkan-compatibility-specialuse)

**Contact**

* 
Mike Blumenkrantz [zmike](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_attachment_feedback_loop_dynamic_state] @zmike%0A*Here describe the issue or question you have about the VK_EXT_attachment_feedback_loop_dynamic_state extension*)

**Extension Proposal**

[VK_EXT_attachment_feedback_loop_dynamic_state](../../../features/latest/features/proposals/VK_EXT_attachment_feedback_loop_dynamic_state.html)

**Last Modified Date**

2023-04-28

**IP Status**

No known IP claims.

**Contributors**

* 
Mike Blumenkrantz, Valve

* 
Daniel Story, Nintendo

* 
Stu Smith, AMD

* 
Samuel Pitoiset, Valve

* 
Ricardo Garcia, Igalia

This extension adds support for setting attachment feedback loops
dynamically on command buffers.

* 
[vkCmdSetAttachmentFeedbackLoopEnableEXT](../chapters/renderpass.html#vkCmdSetAttachmentFeedbackLoopEnableEXT)

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT](../chapters/features.html#VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT)

* 
`VK_EXT_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_EXTENSION_NAME`

* 
`VK_EXT_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_SPEC_VERSION`

* 
Extending [VkDynamicState](../chapters/pipelines.html#VkDynamicState):

`VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT`

* 
Revision 1, 2023-04-28 (Mike Blumenkrantz)

Initial revision

**Name String**

`VK_EXT_attachment_feedback_loop_layout`

**Extension Type**

Device extension

**Registered Extension Number**

340

**Revision**

2

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Special Uses**

* 
[OpenGL / ES support](../chapters/extensions.html#extendingvulkan-compatibility-specialuse)

* 
[D3D support](../chapters/extensions.html#extendingvulkan-compatibility-specialuse)

**Contact**

* 
Joshua Ashton [Joshua-Ashton](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_attachment_feedback_loop_layout] @Joshua-Ashton%0A*Here describe the issue or question you have about the VK_EXT_attachment_feedback_loop_layout extension*)

**Extension Proposal**

[VK_EXT_attachment_feedback_loop_layout](../../../features/latest/features/proposals/VK_EXT_attachment_feedback_loop_layout.html)

**Last Modified Date**

2022-04-04

**IP Status**

No known IP claims.

**Contributors**

* 
Joshua Ashton, Valve

* 
Faith Ekstrand, Collabora

* 
Bas Nieuwenhuizen, Google

* 
Samuel Iglesias Gonslvez, Igalia

* 
Ralph Potter, Samsung

* 
Jan-Harald Fredriksen, Arm

* 
Ricardo Garcia, Igalia

This extension adds a new image layout,
`VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT`, which allows
applications to have an image layout in which they are able to both render
to and sample/fetch from the same subresource of an image in a given render
pass.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT](../chapters/features.html#VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT)

* 
`VK_EXT_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_EXTENSION_NAME`

* 
`VK_EXT_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_SPEC_VERSION`

* 
Extending [VkDependencyFlagBits](../chapters/synchronization.html#VkDependencyFlagBits):

`VK_DEPENDENCY_FEEDBACK_LOOP_BIT_EXT`

Extending [VkImageLayout](../chapters/resources.html#VkImageLayout):

* 
`VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT`

Extending [VkImageUsageFlagBits](../chapters/resources.html#VkImageUsageFlagBits):

* 
`VK_IMAGE_USAGE_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT`

Extending [VkPipelineCreateFlagBits](../chapters/pipelines.html#VkPipelineCreateFlagBits):

* 
`VK_PIPELINE_CREATE_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT`

* 
`VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT`

* 
Revision 2, 2022-04-04 (Joshua Ashton)

Renamed from VALVE to EXT.

Revision 1, 2021-03-09 (Joshua Ashton)

* 
Initial draft.

**Name String**

`VK_EXT_blend_operation_advanced`

**Extension Type**

Device extension

**Registered Extension Number**

149

**Revision**

2

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Contact**

* 
Jeff Bolz [jeffbolznv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_blend_operation_advanced] @jeffbolznv%0A*Here describe the issue or question you have about the VK_EXT_blend_operation_advanced extension*)

**Last Modified Date**

2017-06-12

**Contributors**

* 
Jeff Bolz, NVIDIA

This extension adds a number of advanced blending operations that **can**
be used to perform new color blending operations, many of which are more
complex than the standard blend modes provided by unextended Vulkan.
This extension requires different styles of usage, depending on the level of
hardware support and the enabled features:

* 
If
[VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT](../chapters/features.html#VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT)::`advancedBlendCoherentOperations`
is `VK_FALSE`, the new blending operations are supported, but a
memory dependency **must** separate each advanced blend operation on a
given sample.
`VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT` is used to
synchronize reads using advanced blend operations.

* 
If
[VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT](../chapters/features.html#VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT)::`advancedBlendCoherentOperations`
is `VK_TRUE`, advanced blend operations obey primitive order just
like basic blend operations.

In unextended Vulkan, the set of blending operations is limited, and **can** be
expressed very simply.
The `VK_BLEND_OP_MIN` and `VK_BLEND_OP_MAX` blend operations simply
compute component-wise minimums or maximums of source and destination color
components.
The `VK_BLEND_OP_ADD`, `VK_BLEND_OP_SUBTRACT`, and
`VK_BLEND_OP_REVERSE_SUBTRACT` modes multiply the source and destination
colors by source and destination factors and either add the two products
together or subtract one from the other.
This limited set of operations supports many common blending operations but
precludes the use of more sophisticated transparency and blending operations
commonly available in many dedicated imaging APIs.

This extension provides a number of new advanced blending operations.
Unlike traditional blending operations using `VK_BLEND_OP_ADD`, these
blending equations do not use source and destination factors specified by
[VkBlendFactor](../chapters/framebuffer.html#VkBlendFactor).
Instead, each blend operation specifies a complete equation based on the
source and destination colors.
These new blend operations are used for both RGB and alpha components; they
**must** not be used to perform separate RGB and alpha blending (via different
values of color and alpha [VkBlendOp](../chapters/framebuffer.html#VkBlendOp)).

These blending operations are performed using premultiplied colors, where
RGB colors **can** be considered premultiplied or non-premultiplied by alpha,
according to the `srcPremultiplied` and `dstPremultiplied` members
of [VkPipelineColorBlendAdvancedStateCreateInfoEXT](../chapters/framebuffer.html#VkPipelineColorBlendAdvancedStateCreateInfoEXT).
If a color is considered non-premultiplied, the (R,G,B) color components are
multiplied by the alpha component prior to blending.
For non-premultiplied color components in the range [0,1], the
corresponding premultiplied color component would have values in the range
[0  A, 1  A].

Many of these advanced blending equations are formulated where the result of
blending source and destination colors with partial coverage have three
separate contributions: from the portions covered by both the source and the
destination, from the portion covered only by the source, and from the
portion covered only by the destination.
The blend parameter
[VkPipelineColorBlendAdvancedStateCreateInfoEXT](../chapters/framebuffer.html#VkPipelineColorBlendAdvancedStateCreateInfoEXT)::`blendOverlap`
**can** be used to specify a correlation between source and destination pixel
coverage.
If set to `VK_BLEND_OVERLAP_CONJOINT_EXT`, the source and destination
are considered to have maximal overlap, as would be the case if drawing two
objects on top of each other.
If set to `VK_BLEND_OVERLAP_DISJOINT_EXT`, the source and destination
are considered to have minimal overlap, as would be the case when rendering
a complex polygon tessellated into individual non-intersecting triangles.
If set to `VK_BLEND_OVERLAP_UNCORRELATED_EXT`, the source and
destination coverage are assumed to have no spatial correlation within the
pixel.

In addition to the coherency issues on implementations not supporting
`advancedBlendCoherentOperations`, this extension has several
limitations worth noting.
First, the new blend operations have a limit on the number of color
attachments they **can** be used with, as indicated by
[VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT](../chapters/limits.html#VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT)::`advancedBlendMaxColorAttachments`.
Additionally, blending precision **may** be limited to 16-bit floating-point,
which **may** result in a loss of precision and dynamic range for framebuffer
formats with 32-bit floating-point components, and in a loss of precision
for formats with 12- and 16-bit signed or unsigned normalized integer
components.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT](../chapters/features.html#VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT](../chapters/limits.html#VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT)

Extending [VkPipelineColorBlendStateCreateInfo](../chapters/framebuffer.html#VkPipelineColorBlendStateCreateInfo):

* 
[VkPipelineColorBlendAdvancedStateCreateInfoEXT](../chapters/framebuffer.html#VkPipelineColorBlendAdvancedStateCreateInfoEXT)

* 
[VkBlendOverlapEXT](../chapters/framebuffer.html#VkBlendOverlapEXT)

* 
`VK_EXT_BLEND_OPERATION_ADVANCED_EXTENSION_NAME`

* 
`VK_EXT_BLEND_OPERATION_ADVANCED_SPEC_VERSION`

* 
Extending [VkAccessFlagBits](../chapters/synchronization.html#VkAccessFlagBits):

`VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT`

Extending [VkBlendOp](../chapters/framebuffer.html#VkBlendOp):

* 
`VK_BLEND_OP_BLUE_EXT`

* 
`VK_BLEND_OP_COLORBURN_EXT`

* 
`VK_BLEND_OP_COLORDODGE_EXT`

* 
`VK_BLEND_OP_CONTRAST_EXT`

* 
`VK_BLEND_OP_DARKEN_EXT`

* 
`VK_BLEND_OP_DIFFERENCE_EXT`

* 
`VK_BLEND_OP_DST_ATOP_EXT`

* 
`VK_BLEND_OP_DST_EXT`

* 
`VK_BLEND_OP_DST_IN_EXT`

* 
`VK_BLEND_OP_DST_OUT_EXT`

* 
`VK_BLEND_OP_DST_OVER_EXT`

* 
`VK_BLEND_OP_EXCLUSION_EXT`

* 
`VK_BLEND_OP_GREEN_EXT`

* 
`VK_BLEND_OP_HARDLIGHT_EXT`

* 
`VK_BLEND_OP_HARDMIX_EXT`

* 
`VK_BLEND_OP_HSL_COLOR_EXT`

* 
`VK_BLEND_OP_HSL_HUE_EXT`

* 
`VK_BLEND_OP_HSL_LUMINOSITY_EXT`

* 
`VK_BLEND_OP_HSL_SATURATION_EXT`

* 
`VK_BLEND_OP_INVERT_EXT`

* 
`VK_BLEND_OP_INVERT_OVG_EXT`

* 
`VK_BLEND_OP_INVERT_RGB_EXT`

* 
`VK_BLEND_OP_LIGHTEN_EXT`

* 
`VK_BLEND_OP_LINEARBURN_EXT`

* 
`VK_BLEND_OP_LINEARDODGE_EXT`

* 
`VK_BLEND_OP_LINEARLIGHT_EXT`

* 
`VK_BLEND_OP_MINUS_CLAMPED_EXT`

* 
`VK_BLEND_OP_MINUS_EXT`

* 
`VK_BLEND_OP_MULTIPLY_EXT`

* 
`VK_BLEND_OP_OVERLAY_EXT`

* 
`VK_BLEND_OP_PINLIGHT_EXT`

* 
`VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT`

* 
`VK_BLEND_OP_PLUS_CLAMPED_EXT`

* 
`VK_BLEND_OP_PLUS_DARKER_EXT`

* 
`VK_BLEND_OP_PLUS_EXT`

* 
`VK_BLEND_OP_RED_EXT`

* 
`VK_BLEND_OP_SCREEN_EXT`

* 
`VK_BLEND_OP_SOFTLIGHT_EXT`

* 
`VK_BLEND_OP_SRC_ATOP_EXT`

* 
`VK_BLEND_OP_SRC_EXT`

* 
`VK_BLEND_OP_SRC_IN_EXT`

* 
`VK_BLEND_OP_SRC_OUT_EXT`

* 
`VK_BLEND_OP_SRC_OVER_EXT`

* 
`VK_BLEND_OP_VIVIDLIGHT_EXT`

* 
`VK_BLEND_OP_XOR_EXT`

* 
`VK_BLEND_OP_ZERO_EXT`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT`

* 
`VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT`

None.

* 
Revision 1, 2017-06-12 (Jeff Bolz)

Internal revisions

Revision 2, 2017-06-12 (Jeff Bolz)

* 
Internal revisions

**Name String**

`VK_EXT_border_color_swizzle`

**Extension Type**

Device extension

**Registered Extension Number**

412

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_EXT_custom_border_color](#VK_EXT_custom_border_color)

**Special Uses**

* 
[OpenGL / ES support](../chapters/extensions.html#extendingvulkan-compatibility-specialuse)

* 
[D3D support](../chapters/extensions.html#extendingvulkan-compatibility-specialuse)

**Contact**

* 
Piers Daniell [pdaniell-nv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_border_color_swizzle] @pdaniell-nv%0A*Here describe the issue or question you have about the VK_EXT_border_color_swizzle extension*)

**Last Modified Date**

2021-10-12

**IP Status**

No known IP claims.

**Contributors**

* 
Graeme Leese, Broadcom

* 
Jan-Harald Fredriksen, Arm

* 
Ricardo Garcia, Igalia

* 
Shahbaz Youssefi, Google

* 
Stu Smith, AMD

After the publication of VK_EXT_custom_border_color, it was discovered that
some implementations had undefined behavior when combining a sampler that
uses a custom border color with image views whose component mapping is not
the identity mapping.

Since VK_EXT_custom_border_color has already shipped, this new extension
VK_EXT_border_color_swizzle was created to define the interaction between
custom border colors and non-identity image view swizzles, and provide a
work-around for implementations that must pre-swizzle the sampler border
color to match the image view component mapping it is combined with.

This extension also defines the behavior between samplers with an opaque
black border color and image views with a non-identity component swizzle,
which was previously left undefined.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceBorderColorSwizzleFeaturesEXT](../chapters/features.html#VkPhysicalDeviceBorderColorSwizzleFeaturesEXT)

Extending [VkSamplerCreateInfo](../chapters/samplers.html#VkSamplerCreateInfo):

* 
[VkSamplerBorderColorComponentMappingCreateInfoEXT](../chapters/samplers.html#VkSamplerBorderColorComponentMappingCreateInfoEXT)

* 
`VK_EXT_BORDER_COLOR_SWIZZLE_EXTENSION_NAME`

* 
`VK_EXT_BORDER_COLOR_SWIZZLE_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT`

* 
`VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT`

None.

* 
Revision 1, 2021-10-12 (Piers Daniell)

Internal revisions.

**Name String**

`VK_EXT_color_write_enable`

**Extension Type**

Device extension

**Registered Extension Number**

382

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Contact**

* 
Sharif Elcott [selcott](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_color_write_enable] @selcott%0A*Here describe the issue or question you have about the VK_EXT_color_write_enable extension*)

**Last Modified Date**

2020-02-25

**IP Status**

No known IP claims.

**Contributors**

* 
Sharif Elcott, Google

* 
Tobias Hector, AMD

* 
Piers Daniell, NVIDIA

This extension allows for selectively enabling and disabling writes to
output color attachments via a pipeline dynamic state.

The intended use cases for this new state are mostly identical to those of
colorWriteMask, such as selectively disabling writes to avoid feedback loops
between subpasses or bandwidth savings for unused outputs.
By making the state dynamic, one additional benefit is the ability to reduce
pipeline counts and pipeline switching via shaders that write a superset of
the desired data of which subsets are selected dynamically.
The reason for a new state, colorWriteEnable, rather than making
colorWriteMask dynamic is that, on many implementations, the more flexible
per-component semantics of the colorWriteMask state cannot be made dynamic
in a performant manner.

* 
[vkCmdSetColorWriteEnableEXT](../chapters/framebuffer.html#vkCmdSetColorWriteEnableEXT)

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceColorWriteEnableFeaturesEXT](../chapters/features.html#VkPhysicalDeviceColorWriteEnableFeaturesEXT)

Extending [VkPipelineColorBlendStateCreateInfo](../chapters/framebuffer.html#VkPipelineColorBlendStateCreateInfo):

* 
[VkPipelineColorWriteCreateInfoEXT](../chapters/framebuffer.html#VkPipelineColorWriteCreateInfoEXT)

* 
`VK_EXT_COLOR_WRITE_ENABLE_EXTENSION_NAME`

* 
`VK_EXT_COLOR_WRITE_ENABLE_SPEC_VERSION`

* 
Extending [VkDynamicState](../chapters/pipelines.html#VkDynamicState):

`VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT`

* 
`VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT`

* 
Revision 1, 2020-01-25 (Sharif Elcott)

Internal revisions

**Name String**

`VK_EXT_conditional_rendering`

**Extension Type**

Device extension

**Registered Extension Number**

82

**Revision**

2

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Contact**

* 
Vikram Kushwaha [vkushwaha](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_conditional_rendering] @vkushwaha%0A*Here describe the issue or question you have about the VK_EXT_conditional_rendering extension*)

**Last Modified Date**

2018-05-21

**IP Status**

No known IP claims.

**Contributors**

* 
Vikram Kushwaha, NVIDIA

* 
Daniel Rakos, AMD

* 
Jesse Hall, Google

* 
Jeff Bolz, NVIDIA

* 
Piers Daniell, NVIDIA

* 
Stuart Smith, Imagination Technologies

This extension allows the execution of one or more rendering commands to be
conditional on a value in buffer memory.
This may help an application reduce the latency by conditionally discarding
rendering commands without application intervention.
The conditional rendering commands are limited to draws, compute dispatches
and clearing attachments within a conditional rendering block.

* 
[vkCmdBeginConditionalRenderingEXT](../chapters/drawing.html#vkCmdBeginConditionalRenderingEXT)

* 
[vkCmdEndConditionalRenderingEXT](../chapters/drawing.html#vkCmdEndConditionalRenderingEXT)

* 
[VkConditionalRenderingBeginInfoEXT](../chapters/drawing.html#VkConditionalRenderingBeginInfoEXT)

* 
Extending [VkCommandBufferInheritanceInfo](../chapters/cmdbuffers.html#VkCommandBufferInheritanceInfo):

[VkCommandBufferInheritanceConditionalRenderingInfoEXT](../chapters/cmdbuffers.html#VkCommandBufferInheritanceConditionalRenderingInfoEXT)

Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

* 
[VkPhysicalDeviceConditionalRenderingFeaturesEXT](../chapters/features.html#VkPhysicalDeviceConditionalRenderingFeaturesEXT)

* 
[VkConditionalRenderingFlagBitsEXT](../chapters/drawing.html#VkConditionalRenderingFlagBitsEXT)

* 
[VkConditionalRenderingFlagsEXT](../chapters/drawing.html#VkConditionalRenderingFlagsEXT)

* 
`VK_EXT_CONDITIONAL_RENDERING_EXTENSION_NAME`

* 
`VK_EXT_CONDITIONAL_RENDERING_SPEC_VERSION`

* 
Extending [VkAccessFlagBits](../chapters/synchronization.html#VkAccessFlagBits):

`VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT`

Extending [VkBufferUsageFlagBits](../chapters/resources.html#VkBufferUsageFlagBits):

* 
`VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT`

Extending [VkPipelineStageFlagBits](../chapters/synchronization.html#VkPipelineStageFlagBits):

* 
`VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT`

1) Should conditional rendering affect copy and blit commands?

**RESOLVED**: Conditional rendering should not affect copies and blits.

2) Should secondary command buffers be allowed to execute while conditional
rendering is active in the primary command buffer?

**RESOLVED**: The rendering commands in secondary command buffer will be
affected by an active conditional rendering in primary command buffer if the
`conditionalRenderingEnable` is set to `VK_TRUE`.
Conditional rendering **must** not be active in the primary command buffer if
`conditionalRenderingEnable` is `VK_FALSE`.

None.

* 
Revision 1, 2018-04-19 (Vikram Kushwaha)

First Version

Revision 2, 2018-05-21 (Vikram Kushwaha)

* 
Add new pipeline stage, access flags and limit conditional rendering to
a subpass or entire render pass.

**Name String**

`VK_EXT_conservative_rasterization`

**Extension Type**

Device extension

**Registered Extension Number**

102

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**SPIR-V Dependencies**

* 
[SPV_EXT_fragment_fully_covered](https://github.khronos.org/SPIRV-Registry/extensions/EXT/SPV_EXT_fragment_fully_covered.html)

**Contact**

* 
Piers Daniell [pdaniell-nv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_conservative_rasterization] @pdaniell-nv%0A*Here describe the issue or question you have about the VK_EXT_conservative_rasterization extension*)

**Last Modified Date**

2020-06-09

**Interactions and External Dependencies**

* 
This extension requires
[`SPV_EXT_fragment_fully_covered`](https://github.khronos.org/SPIRV-Registry/extensions/EXT/SPV_EXT_fragment_fully_covered.html)
if the
`VkPhysicalDeviceConservativeRasterizationPropertiesEXT`::`fullyCoveredFragmentShaderInputVariable`
feature is used.

* 
This extension requires
[`SPV_KHR_post_depth_coverage`](https://github.khronos.org/SPIRV-Registry/extensions/KHR/SPV_KHR_post_depth_coverage.html)if
the
`VkPhysicalDeviceConservativeRasterizationPropertiesEXT`::`conservativeRasterizationPostDepthCoverage`
feature is used.

* 
This extension provides API support for
[`GL_NV_conservative_raster_underestimation`](https://registry.khronos.org/OpenGL/extensions/NV/NV_conservative_raster_underestimation.txt)
if the
`VkPhysicalDeviceConservativeRasterizationPropertiesEXT`::`fullyCoveredFragmentShaderInputVariable`
feature is used.

**Contributors**

* 
Daniel Koch, NVIDIA

* 
Daniel Rakos, AMD

* 
Jeff Bolz, NVIDIA

* 
Slawomir Grajewski, Intel

* 
Stu Smith, Imagination Technologies

This extension adds a new rasterization mode called conservative
rasterization.
There are two modes of conservative rasterization; overestimation and
underestimation.

When overestimation is enabled, if any part of the primitive, including its
edges, covers any part of the rectangular pixel area, including its sides,
then a fragment is generated with all coverage samples turned on.
This extension allows for some variation in implementations by accounting
for differences in overestimation, where the generating primitive size is
increased at each of its edges by some sub-pixel amount to further increase
conservative pixel coverage.
Implementations can allow the application to specify an extra overestimation
beyond the base overestimation the implementation already does.
It also allows implementations to either cull degenerate primitives or
rasterize them.

When underestimation is enabled, fragments are only generated if the
rectangular pixel area is fully covered by the generating primitive.
If supported by the implementation, when a pixel rectangle is fully covered
the fragment shader input variable builtin called FullyCoveredEXT is set to
true.
The shader variable works in either overestimation or underestimation mode.

Implementations can process degenerate triangles and lines by either
discarding them or generating conservative fragments for them.
Degenerate triangles are those that end up with zero area after the
rasterizer quantizes them to the fixed-point pixel grid.
Degenerate lines are those with zero length after quantization.

* 
Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

[VkPhysicalDeviceConservativeRasterizationPropertiesEXT](../chapters/limits.html#VkPhysicalDeviceConservativeRasterizationPropertiesEXT)

Extending [VkPipelineRasterizationStateCreateInfo](../chapters/primsrast.html#VkPipelineRasterizationStateCreateInfo):

* 
[VkPipelineRasterizationConservativeStateCreateInfoEXT](../chapters/primsrast.html#VkPipelineRasterizationConservativeStateCreateInfoEXT)

* 
[VkConservativeRasterizationModeEXT](../chapters/primsrast.html#VkConservativeRasterizationModeEXT)

* 
[VkPipelineRasterizationConservativeStateCreateFlagsEXT](../chapters/primsrast.html#VkPipelineRasterizationConservativeStateCreateFlagsEXT)

* 
`VK_EXT_CONSERVATIVE_RASTERIZATION_EXTENSION_NAME`

* 
`VK_EXT_CONSERVATIVE_RASTERIZATION_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT`

* 
`VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT`

* 
[FullyCoveredEXT](../chapters/interfaces.html#interfaces-builtin-variables-fullycoveredext)

* 
[    FragmentFullyCoveredEXT](spirvenv.html#spirvenv-capabilities-table-FragmentFullyCoveredEXT)

* 
Revision 1.1, 2020-09-06 (Piers Daniell)

Add missing SPIR-V and GLSL dependencies.

Revision 1, 2017-08-28 (Piers Daniell)

* 
Internal revisions

**Name String**

`VK_EXT_custom_border_color`

**Extension Type**

Device extension

**Registered Extension Number**

288

**Revision**

12

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Special Uses**

* 
[OpenGL / ES support](../chapters/extensions.html#extendingvulkan-compatibility-specialuse)

* 
[D3D support](../chapters/extensions.html#extendingvulkan-compatibility-specialuse)

**Contact**

* 
Liam Middlebrook [liam-middlebrook](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_custom_border_color] @liam-middlebrook%0A*Here describe the issue or question you have about the VK_EXT_custom_border_color extension*)

**Last Modified Date**

2020-04-16

**IP Status**

No known IP claims.

**Contributors**

* 
Joshua Ashton, Valve

* 
Hans-Kristian Arntzen, Valve

* 
Philip Rebohle, Valve

* 
Liam Middlebrook, NVIDIA

* 
Jeff Bolz, NVIDIA

* 
Tobias Hector, AMD

* 
Faith Ekstrand, Intel

* 
Spencer Fricke, Samsung Electronics

* 
Graeme Leese, Broadcom

* 
Jesse Hall, Google

* 
Jan-Harald Fredriksen, ARM

* 
Tom Olson, ARM

* 
Stuart Smith, Imagination Technologies

* 
Donald Scorgie, Imagination Technologies

* 
Alex Walters, Imagination Technologies

* 
Peter Quayle, Imagination Technologies

This extension provides cross-vendor functionality to specify a custom
border color for use when the sampler address mode
`VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER` is used.

To create a sampler which uses a custom border color set
[VkSamplerCreateInfo](../chapters/samplers.html#VkSamplerCreateInfo)::`borderColor` to one of:

* 
`VK_BORDER_COLOR_FLOAT_CUSTOM_EXT`

* 
`VK_BORDER_COLOR_INT_CUSTOM_EXT`

When `VK_BORDER_COLOR_FLOAT_CUSTOM_EXT` or
`VK_BORDER_COLOR_INT_CUSTOM_EXT` is used, applications must provide a
[VkSamplerCustomBorderColorCreateInfoEXT](../chapters/samplers.html#VkSamplerCustomBorderColorCreateInfoEXT) in the `pNext` chain for
[VkSamplerCreateInfo](../chapters/samplers.html#VkSamplerCreateInfo).

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceCustomBorderColorFeaturesEXT](../chapters/features.html#VkPhysicalDeviceCustomBorderColorFeaturesEXT)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceCustomBorderColorPropertiesEXT](../chapters/limits.html#VkPhysicalDeviceCustomBorderColorPropertiesEXT)

Extending [VkSamplerCreateInfo](../chapters/samplers.html#VkSamplerCreateInfo):

* 
[VkSamplerCustomBorderColorCreateInfoEXT](../chapters/samplers.html#VkSamplerCustomBorderColorCreateInfoEXT)

* 
`VK_EXT_CUSTOM_BORDER_COLOR_EXTENSION_NAME`

* 
`VK_EXT_CUSTOM_BORDER_COLOR_SPEC_VERSION`

* 
Extending [VkBorderColor](../chapters/samplers.html#VkBorderColor):

`VK_BORDER_COLOR_FLOAT_CUSTOM_EXT`

* 
`VK_BORDER_COLOR_INT_CUSTOM_EXT`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT`

* 
`VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT`

1) Should VkClearColorValue be used for the border color value, or should we
have our own struct/union? Do we need to specify the type of the input
values for the components? This is more of a concern if VkClearColorValue is
used here because it provides a union of float,int,uint types.

**RESOLVED**: Will reuse existing VkClearColorValue structure in order to
easily take advantage of float,int,uint borderColor types.

2) For hardware which supports a limited number of border colors what
happens if that number is exceeded? Should this be handled by the driver
unbeknownst to the application? In Revision 1 we had solved this issue using
a new Object type, however that may have lead to additional system resource
consumption which would otherwise not be required.

**RESOLVED**: Added
`VkPhysicalDeviceCustomBorderColorPropertiesEXT`::`maxCustomBorderColorSamplers`
for tracking implementation-specific limit, and Valid Usage statement
handling overflow.

3) Should this be supported for immutable samplers at all, or by a feature
bit? Some implementations may not be able to support custom border colors on
immutable samplersis it worthwhile enabling this to work on them for
implementations that can support it, or forbidding it entirely.

**RESOLVED**: Samplers created with a custom border color are forbidden from
being immutable.
This resolves concerns for implementations where the custom border color is
an index to a LUT instead of being directly embedded into sampler state.

4) Should UINT and SINT (unsigned integer and signed integer) border color
types be separated or should they be combined into one generic INT (integer)
type?

**RESOLVED**: Separating these does not make much sense as the existing fixed
border color types do not have this distinction, and there is no reason in
hardware to do so.
This separation would also create unnecessary work and considerations for
the application.

* 
Revision 1, 2019-10-10 (Joshua Ashton)

Internal revisions.

Revision 2, 2019-10-11 (Liam Middlebrook)

* 
Remove VkCustomBorderColor object and associated functions

* 
Add issues concerning HW limitations for custom border color count

Revision 3, 2019-10-12 (Joshua Ashton)

* 
Re-expose the limits for the maximum number of unique border colors

* 
Add extra details about border color tracking

* 
Fix typos

Revision 4, 2019-10-12 (Joshua Ashton)

* 
Changed maxUniqueCustomBorderColors to a uint32_t from a VkDeviceSize

Revision 5, 2019-10-14 (Liam Middlebrook)

* 
Added features bit

Revision 6, 2019-10-15 (Joshua Ashton)

* 
Type-ize VK_BORDER_COLOR_CUSTOM

* 
Fix const-ness on `pNext` of
VkSamplerCustomBorderColorCreateInfoEXT

Revision 7, 2019-11-26 (Liam Middlebrook)

* 
Renamed maxUniqueCustomBorderColors to maxCustomBorderColors

Revision 8, 2019-11-29 (Joshua Ashton)

* 
Renamed borderColor member of VkSamplerCustomBorderColorCreateInfoEXT
to customBorderColor

Revision 9, 2020-02-19 (Joshua Ashton)

* 
Renamed maxCustomBorderColors to maxCustomBorderColorSamplers

Revision 10, 2020-02-21 (Joshua Ashton)

* 
Added format to VkSamplerCustomBorderColorCreateInfoEXT and feature bit

Revision 11, 2020-04-07 (Joshua Ashton)

* 
Dropped UINT/SINT border color differences, consolidated types

Revision 12, 2020-04-16 (Joshua Ashton)

* 
Renamed VK_BORDER_COLOR_CUSTOM_FLOAT_EXT to
VK_BORDER_COLOR_FLOAT_CUSTOM_EXT for consistency

**Name String**

`VK_EXT_debug_utils`

**Extension Type**

Instance extension

**Registered Extension Number**

129

**Revision**

2

**Ratification Status**

Ratified

**Extension and Version Dependencies**

None

**Special Use**

* 
[Debugging tools](../chapters/extensions.html#extendingvulkan-compatibility-specialuse)

**Contact**

* 
Mark Young [marky-lunarg](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_debug_utils] @marky-lunarg%0A*Here describe the issue or question you have about the VK_EXT_debug_utils extension*)

**Last Modified Date**

2020-04-03

**Revision**

2

**IP Status**

No known IP claims.

**Dependencies**

* 
This extension is written against version 1.0 of the Vulkan API.

* 
Requires [VkObjectType](../chapters/debugging.html#VkObjectType)

**Contributors**

* 
Mark Young, LunarG

* 
Baldur Karlsson

* 
Ian Elliott, Google

* 
Courtney Goeltzenleuchter, Google

* 
Karl Schultz, LunarG

* 
Mark Lobodzinski, LunarG

* 
Mike Schuchardt, LunarG

* 
Jaakko Konttinen, AMD

* 
Dan Ginsburg, Valve Software

* 
Rolando Olivares, Epic Games

* 
Dan Baker, Oxide Games

* 
Kyle Spagnoli, NVIDIA

* 
Jon Ashburn, LunarG

* 
Piers Daniell, NVIDIA

Due to the nature of the Vulkan interface, there is very little error
information available to the developer and application.
By using the `VK_EXT_debug_utils` extension, developers **can** obtain more
information.
When combined with validation layers, even more detailed feedback on the
applications use of Vulkan will be provided.

This extension provides the following capabilities:

* 
The ability to create a debug messenger which will pass along debug
messages to an application supplied callback.

* 
The ability to identify specific Vulkan objects using a name or tag to
improve tracking.

* 
The ability to identify specific sections within a `VkQueue` or
`VkCommandBuffer` using labels to aid organization and offline
analysis in external tools.

The main difference between this extension and `[VK_EXT_debug_report](#VK_EXT_debug_report)`
and `[VK_EXT_debug_marker](#VK_EXT_debug_marker)` is that those extensions use
[VkDebugReportObjectTypeEXT](../chapters/debugging.html#VkDebugReportObjectTypeEXT) to identify objects.
This extension uses the core [VkObjectType](../chapters/debugging.html#VkObjectType) in place of
[VkDebugReportObjectTypeEXT](../chapters/debugging.html#VkDebugReportObjectTypeEXT).
The primary reason for this move is that no future object type handle
enumeration values will be added to [VkDebugReportObjectTypeEXT](../chapters/debugging.html#VkDebugReportObjectTypeEXT) since
the creation of [VkObjectType](../chapters/debugging.html#VkObjectType).

In addition, this extension combines the functionality of both
`[VK_EXT_debug_report](#VK_EXT_debug_report)` and `[VK_EXT_debug_marker](#VK_EXT_debug_marker)` by allowing
object name and debug markers (now called labels) to be returned to the
applications callback function.
This should assist in clarifying the details of a debug message including:
what objects are involved and potentially which location within a
[VkQueue](../chapters/devsandqueues.html#VkQueue) or [VkCommandBuffer](../chapters/cmdbuffers.html#VkCommandBuffer) the message occurred.

* 
[VkDebugUtilsMessengerEXT](../chapters/debugging.html#VkDebugUtilsMessengerEXT)

* 
[vkCmdBeginDebugUtilsLabelEXT](../chapters/debugging.html#vkCmdBeginDebugUtilsLabelEXT)

* 
[vkCmdEndDebugUtilsLabelEXT](../chapters/debugging.html#vkCmdEndDebugUtilsLabelEXT)

* 
[vkCmdInsertDebugUtilsLabelEXT](../chapters/debugging.html#vkCmdInsertDebugUtilsLabelEXT)

* 
[vkCreateDebugUtilsMessengerEXT](../chapters/debugging.html#vkCreateDebugUtilsMessengerEXT)

* 
[vkDestroyDebugUtilsMessengerEXT](../chapters/debugging.html#vkDestroyDebugUtilsMessengerEXT)

* 
[vkQueueBeginDebugUtilsLabelEXT](../chapters/debugging.html#vkQueueBeginDebugUtilsLabelEXT)

* 
[vkQueueEndDebugUtilsLabelEXT](../chapters/debugging.html#vkQueueEndDebugUtilsLabelEXT)

* 
[vkQueueInsertDebugUtilsLabelEXT](../chapters/debugging.html#vkQueueInsertDebugUtilsLabelEXT)

* 
[vkSetDebugUtilsObjectNameEXT](../chapters/debugging.html#vkSetDebugUtilsObjectNameEXT)

* 
[vkSetDebugUtilsObjectTagEXT](../chapters/debugging.html#vkSetDebugUtilsObjectTagEXT)

* 
[vkSubmitDebugUtilsMessageEXT](../chapters/debugging.html#vkSubmitDebugUtilsMessageEXT)

* 
[VkDebugUtilsLabelEXT](../chapters/debugging.html#VkDebugUtilsLabelEXT)

* 
[VkDebugUtilsMessengerCallbackDataEXT](../chapters/debugging.html#VkDebugUtilsMessengerCallbackDataEXT)

* 
[VkDebugUtilsObjectTagInfoEXT](../chapters/debugging.html#VkDebugUtilsObjectTagInfoEXT)

* 
Extending [VkInstanceCreateInfo](../chapters/initialization.html#VkInstanceCreateInfo):

[VkDebugUtilsMessengerCreateInfoEXT](../chapters/debugging.html#VkDebugUtilsMessengerCreateInfoEXT)

Extending [VkPipelineShaderStageCreateInfo](../chapters/pipelines.html#VkPipelineShaderStageCreateInfo):

* 
[VkDebugUtilsObjectNameInfoEXT](../chapters/debugging.html#VkDebugUtilsObjectNameInfoEXT)

* 
[PFN_vkDebugUtilsMessengerCallbackEXT](../chapters/debugging.html#PFN_vkDebugUtilsMessengerCallbackEXT)

* 
[VkDebugUtilsMessageSeverityFlagBitsEXT](../chapters/debugging.html#VkDebugUtilsMessageSeverityFlagBitsEXT)

* 
[VkDebugUtilsMessageTypeFlagBitsEXT](../chapters/debugging.html#VkDebugUtilsMessageTypeFlagBitsEXT)

* 
[VkDebugUtilsMessageSeverityFlagsEXT](../chapters/debugging.html#VkDebugUtilsMessageSeverityFlagsEXT)

* 
[VkDebugUtilsMessageTypeFlagsEXT](../chapters/debugging.html#VkDebugUtilsMessageTypeFlagsEXT)

* 
[VkDebugUtilsMessengerCallbackDataFlagsEXT](../chapters/debugging.html#VkDebugUtilsMessengerCallbackDataFlagsEXT)

* 
[VkDebugUtilsMessengerCreateFlagsEXT](../chapters/debugging.html#VkDebugUtilsMessengerCreateFlagsEXT)

* 
`VK_EXT_DEBUG_UTILS_EXTENSION_NAME`

* 
`VK_EXT_DEBUG_UTILS_SPEC_VERSION`

* 
Extending [VkObjectType](../chapters/debugging.html#VkObjectType):

`VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT`

* 
`VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT`

* 
`VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT`

**Example 1**

`VK_EXT_debug_utils` allows an application to register multiple callbacks
with any Vulkan component wishing to report debug information.
Some callbacks may log the information to a file, others may cause a debug
break point or other application-defined behavior.
An application **can** register callbacks even when no validation layers are
enabled, but they will only be called for loader and, if implemented, driver
events.

To capture events that occur while creating or destroying an instance an
application **can** link a [VkDebugUtilsMessengerCreateInfoEXT](../chapters/debugging.html#VkDebugUtilsMessengerCreateInfoEXT) structure
to the `pNext` chain of the [VkInstanceCreateInfo](../chapters/initialization.html#VkInstanceCreateInfo) structure passed
to [vkCreateInstance](../chapters/initialization.html#vkCreateInstance).

Example uses: Create three callback objects.
One will log errors and warnings to the debug console using Windows
`OutputDebugString`.
The second will cause the debugger to break at that callback when an error
happens and the third will log warnings to stdout.

    extern VkInstance instance;
    VkResult res;
    VkDebugUtilsMessengerEXT cb1, cb2, cb3;

    // Must call extension functions through a function pointer:
    PFN_vkCreateDebugUtilsMessengerEXT pfnCreateDebugUtilsMessengerEXT = (PFN_vkCreateDebugUtilsMessengerEXT)vkGetInstanceProcAddr(instance, "vkCreateDebugUtilsMessengerEXT");
    PFN_vkDestroyDebugUtilsMessengerEXT pfnDestroyDebugUtilsMessengerEXT = (PFN_vkDestroyDebugUtilsMessengerEXT)vkGetInstanceProcAddr(instance, "vkDestroyDebugUtilsMessengerEXT");

    VkDebugUtilsMessengerCreateInfoEXT callback1 = {
        .sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT,
        .pNext = NULL,
        .flags = 0,
        .messageSeverity = VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT |
                           VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT,
        .messageType= VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT |
                      VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT,
        .pfnUserCallback = myOutputDebugString,
        .pUserData = NULL
    };
    res = pfnCreateDebugUtilsMessengerEXT(instance, &callback1, NULL, &cb1);
    if (res != VK_SUCCESS) {
       // Do error handling for VK_ERROR_OUT_OF_MEMORY
    }

    callback1.messageSeverity = VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT;
    callback1.pfnUserCallback = myDebugBreak;
    callback1.pUserData = NULL;
    res = pfnCreateDebugUtilsMessengerEXT(instance, &callback1, NULL, &cb2);
    if (res != VK_SUCCESS) {
       // Do error handling for VK_ERROR_OUT_OF_MEMORY
    }

    VkDebugUtilsMessengerCreateInfoEXT callback3 = {
        .sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT,
        .pNext = NULL,
        .flags = 0,
        .messageSeverity = VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT,
        .messageType = VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT |
                       VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT,
        .pfnUserCallback = mystdOutLogger,
        .pUserData = NULL
    };
    res = pfnCreateDebugUtilsMessengerEXT(instance, &callback3, NULL, &cb3);
    if (res != VK_SUCCESS) {
       // Do error handling for VK_ERROR_OUT_OF_MEMORY
    }

    ...

    // Remove callbacks when cleaning up
    pfnDestroyDebugUtilsMessengerEXT(instance, cb1, NULL);
    pfnDestroyDebugUtilsMessengerEXT(instance, cb2, NULL);
    pfnDestroyDebugUtilsMessengerEXT(instance, cb3, NULL);

**Example 2**

Associate a name with an image, for easier debugging in external tools or
with validation layers that can print a friendly name when referring to
objects in error messages.

    extern VkInstance instance;
    extern VkDevice device;
    extern VkImage image;

    // Must call extension functions through a function pointer:
    PFN_vkSetDebugUtilsObjectNameEXT pfnSetDebugUtilsObjectNameEXT = (PFN_vkSetDebugUtilsObjectNameEXT)vkGetInstanceProcAddr(instance, "vkSetDebugUtilsObjectNameEXT");

    // Set a name on the image
    const VkDebugUtilsObjectNameInfoEXT imageNameInfo =
    {
        .sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT,
        .pNext = NULL,
        .objectType = VK_OBJECT_TYPE_IMAGE,
        .objectHandle = (uint64_t)image,
        .pObjectName = "Brick Diffuse Texture",
    };

    pfnSetDebugUtilsObjectNameEXT(device, &imageNameInfo);

    // A subsequent error might print:
    //   Image 'Brick Diffuse Texture' (0xc0dec0dedeadbeef) is used in a
    //   command buffer with no memory bound to it.

**Example 3**

Annotating regions of a workload with naming information so that offline
analysis tools can display a more usable visualization of the commands
submitted.

    extern VkInstance instance;
    extern VkCommandBuffer commandBuffer;

    // Must call extension functions through a function pointer:
    PFN_vkQueueBeginDebugUtilsLabelEXT pfnQueueBeginDebugUtilsLabelEXT = (PFN_vkQueueBeginDebugUtilsLabelEXT)vkGetInstanceProcAddr(instance, "vkQueueBeginDebugUtilsLabelEXT");
    PFN_vkQueueEndDebugUtilsLabelEXT pfnQueueEndDebugUtilsLabelEXT = (PFN_vkQueueEndDebugUtilsLabelEXT)vkGetInstanceProcAddr(instance, "vkQueueEndDebugUtilsLabelEXT");
    PFN_vkCmdBeginDebugUtilsLabelEXT pfnCmdBeginDebugUtilsLabelEXT = (PFN_vkCmdBeginDebugUtilsLabelEXT)vkGetInstanceProcAddr(instance, "vkCmdBeginDebugUtilsLabelEXT");
    PFN_vkCmdEndDebugUtilsLabelEXT pfnCmdEndDebugUtilsLabelEXT = (PFN_vkCmdEndDebugUtilsLabelEXT)vkGetInstanceProcAddr(instance, "vkCmdEndDebugUtilsLabelEXT");
    PFN_vkCmdInsertDebugUtilsLabelEXT pfnCmdInsertDebugUtilsLabelEXT = (PFN_vkCmdInsertDebugUtilsLabelEXT)vkGetInstanceProcAddr(instance, "vkCmdInsertDebugUtilsLabelEXT");

    // Describe the area being rendered
    const VkDebugUtilsLabelEXT houseLabel =
    {
        .sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT,
        .pNext = NULL,
        .pLabelName = "Brick House",
        .color = { 1.0f, 0.0f, 0.0f, 1.0f },
    };

    // Start an annotated group of calls under the 'Brick House' name
    pfnCmdBeginDebugUtilsLabelEXT(commandBuffer, &houseLabel);
    {
        // A mutable structure for each part being rendered
        VkDebugUtilsLabelEXT housePartLabel =
        {
            .sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT,
            .pNext = NULL,
            .pLabelName = NULL,
            .color = { 0.0f, 0.0f, 0.0f, 0.0f },
        };

        // Set the name and insert the marker
        housePartLabel.pLabelName = "Walls";
        pfnCmdInsertDebugUtilsLabelEXT(commandBuffer, &housePartLabel);

        // Insert the drawcall for the walls
        vkCmdDrawIndexed(commandBuffer, 1000, 1, 0, 0, 0);

        // Insert a recursive region for two sets of windows
        housePartLabel.pLabelName = "Windows";
        pfnCmdBeginDebugUtilsLabelEXT(commandBuffer, &housePartLabel);
        {
            vkCmdDrawIndexed(commandBuffer, 75, 6, 1000, 0, 0);
            vkCmdDrawIndexed(commandBuffer, 100, 2, 1450, 0, 0);
        }
        pfnCmdEndDebugUtilsLabelEXT(commandBuffer);

        housePartLabel.pLabelName = "Front Door";
        pfnCmdInsertDebugUtilsLabelEXT(commandBuffer, &housePartLabel);

        vkCmdDrawIndexed(commandBuffer, 350, 1, 1650, 0, 0);

        housePartLabel.pLabelName = "Roof";
        pfnCmdInsertDebugUtilsLabelEXT(commandBuffer, &housePartLabel);

        vkCmdDrawIndexed(commandBuffer, 500, 1, 2000, 0, 0);
    }
    // End the house annotation started above
    pfnCmdEndDebugUtilsLabelEXT(commandBuffer);

    // Do other work

    vkEndCommandBuffer(commandBuffer);

    // Describe the queue being used
    const VkDebugUtilsLabelEXT queueLabel =
    {
        .sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT,
        .pNext = NULL,
        .pLabelName = "Main Render Work",
        .color = { 0.0f, 1.0f, 0.0f, 1.0f },
    };

    // Identify the queue label region
    pfnQueueBeginDebugUtilsLabelEXT(queue, &queueLabel);

    // Submit the work for the main render thread
    const VkCommandBuffer cmd_bufs[] = {commandBuffer};
    VkSubmitInfo submit_info =
    {
        .sType = VK_STRUCTURE_TYPE_SUBMIT_INFO,
        .pNext = NULL,
        .waitSemaphoreCount = 0,
        .pWaitSemaphores = NULL,
        .pWaitDstStageMask = NULL,
        .commandBufferCount = 1,
        .pCommandBuffers = cmd_bufs,
        .signalSemaphoreCount = 0,
        .pSignalSemaphores = NULL
    };
    vkQueueSubmit(queue, 1, &submit_info, fence);

    // End the queue label region
    pfnQueueEndDebugUtilsLabelEXT(queue);

1) Should we just name this extension `VK_EXT_debug_report2`

**RESOLVED**: No.
There is enough additional changes to the structures to break backwards
compatibility.
So, a new name was decided that would not indicate any interaction with the
previous extension.

2) Will validation layers immediately support all the new features.

**RESOLVED**: Not immediately.
As one can imagine, there is a lot of work involved with converting the
validation layer logging over to the new functionality.
Basic logging, as seen in the origin `[VK_EXT_debug_report](#VK_EXT_debug_report)` extension
will be made available immediately.
However, adding the labels and object names will take time.
Since the priority for Khronos at this time is to continue focusing on Valid
Usage statements, it may take a while before the new functionality is fully
exposed.

3) If the validation layers will not expose the new functionality
immediately, then what is the point of this extension?

**RESOLVED**: We needed a replacement for `[VK_EXT_debug_report](#VK_EXT_debug_report)` because
the [VkDebugReportObjectTypeEXT](../chapters/debugging.html#VkDebugReportObjectTypeEXT) enumeration will no longer be updated
and any new objects will need to be debugged using the new functionality
provided by this extension.

4) Should this extension be split into two separate parts (1 extension that
is an instance extension providing the callback functionality, and another
device extension providing the general debug marker and annotation
functionality)?

**RESOLVED**: No, the functionality for this extension is too closely related.
If we did split up the extension, where would the structures and enums live,
and how would you define that the device behavior in the instance extension
is really only valid if the device extension is enabled, and the
functionality is passed in.
It is cleaner to just define this all as an instance extension, plus it
allows the application to enable all debug functionality provided with one
enable string during [vkCreateInstance](../chapters/initialization.html#vkCreateInstance).

* 
Revision 1, 2017-09-14 (Mark Young and all listed Contributors)

Initial draft, based on `[VK_EXT_debug_report](#VK_EXT_debug_report)` and
`[VK_EXT_debug_marker](#VK_EXT_debug_marker)` in addition to previous feedback supplied
from various companies including Valve, Epic, and Oxide games.

Revision 2, 2020-04-03 (Mark Young and Piers Daniell)

* 
Updated to allow either `NULL` or an empty string to be passed in for
`pObjectName` in `VkDebugUtilsObjectNameInfoEXT`, because the
loader and various drivers support `NULL` already.

**Name String**

`VK_EXT_depth_bias_control`

**Extension Type**

Device extension

**Registered Extension Number**

284

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Special Use**

* 
[D3D support](../chapters/extensions.html#extendingvulkan-compatibility-specialuse)

**Contact**

* 
Joshua Ashton [Joshua-Ashton](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_depth_bias_control] @Joshua-Ashton%0A*Here describe the issue or question you have about the VK_EXT_depth_bias_control extension*)

**Extension Proposal**

[VK_EXT_depth_bias_control](../../../features/latest/features/proposals/VK_EXT_depth_bias_control.html)

**Last Modified Date**

2023-02-15

**IP Status**

No known IP claims.

**Contributors**

* 
Joshua Ashton, VALVE

* 
Hans-Kristian Arntzen, VALVE

* 
Mike Blumenkrantz, VALVE

* 
Georg Lehmann, VALVE

* 
Piers Daniell, NVIDIA

* 
Lionel Landwerlin, INTEL

* 
Tobias Hector, AMD

* 
Ricardo Garcia, IGALIA

* 
Jan-Harald Fredriksen, ARM

* 
Shahbaz Youssefi, GOOGLE

* 
Tom Olson, ARM

This extension adds a new structure, `VkDepthBiasRepresentationInfoEXT`,
that can be added to a `pNext` chain of
`VkPipelineRasterizationStateCreateInfo` and allows setting the scaling
and representation of depth bias for a pipeline.

This state can also be set dynamically by using the new structure mentioned
above in combination with the new `vkCmdSetDepthBias2EXT` command.

* 
[vkCmdSetDepthBias2EXT](../chapters/primsrast.html#vkCmdSetDepthBias2EXT)

* 
[VkDepthBiasInfoEXT](../chapters/primsrast.html#VkDepthBiasInfoEXT)

* 
Extending [VkDepthBiasInfoEXT](../chapters/primsrast.html#VkDepthBiasInfoEXT), [VkPipelineRasterizationStateCreateInfo](../chapters/primsrast.html#VkPipelineRasterizationStateCreateInfo):

[VkDepthBiasRepresentationInfoEXT](../chapters/primsrast.html#VkDepthBiasRepresentationInfoEXT)

Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

* 
[VkPhysicalDeviceDepthBiasControlFeaturesEXT](../chapters/features.html#VkPhysicalDeviceDepthBiasControlFeaturesEXT)

* 
[VkDepthBiasRepresentationEXT](../chapters/primsrast.html#VkDepthBiasRepresentationEXT)

* 
`VK_EXT_DEPTH_BIAS_CONTROL_EXTENSION_NAME`

* 
`VK_EXT_DEPTH_BIAS_CONTROL_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_DEPTH_BIAS_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT`

* 
Revision 1, 2022-09-22 (Joshua Ashton)

Initial draft.

**Name String**

`VK_EXT_depth_clamp_control`

**Extension Type**

Device extension

**Registered Extension Number**

583

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Contact**

* 
Jules Blok [jules](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_depth_clamp_control] @jules%0A*Here describe the issue or question you have about the VK_EXT_depth_clamp_control extension*)

**Extension Proposal**

[VK_EXT_depth_clamp_control](../../../features/latest/features/proposals/VK_EXT_depth_clamp_control.html)

**Last Modified Date**

2024-07-15

**Contributors**

* 
Jules Blok, Independent

This extension allows the application to control the viewport depth clamp
range separately from the viewport `minDepth` and `maxDepth`.
This gives the ability for the application to restrict depth values to an
application-defined range rather than
the viewport depth range or the range defined in the
[VK_EXT_depth_clamp_zero_one](#VK_EXT_depth_clamp_zero_one) extension.

It can be used to set a smaller or larger clamping range than the viewport
depth range without affecting the depth mapping of the viewport transform.
Another possible use of this extension is to restrict depth values beyond
the viewport depth range to a clamping range other than the [0, 1] range
defined in the [VK_EXT_depth_clamp_zero_one](#VK_EXT_depth_clamp_zero_one) extension.

* 
[vkCmdSetDepthClampRangeEXT](../chapters/fragops.html#vkCmdSetDepthClampRangeEXT)

* 
[VkDepthClampRangeEXT](../chapters/fragops.html#VkDepthClampRangeEXT)

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceDepthClampControlFeaturesEXT](../chapters/features.html#VkPhysicalDeviceDepthClampControlFeaturesEXT)

Extending [VkPipelineViewportStateCreateInfo](../chapters/vertexpostproc.html#VkPipelineViewportStateCreateInfo):

* 
[VkPipelineViewportDepthClampControlCreateInfoEXT](../chapters/fragops.html#VkPipelineViewportDepthClampControlCreateInfoEXT)

* 
[VkDepthClampModeEXT](../chapters/fragops.html#VkDepthClampModeEXT)

* 
`VK_EXT_DEPTH_CLAMP_CONTROL_EXTENSION_NAME`

* 
`VK_EXT_DEPTH_CLAMP_CONTROL_SPEC_VERSION`

* 
Extending [VkDynamicState](../chapters/pipelines.html#VkDynamicState):

`VK_DYNAMIC_STATE_DEPTH_CLAMP_RANGE_EXT`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_CONTROL_FEATURES_EXT`

* 
`VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLAMP_CONTROL_CREATE_INFO_EXT`

1) Should the depth clamp range be a per-viewport parameter?

**RESOLVED**: No.
Because the depth clamp range was previously defined to be equal to the
viewport depth range, conformant runtimes are already handling the depth
clamp range as a per-viewport parameter.
However because of complexities from interactions with multiple viewports a
per-viewport clamp range is left to a future extensions if a use case
arises.

2) Should this pipeline state be dynamic?

**RESOLVED**: Yes.
Since the viewport depth range can already be a dynamic state conformant
runtimes are already able to handle the depth clamp range as a dynamic
state.

3) Can the depth clamp range be ignored when depth clamping is disabled?

**RESOLVED**: Yes.
This extension overrides the clamping range used only when depth clamping is
enabled.
The alternative would be highly unintuitive.
As a consequence the [VK_EXT_depth_clip_enable](#VK_EXT_depth_clip_enable) extension is required
if depth clipping is desired in combination with this extension.

* 
Revision 1, 2024-02-13 (Jules Blok)

Initial draft

**Name String**

`VK_EXT_depth_clip_control`

**Extension Type**

Device extension

**Registered Extension Number**

356

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Special Use**

* 
[OpenGL / ES support](../chapters/extensions.html#extendingvulkan-compatibility-specialuse)

**Contact**

* 
Shahbaz Youssefi [syoussefi](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_depth_clip_control] @syoussefi%0A*Here describe the issue or question you have about the VK_EXT_depth_clip_control extension*)

**Last Modified Date**

2021-11-09

**Contributors**

* 
Spencer Fricke, Samsung Electronics

* 
Shahbaz Youssefi, Google

* 
Ralph Potter, Samsung Electronics

This extension allows the application to use the OpenGL depth range in NDC,
i.e. with depth in range [-1, 1], as opposed to Vulkans default of
[0, 1].
The purpose of this extension is to allow efficient layering of OpenGL over
Vulkan, by avoiding emulation in the pre-rasterization shader stages.
This emulation, which effectively duplicates gl_Position but with a
different depth value, costs ALU and consumes shader output components that
the implementation may not have to spare to meet OpenGL minimum
requirements.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceDepthClipControlFeaturesEXT](../chapters/features.html#VkPhysicalDeviceDepthClipControlFeaturesEXT)

Extending [VkPipelineViewportStateCreateInfo](../chapters/vertexpostproc.html#VkPipelineViewportStateCreateInfo):

* 
[VkPipelineViewportDepthClipControlCreateInfoEXT](../chapters/vertexpostproc.html#VkPipelineViewportDepthClipControlCreateInfoEXT)

* 
`VK_EXT_DEPTH_CLIP_CONTROL_EXTENSION_NAME`

* 
`VK_EXT_DEPTH_CLIP_CONTROL_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT`

* 
`VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT`

1) Should this extension include an origin control option to match
GL_LOWER_LEFT found in ARB_clip_control?

**RESOLVED**: No.
The fix for porting over the origin is a simple y-axis flip.
The depth clip control is a much harder problem to solve than what this
extension is aimed to solve.
Adding an equivalent to GL_LOWER_LEFT would require more testing.

2) Should this pipeline state be dynamic?

**RESOLVED**: Yes.
The purpose of this extension is to emulate the OpenGL depth range, which is
expected to be globally fixed (in case of OpenGL ES) or very infrequently
changed (with `glClipControl` in OpenGL).

3) Should the control provided in this extension be an enum that could be
extended in the future?

**RESOLVED**: No.
It is highly unlikely that the depth range is changed to anything other than
[0, 1] in the future.
Should that happen a new extension will be required to extend such an enum,
and that extension might as well add a new structure to chain to
[VkPipelineViewportStateCreateInfo](../chapters/vertexpostproc.html#VkPipelineViewportStateCreateInfo)::`pNext` instead.

* 
Revision 0, 2020-10-01 (Spencer Fricke)

Internal revisions

Revision 1, 2020-11-26 (Shahbaz Youssefi)

* 
Language fixes

**Name String**

`VK_EXT_depth_clip_enable`

**Extension Type**

Device extension

**Registered Extension Number**

103

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Special Use**

* 
[D3D support](../chapters/extensions.html#extendingvulkan-compatibility-specialuse)

**Contact**

* 
Piers Daniell [pdaniell-nv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_depth_clip_enable] @pdaniell-nv%0A*Here describe the issue or question you have about the VK_EXT_depth_clip_enable extension*)

**Last Modified Date**

2018-12-20

**Contributors**

* 
Daniel Rakos, AMD

* 
Henri Verbeet, CodeWeavers

* 
Jeff Bolz, NVIDIA

* 
Philip Rebohle, DXVK

* 
Tobias Hector, AMD

This extension allows the depth clipping operation, that is normally
implicitly controlled by
[VkPipelineRasterizationStateCreateInfo](../chapters/primsrast.html#VkPipelineRasterizationStateCreateInfo)::`depthClampEnable`, to
instead be controlled explicitly by
[VkPipelineRasterizationDepthClipStateCreateInfoEXT](../chapters/primsrast.html#VkPipelineRasterizationDepthClipStateCreateInfoEXT)::`depthClipEnable`.

This is useful for translating DX content which assumes depth clamping is
always enabled, but depth clip can be controlled by the DepthClipEnable
rasterization state (D3D12_RASTERIZER_DESC).

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceDepthClipEnableFeaturesEXT](../chapters/features.html#VkPhysicalDeviceDepthClipEnableFeaturesEXT)

Extending [VkPipelineRasterizationStateCreateInfo](../chapters/primsrast.html#VkPipelineRasterizationStateCreateInfo):

* 
[VkPipelineRasterizationDepthClipStateCreateInfoEXT](../chapters/primsrast.html#VkPipelineRasterizationDepthClipStateCreateInfoEXT)

* 
[VkPipelineRasterizationDepthClipStateCreateFlagsEXT](../chapters/primsrast.html#VkPipelineRasterizationDepthClipStateCreateFlagsEXT)

* 
`VK_EXT_DEPTH_CLIP_ENABLE_EXTENSION_NAME`

* 
`VK_EXT_DEPTH_CLIP_ENABLE_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT`

* 
`VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT`

* 
Revision 1, 2018-12-20 (Piers Daniell)

Internal revisions

**Name String**

`VK_EXT_depth_range_unrestricted`

**Extension Type**

Device extension

**Registered Extension Number**

14

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

None

**Contact**

* 
Piers Daniell [pdaniell-nv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_depth_range_unrestricted] @pdaniell-nv%0A*Here describe the issue or question you have about the VK_EXT_depth_range_unrestricted extension*)

**Last Modified Date**

2017-06-22

**Contributors**

* 
Daniel Koch, NVIDIA

* 
Jeff Bolz, NVIDIA

This extension removes the [VkViewport](../chapters/vertexpostproc.html#VkViewport) `minDepth` and
`maxDepth` restrictions that the values must be between `0.0` and `1.0`,
inclusive.
It also removes the same restriction on
[VkPipelineDepthStencilStateCreateInfo](../chapters/fragops.html#VkPipelineDepthStencilStateCreateInfo) `minDepthBounds` and
`maxDepthBounds`.
Finally it removes the restriction on the `depth` value in
[VkClearDepthStencilValue](../chapters/clears.html#VkClearDepthStencilValue).

* 
`VK_EXT_DEPTH_RANGE_UNRESTRICTED_EXTENSION_NAME`

* 
`VK_EXT_DEPTH_RANGE_UNRESTRICTED_SPEC_VERSION`

1) How do [VkViewport](../chapters/vertexpostproc.html#VkViewport) `minDepth` and `maxDepth` values outside
of the `0.0` to `1.0` range interact with
[Primitive Clipping](../chapters/vertexpostproc.html#vertexpostproc-clipping)?

**RESOLVED**: The behavior described in [Primitive Clipping](../chapters/vertexpostproc.html#vertexpostproc-clipping) still applies.
If depth clamping is disabled the depth values are still clipped to 0
 zc  wc before the viewport transform.
If depth clamping is enabled the above equation is ignored and the depth
values are instead clamped to the [VkViewport](../chapters/vertexpostproc.html#VkViewport) `minDepth` and
`maxDepth` values, which in the case of this extension can be outside of
the `0.0` to `1.0` range.

2) What happens if a resulting depth fragment is outside of the `0.0` to
`1.0` range and the depth buffer is fixed-point rather than floating-point?

**RESOLVED**: This situation can also arise without this extension (when
fragment shaders replace depth values, for example), and this extension does
not change the behavior, which is defined in the [Depth Test](../chapters/fragops.html#fragops-depth) section of the Fragment Operations chapter.

* 
Revision 1, 2017-06-22 (Piers Daniell)

Internal revisions

**Name String**

`VK_EXT_descriptor_buffer`

**Extension Type**

Device extension

**Registered Extension Number**

317

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

 [VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

 or

 [Vulkan Version 1.1](versions.html#versions-1.1)

 and

 [VK_KHR_buffer_device_address](#VK_KHR_buffer_device_address)

 and

 [VK_EXT_descriptor_indexing](#VK_EXT_descriptor_indexing)

 or

 [Vulkan Version 1.2](versions.html#versions-1.2)

 and

 [VK_KHR_synchronization2](#VK_KHR_synchronization2)

or

[Vulkan Version 1.3](versions.html#versions-1.3)

**API Interactions**

* 
Interacts with VK_KHR_acceleration_structure

* 
Interacts with VK_NV_ray_tracing

**Contact**

* 
Tobias Hector [tobski](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_descriptor_buffer] @tobski%0A*Here describe the issue or question you have about the VK_EXT_descriptor_buffer extension*)

**Extension Proposal**

[VK_EXT_descriptor_buffer](../../../features/latest/features/proposals/VK_EXT_descriptor_buffer.html)

**Last Modified Date**

2021-06-07

**IP Status**

No known IP claims.

**Contributors**

* 
Tobias Hector, AMD

* 
Stu Smith, AMD

* 
Maciej Jesionowski, AMD

* 
Boris Zanin, AMD

* 
Hans-Kristian Arntzen, Valve

* 
Connor Abbott, Valve

* 
Baldur Karlsson, Valve

* 
Mike Blumenkrantz, Valve

* 
Graeme Leese, Broadcom

* 
Jan-Harald Fredriksen, Arm

* 
Rodrigo Locatti, NVIDIA

* 
Jeff Bolz, NVIDIA

* 
Piers Daniell, NVIDIA

* 
Jeff Leger, QUALCOMM

* 
Lionel Landwerlin, Intel

* 
Slawomir Grajewski, Intel

This extension introduces new commands to put shader-accessible descriptors
directly in memory, making the management of descriptor data more explicit.

* 
[vkCmdBindDescriptorBufferEmbeddedSamplersEXT](../chapters/descriptorsets.html#vkCmdBindDescriptorBufferEmbeddedSamplersEXT)

* 
[vkCmdBindDescriptorBuffersEXT](../chapters/descriptorsets.html#vkCmdBindDescriptorBuffersEXT)

* 
[vkCmdSetDescriptorBufferOffsetsEXT](../chapters/descriptorsets.html#vkCmdSetDescriptorBufferOffsetsEXT)

* 
[vkGetBufferOpaqueCaptureDescriptorDataEXT](../chapters/descriptorsets.html#vkGetBufferOpaqueCaptureDescriptorDataEXT)

* 
[vkGetDescriptorEXT](../chapters/descriptorsets.html#vkGetDescriptorEXT)

* 
[vkGetDescriptorSetLayoutBindingOffsetEXT](../chapters/descriptorsets.html#vkGetDescriptorSetLayoutBindingOffsetEXT)

* 
[vkGetDescriptorSetLayoutSizeEXT](../chapters/descriptorsets.html#vkGetDescriptorSetLayoutSizeEXT)

* 
[vkGetImageOpaqueCaptureDescriptorDataEXT](../chapters/descriptorsets.html#vkGetImageOpaqueCaptureDescriptorDataEXT)

* 
[vkGetImageViewOpaqueCaptureDescriptorDataEXT](../chapters/descriptorsets.html#vkGetImageViewOpaqueCaptureDescriptorDataEXT)

* 
[vkGetSamplerOpaqueCaptureDescriptorDataEXT](../chapters/descriptorsets.html#vkGetSamplerOpaqueCaptureDescriptorDataEXT)

If [VK_KHR_acceleration_structure](#VK_KHR_acceleration_structure) or [VK_NV_ray_tracing](#VK_NV_ray_tracing) is supported:

* 
[vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT](../chapters/descriptorsets.html#vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT)

* 
[VkBufferCaptureDescriptorDataInfoEXT](../chapters/descriptorsets.html#VkBufferCaptureDescriptorDataInfoEXT)

* 
[VkDescriptorAddressInfoEXT](../chapters/descriptorsets.html#VkDescriptorAddressInfoEXT)

* 
[VkDescriptorBufferBindingInfoEXT](../chapters/descriptorsets.html#VkDescriptorBufferBindingInfoEXT)

* 
[VkDescriptorGetInfoEXT](../chapters/descriptorsets.html#VkDescriptorGetInfoEXT)

* 
[VkImageCaptureDescriptorDataInfoEXT](../chapters/descriptorsets.html#VkImageCaptureDescriptorDataInfoEXT)

* 
[VkImageViewCaptureDescriptorDataInfoEXT](../chapters/descriptorsets.html#VkImageViewCaptureDescriptorDataInfoEXT)

* 
[VkSamplerCaptureDescriptorDataInfoEXT](../chapters/descriptorsets.html#VkSamplerCaptureDescriptorDataInfoEXT)

* 
Extending [VkBufferCreateInfo](../chapters/resources.html#VkBufferCreateInfo), [VkImageCreateInfo](../chapters/resources.html#VkImageCreateInfo), [VkImageViewCreateInfo](../chapters/resources.html#VkImageViewCreateInfo), [VkSamplerCreateInfo](../chapters/samplers.html#VkSamplerCreateInfo), [VkAccelerationStructureCreateInfoKHR](../chapters/resources.html#VkAccelerationStructureCreateInfoKHR), [VkAccelerationStructureCreateInfoNV](../chapters/resources.html#VkAccelerationStructureCreateInfoNV):

[VkOpaqueCaptureDescriptorDataCreateInfoEXT](../chapters/descriptorsets.html#VkOpaqueCaptureDescriptorDataCreateInfoEXT)

Extending [VkDescriptorBufferBindingInfoEXT](../chapters/descriptorsets.html#VkDescriptorBufferBindingInfoEXT):

* 
[VkDescriptorBufferBindingPushDescriptorBufferHandleEXT](../chapters/descriptorsets.html#VkDescriptorBufferBindingPushDescriptorBufferHandleEXT)

Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

* 
[VkPhysicalDeviceDescriptorBufferFeaturesEXT](../chapters/features.html#VkPhysicalDeviceDescriptorBufferFeaturesEXT)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT](../chapters/limits.html#VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT)

* 
[VkPhysicalDeviceDescriptorBufferPropertiesEXT](../chapters/limits.html#VkPhysicalDeviceDescriptorBufferPropertiesEXT)

If [VK_KHR_acceleration_structure](#VK_KHR_acceleration_structure) or [VK_NV_ray_tracing](#VK_NV_ray_tracing) is supported:

* 
[VkAccelerationStructureCaptureDescriptorDataInfoEXT](../chapters/descriptorsets.html#VkAccelerationStructureCaptureDescriptorDataInfoEXT)

* 
[VkDescriptorDataEXT](../chapters/descriptorsets.html#VkDescriptorDataEXT)

* 
`VK_EXT_DESCRIPTOR_BUFFER_EXTENSION_NAME`

* 
`VK_EXT_DESCRIPTOR_BUFFER_SPEC_VERSION`

* 
Extending [VkAccelerationStructureCreateFlagBitsKHR](../chapters/resources.html#VkAccelerationStructureCreateFlagBitsKHR):

`VK_ACCELERATION_STRUCTURE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT`

Extending [VkAccessFlagBits2](../chapters/synchronization.html#VkAccessFlagBits2):

* 
`VK_ACCESS_2_DESCRIPTOR_BUFFER_READ_BIT_EXT`

Extending [VkBufferCreateFlagBits](../chapters/resources.html#VkBufferCreateFlagBits):

* 
`VK_BUFFER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT`

Extending [VkBufferUsageFlagBits](../chapters/resources.html#VkBufferUsageFlagBits):

* 
`VK_BUFFER_USAGE_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT`

* 
`VK_BUFFER_USAGE_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT`

* 
`VK_BUFFER_USAGE_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT`

Extending [VkDescriptorSetLayoutCreateFlagBits](../chapters/descriptorsets.html#VkDescriptorSetLayoutCreateFlagBits):

* 
`VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT`

* 
`VK_DESCRIPTOR_SET_LAYOUT_CREATE_EMBEDDED_IMMUTABLE_SAMPLERS_BIT_EXT`

Extending [VkImageCreateFlagBits](../chapters/resources.html#VkImageCreateFlagBits):

* 
`VK_IMAGE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT`

Extending [VkImageViewCreateFlagBits](../chapters/resources.html#VkImageViewCreateFlagBits):

* 
`VK_IMAGE_VIEW_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT`

Extending [VkPipelineCreateFlagBits](../chapters/pipelines.html#VkPipelineCreateFlagBits):

* 
`VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT`

Extending [VkSamplerCreateFlagBits](../chapters/samplers.html#VkSamplerCreateFlagBits):

* 
`VK_SAMPLER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_BUFFER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_DESCRIPTOR_ADDRESS_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT`

* 
`VK_STRUCTURE_TYPE_DESCRIPTOR_GET_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_IMAGE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_IMAGE_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT`

* 
`VK_STRUCTURE_TYPE_SAMPLER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT`

If [VK_KHR_acceleration_structure](#VK_KHR_acceleration_structure) or [VK_NV_ray_tracing](#VK_NV_ray_tracing) is supported:

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT`

* 
Revision 1, 2021-06-07 (Stu Smith)

Initial revision

**Name String**

`VK_EXT_device_address_binding_report`

**Extension Type**

Device extension

**Registered Extension Number**

355

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

 [VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

 or

 [Vulkan Version 1.1](versions.html#versions-1.1)

and

[VK_EXT_debug_utils](#VK_EXT_debug_utils)

**Special Uses**

* 
[Debugging tools](../chapters/extensions.html#extendingvulkan-compatibility-specialuse)

* 
[Developer tools](../chapters/extensions.html#extendingvulkan-compatibility-specialuse)

**Contact**

* 
Ralph Potter r_potter

**Last Modified Date**

2020-11-23

**Interactions and External Dependencies**

* 
This extension requires `VK_EXT_debug_utils`

**Contributors**

* 
Ralph Potter, Samsung

* 
Spencer Fricke, Samsung

* 
Jan-Harald Fredriksen, ARM

* 
Andrew Ellem, Google

* 
Alex Walters, IMG

* 
Jeff Bolz, NVIDIA

This extension enables applications to track the binding of regions of the
GPU virtual address space, and to associate those regions with Vulkan
objects.
This extension is primarily intended to aid in crash postmortem, where
applications may wish to map a faulting GPU address to a Vulkan object.

For example, a page fault triggered by accessing an address located within a
region of the GPU virtual address space that was previously reported as
bound and then unbound may indicate a use-after-free error.
Similarly, faults generated by accessing virtual addresses outside the
limits of a bound region of GPU virtual address space may indicate indexing
beyond the bounds of a resource.

* 
Extending [VkDebugUtilsMessengerCallbackDataEXT](../chapters/debugging.html#VkDebugUtilsMessengerCallbackDataEXT):

[VkDeviceAddressBindingCallbackDataEXT](../chapters/debugging.html#VkDeviceAddressBindingCallbackDataEXT)

Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

* 
[VkPhysicalDeviceAddressBindingReportFeaturesEXT](../chapters/features.html#VkPhysicalDeviceAddressBindingReportFeaturesEXT)

* 
[VkDeviceAddressBindingFlagBitsEXT](../chapters/debugging.html#VkDeviceAddressBindingFlagBitsEXT)

* 
[VkDeviceAddressBindingTypeEXT](../chapters/debugging.html#VkDeviceAddressBindingTypeEXT)

* 
[VkDeviceAddressBindingFlagsEXT](../chapters/debugging.html#VkDeviceAddressBindingFlagsEXT)

* 
`VK_EXT_DEVICE_ADDRESS_BINDING_REPORT_EXTENSION_NAME`

* 
`VK_EXT_DEVICE_ADDRESS_BINDING_REPORT_SPEC_VERSION`

* 
Extending [VkDebugUtilsMessageTypeFlagBitsEXT](../chapters/debugging.html#VkDebugUtilsMessageTypeFlagBitsEXT):

`VK_DEBUG_UTILS_MESSAGE_TYPE_DEVICE_ADDRESS_BINDING_BIT_EXT`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT`

1.) Should this extend VK_EXT_debug_utils or VK_EXT_device_memory_report?

**RESOLVED**: Extend VK_EXT_debug_utils.
VK_EXT_device_memory_report focuses on memory allocations and would not
normally trigger callbacks in all of the situations where
VK_EXT_device_address_binding_report is expected to.

2.) Should this extension cover all Vulkan object types, or only resources
such as buffers and images?

**RESOLVED**: The extension covers all Vulkan objects, and is not restricted
to objects backed by VkDeviceMemory objects.

3.) Should reallocation be identified explicitly, or as an unbind/bind pair?

**RESOLVED**: Reallocation should be represented as an unbind/bind pair.

4.) Can multiple Vulkan objects share an overlapping virtual address range?

**RESOLVED**: Yes.
This can be expected to occur due to resources aliasing.

5.) Can a single Vulkan object be associated with multiple virtual address
ranges concurrently?

**RESOLVED**: Yes.
These should be reported via multiple calls to the reporting callback.

6.) Should the virtual address ranges associated with internal allocations
such as memory pools be reported?

**RESOLVED**: Virtual address ranges associated with internal allocations
should only be reported when they become associated with a specific Vulkan
object.
In the case of internal pool allocations, a bind event should be reported
when resources from the pool are assigned to a Vulkan object, and an unbind
event should be reported when those resources are returned to the pool.
Implementations should not report the binding or unbinding of virtual
address ranges for which there are no related API objects visible to the
application developer.

7.) Can an implementation report binding a virtual address range at VkImage
or VkImageView creation, rather than in response to vkBindImageMemory?

**RESOLVED**: Yes.
Virtual address range binding should be reported at the appropriate point at
which it occurs within the implementation.
This extension does not mandate when that should occur, and applications
should anticipate receiving callback events at any point after registering
callbacks.

8.) Can reporting of binding/unbinding be deferred until a resource is
referenced by an executing command buffer?

**RESOLVED**: Changes to the virtual address ranges associated with a Vulkan
object should be reported as close as possible to where they occur within
the implementation.
If virtual address binding is deferred, then the callback should also be
deferred to match.

9.) Do bind/unbind callbacks have to form matched pairs? Can a large region
be bound, and then subregions unbound, resulting in fragmentation?

**RESOLVED**: Splitting of virtual address regions, and unmatched bind/unbind
callbacks may occur.
Developers should anticipate that sparse memory may exhibit this behavior.

10.) The specification mandates that a callback **must** be triggered whenever
a GPU virtual address range associated with any Vulkan object is bound or
unbound.
Do we need queries or properties indicating which Vulkan objects will report
binding modifications?

**RESOLVED**: No.
This extension is not intended to mandate how and when implementations bind
virtual ranges to objects.
Adding queries or properties would constrain implementations, which might
otherwise vary how virtual address bindings occur based on usage.

11.) Should vkAllocateMemory and vkFreeMemory trigger reporting callbacks?

**RESOLVED**: If an implementation binds a GPU virtual address range when
vkAllocateMemory is called, then the callbacks must be triggered associating
the virtual address range with the VkDeviceMemory object.
If the device memory is subsequently bound to a buffer or image via
vkBind*Memory, the callbacks should be triggered a second time, reporting
the association between virtual address range and the buffer/image.

* 
Revision 1, 2020-09-23 (Ralph Potter)

Internal revisions

**Name String**

`VK_EXT_device_fault`

**Extension Type**

Device extension

**Registered Extension Number**

342

**Revision**

2

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Contact**

* 
Ralph Potter r_potter

**Extension Proposal**

[VK_EXT_device_fault](../../../features/latest/features/proposals/VK_EXT_device_fault.html)

**Last Modified Date**

2021-03-10

**IP Status**

No known IP claims.

**Contributors**

* 
Ralph Potter, Samsung

* 
Stuart Smith, AMD

* 
Jan-Harald Fredriksen, ARM

* 
Mark Bellamy, ARM

* 
Andrew Ellem, Google

* 
Alex Walters, IMG

* 
Jeff Bolz, NVIDIA

* 
Baldur Karlsson, Valve

Device loss can be triggered by a variety of issues, including invalid API
usage, implementation errors, or hardware failures.

This extension introduces a new command: [vkGetDeviceFaultInfoEXT](../chapters/debugging.html#vkGetDeviceFaultInfoEXT),
which may be called subsequent to a `VK_ERROR_DEVICE_LOST` error code
having been returned by the implementation.
This command allows developers to query for additional information on GPU
faults which may have caused device loss, and to generate binary crash
dumps, which may be loaded into external tools for further diagnosis.

* 
[vkGetDeviceFaultInfoEXT](../chapters/debugging.html#vkGetDeviceFaultInfoEXT)

* 
[VkDeviceFaultAddressInfoEXT](../chapters/debugging.html#VkDeviceFaultAddressInfoEXT)

* 
[VkDeviceFaultCountsEXT](../chapters/debugging.html#VkDeviceFaultCountsEXT)

* 
[VkDeviceFaultInfoEXT](../chapters/debugging.html#VkDeviceFaultInfoEXT)

* 
[VkDeviceFaultVendorBinaryHeaderVersionOneEXT](../chapters/debugging.html#VkDeviceFaultVendorBinaryHeaderVersionOneEXT)

* 
[VkDeviceFaultVendorInfoEXT](../chapters/debugging.html#VkDeviceFaultVendorInfoEXT)

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceFaultFeaturesEXT](../chapters/features.html#VkPhysicalDeviceFaultFeaturesEXT)

* 
[VkDeviceFaultAddressTypeEXT](../chapters/debugging.html#VkDeviceFaultAddressTypeEXT)

* 
[VkDeviceFaultVendorBinaryHeaderVersionEXT](../chapters/debugging.html#VkDeviceFaultVendorBinaryHeaderVersionEXT)

* 
`VK_EXT_DEVICE_FAULT_EXTENSION_NAME`

* 
`VK_EXT_DEVICE_FAULT_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_DEVICE_FAULT_COUNTS_EXT`

* 
`VK_STRUCTURE_TYPE_DEVICE_FAULT_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT`

* 
Revision 2, 2023-04-05 (Ralph Potter)

Restored two missing members to the XML definition of
VkDeviceFaultVendorBinaryHeaderVersionOneEXT.
No functional change to the specification.

Revision 1, 2020-10-19 (Ralph Potter)

* 
Initial revision

**Name String**

`VK_EXT_device_generated_commands`

**Extension Type**

Device extension

**Registered Extension Number**

573

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

 [VK_KHR_buffer_device_address](#VK_KHR_buffer_device_address)

 or

 [Vulkan Version 1.2](versions.html#versions-1.2)

 and

 [VK_KHR_maintenance5](#VK_KHR_maintenance5)

or

[Vulkan Version 1.3](versions.html#versions-1.3)

**API Interactions**

* 
Interacts with VK_EXT_shader_object

**Contact**

* 
Mike Blumenkrantz [zmike](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_device_generated_commands] @zmike%0A*Here describe the issue or question you have about the VK_EXT_device_generated_commands extension*)

**Extension Proposal**

[VK_EXT_device_generated_commands](../../../features/latest/features/proposals/VK_EXT_device_generated_commands.html)

**Last Modified Date**

2024-02-23

**Interactions and External Dependencies**

* 
This extension requires Vulkan 1.1

* 
This extension requires `VK_EXT_buffer_device_address` or
`VK_KHR_buffer_device_address` or Vulkan 1.2 for the ability to bind
vertex and index buffers on the device.

* 
This extension requires `VK_KHR_maintenance5` for the ability to use
VkPipelineCreateFlags2KHR.

* 
This extension interacts with `VK_NV_mesh_shader`.
If the latter extension is not supported, remove the command tokens to
initiate NV mesh tasks drawing in this extension.

* 
This extension interacts with `VK_EXT_mesh_shader`.
If the latter extension is not supported, remove the command tokens to
initiate EXT mesh tasks drawing in this extension.

* 
This extension interacts with `VK_KHR_ray_tracing_pipeline`.
If the latter extension is not supported, remove the command tokens to
initiate ray tracing in this extension.

* 
This extension interacts with `VK_EXT_shader_object`.
If the latter extension is not supported, remove references to shader
objects in this extension.

**Contributors**

* 
Mike Blumenkrantz, VALVE

* 
Hans-Kristian Arntzen, VALVE

* 
Jan-Harald Fredriksen, ARM

* 
Spencer Fricke, LunarG

* 
Ricardo Garcia, Igalia

* 
Tobias Hector, AMD

* 
Baldur Karlsson, VALVE

* 
Christoph Kubisch, NVIDIA

* 
Lionel Landwerlin, INTEL

* 
Jon Leech, Khronos

* 
Ting Wei, ARM

* 
Ken Shanyi Zhang, AMD

* 
Faith Ekstrand, Collabora

* 
Vikram Kushwaha, NVIDIA

* 
Connor Abbott, VALVE

* 
Samuel Pitoiset, VALVE

This extension allows the device to generate a number of commands for
command buffers.
It provides a subset of functionality from both
`VK_NV_device_generated_commands` and
`VK_NV_device_generated_commands_compute` as well as some new features.

When rendering a large number of objects, the device can be leveraged to
implement a number of critical functions, like updating matrices, or
implementing occlusion culling, frustum culling, front to back sorting, etc.
Implementing those on the device does not require any special extension,
since an application is free to define its own data structures, and just
process them using shaders.

To render objects which have been processed on the device, Vulkan has
several ways to perform indirect rendering, from the most basic
`vkCmdDrawIndirect` with one indirect draw to `vkCmdDrawIndirectCount` which
supports multiple indirect draws batched together, with a way to determine
number of draws at device execution time.

However, if rendering state needs to change between the indirect draws, then
unextended Vulkan forces the application to speculatively record a
prohibitive number of redundant indirect commands covering all possible
state combinations -
which could end up processing nothing after culling -
or read back the processed stream and issue graphics command from the host.
For very large scenes, the synchronization overhead and cost to generate the
command buffer can become the bottleneck.
This extension allows an application to generate a device side stream of
state changes and commands, and convert it efficiently into a command buffer
without having to read it back to the host.

Furthermore, it allows incremental changes to such command buffers by
manipulating only partial sections of a command streamfor example
pipeline and shader object bindings.
Unextended Vulkan requires re-creation of entire command buffers in such a
scenario, or updates synchronized on the host.

The intended usage for this extension is for the application to:

* 
create `VkBuffer` objects and retrieve physical addresses from them
via [vkGetBufferDeviceAddress](../chapters/descriptorsets.html#vkGetBufferDeviceAddress)

* 
create a `VkIndirectExecutionSetEXT` for the ability to change
shaders on the device.

* 
create a [VkIndirectCommandsLayoutEXT](../chapters/device_generated_commands/generatedcommands.html#VkIndirectCommandsLayoutEXT), which lists the
[VkIndirectCommandsTokenTypeEXT](../chapters/device_generated_commands/generatedcommands.html#VkIndirectCommandsTokenTypeEXT) it wants to dynamically execute as
an atomic command sequence.
This step likely involves some internal device code compilation, since
the intent is for the GPU to generate the command buffer based on the
layout.

* 
fill the input stream buffers with the data for each of the inputs it
needs.
Each input is an array that will be filled with token-dependent data.

* 
set up a preprocess `VkBuffer` that uses memory according to the
information retrieved via
[vkGetGeneratedCommandsMemoryRequirementsEXT](../chapters/device_generated_commands/generatedcommands.html#vkGetGeneratedCommandsMemoryRequirementsEXT).

* 
optionally preprocess the generated content using
[vkCmdPreprocessGeneratedCommandsEXT](../chapters/device_generated_commands/generatedcommands.html#vkCmdPreprocessGeneratedCommandsEXT), for example on an
asynchronous compute queue, or for the purpose of reusing the data in
multiple executions.

* 
call [vkCmdExecuteGeneratedCommandsEXT](../chapters/device_generated_commands/generatedcommands.html#vkCmdExecuteGeneratedCommandsEXT) to create and execute the
actual device commands for all sequences based on the inputs provided.

For each draw in a sequence, the following can be specified:

* 
a number of vertex buffer bindings

* 
a different index buffer, with an optional dynamic offset and index type

* 
a number of different push constants

* 
updates to bound shader stages

For each dispatch in a sequence, the following can be specified:

* 
a number of different push constants

* 
updates to bound shader stages

For each trace rays in a sequence, the following can be specified:

* 
a number of different push constants

* 
updates to bound shader stages

While the GPU can be faster than a CPU to generate the commands, it will not
happen asynchronously to the device, therefore the primary use case is
generating less total work (occlusion culling, classification to use
specialized shaders, etc.).

* 
[VkIndirectCommandsLayoutEXT](../chapters/device_generated_commands/generatedcommands.html#VkIndirectCommandsLayoutEXT)

* 
[VkIndirectExecutionSetEXT](../chapters/device_generated_commands/generatedcommands.html#VkIndirectExecutionSetEXT)

* 
[vkCmdExecuteGeneratedCommandsEXT](../chapters/device_generated_commands/generatedcommands.html#vkCmdExecuteGeneratedCommandsEXT)

* 
[vkCmdPreprocessGeneratedCommandsEXT](../chapters/device_generated_commands/generatedcommands.html#vkCmdPreprocessGeneratedCommandsEXT)

* 
[vkCreateIndirectCommandsLayoutEXT](../chapters/device_generated_commands/generatedcommands.html#vkCreateIndirectCommandsLayoutEXT)

* 
[vkCreateIndirectExecutionSetEXT](../chapters/device_generated_commands/generatedcommands.html#vkCreateIndirectExecutionSetEXT)

* 
[vkDestroyIndirectCommandsLayoutEXT](../chapters/device_generated_commands/generatedcommands.html#vkDestroyIndirectCommandsLayoutEXT)

* 
[vkDestroyIndirectExecutionSetEXT](../chapters/device_generated_commands/generatedcommands.html#vkDestroyIndirectExecutionSetEXT)

* 
[vkGetGeneratedCommandsMemoryRequirementsEXT](../chapters/device_generated_commands/generatedcommands.html#vkGetGeneratedCommandsMemoryRequirementsEXT)

* 
[vkUpdateIndirectExecutionSetPipelineEXT](../chapters/device_generated_commands/generatedcommands.html#vkUpdateIndirectExecutionSetPipelineEXT)

* 
[vkUpdateIndirectExecutionSetShaderEXT](../chapters/device_generated_commands/generatedcommands.html#vkUpdateIndirectExecutionSetShaderEXT)

* 
[VkBindIndexBufferIndirectCommandEXT](../chapters/device_generated_commands/generatedcommands.html#VkBindIndexBufferIndirectCommandEXT)

* 
[VkBindVertexBufferIndirectCommandEXT](../chapters/device_generated_commands/generatedcommands.html#VkBindVertexBufferIndirectCommandEXT)

* 
[VkDrawIndirectCountIndirectCommandEXT](../chapters/device_generated_commands/generatedcommands.html#VkDrawIndirectCountIndirectCommandEXT)

* 
[VkGeneratedCommandsInfoEXT](../chapters/device_generated_commands/generatedcommands.html#VkGeneratedCommandsInfoEXT)

* 
[VkGeneratedCommandsMemoryRequirementsInfoEXT](../chapters/device_generated_commands/generatedcommands.html#VkGeneratedCommandsMemoryRequirementsInfoEXT)

* 
[VkIndirectCommandsExecutionSetTokenEXT](../chapters/device_generated_commands/generatedcommands.html#VkIndirectCommandsExecutionSetTokenEXT)

* 
[VkIndirectCommandsIndexBufferTokenEXT](../chapters/device_generated_commands/generatedcommands.html#VkIndirectCommandsIndexBufferTokenEXT)

* 
[VkIndirectCommandsLayoutCreateInfoEXT](../chapters/device_generated_commands/generatedcommands.html#VkIndirectCommandsLayoutCreateInfoEXT)

* 
[VkIndirectCommandsLayoutTokenEXT](../chapters/device_generated_commands/generatedcommands.html#VkIndirectCommandsLayoutTokenEXT)

* 
[VkIndirectCommandsPushConstantTokenEXT](../chapters/device_generated_commands/generatedcommands.html#VkIndirectCommandsPushConstantTokenEXT)

* 
[VkIndirectCommandsVertexBufferTokenEXT](../chapters/device_generated_commands/generatedcommands.html#VkIndirectCommandsVertexBufferTokenEXT)

* 
[VkIndirectExecutionSetCreateInfoEXT](../chapters/device_generated_commands/generatedcommands.html#VkIndirectExecutionSetCreateInfoEXT)

* 
[VkIndirectExecutionSetPipelineInfoEXT](../chapters/device_generated_commands/generatedcommands.html#VkIndirectExecutionSetPipelineInfoEXT)

* 
[VkIndirectExecutionSetShaderInfoEXT](../chapters/device_generated_commands/generatedcommands.html#VkIndirectExecutionSetShaderInfoEXT)

* 
[VkIndirectExecutionSetShaderLayoutInfoEXT](../chapters/device_generated_commands/generatedcommands.html#VkIndirectExecutionSetShaderLayoutInfoEXT)

* 
[VkWriteIndirectExecutionSetPipelineEXT](../chapters/device_generated_commands/generatedcommands.html#VkWriteIndirectExecutionSetPipelineEXT)

* 
Extending [VkGeneratedCommandsInfoEXT](../chapters/device_generated_commands/generatedcommands.html#VkGeneratedCommandsInfoEXT), [VkGeneratedCommandsMemoryRequirementsInfoEXT](../chapters/device_generated_commands/generatedcommands.html#VkGeneratedCommandsMemoryRequirementsInfoEXT):

[VkGeneratedCommandsPipelineInfoEXT](../chapters/device_generated_commands/generatedcommands.html#VkGeneratedCommandsPipelineInfoEXT)

* 
[VkGeneratedCommandsShaderInfoEXT](../chapters/device_generated_commands/generatedcommands.html#VkGeneratedCommandsShaderInfoEXT)

Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

* 
[VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT](../chapters/features.html#VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT](../chapters/limits.html#VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT)

If [VK_EXT_shader_object](#VK_EXT_shader_object) is supported:

* 
[VkWriteIndirectExecutionSetShaderEXT](../chapters/device_generated_commands/generatedcommands.html#VkWriteIndirectExecutionSetShaderEXT)

* 
[VkIndirectCommandsTokenDataEXT](../chapters/device_generated_commands/generatedcommands.html#VkIndirectCommandsTokenDataEXT)

* 
[VkIndirectExecutionSetInfoEXT](../chapters/device_generated_commands/generatedcommands.html#VkIndirectExecutionSetInfoEXT)

* 
[VkIndirectCommandsInputModeFlagBitsEXT](../chapters/device_generated_commands/generatedcommands.html#VkIndirectCommandsInputModeFlagBitsEXT)

* 
[VkIndirectCommandsLayoutUsageFlagBitsEXT](../chapters/device_generated_commands/generatedcommands.html#VkIndirectCommandsLayoutUsageFlagBitsEXT)

* 
[VkIndirectCommandsTokenTypeEXT](../chapters/device_generated_commands/generatedcommands.html#VkIndirectCommandsTokenTypeEXT)

* 
[VkIndirectExecutionSetInfoTypeEXT](../chapters/device_generated_commands/generatedcommands.html#VkIndirectExecutionSetInfoTypeEXT)

* 
[VkIndirectCommandsInputModeFlagsEXT](../chapters/device_generated_commands/generatedcommands.html#VkIndirectCommandsInputModeFlagsEXT)

* 
[VkIndirectCommandsLayoutUsageFlagsEXT](../chapters/device_generated_commands/generatedcommands.html#VkIndirectCommandsLayoutUsageFlagsEXT)

* 
`VK_EXT_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME`

* 
`VK_EXT_DEVICE_GENERATED_COMMANDS_SPEC_VERSION`

* 
Extending [VkAccessFlagBits](../chapters/synchronization.html#VkAccessFlagBits):

`VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_EXT`

* 
`VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_EXT`

Extending [VkBufferUsageFlagBits2](../chapters/resources.html#VkBufferUsageFlagBits2):

* 
`VK_BUFFER_USAGE_2_PREPROCESS_BUFFER_BIT_EXT`

Extending [VkObjectType](../chapters/debugging.html#VkObjectType):

* 
`VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_EXT`

* 
`VK_OBJECT_TYPE_INDIRECT_EXECUTION_SET_EXT`

Extending [VkPipelineCreateFlagBits2](../chapters/pipelines.html#VkPipelineCreateFlagBits2):

* 
`VK_PIPELINE_CREATE_2_INDIRECT_BINDABLE_BIT_EXT`

Extending [VkPipelineStageFlagBits](../chapters/synchronization.html#VkPipelineStageFlagBits):

* 
`VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_EXT`

Extending [VkShaderCreateFlagBitsEXT](../chapters/shaders.html#VkShaderCreateFlagBitsEXT):

* 
`VK_SHADER_CREATE_INDIRECT_BINDABLE_BIT_EXT`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_GENERATED_COMMANDS_PIPELINE_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_GENERATED_COMMANDS_SHADER_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_EXT`

* 
`VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_CREATE_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_PIPELINE_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_LAYOUT_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_EXT`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_EXT`

* 
`VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_PIPELINE_EXT`

* 
`VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_SHADER_EXT`

TODO

* 
Revision 1, 2024-02-23 (Mike Blumenkrantz)

Initial version

**Name String**

`VK_EXT_device_memory_report`

**Extension Type**

Device extension

**Registered Extension Number**

285

**Revision**

2

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Special Use**

* 
[Developer tools](../chapters/extensions.html#extendingvulkan-compatibility-specialuse)

**Contact**

* 
Yiwei Zhang [zhangyiwei](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_device_memory_report] @zhangyiwei%0A*Here describe the issue or question you have about the VK_EXT_device_memory_report extension*)

**Last Modified Date**

2021-01-06

**IP Status**

No known IP claims.

**Contributors**

* 
Yiwei Zhang, Google

* 
Jesse Hall, Google

This device extension allows registration of device memory event callbacks
upon device creation, so that applications or middleware can obtain detailed
information about memory usage and how memory is associated with Vulkan
objects.
This extension exposes the actual underlying device memory usage, including
allocations that are not normally visible to the application, such as memory
consumed by [vkCreateGraphicsPipelines](../chapters/pipelines.html#vkCreateGraphicsPipelines).
It is intended primarily for use by debug tooling rather than for production
applications.

* 
[VkDeviceMemoryReportCallbackDataEXT](../chapters/devsandqueues.html#VkDeviceMemoryReportCallbackDataEXT)

* 
Extending [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkDeviceDeviceMemoryReportCreateInfoEXT](../chapters/devsandqueues.html#VkDeviceDeviceMemoryReportCreateInfoEXT)

Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

* 
[VkPhysicalDeviceDeviceMemoryReportFeaturesEXT](../chapters/features.html#VkPhysicalDeviceDeviceMemoryReportFeaturesEXT)

* 
[PFN_vkDeviceMemoryReportCallbackEXT](../chapters/devsandqueues.html#PFN_vkDeviceMemoryReportCallbackEXT)

* 
[VkDeviceMemoryReportEventTypeEXT](../chapters/devsandqueues.html#VkDeviceMemoryReportEventTypeEXT)

* 
[VkDeviceMemoryReportFlagsEXT](../chapters/devsandqueues.html#VkDeviceMemoryReportFlagsEXT)

* 
`VK_EXT_DEVICE_MEMORY_REPORT_EXTENSION_NAME`

* 
`VK_EXT_DEVICE_MEMORY_REPORT_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT`

1) Should this be better expressed as an extension to VK_EXT_debug_utils and
its general-purpose messenger construct?

**RESOLVED**: No.
The intended lifecycle is quite different.
We want to make this extension tied to the devices lifecycle.
Each ICD just handles its own implementation of this extension, and this
extension will only be directly exposed from the ICD.
So we can avoid the extra implementation complexity used to accommodate the
flexibility of `[VK_EXT_debug_utils](#VK_EXT_debug_utils)` extension.

2) Can we extend and use the existing internal allocation callbacks instead
of adding the new callback structure in this extension?

**RESOLVED**: No.
Our memory reporting layer that combines this information with other memory
information it collects directly (e.g. bindings of resources to
[VkDeviceMemory](../chapters/memory.html#VkDeviceMemory)) would have to intercept all entry points that take a
[VkAllocationCallbacks](../chapters/memory.html#VkAllocationCallbacks) parameter and inject its own
`pfnInternalAllocation` and `pfnInternalFree`.
That may be doable for the extensions we know about, but not for ones we do
not.
The proposal would work fine in the face of most unknown extensions.
But even for ones we know about, since apps can provide a different set of
callbacks and userdata and those can be retained by the driver and used
later (esp.
for pool object, but not just those), we would have to dynamically allocate
the interception trampoline every time.
That is getting to be an unreasonably large amount of complexity and
(possibly) overhead.

We are interested in both alloc/free and import/unimport.
The latter is fairly important for tracking (and avoiding double-counting)
of swapchain images (still true with native swapchains based on external
memory) and media/camera interop.
Though we might be able to handle this with additional
[VkInternalAllocationType](../chapters/memory.html#VkInternalAllocationType) values, for import/export we do want to be
able to tie this to the external resource, which is one thing that the
`memoryObjectId` is for.

The internal alloc/free callbacks are not extensible except via new
[VkInternalAllocationType](../chapters/memory.html#VkInternalAllocationType) values.
The [VkDeviceMemoryReportCallbackDataEXT](../chapters/devsandqueues.html#VkDeviceMemoryReportCallbackDataEXT) in this extension is
extensible.
That was deliberate: there is a real possibility we will want to get extra
information in the future.
As one example, currently this reports only physical allocations, but we
believe there are interesting cases for tracking how populated that VA
region is.

The callbacks are clearly specified as only callable within the context of a
call from the application into Vulkan.
We believe there are some cases where drivers can allocate device memory
asynchronously.
This was one of the sticky issues that derailed the internal device memory
allocation reporting design (which is essentially what this extension is
trying to do) leading up to 1.0.

[VkAllocationCallbacks](../chapters/memory.html#VkAllocationCallbacks) is described in a section called Host memory
and the intro to it is very explicitly about host memory.
The other callbacks are all inherently about host memory.
But this extension is very focused on device memory.

3) Should the callback be reporting which heap is used?

**RESOLVED**: Yes.
It is important for non-UMA systems to have all the device memory
allocations attributed to the corresponding device memory heaps.
For internally-allocated device memory, `heapIndex` will always
correspond to an advertised heap, rather than having a magic value
indicating a non-advertised heap.
Drivers can advertise heaps that do not have any corresponding memory types
if they need to.

4) Should we use an array of callback for the layers to intercept instead of
chaining multiple of the [VkDeviceDeviceMemoryReportCreateInfoEXT](../chapters/devsandqueues.html#VkDeviceDeviceMemoryReportCreateInfoEXT)
structures in the `pNext` of [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo)?

**RESOLVED** No.
The pointer to the [VkDeviceDeviceMemoryReportCreateInfoEXT](../chapters/devsandqueues.html#VkDeviceDeviceMemoryReportCreateInfoEXT) structure
itself is const and you cannot just cast it away.
Thus we cannot update the callback array inside the structure.
In addition, we cannot drop this `pNext` chain either, so making a copy
of this whole structure does not work either.

5) Should we track bulk allocations shared among multiple objects?

**RESOLVED** No.
Take the shader heap as an example.
Some implementations will let multiple [VkPipeline](../chapters/pipelines.html#VkPipeline) objects share the
same shader heap.
We are not asking the implementation to report `VK_OBJECT_TYPE_PIPELINE`
along with a [VK_NULL_HANDLE](boilerplate.html#VK_NULL_HANDLE) for this bulk allocation.
Instead, this bulk allocation is considered as a layer below what this
extension is interested in.
Later, when the actual [VkPipeline](../chapters/pipelines.html#VkPipeline) objects are created by suballocating
from the bulk allocation, we ask the implementation to report the valid
handles of the [VkPipeline](../chapters/pipelines.html#VkPipeline) objects along with the actual suballocated
sizes and different `memoryObjectId`.

6) Can we require the callbacks to be always called in the same thread with
the Vulkan commands?

**RESOLVED** No.
Some implementations might choose to multiplex work from multiple
application threads into a single backend thread and perform JIT allocations
as a part of that flow.
Since this behavior is theoretically legit, we cannot require the callbacks
to be always called in the same thread with the Vulkan commands, and the
note is to remind the applications to handle this case properly.

7) Should we add an additional allocation failed event type with things
like size and heap index reported?

**RESOLVED** Yes.
This fits in well with the callback infrastructure added in this extension,
and implementation touches the same code and has the same overheads as the
rest of the extension.
It could help debugging things like getting a
`VK_ERROR_OUT_OF_HOST_MEMORY` error when ending a command buffer.
Right now the allocation failure could have happened anywhere during
recording, and a callback would be really useful to understand where and
why.

* 
Revision 1, 2020-08-26 (Yiwei Zhang)

Initial version

Revision 2, 2021-01-06 (Yiwei Zhang)

* 
Minor description update

**Name String**

`VK_EXT_direct_mode_display`

**Extension Type**

Instance extension

**Registered Extension Number**

89

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_display](#VK_KHR_display)

**Contact**

* 
James Jones [cubanismo](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_direct_mode_display] @cubanismo%0A*Here describe the issue or question you have about the VK_EXT_direct_mode_display extension*)

**Last Modified Date**

2016-12-13

**IP Status**

No known IP claims.

**Contributors**

* 
Pierre Boudier, NVIDIA

* 
James Jones, NVIDIA

* 
Damien Leone, NVIDIA

* 
Pierre-Loup Griffais, Valve

* 
Liam Middlebrook, NVIDIA

This is extension, along with related platform extensions, allows
applications to take exclusive control of displays associated with a native
windowing system.
This is especially useful for virtual reality applications that wish to hide
HMDs (head mounted displays) from the native platforms display management
system, desktop, and/or other applications.

* 
[vkReleaseDisplayEXT](../chapters/VK_KHR_surface/wsi.html#vkReleaseDisplayEXT)

* 
`VK_EXT_DIRECT_MODE_DISPLAY_EXTENSION_NAME`

* 
`VK_EXT_DIRECT_MODE_DISPLAY_SPEC_VERSION`

1) Should this extension and its related platform-specific extensions
leverage `[VK_KHR_display](#VK_KHR_display)`, or provide separate equivalent interfaces.

**RESOLVED**: Use `[VK_KHR_display](#VK_KHR_display)` concepts and objects.
`[VK_KHR_display](#VK_KHR_display)` can be used to enumerate all displays on the system,
including those attached to/in use by a window system or native platform,
but `[VK_KHR_display_swapchain](#VK_KHR_display_swapchain)` will fail to create a swapchain on
in-use displays.
This extension and its platform-specific children will allow applications to
grab in-use displays away from window systems and/or native platforms,
allowing them to be used with `[VK_KHR_display_swapchain](#VK_KHR_display_swapchain)`.

2) Are separate calls needed to acquire displays and enable direct mode?

**RESOLVED**: No, these operations happen in one combined command.
Acquiring a display puts it into direct mode.

* 
Revision 1, 2016-12-13 (James Jones)

Initial draft

**Name String**

`VK_EXT_directfb_surface`

**Extension Type**

Instance extension

**Registered Extension Number**

347

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_surface](#VK_KHR_surface)

**Contact**

* 
Nicolas Caramelli [caramelli](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_directfb_surface] @caramelli%0A*Here describe the issue or question you have about the VK_EXT_directfb_surface extension*)

**Last Modified Date**

2020-06-16

**IP Status**

No known IP claims.

**Contributors**

* 
Nicolas Caramelli

The `VK_EXT_directfb_surface` extension is an instance extension.
It provides a mechanism to create a [VkSurfaceKHR](../chapters/VK_KHR_surface/wsi.html#VkSurfaceKHR) object (defined by
the `[VK_KHR_surface](#VK_KHR_surface)` extension) that refers to a DirectFB
`IDirectFBSurface`, as well as a query to determine support for rendering
via DirectFB.

* 
[vkCreateDirectFBSurfaceEXT](../chapters/VK_KHR_surface/wsi.html#vkCreateDirectFBSurfaceEXT)

* 
[vkGetPhysicalDeviceDirectFBPresentationSupportEXT](../chapters/VK_KHR_surface/wsi.html#vkGetPhysicalDeviceDirectFBPresentationSupportEXT)

* 
[VkDirectFBSurfaceCreateInfoEXT](../chapters/VK_KHR_surface/wsi.html#VkDirectFBSurfaceCreateInfoEXT)

* 
[VkDirectFBSurfaceCreateFlagsEXT](../chapters/VK_KHR_surface/wsi.html#VkDirectFBSurfaceCreateFlagsEXT)

* 
`VK_EXT_DIRECTFB_SURFACE_EXTENSION_NAME`

* 
`VK_EXT_DIRECTFB_SURFACE_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT`

* 
Revision 1, 2020-06-16 (Nicolas Caramelli)

Initial version

**Name String**

`VK_EXT_discard_rectangles`

**Extension Type**

Device extension

**Registered Extension Number**

100

**Revision**

2

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Contact**

* 
Piers Daniell [pdaniell-nv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_discard_rectangles] @pdaniell-nv%0A*Here describe the issue or question you have about the VK_EXT_discard_rectangles extension*)

**Last Modified Date**

2023-01-18

**Interactions and External Dependencies**

* 
Interacts with `[VK_KHR_device_group](#VK_KHR_device_group)`

* 
Interacts with Vulkan 1.1

**Contributors**

* 
Daniel Koch, NVIDIA

* 
Jeff Bolz, NVIDIA

This extension provides additional orthogonally aligned discard
rectangles specified in framebuffer-space coordinates that restrict
rasterization of all points, lines and triangles.

From zero to an implementation-dependent limit (specified by
`maxDiscardRectangles`) number of discard rectangles can be operational
at once.
When one or more discard rectangles are active, rasterized fragments can
either survive if the fragment is within any of the operational discard
rectangles (`VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT` mode) or be
rejected if the fragment is within any of the operational discard rectangles
(`VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT` mode).

These discard rectangles operate orthogonally to the existing scissor test
functionality.
The discard rectangles can be different for each physical device in a device
group by specifying the device mask and setting discard rectangle dynamic
state.

Version 2 of this extension introduces new dynamic states
`VK_DYNAMIC_STATE_DISCARD_RECTANGLE_ENABLE_EXT` and
`VK_DYNAMIC_STATE_DISCARD_RECTANGLE_MODE_EXT`, and the corresponding
functions [vkCmdSetDiscardRectangleEnableEXT](../chapters/fragops.html#vkCmdSetDiscardRectangleEnableEXT) and
[vkCmdSetDiscardRectangleModeEXT](../chapters/fragops.html#vkCmdSetDiscardRectangleModeEXT).
Applications that use these dynamic states must ensure the implementation
advertises at least `specVersion` `2` of this extension.

* 
[vkCmdSetDiscardRectangleEXT](../chapters/fragops.html#vkCmdSetDiscardRectangleEXT)

* 
[vkCmdSetDiscardRectangleEnableEXT](../chapters/fragops.html#vkCmdSetDiscardRectangleEnableEXT)

* 
[vkCmdSetDiscardRectangleModeEXT](../chapters/fragops.html#vkCmdSetDiscardRectangleModeEXT)

* 
Extending [VkGraphicsPipelineCreateInfo](../chapters/pipelines.html#VkGraphicsPipelineCreateInfo):

[VkPipelineDiscardRectangleStateCreateInfoEXT](../chapters/fragops.html#VkPipelineDiscardRectangleStateCreateInfoEXT)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceDiscardRectanglePropertiesEXT](../chapters/limits.html#VkPhysicalDeviceDiscardRectanglePropertiesEXT)

* 
[VkDiscardRectangleModeEXT](../chapters/fragops.html#VkDiscardRectangleModeEXT)

* 
[VkPipelineDiscardRectangleStateCreateFlagsEXT](../chapters/fragops.html#VkPipelineDiscardRectangleStateCreateFlagsEXT)

* 
`VK_EXT_DISCARD_RECTANGLES_EXTENSION_NAME`

* 
`VK_EXT_DISCARD_RECTANGLES_SPEC_VERSION`

* 
Extending [VkDynamicState](../chapters/pipelines.html#VkDynamicState):

`VK_DYNAMIC_STATE_DISCARD_RECTANGLE_ENABLE_EXT`

* 
`VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT`

* 
`VK_DYNAMIC_STATE_DISCARD_RECTANGLE_MODE_EXT`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT`

* 
`VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT`

* 
Revision 2, 2023-01-18 (Piers Daniell)

Add dynamic states for discard rectangle enable/disable and mode.

Revision 1, 2016-12-22 (Piers Daniell)

* 
Internal revisions

**Name String**

`VK_EXT_display_control`

**Extension Type**

Device extension

**Registered Extension Number**

92

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_EXT_display_surface_counter](#VK_EXT_display_surface_counter)

and

[VK_KHR_swapchain](#VK_KHR_swapchain)

**Contact**

* 
James Jones [cubanismo](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_display_control] @cubanismo%0A*Here describe the issue or question you have about the VK_EXT_display_control extension*)

**Last Modified Date**

2016-12-13

**IP Status**

No known IP claims.

**Contributors**

* 
Pierre Boudier, NVIDIA

* 
James Jones, NVIDIA

* 
Damien Leone, NVIDIA

* 
Pierre-Loup Griffais, Valve

* 
Daniel Vetter, Intel

This extension defines a set of utility functions for use with the
`[VK_KHR_display](#VK_KHR_display)` and `[VK_KHR_display_swapchain](#VK_KHR_display_swapchain)` extensions.

* 
[vkDisplayPowerControlEXT](../chapters/VK_KHR_surface/wsi.html#vkDisplayPowerControlEXT)

* 
[vkGetSwapchainCounterEXT](../chapters/VK_KHR_surface/wsi.html#vkGetSwapchainCounterEXT)

* 
[vkRegisterDeviceEventEXT](../chapters/synchronization.html#vkRegisterDeviceEventEXT)

* 
[vkRegisterDisplayEventEXT](../chapters/synchronization.html#vkRegisterDisplayEventEXT)

* 
[VkDeviceEventInfoEXT](../chapters/synchronization.html#VkDeviceEventInfoEXT)

* 
[VkDisplayEventInfoEXT](../chapters/synchronization.html#VkDisplayEventInfoEXT)

* 
[VkDisplayPowerInfoEXT](../chapters/VK_KHR_surface/wsi.html#VkDisplayPowerInfoEXT)

* 
Extending [VkSwapchainCreateInfoKHR](../chapters/VK_KHR_surface/wsi.html#VkSwapchainCreateInfoKHR):

[VkSwapchainCounterCreateInfoEXT](../chapters/VK_KHR_surface/wsi.html#VkSwapchainCounterCreateInfoEXT)

* 
[VkDeviceEventTypeEXT](../chapters/synchronization.html#VkDeviceEventTypeEXT)

* 
[VkDisplayEventTypeEXT](../chapters/synchronization.html#VkDisplayEventTypeEXT)

* 
[VkDisplayPowerStateEXT](../chapters/VK_KHR_surface/wsi.html#VkDisplayPowerStateEXT)

* 
`VK_EXT_DISPLAY_CONTROL_EXTENSION_NAME`

* 
`VK_EXT_DISPLAY_CONTROL_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT`

1) Should this extension add an explicit WaitForVsync API or a fence
signaled at vsync that the application can wait on?

**RESOLVED**: A fence.
A separate API could later be provided that allows exporting the fence to a
native object that could be inserted into standard run loops on POSIX and
Windows systems.

2) Should callbacks be added for a vsync event, or in general to monitor
events in Vulkan?

**RESOLVED**: No, fences should be used.
Some events are generated by interrupts which are managed in the kernel.
In order to use a callback provided by the application, drivers would need
to have the userspace driver spawn threads that would wait on the kernel
event, and hence the callbacks could be difficult for the application to
synchronize with its other work given they would arrive on a foreign thread.

3) Should vblank or scanline events be exposed?

**RESOLVED**: Vblank events.
Scanline events could be added by a separate extension, but the latency of
processing an interrupt and waking up a userspace event is high enough that
the accuracy of a scanline event would be rather low.
Further, per-scanline interrupts are not supported by all hardware.

* 
Revision 1, 2016-12-13 (James Jones)

Initial draft

**Name String**

`VK_EXT_display_surface_counter`

**Extension Type**

Instance extension

**Registered Extension Number**

91

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_display](#VK_KHR_display)

**Contact**

* 
James Jones [cubanismo](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_display_surface_counter] @cubanismo%0A*Here describe the issue or question you have about the VK_EXT_display_surface_counter extension*)

**Last Modified Date**

2016-12-13

**IP Status**

No known IP claims.

**Contributors**

* 
Pierre Boudier, NVIDIA

* 
James Jones, NVIDIA

* 
Damien Leone, NVIDIA

* 
Pierre-Loup Griffais, Valve

* 
Daniel Vetter, Intel

This extension defines a vertical blanking period counter associated with
display surfaces.
It provides a mechanism to query support for such a counter from a
[VkSurfaceKHR](../chapters/VK_KHR_surface/wsi.html#VkSurfaceKHR) object.

* 
[vkGetPhysicalDeviceSurfaceCapabilities2EXT](../chapters/VK_KHR_surface/wsi.html#vkGetPhysicalDeviceSurfaceCapabilities2EXT)

* 
[VkSurfaceCapabilities2EXT](../chapters/VK_KHR_surface/wsi.html#VkSurfaceCapabilities2EXT)

* 
[VkSurfaceCounterFlagBitsEXT](../chapters/VK_KHR_surface/wsi.html#VkSurfaceCounterFlagBitsEXT)

* 
[VkSurfaceCounterFlagsEXT](../chapters/VK_KHR_surface/wsi.html#VkSurfaceCounterFlagsEXT)

* 
`VK_EXT_DISPLAY_SURFACE_COUNTER_EXTENSION_NAME`

* 
`VK_EXT_DISPLAY_SURFACE_COUNTER_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES2_EXT`

* 
`VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT`

* 
Revision 1, 2016-12-13 (James Jones)

Initial draft

**Name String**

`VK_EXT_dynamic_rendering_unused_attachments`

**Extension Type**

Device extension

**Registered Extension Number**

500

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

 [VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

 or

 [Vulkan Version 1.1](versions.html#versions-1.1)

 and

 [VK_KHR_dynamic_rendering](#VK_KHR_dynamic_rendering)

or

[Vulkan Version 1.3](versions.html#versions-1.3)

**Contact**

* 
Piers Daniell [pdaniell-nv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_dynamic_rendering_unused_attachments] @pdaniell-nv%0A*Here describe the issue or question you have about the VK_EXT_dynamic_rendering_unused_attachments extension*)

**Extension Proposal**

[VK_EXT_dynamic_rendering_unused_attachments](../../../features/latest/features/proposals/VK_EXT_dynamic_rendering_unused_attachments.html)

**Last Modified Date**

2023-05-22

**IP Status**

No known IP claims.

**Contributors**

* 
Daniel Story, Nintendo

* 
Hans-Kristian Arntzen, Valve

* 
Jan-Harald Fredriksen, Arm

* 
James Fitzpatrick, Imagination Technologies

* 
Pan Gao, Huawei Technologies

* 
Ricardo Garcia, Igalia

* 
Stu Smith, AMD

This extension lifts some restrictions in the
`[VK_KHR_dynamic_rendering](#VK_KHR_dynamic_rendering)` extension to allow render pass instances
and bound pipelines within those render pass instances to have an unused
attachment specified in one but not the other.
It also allows pipelines to use different formats in a render pass as long
the attachment is NULL.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT](../chapters/features.html#VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT)

* 
`VK_EXT_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_EXTENSION_NAME`

* 
`VK_EXT_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT`

None.

* 
Revision 1, 2023-05-22 (Piers Daniell)

Internal revisions

**Name String**

`VK_EXT_extended_dynamic_state3`

**Extension Type**

Device extension

**Registered Extension Number**

456

**Revision**

2

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**API Interactions**

* 
Interacts with VK_VERSION_1_1

* 
Interacts with VK_EXT_blend_operation_advanced

* 
Interacts with VK_EXT_conservative_rasterization

* 
Interacts with VK_EXT_depth_clip_control

* 
Interacts with VK_EXT_depth_clip_enable

* 
Interacts with VK_EXT_line_rasterization

* 
Interacts with VK_EXT_provoking_vertex

* 
Interacts with VK_EXT_sample_locations

* 
Interacts with VK_EXT_transform_feedback

* 
Interacts with VK_KHR_maintenance2

* 
Interacts with VK_NV_clip_space_w_scaling

* 
Interacts with VK_NV_coverage_reduction_mode

* 
Interacts with VK_NV_fragment_coverage_to_color

* 
Interacts with VK_NV_framebuffer_mixed_samples

* 
Interacts with VK_NV_representative_fragment_test

* 
Interacts with VK_NV_shading_rate_image

* 
Interacts with VK_NV_viewport_swizzle

* 
Interacts with VkPhysicalDeviceExtendedDynamicState3FeaturesEXT::extendedDynamicState3AlphaToOneEnable

* 
Interacts with VkPhysicalDeviceExtendedDynamicState3FeaturesEXT::extendedDynamicState3DepthClampEnable

* 
Interacts with VkPhysicalDeviceExtendedDynamicState3FeaturesEXT::extendedDynamicState3LogicOpEnable

* 
Interacts with VkPhysicalDeviceExtendedDynamicState3FeaturesEXT::extendedDynamicState3PolygonMode

* 
Interacts with VkPhysicalDeviceExtendedDynamicState3FeaturesEXT::extendedDynamicState3RasterizationStream

* 
Interacts with VkPhysicalDeviceExtendedDynamicState3FeaturesEXT::extendedDynamicState3TessellationDomainOrigin

**Contact**

* 
Piers Daniell [pdaniell-nv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_extended_dynamic_state3] @pdaniell-nv%0A*Here describe the issue or question you have about the VK_EXT_extended_dynamic_state3 extension*)

**Extension Proposal**

[VK_EXT_extended_dynamic_state3](../../../features/latest/features/proposals/VK_EXT_extended_dynamic_state3.html)

**Last Modified Date**

2022-09-02

**IP Status**

No known IP claims.

**Contributors**

* 
Daniel Story, Nintendo

* 
Jamie Madill, Google

* 
Jan-Harald Fredriksen, Arm

* 
Faith Ekstrand, Collabora

* 
Mike Blumenkrantz, Valve

* 
Ricardo Garcia, Igalia

* 
Samuel Pitoiset, Valve

* 
Shahbaz Youssefi, Google

* 
Stu Smith, AMD

* 
Tapani Plli, Intel

This extension adds almost all of the remaining pipeline state as dynamic
state to help applications further reduce the number of monolithic pipelines
they need to create and bind.

* 
[vkCmdSetAlphaToCoverageEnableEXT](../chapters/fragops.html#vkCmdSetAlphaToCoverageEnableEXT)

* 
[vkCmdSetAlphaToOneEnableEXT](../chapters/fragops.html#vkCmdSetAlphaToOneEnableEXT)

* 
[vkCmdSetColorBlendEnableEXT](../chapters/framebuffer.html#vkCmdSetColorBlendEnableEXT)

* 
[vkCmdSetColorBlendEquationEXT](../chapters/framebuffer.html#vkCmdSetColorBlendEquationEXT)

* 
[vkCmdSetColorWriteMaskEXT](../chapters/framebuffer.html#vkCmdSetColorWriteMaskEXT)

* 
[vkCmdSetDepthClampEnableEXT](../chapters/vertexpostproc.html#vkCmdSetDepthClampEnableEXT)

* 
[vkCmdSetLogicOpEnableEXT](../chapters/framebuffer.html#vkCmdSetLogicOpEnableEXT)

* 
[vkCmdSetPolygonModeEXT](../chapters/primsrast.html#vkCmdSetPolygonModeEXT)

* 
[vkCmdSetRasterizationSamplesEXT](../chapters/primsrast.html#vkCmdSetRasterizationSamplesEXT)

* 
[vkCmdSetSampleMaskEXT](../chapters/fragops.html#vkCmdSetSampleMaskEXT)

If [VK_EXT_blend_operation_advanced](#VK_EXT_blend_operation_advanced) is supported:

* 
[vkCmdSetColorBlendAdvancedEXT](../chapters/framebuffer.html#vkCmdSetColorBlendAdvancedEXT)

If [VK_EXT_conservative_rasterization](#VK_EXT_conservative_rasterization) is supported:

* 
[vkCmdSetConservativeRasterizationModeEXT](../chapters/primsrast.html#vkCmdSetConservativeRasterizationModeEXT)

* 
[vkCmdSetExtraPrimitiveOverestimationSizeEXT](../chapters/primsrast.html#vkCmdSetExtraPrimitiveOverestimationSizeEXT)

If [VK_EXT_depth_clip_control](#VK_EXT_depth_clip_control) is supported:

* 
[vkCmdSetDepthClipNegativeOneToOneEXT](../chapters/vertexpostproc.html#vkCmdSetDepthClipNegativeOneToOneEXT)

If [VK_EXT_depth_clip_enable](#VK_EXT_depth_clip_enable) is supported:

* 
[vkCmdSetDepthClipEnableEXT](../chapters/vertexpostproc.html#vkCmdSetDepthClipEnableEXT)

If [VK_EXT_line_rasterization](#VK_EXT_line_rasterization) is supported:

* 
[vkCmdSetLineRasterizationModeEXT](../chapters/primsrast.html#vkCmdSetLineRasterizationModeEXT)

* 
[vkCmdSetLineStippleEnableEXT](../chapters/primsrast.html#vkCmdSetLineStippleEnableEXT)

If [VK_EXT_provoking_vertex](#VK_EXT_provoking_vertex) is supported:

* 
[vkCmdSetProvokingVertexModeEXT](../chapters/vertexpostproc.html#vkCmdSetProvokingVertexModeEXT)

If [VK_EXT_sample_locations](#VK_EXT_sample_locations) is supported:

* 
[vkCmdSetSampleLocationsEnableEXT](../chapters/primsrast.html#vkCmdSetSampleLocationsEnableEXT)

If [VK_EXT_transform_feedback](#VK_EXT_transform_feedback) is supported:

* 
[vkCmdSetRasterizationStreamEXT](../chapters/primsrast.html#vkCmdSetRasterizationStreamEXT)

If [VK_KHR_maintenance2](#VK_KHR_maintenance2) or [Vulkan Version 1.1](versions.html#versions-1.1) is supported:

* 
[vkCmdSetTessellationDomainOriginEXT](../chapters/tessellation.html#vkCmdSetTessellationDomainOriginEXT)

If [VK_NV_clip_space_w_scaling](#VK_NV_clip_space_w_scaling) is supported:

* 
[vkCmdSetViewportWScalingEnableNV](../chapters/vertexpostproc.html#vkCmdSetViewportWScalingEnableNV)

If [VK_NV_coverage_reduction_mode](#VK_NV_coverage_reduction_mode) is supported:

* 
[vkCmdSetCoverageReductionModeNV](../chapters/fragops.html#vkCmdSetCoverageReductionModeNV)

If [VK_NV_fragment_coverage_to_color](#VK_NV_fragment_coverage_to_color) is supported:

* 
[vkCmdSetCoverageToColorEnableNV](../chapters/fragops.html#vkCmdSetCoverageToColorEnableNV)

* 
[vkCmdSetCoverageToColorLocationNV](../chapters/fragops.html#vkCmdSetCoverageToColorLocationNV)

If [VK_NV_framebuffer_mixed_samples](#VK_NV_framebuffer_mixed_samples) is supported:

* 
[vkCmdSetCoverageModulationModeNV](../chapters/fragops.html#vkCmdSetCoverageModulationModeNV)

* 
[vkCmdSetCoverageModulationTableEnableNV](../chapters/fragops.html#vkCmdSetCoverageModulationTableEnableNV)

* 
[vkCmdSetCoverageModulationTableNV](../chapters/fragops.html#vkCmdSetCoverageModulationTableNV)

If [VK_NV_representative_fragment_test](#VK_NV_representative_fragment_test) is supported:

* 
[vkCmdSetRepresentativeFragmentTestEnableNV](../chapters/fragops.html#vkCmdSetRepresentativeFragmentTestEnableNV)

If [VK_NV_shading_rate_image](#VK_NV_shading_rate_image) is supported:

* 
[vkCmdSetShadingRateImageEnableNV](../chapters/primsrast.html#vkCmdSetShadingRateImageEnableNV)

If [VK_NV_viewport_swizzle](#VK_NV_viewport_swizzle) is supported:

* 
[vkCmdSetViewportSwizzleNV](../chapters/vertexpostproc.html#vkCmdSetViewportSwizzleNV)

* 
[VkColorBlendAdvancedEXT](../chapters/framebuffer.html#VkColorBlendAdvancedEXT)

* 
[VkColorBlendEquationEXT](../chapters/framebuffer.html#VkColorBlendEquationEXT)

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceExtendedDynamicState3FeaturesEXT](../chapters/features.html#VkPhysicalDeviceExtendedDynamicState3FeaturesEXT)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceExtendedDynamicState3PropertiesEXT](../chapters/limits.html#VkPhysicalDeviceExtendedDynamicState3PropertiesEXT)

* 
`VK_EXT_EXTENDED_DYNAMIC_STATE_3_EXTENSION_NAME`

* 
`VK_EXT_EXTENDED_DYNAMIC_STATE_3_SPEC_VERSION`

* 
Extending [VkDynamicState](../chapters/pipelines.html#VkDynamicState):

`VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT`

* 
`VK_DYNAMIC_STATE_ALPHA_TO_ONE_ENABLE_EXT`

* 
`VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT`

* 
`VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT`

* 
`VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT`

* 
`VK_DYNAMIC_STATE_DEPTH_CLAMP_ENABLE_EXT`

* 
`VK_DYNAMIC_STATE_LOGIC_OP_ENABLE_EXT`

* 
`VK_DYNAMIC_STATE_POLYGON_MODE_EXT`

* 
`VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT`

* 
`VK_DYNAMIC_STATE_SAMPLE_MASK_EXT`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT`

If [VK_EXT_blend_operation_advanced](#VK_EXT_blend_operation_advanced) is supported:

* 
Extending [VkDynamicState](../chapters/pipelines.html#VkDynamicState):

`VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT`

If [VK_EXT_conservative_rasterization](#VK_EXT_conservative_rasterization) is supported:

* 
Extending [VkDynamicState](../chapters/pipelines.html#VkDynamicState):

`VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT`

* 
`VK_DYNAMIC_STATE_EXTRA_PRIMITIVE_OVERESTIMATION_SIZE_EXT`

If [VK_EXT_depth_clip_control](#VK_EXT_depth_clip_control) is supported:

* 
Extending [VkDynamicState](../chapters/pipelines.html#VkDynamicState):

`VK_DYNAMIC_STATE_DEPTH_CLIP_NEGATIVE_ONE_TO_ONE_EXT`

If [VK_EXT_depth_clip_enable](#VK_EXT_depth_clip_enable) is supported:

* 
Extending [VkDynamicState](../chapters/pipelines.html#VkDynamicState):

`VK_DYNAMIC_STATE_DEPTH_CLIP_ENABLE_EXT`

If [VK_EXT_line_rasterization](#VK_EXT_line_rasterization) is supported:

* 
Extending [VkDynamicState](../chapters/pipelines.html#VkDynamicState):

`VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT`

* 
`VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT`

If [VK_EXT_provoking_vertex](#VK_EXT_provoking_vertex) is supported:

* 
Extending [VkDynamicState](../chapters/pipelines.html#VkDynamicState):

`VK_DYNAMIC_STATE_PROVOKING_VERTEX_MODE_EXT`

If [VK_EXT_sample_locations](#VK_EXT_sample_locations) is supported:

* 
Extending [VkDynamicState](../chapters/pipelines.html#VkDynamicState):

`VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT`

If [VK_EXT_transform_feedback](#VK_EXT_transform_feedback) is supported:

* 
Extending [VkDynamicState](../chapters/pipelines.html#VkDynamicState):

`VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT`

If [VK_KHR_maintenance2](#VK_KHR_maintenance2) or [Vulkan Version 1.1](versions.html#versions-1.1) is supported:

* 
Extending [VkDynamicState](../chapters/pipelines.html#VkDynamicState):

`VK_DYNAMIC_STATE_TESSELLATION_DOMAIN_ORIGIN_EXT`

If [VK_NV_clip_space_w_scaling](#VK_NV_clip_space_w_scaling) is supported:

* 
Extending [VkDynamicState](../chapters/pipelines.html#VkDynamicState):

`VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_ENABLE_NV`

If [VK_NV_coverage_reduction_mode](#VK_NV_coverage_reduction_mode) is supported:

* 
Extending [VkDynamicState](../chapters/pipelines.html#VkDynamicState):

`VK_DYNAMIC_STATE_COVERAGE_REDUCTION_MODE_NV`

If [VK_NV_fragment_coverage_to_color](#VK_NV_fragment_coverage_to_color) is supported:

* 
Extending [VkDynamicState](../chapters/pipelines.html#VkDynamicState):

`VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV`

* 
`VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_LOCATION_NV`

If [VK_NV_framebuffer_mixed_samples](#VK_NV_framebuffer_mixed_samples) is supported:

* 
Extending [VkDynamicState](../chapters/pipelines.html#VkDynamicState):

`VK_DYNAMIC_STATE_COVERAGE_MODULATION_MODE_NV`

* 
`VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV`

* 
`VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_NV`

If [VK_NV_representative_fragment_test](#VK_NV_representative_fragment_test) is supported:

* 
Extending [VkDynamicState](../chapters/pipelines.html#VkDynamicState):

`VK_DYNAMIC_STATE_REPRESENTATIVE_FRAGMENT_TEST_ENABLE_NV`

If [VK_NV_shading_rate_image](#VK_NV_shading_rate_image) is supported:

* 
Extending [VkDynamicState](../chapters/pipelines.html#VkDynamicState):

`VK_DYNAMIC_STATE_SHADING_RATE_IMAGE_ENABLE_NV`

If [VK_NV_viewport_swizzle](#VK_NV_viewport_swizzle) is supported:

* 
Extending [VkDynamicState](../chapters/pipelines.html#VkDynamicState):

`VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV`

1) What about the VkPipelineMultisampleStateCreateInfo state
`sampleShadingEnable` and `minSampleShading`?

**UNRESOLVED**

* 
`sampleShadingEnable` and `minSampleShading` are required when compiling
the fragment shader, and it is not meaningful to set them dynamically
since they always need to match the fragment shader state, so this
hardware state may as well just come from the pipeline with the fragment
shader.

* 
Revision 2, 2022-07-18 (Piers Daniell)

Added rasterizationSamples

Revision 1, 2022-05-18 (Piers Daniell)

* 
Internal revisions

**Name String**

`VK_EXT_external_memory_acquire_unmodified`

**Extension Type**

Device extension

**Registered Extension Number**

454

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_external_memory](#VK_KHR_external_memory)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Contact**

* 
Lina Versace [linyaa-kiwi](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_external_memory_acquire_unmodified] @linyaa-kiwi%0A*Here describe the issue or question you have about the VK_EXT_external_memory_acquire_unmodified extension*)

**Extension Proposal**

[VK_EXT_external_memory_acquire_unmodified](../../../features/latest/features/proposals/VK_EXT_external_memory_acquire_unmodified.html)

**Last Modified Date**

2023-03-09

**Contributors**

* 
Lina Versace, Google

* 
Chia-I Wu, Google

* 
James Jones, NVIDIA

* 
Yiwei Zhang, Google

A memory barrier **may** have a performance penalty when acquiring ownership of
a subresource range from an external queue family.
This extension provides API that **may** reduce the performance penalty if
ownership of the subresource range was previously released to the external
queue family and if the resources memory has remained unmodified between
the release and acquire operations.

* 
Extending [VkBufferMemoryBarrier](../chapters/synchronization.html#VkBufferMemoryBarrier), [VkBufferMemoryBarrier2](../chapters/synchronization.html#VkBufferMemoryBarrier2), [VkImageMemoryBarrier](../chapters/synchronization.html#VkImageMemoryBarrier), [VkImageMemoryBarrier2](../chapters/synchronization.html#VkImageMemoryBarrier2):

[VkExternalMemoryAcquireUnmodifiedEXT](../chapters/synchronization.html#VkExternalMemoryAcquireUnmodifiedEXT)

* 
`VK_EXT_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXTENSION_NAME`

* 
`VK_EXT_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT`

* 
Revision 1, 2023-03-09 (Lina Versace)

Initial revision

**Name String**

`VK_EXT_external_memory_dma_buf`

**Extension Type**

Device extension

**Registered Extension Number**

126

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_external_memory_fd](#VK_KHR_external_memory_fd)

**Contact**

* 
Lina Versace [linyaa-kiwi](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_external_memory_dma_buf] @linyaa-kiwi%0A*Here describe the issue or question you have about the VK_EXT_external_memory_dma_buf extension*)

**Last Modified Date**

2017-10-10

**IP Status**

No known IP claims.

**Contributors**

* 
Lina Versace, Google

* 
James Jones, NVIDIA

* 
Faith Ekstrand, Intel

A `dma_buf` is a type of file descriptor, defined by the Linux kernel,
that allows sharing memory across kernel device drivers and across
processes.
This extension enables applications to import a `dma_buf` as
[VkDeviceMemory](../chapters/memory.html#VkDeviceMemory), to export [VkDeviceMemory](../chapters/memory.html#VkDeviceMemory) as a `dma_buf`, and
to create [VkBuffer](../chapters/resources.html#VkBuffer) objects that **can** be bound to that memory.

* 
`VK_EXT_EXTERNAL_MEMORY_DMA_BUF_EXTENSION_NAME`

* 
`VK_EXT_EXTERNAL_MEMORY_DMA_BUF_SPEC_VERSION`

* 
Extending [VkExternalMemoryHandleTypeFlagBits](../chapters/capabilities.html#VkExternalMemoryHandleTypeFlagBits):

`VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT`

1) How does the application, when creating a [VkImage](../chapters/resources.html#VkImage) that it intends
to bind to `dma_buf` [VkDeviceMemory](../chapters/memory.html#VkDeviceMemory) containing an externally
produced image, specify the memory layout (such as row pitch and DRM format
modifier) of the [VkImage](../chapters/resources.html#VkImage)? In other words, how does the application
achieve behavior comparable to that provided by
[`EGL_EXT_image_dma_buf_import`](https://registry.khronos.org/EGL/extensions/EXT/EGL_EXT_image_dma_buf_import.txt)
and
[`EGL_EXT_image_dma_buf_import_modifiers`](https://registry.khronos.org/EGL/extensions/EXT/EGL_EXT_image_dma_buf_import_modifiers.txt)
?

**RESOLVED**: Features comparable to those in
[`EGL_EXT_image_dma_buf_import`](https://registry.khronos.org/EGL/extensions/EXT/EGL_EXT_image_dma_buf_import.txt)
and
[`EGL_EXT_image_dma_buf_import_modifiers`](https://registry.khronos.org/EGL/extensions/EXT/EGL_EXT_image_dma_buf_import_modifiers.txt)
will be provided by an extension layered atop this one.

2) Without the ability to specify the memory layout of external `dma_buf`
images, how is this extension useful?

**RESOLVED**: This extension provides exactly one new feature: the ability to
import/export between `dma_buf` and [VkDeviceMemory](../chapters/memory.html#VkDeviceMemory).
This feature, together with features provided by
`[VK_KHR_external_memory_fd](#VK_KHR_external_memory_fd)`, is sufficient to bind a [VkBuffer](../chapters/resources.html#VkBuffer)
to `dma_buf`.

* 
Revision 1, 2017-10-10 (Lina Versace)

Squashed internal revisions

**Name String**

`VK_EXT_external_memory_host`

**Extension Type**

Device extension

**Registered Extension Number**

179

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_external_memory](#VK_KHR_external_memory)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Contact**

* 
Daniel Rakos [drakos-amd](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_external_memory_host] @drakos-amd%0A*Here describe the issue or question you have about the VK_EXT_external_memory_host extension*)

**Last Modified Date**

2017-11-10

**IP Status**

No known IP claims.

**Contributors**

* 
Jaakko Konttinen, AMD

* 
David Mao, AMD

* 
Daniel Rakos, AMD

* 
Tobias Hector, Imagination Technologies

* 
Faith Ekstrand, Intel

* 
James Jones, NVIDIA

This extension enables an application to import host allocations and host
mapped foreign device memory to Vulkan memory objects.

* 
[vkGetMemoryHostPointerPropertiesEXT](../chapters/memory.html#vkGetMemoryHostPointerPropertiesEXT)

* 
[VkMemoryHostPointerPropertiesEXT](../chapters/memory.html#VkMemoryHostPointerPropertiesEXT)

* 
Extending [VkMemoryAllocateInfo](../chapters/memory.html#VkMemoryAllocateInfo):

[VkImportMemoryHostPointerInfoEXT](../chapters/memory.html#VkImportMemoryHostPointerInfoEXT)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceExternalMemoryHostPropertiesEXT](../chapters/limits.html#VkPhysicalDeviceExternalMemoryHostPropertiesEXT)

* 
`VK_EXT_EXTERNAL_MEMORY_HOST_EXTENSION_NAME`

* 
`VK_EXT_EXTERNAL_MEMORY_HOST_SPEC_VERSION`

* 
Extending [VkExternalMemoryHandleTypeFlagBits](../chapters/capabilities.html#VkExternalMemoryHandleTypeFlagBits):

`VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT`

* 
`VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT`

1) What memory type has to be used to import host pointers?

**RESOLVED**: Depends on the implementation.
Applications have to use the new [vkGetMemoryHostPointerPropertiesEXT](../chapters/memory.html#vkGetMemoryHostPointerPropertiesEXT)
command to query the supported memory types for a particular host pointer.
The reported memory types may include memory types that come from a memory
heap that is otherwise not usable for regular memory object allocation and
thus such a heaps size may be zero.

2) Can the application still access the contents of the host allocation
after importing?

**RESOLVED**: Yes.
However, usual synchronization requirements apply.

3) Can the application free the host allocation?

**RESOLVED**: No, it violates valid usage conditions.
Using the memory object imported from a host allocation that is already
freed thus results in **undefined** behavior.

4) Is [vkMapMemory](../chapters/memory.html#vkMapMemory) expected to return the same host address which was
specified when importing it to the memory object?

**RESOLVED**: No.
Implementations are allowed to return the same address but it is not
required.
Some implementations might return a different virtual mapping of the
allocation, although the same physical pages will be used.

5) Is there any limitation on the alignment of the host pointer and/or size?

**RESOLVED**: Yes.
Both the address and the size have to be an integer multiple of
`minImportedHostPointerAlignment`.
In addition, some platforms and foreign devices may have additional
restrictions.

6) Can the same host allocation be imported multiple times into a given
physical device?

**RESOLVED**: No, at least not guaranteed by this extension.
Some platforms do not allow locking the same physical pages for device
access multiple times, so attempting to do it may result in **undefined**
behavior.

7) Does this extension support exporting the new handle type?

**RESOLVED**: No.

8) Should we include the possibility to import host mapped foreign device
memory using this API?

**RESOLVED**: Yes, through a separate handle type.
Implementations are still allowed to support only one of the handle types
introduced by this extension by not returning import support for a
particular handle type as returned in [VkExternalMemoryPropertiesKHR](../chapters/capabilities.html#VkExternalMemoryPropertiesKHR).

* 
Revision 1, 2017-11-10 (Daniel Rakos)

Internal revisions

**Name String**

`VK_EXT_external_memory_metal`

**Extension Type**

Device extension

**Registered Extension Number**

603

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_external_memory](#VK_KHR_external_memory)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Contact**

* 
Aitor Camacho Larrondo [aitor-lunarg](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_external_memory_metal] @aitor-lunarg%0A*Here describe the issue or question you have about the VK_EXT_external_memory_metal extension*)

**Extension Proposal**

[VK_EXT_external_memory_metal](../../../features/latest/features/proposals/VK_EXT_external_memory_metal.html)

**Last Modified Date**

2024-07-18

**IP Status**

No known IP claims.

**Contributors**

* 
Aitor Camacho Larrondo, LunarG Inc.

An application may wish to reference device memory in multiple Vulkan device
instances, in multiple processes, and/or in Metal API.
This extension enables an application to export and import Metal handles
from Vulkan memory objects such that the underlying resources can be
referenced outside the scope of the Vulkan device instance that created
them.

* 
[vkGetMemoryMetalHandleEXT](../chapters/memory.html#vkGetMemoryMetalHandleEXT)

* 
[vkGetMemoryMetalHandlePropertiesEXT](../chapters/memory.html#vkGetMemoryMetalHandlePropertiesEXT)

* 
[VkMemoryGetMetalHandleInfoEXT](../chapters/memory.html#VkMemoryGetMetalHandleInfoEXT)

* 
[VkMemoryMetalHandlePropertiesEXT](../chapters/memory.html#VkMemoryMetalHandlePropertiesEXT)

* 
Extending [VkMemoryAllocateInfo](../chapters/memory.html#VkMemoryAllocateInfo):

[VkImportMemoryMetalHandleInfoEXT](../chapters/memory.html#VkImportMemoryMetalHandleInfoEXT)

* 
`VK_EXT_EXTERNAL_MEMORY_METAL_EXTENSION_NAME`

* 
`VK_EXT_EXTERNAL_MEMORY_METAL_SPEC_VERSION`

* 
Extending [VkExternalMemoryHandleTypeFlagBits](../chapters/capabilities.html#VkExternalMemoryHandleTypeFlagBits):

`VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLBUFFER_BIT_EXT`

* 
`VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLHEAP_BIT_EXT`

* 
`VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLTEXTURE_BIT_EXT`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_IMPORT_MEMORY_METAL_HANDLE_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_MEMORY_GET_METAL_HANDLE_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_MEMORY_METAL_HANDLE_PROPERTIES_EXT`

* 
Revision 1, 2024-07-18 (Aitor Camacho Larrondo)

Initial revision

**Name String**

`VK_EXT_filter_cubic`

**Extension Type**

Device extension

**Registered Extension Number**

171

**Revision**

3

**Ratification Status**

Ratified

**Extension and Version Dependencies**

None

**Contact**

* 
Matthew Netsch [mnetsch](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_filter_cubic] @mnetsch%0A*Here describe the issue or question you have about the VK_EXT_filter_cubic extension*)

**Last Modified Date**

2019-12-13

**Contributors**

* 
Bill Licea-Kane, Qualcomm Technologies, Inc.

* 
Andrew Garrard, Samsung

* 
Daniel Koch, NVIDIA

* 
Donald Scorgie, Imagination Technologies

* 
Graeme Leese, Broadcom

* 
Jan-Harald Fredriksen, ARM

* 
Jeff Leger, Qualcomm Technologies, Inc.

* 
Tobias Hector, AMD

* 
Tom Olson, ARM

* 
Stuart Smith, Imagination Technologies

`VK_EXT_filter_cubic` extends `VK_IMG_filter_cubic`.

It documents cubic filtering of other image view types.
It adds new structures that **can** be added to the `pNext` chain of
[VkPhysicalDeviceImageFormatInfo2](../chapters/capabilities.html#VkPhysicalDeviceImageFormatInfo2) and [VkImageFormatProperties2](../chapters/capabilities.html#VkImageFormatProperties2)
that **can** be used to determine which image types and which image view types
support cubic filtering.

* 
Extending [VkImageFormatProperties2](../chapters/capabilities.html#VkImageFormatProperties2):

[VkFilterCubicImageViewImageFormatPropertiesEXT](../chapters/capabilities.html#VkFilterCubicImageViewImageFormatPropertiesEXT)

Extending [VkPhysicalDeviceImageFormatInfo2](../chapters/capabilities.html#VkPhysicalDeviceImageFormatInfo2):

* 
[VkPhysicalDeviceImageViewImageFormatInfoEXT](../chapters/capabilities.html#VkPhysicalDeviceImageViewImageFormatInfoEXT)

* 
`VK_EXT_FILTER_CUBIC_EXTENSION_NAME`

* 
`VK_EXT_FILTER_CUBIC_SPEC_VERSION`

* 
Extending [VkFilter](../chapters/samplers.html#VkFilter):

`VK_FILTER_CUBIC_EXT`

Extending [VkFormatFeatureFlagBits](../chapters/formats.html#VkFormatFeatureFlagBits):

* 
`VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT`

* 
Revision 3, 2019-12-13 (wwlk)

Delete requirement to cubic filter the formats USCALED_PACKED32,
SSCALED_PACKED32, UINT_PACK32, and SINT_PACK32 (cut/paste error)

Revision 2, 2019-06-05 (wwlk)

* 
Clarify 1D optional

Revision 1, 2019-01-24 (wwlk)

* 
Initial version

**Name String**

`VK_EXT_fragment_density_map`

**Extension Type**

Device extension

**Registered Extension Number**

219

**Revision**

2

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**API Interactions**

* 
Interacts with VK_VERSION_1_3

* 
Interacts with VK_KHR_dynamic_rendering

* 
Interacts with VK_KHR_format_feature_flags2

**SPIR-V Dependencies**

* 
[SPV_EXT_fragment_invocation_density](https://github.khronos.org/SPIRV-Registry/extensions/EXT/SPV_EXT_fragment_invocation_density.html)

**Contact**

* 
Matthew Netsch [mnetsch](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_fragment_density_map] @mnetsch%0A*Here describe the issue or question you have about the VK_EXT_fragment_density_map extension*)

**Last Modified Date**

2021-09-30

**Interactions and External Dependencies**

* 
This extension provides API support for
[`GL_EXT_fragment_invocation_density`](https://github.com/KhronosGroup/GLSL/blob/main/extensions/ext/GLSL_EXT_fragment_invocation_density.txt)

**Contributors**

* 
Matthew Netsch, Qualcomm Technologies, Inc.

* 
Robert VanReenen, Qualcomm Technologies, Inc.

* 
Jonathan Wicks, Qualcomm Technologies, Inc.

* 
Tate Hornbeck, Qualcomm Technologies, Inc.

* 
Sam Holmes, Qualcomm Technologies, Inc.

* 
Jeff Leger, Qualcomm Technologies, Inc.

* 
Jan-Harald Fredriksen, ARM

* 
Jeff Bolz, NVIDIA

* 
Pat Brown, NVIDIA

* 
Daniel Rakos, AMD

* 
Piers Daniell, NVIDIA

This extension allows an application to specify areas of the render target
where the fragment shader may be invoked fewer times.
These fragments are broadcasted out to multiple pixels to cover the render
target.

The primary use of this extension is to reduce workloads in areas where
lower quality may not be perceived such as the distorted edges of a lens or
the periphery of a users gaze.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceFragmentDensityMapFeaturesEXT](../chapters/features.html#VkPhysicalDeviceFragmentDensityMapFeaturesEXT)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceFragmentDensityMapPropertiesEXT](../chapters/limits.html#VkPhysicalDeviceFragmentDensityMapPropertiesEXT)

Extending [VkRenderPassCreateInfo](../chapters/renderpass.html#VkRenderPassCreateInfo), [VkRenderPassCreateInfo2](../chapters/renderpass.html#VkRenderPassCreateInfo2):

* 
[VkRenderPassFragmentDensityMapCreateInfoEXT](../chapters/renderpass.html#VkRenderPassFragmentDensityMapCreateInfoEXT)

If [Vulkan Version 1.3](versions.html#versions-1.3) or [VK_KHR_dynamic_rendering](#VK_KHR_dynamic_rendering) is supported:

* 
Extending [VkRenderingInfo](../chapters/renderpass.html#VkRenderingInfo):

[VkRenderingFragmentDensityMapAttachmentInfoEXT](../chapters/renderpass.html#VkRenderingFragmentDensityMapAttachmentInfoEXT)

* 
`VK_EXT_FRAGMENT_DENSITY_MAP_EXTENSION_NAME`

* 
`VK_EXT_FRAGMENT_DENSITY_MAP_SPEC_VERSION`

* 
Extending [VkAccessFlagBits](../chapters/synchronization.html#VkAccessFlagBits):

`VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT`

Extending [VkFormatFeatureFlagBits](../chapters/formats.html#VkFormatFeatureFlagBits):

* 
`VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT`

Extending [VkImageCreateFlagBits](../chapters/resources.html#VkImageCreateFlagBits):

* 
`VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT`

Extending [VkImageLayout](../chapters/resources.html#VkImageLayout):

* 
`VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT`

Extending [VkImageUsageFlagBits](../chapters/resources.html#VkImageUsageFlagBits):

* 
`VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT`

Extending [VkImageViewCreateFlagBits](../chapters/resources.html#VkImageViewCreateFlagBits):

* 
`VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT`

Extending [VkPipelineStageFlagBits](../chapters/synchronization.html#VkPipelineStageFlagBits):

* 
`VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT`

Extending [VkSamplerCreateFlagBits](../chapters/samplers.html#VkSamplerCreateFlagBits):

* 
`VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT`

* 
`VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT`

* 
`VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT`

If [VK_KHR_format_feature_flags2](#VK_KHR_format_feature_flags2) or [Vulkan Version 1.3](versions.html#versions-1.3) is supported:

* 
Extending [VkFormatFeatureFlagBits2](../chapters/formats.html#VkFormatFeatureFlagBits2):

`VK_FORMAT_FEATURE_2_FRAGMENT_DENSITY_MAP_BIT_EXT`

If [Vulkan Version 1.3](versions.html#versions-1.3) or [VK_KHR_dynamic_rendering](#VK_KHR_dynamic_rendering) is supported:

* 
Extending [VkPipelineCreateFlagBits](../chapters/pipelines.html#VkPipelineCreateFlagBits):

`VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT`

* 
`VK_PIPELINE_RASTERIZATION_STATE_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT`

* 
[`FragInvocationCountEXT`](../chapters/interfaces.html#interfaces-builtin-variables-fraginvocationcount)

* 
[`FragSizeEXT`](../chapters/interfaces.html#interfaces-builtin-variables-fragsize)

* 
[    `FragmentDensityEXT`](spirvenv.html#spirvenv-capabilities-table-FragmentDensityEXT)

* 
Revision 1, 2018-09-25 (Matthew Netsch)

Initial version

Revision 2, 2021-09-30 (Jon Leech)

* 
Add interaction with `[VK_KHR_format_feature_flags2](#VK_KHR_format_feature_flags2)` to `vk.xml`

**Name String**

`VK_EXT_fragment_density_map2`

**Extension Type**

Device extension

**Registered Extension Number**

333

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_EXT_fragment_density_map](#VK_EXT_fragment_density_map)

**Contact**

* 
Matthew Netsch [mnetsch](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_fragment_density_map2] @mnetsch%0A*Here describe the issue or question you have about the VK_EXT_fragment_density_map2 extension*)

**Last Modified Date**

2020-06-16

**Interactions and External Dependencies**

* 
Interacts with Vulkan 1.1

**Contributors**

* 
Matthew Netsch, Qualcomm Technologies, Inc.

* 
Jonathan Tinkham, Qualcomm Technologies, Inc.

* 
Jonathan Wicks, Qualcomm Technologies, Inc.

* 
Jan-Harald Fredriksen, ARM

This extension adds additional features and properties to
`[VK_EXT_fragment_density_map](#VK_EXT_fragment_density_map)` in order to reduce fragment density map
host latency as well as improved queries for subsampled sampler
implementation-dependent behavior.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceFragmentDensityMap2FeaturesEXT](../chapters/features.html#VkPhysicalDeviceFragmentDensityMap2FeaturesEXT)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceFragmentDensityMap2PropertiesEXT](../chapters/limits.html#VkPhysicalDeviceFragmentDensityMap2PropertiesEXT)

* 
`VK_EXT_FRAGMENT_DENSITY_MAP_2_EXTENSION_NAME`

* 
`VK_EXT_FRAGMENT_DENSITY_MAP_2_SPEC_VERSION`

* 
Extending [VkImageViewCreateFlagBits](../chapters/resources.html#VkImageViewCreateFlagBits):

`VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT`

* 
Revision 1, 2020-06-16 (Matthew Netsch)

Initial version

**Name String**

`VK_EXT_fragment_density_map_offset`

**Extension Type**

Device extension

**Registered Extension Number**

620

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

 [VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

 or

 [Vulkan Version 1.1](versions.html#versions-1.1)

and

[VK_EXT_fragment_density_map](#VK_EXT_fragment_density_map)

and

 [VK_KHR_create_renderpass2](#VK_KHR_create_renderpass2)

 or

 [Vulkan Version 1.2](versions.html#versions-1.2)

and

 [Vulkan Version 1.3](versions.html#versions-1.3)

 or

 [VK_KHR_dynamic_rendering](#VK_KHR_dynamic_rendering)

**Contact**

* 
Connor Abbott [cwabbott0](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_fragment_density_map_offset] @cwabbott0%0A*Here describe the issue or question you have about the VK_EXT_fragment_density_map_offset extension*)

**Extension Proposal**

[VK_EXT_fragment_density_map_offset](../../../features/latest/features/proposals/VK_EXT_fragment_density_map_offset.html)

**Last Modified Date**

2025-02-14

**Contributors**

* 
Connor Abbott, Valve Corporation

* 
Matthew Netsch, Qualcomm Technologies, Inc.

* 
Jonathan Wicks, Qualcomm Technologies, Inc.

* 
Jonathan Tinkham, Qualcomm Technologies, Inc.

* 
Jeff Leger, Qualcomm Technologies, Inc.

* 
Manan Katwala, Qualcomm Technologies, Inc.

* 
Mike Blumenkrantz, Valve Corporation

This extension allows an application to specify offsets to a fragment
density map attachment, changing the framebuffer location where density
values are applied to without having to regenerate the fragment density map.

* 
[vkCmdEndRendering2EXT](../chapters/renderpass.html#vkCmdEndRendering2EXT)

* 
[VkRenderingEndInfoEXT](../chapters/renderpass.html#VkRenderingEndInfoEXT)

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT](../chapters/features.html#VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT](../chapters/limits.html#VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT)

Extending [VkSubpassEndInfo](../chapters/renderpass.html#VkSubpassEndInfo), [VkRenderingEndInfoEXT](../chapters/renderpass.html#VkRenderingEndInfoEXT):

* 
[VkRenderPassFragmentDensityMapOffsetEndInfoEXT](../chapters/renderpass.html#VkRenderPassFragmentDensityMapOffsetEndInfoEXT)

* 
`VK_EXT_FRAGMENT_DENSITY_MAP_OFFSET_EXTENSION_NAME`

* 
`VK_EXT_FRAGMENT_DENSITY_MAP_OFFSET_SPEC_VERSION`

* 
Extending [VkImageCreateFlagBits](../chapters/resources.html#VkImageCreateFlagBits):

`VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_EXT`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_EXT`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_EXT`

* 
`VK_STRUCTURE_TYPE_RENDERING_END_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_EXT`

* 
Revision 1, 2025-02-14 (Connor Abbott)

Initial version

**Name String**

`VK_EXT_fragment_shader_interlock`

**Extension Type**

Device extension

**Registered Extension Number**

252

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**SPIR-V Dependencies**

* 
[SPV_EXT_fragment_shader_interlock](https://github.khronos.org/SPIRV-Registry/extensions/EXT/SPV_EXT_fragment_shader_interlock.html)

**Contact**

* 
Piers Daniell [pdaniell-nv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_fragment_shader_interlock] @pdaniell-nv%0A*Here describe the issue or question you have about the VK_EXT_fragment_shader_interlock extension*)

**Last Modified Date**

2019-05-02

**Interactions and External Dependencies**

* 
This extension provides API support for
[`GL_ARB_fragment_shader_interlock`](https://registry.khronos.org/OpenGL/extensions/ARB/ARB_fragment_shader_interlock.txt)

**Contributors**

* 
Daniel Koch, NVIDIA

* 
Graeme Leese, Broadcom

* 
Jan-Harald Fredriksen, Arm

* 
Faith Ekstrand, Intel

* 
Jeff Bolz, NVIDIA

* 
Ruihao Zhang, Qualcomm

* 
Slawomir Grajewski, Intel

* 
Spencer Fricke, Samsung

This extension adds support for the `FragmentShaderPixelInterlockEXT`,
`FragmentShaderSampleInterlockEXT`, and
`FragmentShaderShadingRateInterlockEXT` capabilities from the
`SPV_EXT_fragment_shader_interlock` extension to Vulkan.

Enabling these capabilities provides a critical section for fragment shaders
to avoid overlapping pixels being processed at the same time, and certain
guarantees about the ordering of fragment shader invocations of fragments of
overlapping pixels.

This extension can be useful for algorithms that need to access per-pixel
data structures via shader loads and stores.
Algorithms using this extension can access per-pixel data structures in
critical sections without other invocations accessing the same per-pixel
data.
Additionally, the ordering guarantees are useful for cases where the API
ordering of fragments is meaningful.
For example, applications may be able to execute programmable blending
operations in the fragment shader, where the destination buffer is read via
image loads and the final value is written via image stores.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT](../chapters/features.html#VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT)

* 
`VK_EXT_FRAGMENT_SHADER_INTERLOCK_EXTENSION_NAME`

* 
`VK_EXT_FRAGMENT_SHADER_INTERLOCK_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT`

* 
[    `FragmentShaderInterlockEXT`](spirvenv.html#spirvenv-capabilities-table-FragmentShaderSampleInterlockEXT)

* 
[    `FragmentShaderPixelInterlockEXT`](spirvenv.html#spirvenv-capabilities-table-FragmentShaderPixelInterlockEXT)

* 
[    `FragmentShaderShadingRateInterlockEXT`](spirvenv.html#spirvenv-capabilities-table-FragmentShaderShadingRateInterlockEXT)

* 
Revision 1, 2019-05-24 (Piers Daniell)

Internal revisions

**Name String**

`VK_EXT_frame_boundary`

**Extension Type**

Device extension

**Registered Extension Number**

376

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

None

**Contact**

* 
James Fitzpatrick [jamesfitzpatrick](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_frame_boundary] @jamesfitzpatrick%0A*Here describe the issue or question you have about the VK_EXT_frame_boundary extension*)

**Extension Proposal**

[VK_EXT_frame_boundary](../../../features/latest/features/proposals/VK_EXT_frame_boundary.html)

**Last Modified Date**

2023-06-14

**Contributors**

* 
James Fitzpatrick, Imagination Technologies

* 
Hugues Evrard, Google

* 
Melih Yasin Yalcin, Google

* 
Andrew Garrard, Imagination Technologies

* 
Jan-Harald Fredriksen, Arm

* 
Vassili Nikolaev, NVIDIA

* 
Ting Wei, Huawei

[VK_EXT_frame_boundary](#VK_EXT_frame_boundary) is a device extension that helps **tools** (such
as debuggers) to group queue submissions per frames in non-trivial
scenarios, typically when [vkQueuePresentKHR](../chapters/VK_KHR_surface/wsi.html#vkQueuePresentKHR) is not a relevant frame
boundary delimiter.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceFrameBoundaryFeaturesEXT](../chapters/features.html#VkPhysicalDeviceFrameBoundaryFeaturesEXT)

Extending [VkSubmitInfo](../chapters/cmdbuffers.html#VkSubmitInfo), [VkSubmitInfo2](../chapters/cmdbuffers.html#VkSubmitInfo2), [VkPresentInfoKHR](../chapters/VK_KHR_surface/wsi.html#VkPresentInfoKHR), [VkBindSparseInfo](../chapters/sparsemem.html#VkBindSparseInfo):

* 
[VkFrameBoundaryEXT](../chapters/debugging.html#VkFrameBoundaryEXT)

* 
[VkFrameBoundaryFlagBitsEXT](../chapters/debugging.html#VkFrameBoundaryFlagBitsEXT)

* 
[VkFrameBoundaryFlagsEXT](../chapters/debugging.html#VkFrameBoundaryFlagsEXT)

* 
`VK_EXT_FRAME_BOUNDARY_EXTENSION_NAME`

* 
`VK_EXT_FRAME_BOUNDARY_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT`

* 
Revision 0, 2022-01-14 (Hugues Evard)

Initial proposal

Revision 1, 2023-06-14 (James Fitzpatrick)

* 
Initial draft

**Name String**

`VK_EXT_full_screen_exclusive`

**Extension Type**

Device extension

**Registered Extension Number**

256

**Revision**

4

**Ratification Status**

Ratified

**Extension and Version Dependencies**

 [VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

 or

 [Vulkan Version 1.1](versions.html#versions-1.1)

and

[VK_KHR_surface](#VK_KHR_surface)

and

[VK_KHR_get_surface_capabilities2](#VK_KHR_get_surface_capabilities2)

and

[VK_KHR_swapchain](#VK_KHR_swapchain)

**API Interactions**

* 
Interacts with VK_VERSION_1_1

* 
Interacts with VK_KHR_device_group

* 
Interacts with VK_KHR_win32_surface

**Contact**

* 
James Jones [cubanismo](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_full_screen_exclusive] @cubanismo%0A*Here describe the issue or question you have about the VK_EXT_full_screen_exclusive extension*)

**Last Modified Date**

2019-03-12

**IP Status**

No known IP claims.

**Interactions and External Dependencies**

* 
Interacts with Vulkan 1.1

* 
Interacts with `[VK_KHR_device_group](#VK_KHR_device_group)`

* 
Interacts with `[VK_KHR_win32_surface](#VK_KHR_win32_surface)`

**Contributors**

* 
Hans-Kristian Arntzen, ARM

* 
Slawomir Grajewski, Intel

* 
Tobias Hector, AMD

* 
James Jones, NVIDIA

* 
Daniel Rakos, AMD

* 
Jeff Juliano, NVIDIA

* 
Joshua Schnarr, NVIDIA

* 
Aaron Hagan, AMD

This extension allows applications to set the policy for swapchain creation
and presentation mechanisms relating to full-screen access.
Implementations may be able to acquire exclusive access to a particular
display for an application window that covers the whole screen.
This can increase performance on some systems by bypassing composition,
however it can also result in disruptive or expensive transitions in the
underlying windowing system when a change occurs.

Applications can choose between explicitly disallowing or allowing this
behavior, letting the implementation decide, or managing this mode of
operation directly using the new [vkAcquireFullScreenExclusiveModeEXT](../chapters/VK_KHR_surface/wsi.html#vkAcquireFullScreenExclusiveModeEXT)
and [vkReleaseFullScreenExclusiveModeEXT](../chapters/VK_KHR_surface/wsi.html#vkReleaseFullScreenExclusiveModeEXT) commands.

* 
[vkAcquireFullScreenExclusiveModeEXT](../chapters/VK_KHR_surface/wsi.html#vkAcquireFullScreenExclusiveModeEXT)

* 
[vkGetPhysicalDeviceSurfacePresentModes2EXT](../chapters/VK_KHR_surface/wsi.html#vkGetPhysicalDeviceSurfacePresentModes2EXT)

* 
[vkReleaseFullScreenExclusiveModeEXT](../chapters/VK_KHR_surface/wsi.html#vkReleaseFullScreenExclusiveModeEXT)

If [VK_KHR_device_group](#VK_KHR_device_group) or [Vulkan Version 1.1](versions.html#versions-1.1) is supported:

* 
[vkGetDeviceGroupSurfacePresentModes2EXT](../chapters/VK_KHR_surface/wsi.html#vkGetDeviceGroupSurfacePresentModes2EXT)

* 
Extending [VkPhysicalDeviceSurfaceInfo2KHR](../chapters/VK_KHR_surface/wsi.html#VkPhysicalDeviceSurfaceInfo2KHR), [VkSwapchainCreateInfoKHR](../chapters/VK_KHR_surface/wsi.html#VkSwapchainCreateInfoKHR):

[VkSurfaceFullScreenExclusiveInfoEXT](../chapters/VK_KHR_surface/wsi.html#VkSurfaceFullScreenExclusiveInfoEXT)

Extending [VkSurfaceCapabilities2KHR](../chapters/VK_KHR_surface/wsi.html#VkSurfaceCapabilities2KHR):

* 
[VkSurfaceCapabilitiesFullScreenExclusiveEXT](../chapters/VK_KHR_surface/wsi.html#VkSurfaceCapabilitiesFullScreenExclusiveEXT)

If [VK_KHR_win32_surface](#VK_KHR_win32_surface) is supported:

* 
Extending [VkPhysicalDeviceSurfaceInfo2KHR](../chapters/VK_KHR_surface/wsi.html#VkPhysicalDeviceSurfaceInfo2KHR), [VkSwapchainCreateInfoKHR](../chapters/VK_KHR_surface/wsi.html#VkSwapchainCreateInfoKHR):

[VkSurfaceFullScreenExclusiveWin32InfoEXT](../chapters/VK_KHR_surface/wsi.html#VkSurfaceFullScreenExclusiveWin32InfoEXT)

* 
[VkFullScreenExclusiveEXT](../chapters/VK_KHR_surface/wsi.html#VkFullScreenExclusiveEXT)

* 
`VK_EXT_FULL_SCREEN_EXCLUSIVE_EXTENSION_NAME`

* 
`VK_EXT_FULL_SCREEN_EXCLUSIVE_SPEC_VERSION`

* 
Extending [VkResult](../chapters/fundamentals.html#VkResult):

`VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT`

* 
`VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT`

If [VK_KHR_win32_surface](#VK_KHR_win32_surface) is supported:

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT`

1) What should the extension & flag be called?

**RESOLVED**: VK_EXT_full_screen_exclusive.

Other options considered (prior to the app-controlled mode) were:

* 
VK_EXT_smooth_fullscreen_transition

* 
VK_EXT_fullscreen_behavior

* 
VK_EXT_fullscreen_preference

* 
VK_EXT_fullscreen_hint

* 
VK_EXT_fast_fullscreen_transition

* 
VK_EXT_avoid_fullscreen_exclusive

2) Do we need more than a boolean toggle?

**RESOLVED**: Yes.

Using an enum with default/allowed/disallowed/app-controlled enables
applications to accept driver default behavior, specifically override it in
either direction without implying the driver is ever required to use
full-screen exclusive mechanisms, or manage this mode explicitly.

3) Should this be a KHR or EXT extension?

**RESOLVED**: EXT, in order to allow it to be shipped faster.

4) Can the fullscreen hint affect the surface capabilities, and if so,
should the hint also be specified as input when querying the surface
capabilities?

**RESOLVED**: Yes on both accounts.

While the hint does not guarantee a particular fullscreen mode will be used
when the swapchain is created, it can sometimes imply particular modes will
NOT be used.
If the driver determines that it will opt-out of using a particular mode
based on the policy, and knows it can only support certain capabilities if
that mode is used, it would be confusing at best to the application to
report those capabilities in such cases.
Not allowing implementations to report this state to applications could
result in situations where applications are unable to determine why
swapchain creation fails when they specify certain hint values, which could
result in never- terminating surface creation loops.

5) Should full-screen be one word or two?

**RESOLVED**: Two words.

"Fullscreen" is not in my dictionary, and web searches did not turn up
definitive proof that it is a colloquially accepted compound word.
Documentation for the corresponding Windows API mechanisms dithers.
The text consistently uses a hyphen, but none-the-less, there is a
SetFullscreenState method in the DXGI swapchain object.
Given this inconclusive external guidance, it is best to adhere to the
Vulkan style guidelines and avoid inventing new compound words.

* 
Revision 4, 2019-03-12 (Tobias Hector)

Added application-controlled mode, and related functions

* 
Tidied up appendix

Revision 3, 2019-01-03 (James Jones)

* 
Renamed to VK_EXT_full_screen_exclusive

* 
Made related adjustments to the tri-state enumerant names.

Revision 2, 2018-11-27 (James Jones)

* 
Renamed to VK_KHR_fullscreen_behavior

* 
Switched from boolean flag to tri-state enum

Revision 1, 2018-11-06 (James Jones)

* 
Internal revision

**Name String**

`VK_EXT_graphics_pipeline_library`

**Extension Type**

Device extension

**Registered Extension Number**

321

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

 [VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

 or

 [Vulkan Version 1.1](versions.html#versions-1.1)

and

[VK_KHR_pipeline_library](#VK_KHR_pipeline_library)

**Contact**

* 
Tobias Hector [tobski](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_graphics_pipeline_library] @tobski%0A*Here describe the issue or question you have about the VK_EXT_graphics_pipeline_library extension*)

**Extension Proposal**

[VK_EXT_graphics_pipeline_library](../../../features/latest/features/proposals/VK_EXT_graphics_pipeline_library.html)

**Last Modified Date**

2021-08-17

**Contributors**

* 
Tobias Hector, AMD

* 
Chris Glover, Google

* 
Jeff Leger, Qualcomm

* 
Jan-Harald Fredriksen, Arm

* 
Piers Daniell, NVidia

* 
Boris Zanin, Mobica

* 
Krzysztof Niski, NVidia

* 
Dan Ginsburg, Valve

* 
Sebastian Aaltonen, Unity

* 
Arseny Kapoulkine, Roblox

* 
Calle Lejdfors, Ubisoft

* 
Tiago Rodrigues, Ubisoft

* 
Francois Duranleau, Gameloft

This extension allows the separate compilation of four distinct parts of
graphics pipelines, with the intent of allowing faster pipeline loading for
applications reusing the same shaders or state in multiple pipelines.
Each part can be independently compiled into a graphics pipeline library,
with a final link step required to create an executable pipeline that can be
bound to a command buffer.

* 
Extending [VkGraphicsPipelineCreateInfo](../chapters/pipelines.html#VkGraphicsPipelineCreateInfo):

[VkGraphicsPipelineLibraryCreateInfoEXT](../chapters/pipelines.html#VkGraphicsPipelineLibraryCreateInfoEXT)

Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

* 
[VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT](../chapters/features.html#VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT](../chapters/limits.html#VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT)

* 
[VkGraphicsPipelineLibraryFlagBitsEXT](../chapters/pipelines.html#VkGraphicsPipelineLibraryFlagBitsEXT)

* 
[VkPipelineLayoutCreateFlagBits](../chapters/descriptorsets.html#VkPipelineLayoutCreateFlagBits)

* 
[VkGraphicsPipelineLibraryFlagsEXT](../chapters/pipelines.html#VkGraphicsPipelineLibraryFlagsEXT)

* 
`VK_EXT_GRAPHICS_PIPELINE_LIBRARY_EXTENSION_NAME`

* 
`VK_EXT_GRAPHICS_PIPELINE_LIBRARY_SPEC_VERSION`

* 
Extending [VkPipelineCreateFlagBits](../chapters/pipelines.html#VkPipelineCreateFlagBits):

`VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT`

* 
`VK_PIPELINE_CREATE_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT`

Extending [VkPipelineLayoutCreateFlagBits](../chapters/descriptorsets.html#VkPipelineLayoutCreateFlagBits):

* 
`VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT`

* 
Revision 1, 2021-08-17 (Tobias Hector)

Initial draft.

**Name String**

`VK_EXT_hdr_metadata`

**Extension Type**

Device extension

**Registered Extension Number**

106

**Revision**

3

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_swapchain](#VK_KHR_swapchain)

**Contact**

* 
Courtney Goeltzenleuchter [courtney-g](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_hdr_metadata] @courtney-g%0A*Here describe the issue or question you have about the VK_EXT_hdr_metadata extension*)

**Last Modified Date**

2024-03-26

**IP Status**

No known IP claims.

**Contributors**

* 
Courtney Goeltzenleuchter, Google

* 
Sebastian Wick, Red Hat Inc.

* 
Tobias Hector, AMD

This extension defines two new structures and a function to assign SMPTE
(the Society of Motion Picture and Television Engineers) 2086 metadata and
CTA (Consumer Technology Association) 861.3 metadata to a swapchain.

SMPTE 2086 metadata defines the color volume of the display on which the
content was optimized for viewing and includes the color primaries, white
point, and luminance range.
When such content is reproduced on another display, this metadata can be
used by the presentation engine to improve processing of images.
For instance, values in the image can first be clamped to the color volume
described in the metadata, and then what remains can be remapped to the
color volume of the presentation engine.

CTA 861.3 metadata additionally includes the maximum intended luminance for
the content and the maximum average light level across frames.

This extension does not define exactly how this metadata is used, however,
it simply provides a mechanism to provide it to the presentation engine.
Presentation engines may process the image based on the metadata before
displaying it, resulting in the image being modified outside of Vulkan.
For example, the clamping of colors in the image to the color volume may
change those values in the image itself.

The metadata does not override or otherwise influence the color space and
color encoding.

* 
[vkSetHdrMetadataEXT](../chapters/VK_KHR_surface/wsi.html#vkSetHdrMetadataEXT)

* 
[VkHdrMetadataEXT](../chapters/VK_KHR_surface/wsi.html#VkHdrMetadataEXT)

* 
[VkXYColorEXT](../chapters/VK_KHR_surface/wsi.html#VkXYColorEXT)

* 
`VK_EXT_HDR_METADATA_EXTENSION_NAME`

* 
`VK_EXT_HDR_METADATA_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_HDR_METADATA_EXT`

1) Do we need a query function for the currently specified metadata?

No, Vulkan does not provide queries for state that the application can track
on its own.

2) Should we specify default metadata if not specified by the application?

No, the metadata is optional and the absence of the metadata is
well-defined.

* 
Revision 1, 2016-12-27 (Courtney Goeltzenleuchter)

Initial version

Revision 2, 2018-12-19 (Courtney Goeltzenleuchter)

* 
Correct implicit validity for VkHdrMetadataEXT structure

Revision 3, 2024-03-26 (Tobias Hector & Sebastian Wick)

* 
Clarifications and removal of erroneous "reference monitor" term

**Name String**

`VK_EXT_headless_surface`

**Extension Type**

Instance extension

**Registered Extension Number**

257

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_surface](#VK_KHR_surface)

**Contact**

* 
Lisa Wu [chengtianww](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_headless_surface] @chengtianww%0A*Here describe the issue or question you have about the VK_EXT_headless_surface extension*)

**Last Modified Date**

2019-03-21

**IP Status**

No known IP claims.

**Contributors**

* 
Ray Smith, Arm

The `VK_EXT_headless_surface` extension is an instance extension.
It provides a mechanism to create [VkSurfaceKHR](../chapters/VK_KHR_surface/wsi.html#VkSurfaceKHR) objects independently
of any window system or display device.
The presentation operation for a swapchain created from a headless surface
is by default a no-op, resulting in no externally-visible result.

Because there is no real presentation target, future extensions can layer on
top of the headless surface to introduce arbitrary or customizable sets of
restrictions or features.
These could include features like saving to a file or restrictions to
emulate a particular presentation target.

This functionality is expected to be useful for application and driver
development because it allows any platform to expose an arbitrary or
customizable set of restrictions and features of a presentation engine.
This makes it a useful portable test target for applications targeting a
wide range of presentation engines where the actual target presentation
engines might be scarce, unavailable or otherwise undesirable or
inconvenient to use for general Vulkan application development.

* 
[vkCreateHeadlessSurfaceEXT](../chapters/VK_KHR_surface/wsi.html#vkCreateHeadlessSurfaceEXT)

* 
[VkHeadlessSurfaceCreateInfoEXT](../chapters/VK_KHR_surface/wsi.html#VkHeadlessSurfaceCreateInfoEXT)

* 
[VkHeadlessSurfaceCreateFlagsEXT](../chapters/VK_KHR_surface/wsi.html#VkHeadlessSurfaceCreateFlagsEXT)

* 
`VK_EXT_HEADLESS_SURFACE_EXTENSION_NAME`

* 
`VK_EXT_HEADLESS_SURFACE_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT`

* 
Revision 1, 2019-03-21 (Ray Smith)

Initial draft

**Name String**

`VK_EXT_image_2d_view_of_3d`

**Extension Type**

Device extension

**Registered Extension Number**

394

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

 [VK_KHR_maintenance1](#VK_KHR_maintenance1)

 and

 [VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Special Use**

* 
[OpenGL / ES support](../chapters/extensions.html#extendingvulkan-compatibility-specialuse)

**Contact**

* 
Mike Blumenkrantz [zmike](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_image_2d_view_of_3d] @zmike%0A*Here describe the issue or question you have about the VK_EXT_image_2d_view_of_3d extension*)

**Last Modified Date**

2022-02-22

**IP Status**

No known IP claims.

**Contributors**

* 
Mike Blumenkrantz, Valve

* 
Piers Daniell, NVIDIA

* 
Spencer Fricke, Samsung

* 
Ricardo Garcia, Igalia

* 
Graeme Leese, Broadcom

* 
Ralph Potter, Samsung

* 
Stu Smith, AMD

* 
Shahbaz Youssefi, Google

* 
Alex Walters, Imagination

This extension allows a single slice of a 3D image to be used as a 2D view
in image descriptors, matching both the functionality of glBindImageTexture
in OpenGL with the `layer` parameter set to true and 2D view binding
provided by the extension EGL_KHR_gl_texture_3D_image.
It is primarily intended to support GL emulation.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceImage2DViewOf3DFeaturesEXT](../chapters/features.html#VkPhysicalDeviceImage2DViewOf3DFeaturesEXT)

* 
`VK_EXT_IMAGE_2D_VIEW_OF_3D_EXTENSION_NAME`

* 
`VK_EXT_IMAGE_2D_VIEW_OF_3D_SPEC_VERSION`

* 
Extending [VkImageCreateFlagBits](../chapters/resources.html#VkImageCreateFlagBits):

`VK_IMAGE_CREATE_2D_VIEW_COMPATIBLE_BIT_EXT`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT`

* 
Revision 1, 2022-03-25 (Mike Blumenkrantz)

Internal revisions

**Name String**

`VK_EXT_image_compression_control`

**Extension Type**

Device extension

**Registered Extension Number**

339

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Contact**

* 
Jan-Harald Fredriksen [janharaldfredriksen-arm](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_image_compression_control] @janharaldfredriksen-arm%0A*Here describe the issue or question you have about the VK_EXT_image_compression_control extension*)

**Extension Proposal**

[VK_EXT_image_compression_control](../../../features/latest/features/proposals/VK_EXT_image_compression_control.html)

**Last Modified Date**

2022-05-02

**IP Status**

No known IP claims.

**Contributors**

* 
Jan-Harald Fredriksen, Arm

* 
Graeme Leese, Broadcom

* 
Andrew Garrard, Imagination

* 
Lisa Wu, Arm

* 
Peter Kohaut, Arm

This extension enables fixed-rate image compression and adds the ability to
control when this kind of compression can be applied.
Many implementations support some form of framebuffer compression.
This is typically transparent to applications as lossless compression
schemes are used.
With fixed-rate compression, the compression is done at a defined bitrate.
Such compression algorithms generally produce results that are visually
lossless, but the results are typically not bit-exact when compared to a
non-compressed result.
The implementation may not be able to use the requested compression rate in
all cases.
This extension adds a query that can be used to determine the compression
scheme and rate that was applied to an image.

* 
[vkGetImageSubresourceLayout2EXT](../chapters/resources.html#vkGetImageSubresourceLayout2EXT)

* 
[VkImageSubresource2EXT](../chapters/resources.html#VkImageSubresource2EXT)

* 
[VkSubresourceLayout2EXT](../chapters/resources.html#VkSubresourceLayout2EXT)

* 
Extending [VkImageCreateInfo](../chapters/resources.html#VkImageCreateInfo), [VkSwapchainCreateInfoKHR](../chapters/VK_KHR_surface/wsi.html#VkSwapchainCreateInfoKHR), [VkPhysicalDeviceImageFormatInfo2](../chapters/capabilities.html#VkPhysicalDeviceImageFormatInfo2):

[VkImageCompressionControlEXT](../chapters/resources.html#VkImageCompressionControlEXT)

Extending [VkImageFormatProperties2](../chapters/capabilities.html#VkImageFormatProperties2), [VkSurfaceFormat2KHR](../chapters/VK_KHR_surface/wsi.html#VkSurfaceFormat2KHR), [VkSubresourceLayout2](../chapters/resources.html#VkSubresourceLayout2):

* 
[VkImageCompressionPropertiesEXT](../chapters/resources.html#VkImageCompressionPropertiesEXT)

Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

* 
[VkPhysicalDeviceImageCompressionControlFeaturesEXT](../chapters/features.html#VkPhysicalDeviceImageCompressionControlFeaturesEXT)

* 
[VkImageCompressionFixedRateFlagBitsEXT](../chapters/resources.html#VkImageCompressionFixedRateFlagBitsEXT)

* 
[VkImageCompressionFlagBitsEXT](../chapters/resources.html#VkImageCompressionFlagBitsEXT)

* 
[VkImageCompressionFixedRateFlagsEXT](../chapters/resources.html#VkImageCompressionFixedRateFlagsEXT)

* 
[VkImageCompressionFlagsEXT](../chapters/resources.html#VkImageCompressionFlagsEXT)

* 
`VK_EXT_IMAGE_COMPRESSION_CONTROL_EXTENSION_NAME`

* 
`VK_EXT_IMAGE_COMPRESSION_CONTROL_SPEC_VERSION`

* 
Extending [VkResult](../chapters/fundamentals.html#VkResult):

`VK_ERROR_COMPRESSION_EXHAUSTED_EXT`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT`

* 
`VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT`

* 
`VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_EXT`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT`

* 
`VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_EXT`

* 
Revision 1, 2022-05-02 (Jan-Harald Fredriksen)

Initial draft

**Name String**

`VK_EXT_image_compression_control_swapchain`

**Extension Type**

Device extension

**Registered Extension Number**

438

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_EXT_image_compression_control](#VK_EXT_image_compression_control)

**Contact**

* 
Jan-Harald Fredriksen [janharaldfredriksen-arm](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_image_compression_control_swapchain] @janharaldfredriksen-arm%0A*Here describe the issue or question you have about the VK_EXT_image_compression_control_swapchain extension*)

**Last Modified Date**

2022-05-02

**IP Status**

No known IP claims.

**Contributors**

* 
Jan-Harald Fredriksen, Arm

* 
Graeme Leese, Broadcom

* 
Andrew Garrard, Imagination

* 
Lisa Wu, Arm

* 
Peter Kohaut, Arm

* 
Ian Elliott, Google

This extension enables fixed-rate image compression and adds the ability to
control when this kind of compression can be applied to swapchain images.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT](../chapters/features.html#VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT)

* 
`VK_EXT_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_EXTENSION_NAME`

* 
`VK_EXT_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT`

* 
Revision 1, 2022-05-02 (Jan-Harald Fredriksen)

Initial draft

**Name String**

`VK_EXT_image_drm_format_modifier`

**Extension Type**

Device extension

**Registered Extension Number**

159

**Revision**

2

**Ratification Status**

Ratified

**Extension and Version Dependencies**

 [VK_KHR_bind_memory2](#VK_KHR_bind_memory2)

 and

 [VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

 and

 [VK_KHR_sampler_ycbcr_conversion](#VK_KHR_sampler_ycbcr_conversion)

 or

 [Vulkan Version 1.1](versions.html#versions-1.1)

 and

 [VK_KHR_image_format_list](#VK_KHR_image_format_list)

or

[Vulkan Version 1.2](versions.html#versions-1.2)

**API Interactions**

* 
Interacts with VK_VERSION_1_3

* 
Interacts with VK_KHR_format_feature_flags2

**Contact**

* 
Lina Versace [linyaa-kiwi](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_image_drm_format_modifier] @linyaa-kiwi%0A*Here describe the issue or question you have about the VK_EXT_image_drm_format_modifier extension*)

**Last Modified Date**

2021-09-30

**IP Status**

No known IP claims.

**Contributors**

* 
Antoine Labour, Google

* 
Bas Nieuwenhuizen, Google

* 
Lina Versace, Google

* 
James Jones, NVIDIA

* 
Faith Ekstrand, Intel

* 
Jrg Wagner, ARM

* 
Kristian Hgsberg Kristensen, Google

* 
Ray Smith, ARM

This extension provides the ability to use *DRM format modifiers* with
images, enabling Vulkan to better integrate with the Linux ecosystem of
graphics, video, and display APIs.

Its functionality closely overlaps with
`EGL_EXT_image_dma_buf_import_modifiers`[2](#VK_EXT_image_drm_format_modifier-fn2)
and
`EGL_MESA_image_dma_buf_export`[3](#VK_EXT_image_drm_format_modifier-fn3).
Unlike the EGL extensions, this extension does not require the use of a
specific handle type (such as a dma_buf) for external memory and provides
more explicit control of image creation.

A *DRM format modifier* is a 64-bit, vendor-prefixed, semi-opaque unsigned
integer.
Most *modifiers* represent a concrete, vendor-specific tiling format for
images.
Some exceptions are `DRM_FORMAT_MOD_LINEAR` (which is not
vendor-specific); `DRM_FORMAT_MOD_NONE` (which is an alias of
`DRM_FORMAT_MOD_LINEAR` due to historical accident); and
`DRM_FORMAT_MOD_INVALID` (which does not represent a tiling format).
The *modifiers* vendor prefix consists of the 8 most significant bits.
The canonical list of *modifiers* and vendor prefixes is found in
[`drm_fourcc.h`](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/uapi/drm/drm_fourcc.h)
in the Linux kernel source.
The other dominant source of *modifiers* are vendor kernel trees.

One goal of *modifiers* in the Linux ecosystem is to enumerate for each
vendor a reasonably sized set of tiling formats that are appropriate for
images shared across processes, APIs, and/or devices, where each
participating component may possibly be from different vendors.
A non-goal is to enumerate all tiling formats supported by all vendors.
Some tiling formats used internally by vendors are inappropriate for
sharing; no *modifiers* should be assigned to such tiling formats.

Modifier values typically do not *describe* memory layouts.
More precisely, a *modifier*'s lower 56 bits usually have no structure.
Instead, modifiers *name* memory layouts; they name a small set of
vendor-preferred layouts for image sharing.
As a consequence, in each vendor namespace the modifier values are often
sequentially allocated starting at 1.

Each *modifier* is usually supported by a single vendor and its name matches
the pattern `{VENDOR}_FORMAT_MOD_*` or `DRM_FORMAT_MOD_{VENDOR}_*`.
Examples are `I915_FORMAT_MOD_X_TILED` and
`DRM_FORMAT_MOD_BROADCOM_VC4_T_TILED`.
An exception is `DRM_FORMAT_MOD_LINEAR`, which is supported by most
vendors.

Many APIs in Linux use *modifiers* to negotiate and specify the memory
layout of shared images.
For example, a Wayland compositor and Wayland client may, by relaying
*modifiers* over the Wayland protocol `zwp_linux_dmabuf_v1`, negotiate a
vendor-specific tiling format for a shared `wl_buffer`.
The client may allocate the underlying memory for the `wl_buffer` with
GBM, providing the chosen *modifier* to `gbm_bo_create_with_modifiers`.
The client may then import the `wl_buffer` into Vulkan for producing
image content, providing the resources dma_buf to
[VkImportMemoryFdInfoKHR](../chapters/memory.html#VkImportMemoryFdInfoKHR) and its *modifier* to
[VkImageDrmFormatModifierExplicitCreateInfoEXT](../chapters/resources.html#VkImageDrmFormatModifierExplicitCreateInfoEXT).
The compositor may then import the `wl_buffer` into OpenGL for sampling,
providing the resources dma_buf and *modifier* to `eglCreateImage`.
The compositor may also bypass OpenGL and submit the `wl_buffer` directly
to the kernels display API, providing the dma_buf and *modifier* through
`drm_mode_fb_cmd2`.

*Modifier*-capable APIs often pair *modifiers* with DRM formats, which are
defined in
[`drm_fourcc.h`](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/uapi/drm/drm_fourcc.h).
However, `VK_EXT_image_drm_format_modifier` uses [VkFormat](../chapters/formats.html#VkFormat) instead of
DRM formats.
The application must convert between [VkFormat](../chapters/formats.html#VkFormat) and DRM format when it
sends or receives a DRM format to or from an external API.

The mapping from [VkFormat](../chapters/formats.html#VkFormat) to DRM format is lossy.
Therefore, when receiving a DRM format from an external API, often the
application must use information from the external API to accurately map the
DRM format to a [VkFormat](../chapters/formats.html#VkFormat).
For example, DRM formats do not distinguish between RGB and sRGB (as of
2018-03-28); external information is required to identify the images color
space.

The mapping between [VkFormat](../chapters/formats.html#VkFormat) and DRM format is also incomplete.
For some DRM formats there exist no corresponding Vulkan format, and for
some Vulkan formats there exist no corresponding DRM format.

Three primary usage patterns are intended for this extension:

* 
**Negotiation.** The application negotiates with *modifier*-aware,
external components to determine sets of image creation parameters
supported among all components.

In the Linux ecosystem, the negotiation usually assumes the image is a 2D,
single-sampled, non-mipmapped, non-array image; this extension permits that
assumption but does not require it.
The result of the negotiation usually resembles a set of tuples such as
*(drmFormat, drmFormatModifier)*, where each participating component
supports all tuples in the set.

Many details of this negotiation - such as the protocol used during
negotiation, the set of image creation parameters expressible in the
protocol, and how the protocol chooses which process and which API will
create the image - are outside the scope of this specification.

In this extension, [vkGetPhysicalDeviceFormatProperties2](../chapters/formats.html#vkGetPhysicalDeviceFormatProperties2) with
[VkDrmFormatModifierPropertiesListEXT](../chapters/formats.html#VkDrmFormatModifierPropertiesListEXT) serves a primary role during the
negotiation, and [vkGetPhysicalDeviceImageFormatProperties2](../chapters/capabilities.html#vkGetPhysicalDeviceImageFormatProperties2) with
[VkPhysicalDeviceImageDrmFormatModifierInfoEXT](../chapters/capabilities.html#VkPhysicalDeviceImageDrmFormatModifierInfoEXT) serves a secondary role.

* 
**Import.** The application imports an image with a *modifier*.

In this pattern, the application receives from an external source the
images memory and its creation parameters, which are often the result of
the negotiation described above.
Some image creation parameters are implicitly defined by the external
source; for example, `VK_IMAGE_TYPE_2D` is often assumed.
Some image creation parameters are usually explicit, such as the images
`format`, `drmFormatModifier`, and `extent`; and each planes
`offset` and `rowPitch`.

Before creating the image, the application first verifies that the physical
device supports the received creation parameters by querying
[vkGetPhysicalDeviceFormatProperties2](../chapters/formats.html#vkGetPhysicalDeviceFormatProperties2) with
[VkDrmFormatModifierPropertiesListEXT](../chapters/formats.html#VkDrmFormatModifierPropertiesListEXT) and
[vkGetPhysicalDeviceImageFormatProperties2](../chapters/capabilities.html#vkGetPhysicalDeviceImageFormatProperties2) with
[VkPhysicalDeviceImageDrmFormatModifierInfoEXT](../chapters/capabilities.html#VkPhysicalDeviceImageDrmFormatModifierInfoEXT).
Then the application creates the image by chaining
[VkImageDrmFormatModifierExplicitCreateInfoEXT](../chapters/resources.html#VkImageDrmFormatModifierExplicitCreateInfoEXT) and
[VkExternalMemoryImageCreateInfo](../chapters/resources.html#VkExternalMemoryImageCreateInfo) onto [VkImageCreateInfo](../chapters/resources.html#VkImageCreateInfo).

* 
**Export.** The application creates an image and allocates its memory.
Then the application exports to *modifier*-aware consumers the images
memory handles; its creation parameters; its *modifier*; and the
[`offset`](../chapters/resources.html#VkSubresourceLayout),
[`size`](../chapters/resources.html#VkSubresourceLayout), and
[`rowPitch`](../chapters/resources.html#VkSubresourceLayout) of each *memory plane*.

In this pattern, the Vulkan device is the authority for the image; it is the
allocator of the images memory and the decider of the images creation
parameters.
When choosing the images creation parameters, the application usually
chooses a tuple *(format, drmFormatModifier)* from the result of the
negotiation described above.
The negotiations result often contains multiple tuples that share the same
format but differ in their *modifier*.
In this case, the application should defer the choice of the images
*modifier* to the Vulkan implementation by providing all such *modifiers* to
[VkImageDrmFormatModifierListCreateInfoEXT](../chapters/resources.html#VkImageDrmFormatModifierListCreateInfoEXT)::`pDrmFormatModifiers`;
and the implementation should choose from `pDrmFormatModifiers` the
optimal *modifier* in consideration with the other image parameters.

The application creates the image by chaining
[VkImageDrmFormatModifierListCreateInfoEXT](../chapters/resources.html#VkImageDrmFormatModifierListCreateInfoEXT) and
[VkExternalMemoryImageCreateInfo](../chapters/resources.html#VkExternalMemoryImageCreateInfo) onto [VkImageCreateInfo](../chapters/resources.html#VkImageCreateInfo).
The protocol and APIs by which the application will share the image with
external consumers will likely determine the value of
[VkExternalMemoryImageCreateInfo](../chapters/resources.html#VkExternalMemoryImageCreateInfo)::`handleTypes`.
The implementation chooses for the image an optimal *modifier* from
[VkImageDrmFormatModifierListCreateInfoEXT](../chapters/resources.html#VkImageDrmFormatModifierListCreateInfoEXT)::`pDrmFormatModifiers`.
The application then queries the implementation-chosen *modifier* with
[vkGetImageDrmFormatModifierPropertiesEXT](../chapters/resources.html#vkGetImageDrmFormatModifierPropertiesEXT), and queries the memory
layout of each plane with [vkGetImageSubresourceLayout](../chapters/resources.html#vkGetImageSubresourceLayout).

The application then allocates the images memory with
[VkMemoryAllocateInfo](../chapters/memory.html#VkMemoryAllocateInfo), adding chained extending structures for external
memory; binds it to the image; and exports the memory, for example, with
[vkGetMemoryFdKHR](../chapters/memory.html#vkGetMemoryFdKHR).

Finally, the application sends the images creation parameters, its
*modifier*, its per-plane memory layout, and the exported memory handle to
the external consumers.
The details of how the application transmits this information to external
consumers is outside the scope of this specification.

Extension
`EGL_EXT_image_dma_buf_import`[1](#VK_EXT_image_drm_format_modifier-fn1)
introduced the ability to create an `EGLImage` by importing for each
plane a dma_buf, offset, and row pitch.

Later, extension
`EGL_EXT_image_dma_buf_import_modifiers`[2](#VK_EXT_image_drm_format_modifier-fn2)
introduced the ability to query which combination of formats and *modifiers*
the implementation supports and to specify *modifiers* during creation of
the `EGLImage`.

Extension
`EGL_MESA_image_dma_buf_export`[3](#VK_EXT_image_drm_format_modifier-fn3)
is the inverse of `EGL_EXT_image_dma_buf_import_modifiers`.

The Linux kernel modesetting API (KMS), when configuring the displays
framebuffer with `struct
drm_mode_fb_cmd2`[4](#VK_EXT_image_drm_format_modifier-fn4), allows one to
specify the framebuffers *modifier* as well as a per-plane memory handle,
offset, and row pitch.

GBM, a graphics buffer manager for Linux, allows creation of a `gbm_bo`
(that is, a graphics *buffer object*) by importing data similar to that in
`EGL_EXT_image_dma_buf_import_modifiers`[1](#VK_EXT_image_drm_format_modifier-fn1);
and symmetrically allows exporting the same data from the `gbm_bo`.
See the references to *modifier* and *plane* in
`gbm.h`[5](#VK_EXT_image_drm_format_modifier-fn5).

* 
[vkGetImageDrmFormatModifierPropertiesEXT](../chapters/resources.html#vkGetImageDrmFormatModifierPropertiesEXT)

* 
[VkDrmFormatModifierPropertiesEXT](../chapters/formats.html#VkDrmFormatModifierPropertiesEXT)

* 
[VkImageDrmFormatModifierPropertiesEXT](../chapters/resources.html#VkImageDrmFormatModifierPropertiesEXT)

* 
Extending [VkFormatProperties2](../chapters/formats.html#VkFormatProperties2):

[VkDrmFormatModifierPropertiesListEXT](../chapters/formats.html#VkDrmFormatModifierPropertiesListEXT)

Extending [VkImageCreateInfo](../chapters/resources.html#VkImageCreateInfo):

* 
[VkImageDrmFormatModifierExplicitCreateInfoEXT](../chapters/resources.html#VkImageDrmFormatModifierExplicitCreateInfoEXT)

* 
[VkImageDrmFormatModifierListCreateInfoEXT](../chapters/resources.html#VkImageDrmFormatModifierListCreateInfoEXT)

Extending [VkPhysicalDeviceImageFormatInfo2](../chapters/capabilities.html#VkPhysicalDeviceImageFormatInfo2):

* 
[VkPhysicalDeviceImageDrmFormatModifierInfoEXT](../chapters/capabilities.html#VkPhysicalDeviceImageDrmFormatModifierInfoEXT)

If [VK_KHR_format_feature_flags2](#VK_KHR_format_feature_flags2) or [Vulkan Version 1.3](versions.html#versions-1.3) is supported:

* 
[VkDrmFormatModifierProperties2EXT](../chapters/formats.html#VkDrmFormatModifierProperties2EXT)

* 
Extending [VkFormatProperties2](../chapters/formats.html#VkFormatProperties2):

[VkDrmFormatModifierPropertiesList2EXT](../chapters/formats.html#VkDrmFormatModifierPropertiesList2EXT)

* 
`VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_EXTENSION_NAME`

* 
`VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_SPEC_VERSION`

* 
Extending [VkImageAspectFlagBits](../chapters/resources.html#VkImageAspectFlagBits):

`VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT`

* 
`VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT`

* 
`VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT`

* 
`VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT`

Extending [VkImageTiling](../chapters/resources.html#VkImageTiling):

* 
`VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT`

Extending [VkResult](../chapters/fundamentals.html#VkResult):

* 
`VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT`

* 
`VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT`

If [VK_KHR_format_feature_flags2](#VK_KHR_format_feature_flags2) or [Vulkan Version 1.3](versions.html#versions-1.3) is supported:

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT`

1) Should this extension define a single DRM format modifier per
`VkImage`? Or define one per plane?

+

**RESOLVED**: There exists a single DRM format modifier per `VkImage`.

**DISCUSSION**: Prior art, such as
`EGL_EXT_image_dma_buf_import_modifiers`[2](#VK_EXT_image_drm_format_modifier-fn2),
`struct drm_mode_fb_cmd2`[4](#VK_EXT_image_drm_format_modifier-fn4), and
`struct
gbm_import_fd_modifier_data`[5](#VK_EXT_image_drm_format_modifier-fn5),
allows defining one *modifier* per plane.
However, developers of the GBM and kernel APIs concede it was a mistake.
Beginning in Linux 4.10, the kernel requires that the application provide
the same DRM format *modifier* for each plane.
(See Linux commit
[bae781b259269590109e8a4a8227331362b88212](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=bae781b259269590109e8a4a8227331362b88212)).
And GBM provides an entry point, `gbm_bo_get_modifier`, for querying the
*modifier* of the image but does not provide one to query the modifier of
individual planes.

2) When creating an image with
[VkImageDrmFormatModifierExplicitCreateInfoEXT](../chapters/resources.html#VkImageDrmFormatModifierExplicitCreateInfoEXT), which is typically used
when *importing* an image, should the application explicitly provide the
size of each plane?

+

**RESOLVED**: No.
The application **must** not provide the size.
To enforce this, the API requires that
[VkImageDrmFormatModifierExplicitCreateInfoEXT](../chapters/resources.html#VkImageDrmFormatModifierExplicitCreateInfoEXT)::`pPlaneLayouts->size`
**must** be 0.

**DISCUSSION**: Prior art, such as
`EGL_EXT_image_dma_buf_import_modifiers`[2](#VK_EXT_image_drm_format_modifier-fn2),
`struct drm_mode_fb_cmd2`[4](#VK_EXT_image_drm_format_modifier-fn4), and
`struct
gbm_import_fd_modifier_data`[5](#VK_EXT_image_drm_format_modifier-fn5),
omits from the API the size of each plane.
Instead, the APIs infer each planes size from the import parameters, which
include the images pixel format and a dma_buf, offset, and row pitch for
each plane.

However, Vulkan differs from EGL and GBM with regards to image creation in
the following ways:

Differences in Image Creation

* 
**Undedicated allocation by default.** When importing or exporting a set
of dma_bufs as an `EGLImage` or `gbm_bo`, common practice mandates
that each dma_bufs memory be dedicated (in the sense of
`VK_KHR_dedicated_allocation`) to the image (though not necessarily
dedicated to a single plane).
In particular, neither the GBM documentation nor the EGL extension
specifications explicitly state this requirement, but in light of common
practice this is likely due to under-specification rather than
intentional omission.
In contrast, `VK_EXT_image_drm_format_modifier` permits, but does not
require, the implementation to require dedicated allocations for images
created with `VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT`.

* 
**Separation of image creation and memory allocation.** When importing a
set of dma_bufs as an `EGLImage` or `gbm_bo`, EGL and GBM create
the image resource and bind it to memory (the dma_bufs) simultaneously.
This allows EGL and GBM to query each dma_bufs size during image
creation.
In Vulkan, image creation and memory allocation are independent unless a
dedicated allocation is used (as in `VK_KHR_dedicated_allocation`).
Therefore, without requiring dedicated allocation, Vulkan cannot query
the size of each dma_buf (or other external handle) when calculating the
images memory layout.
Even if dedication allocation were required, Vulkan cannot calculate the
images memory layout until after the image is bound to its dma_ufs.

The above differences complicate the potential inference of plane size in
Vulkan.
Consider the following problematic cases:

Problematic Plane Size Calculations

* 
**Padding.** Some plane of the image may require implementation-dependent
padding.

* 
**Metadata.** For some *modifiers*, the image may have a metadata plane
which requires a non-trivial calculation to determine its size.

* 
**Mipmapped, array, and 3D images.** The implementation may support
`VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT` for images whose
`mipLevels`, `arrayLayers`, or `depth` is greater than 1.
For such images with certain *modifiers*, the calculation of each
planes size may be non-trivial.

However, an application-provided plane size solves none of the above
problems.

For simplicity, consider an external image with a single memory plane.
The implementation is obviously capable calculating the images size when
its tiling is `VK_IMAGE_TILING_OPTIMAL`.
Likewise, any reasonable implementation is capable of calculating the
images size when its tiling uses a supported *modifier*.

Suppose that the external images size is smaller than the
implementation-calculated size.
If the application provided the external images size to
[vkCreateImage](../chapters/resources.html#vkCreateImage), the implementation would observe the mismatched size
and recognize its inability to comprehend the external images layout
(unless the implementation used the application-provided size to select a
refinement of the tiling layout indicated by the *modifier*, which is
strongly discouraged).
The implementation would observe the conflict, and reject image creation
with `VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT`.
On the other hand, if the application did not provide the external images
size to [vkCreateImage](../chapters/resources.html#vkCreateImage), then the application would observe after
calling [vkGetImageMemoryRequirements](../chapters/resources.html#vkGetImageMemoryRequirements) that the external images size is
less than the size required by the implementation.
The application would observe the conflict and refuse to bind the
`VkImage` to the external memory.
In both cases, the result is explicit failure.

Suppose that the external images size is larger than the
implementation-calculated size.
If the application provided the external images size to
[vkCreateImage](../chapters/resources.html#vkCreateImage), for reasons similar to above the implementation would
observe the mismatched size and recognize its inability to comprehend the
image data residing in the extra size.
The implementation, however, must assume that image data resides in the
entire size provided by the application.
The implementation would observe the conflict and reject image creation with
`VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT`.
On the other hand, if the application did not provide the external images
size to [vkCreateImage](../chapters/resources.html#vkCreateImage), then the application would observe after
calling [vkGetImageMemoryRequirements](../chapters/resources.html#vkGetImageMemoryRequirements) that the external images size is
larger than the implementation-usable size.
The application would observe the conflict and refuse to bind the
`VkImage` to the external memory.
In both cases, the result is explicit failure.

Therefore, an application-provided size provides no benefit, and this
extension should not require it.
This decision renders [VkSubresourceLayout](../chapters/resources.html#VkSubresourceLayout)::`size` an unused field
during image creation, and thus introduces a risk that implementations may
require applications to submit sideband creation parameters in the unused
field.
To prevent implementations from relying on sideband data, this extension
*requires* the application to set `size` to 0.

[`EGL_EXT_image_dma_buf_import`](https://registry.khronos.org/EGL/extensions/EXT/EGL_EXT_image_dma_buf_import.txt)

[`EGL_EXT_image_dma_buf_import_modifiers`](https://registry.khronos.org/EGL/extensions/EXT/EGL_EXT_image_dma_buf_import_modifiers.txt)

[`EGL_MESA_image_dma_buf_export`](https://registry.khronos.org/EGL/extensions/MESA/EGL_MESA_image_dma_buf_export.txt)

[`struct
drm_mode_fb_cmd2`](https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/include/uapi/drm/drm_mode.h?id=refs/tags/v4.10#n392)

[`gbm.h`](https://cgit.freedesktop.org/mesa/mesa/tree/src/gbm/main/gbm.h?id=refs/tags/mesa-18.0.0-rc1)

* 
Revision 1, 2018-08-29 (Lina Versace)

First stable revision

Revision 2, 2021-09-30 (Jon Leech)

* 
Add interaction with `[VK_KHR_format_feature_flags2](#VK_KHR_format_feature_flags2)` to `vk.xml`

**Name String**

`VK_EXT_image_sliced_view_of_3d`

**Extension Type**

Device extension

**Registered Extension Number**

419

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

 [VK_KHR_maintenance1](#VK_KHR_maintenance1)

 and

 [VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Special Use**

* 
[D3D support](../chapters/extensions.html#extendingvulkan-compatibility-specialuse)

**Contact**

* 
Mike Blumenkrantz [zmike](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_image_sliced_view_of_3d] @zmike%0A*Here describe the issue or question you have about the VK_EXT_image_sliced_view_of_3d extension*)

**Extension Proposal**

[VK_EXT_image_sliced_view_of_3d](../../../features/latest/features/proposals/VK_EXT_image_sliced_view_of_3d.html)

**Last Modified Date**

2023-01-24

**IP Status**

No known IP claims.

**Contributors**

* 
Mike Blumenkrantz, Valve

* 
Hans-Kristian Arntzen, Valve

* 
Ricardo Garcia, Igalia

* 
Shahbaz Youssefi, Google

* 
Piers Daniell, NVIDIA

This extension allows creating 3D views of 3D images such that the views
contain a subset of the slices in the image, using a Z offset and range, for
the purpose of using the views as storage image descriptors.
This matches functionality in D3D12 and is primarily intended to support
D3D12 emulation.

* 
Extending [VkImageViewCreateInfo](../chapters/resources.html#VkImageViewCreateInfo):

[VkImageViewSlicedCreateInfoEXT](../chapters/resources.html#VkImageViewSlicedCreateInfoEXT)

Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

* 
[VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT](../chapters/features.html#VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT)

* 
`VK_EXT_IMAGE_SLICED_VIEW_OF_3D_EXTENSION_NAME`

* 
`VK_EXT_IMAGE_SLICED_VIEW_OF_3D_SPEC_VERSION`

* 
`VK_REMAINING_3D_SLICES_EXT`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT`

* 
Revision 1, 2022-10-21 (Mike Blumenkrantz)

Initial revision

**Name String**

`VK_EXT_image_view_min_lod`

**Extension Type**

Device extension

**Registered Extension Number**

392

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Contact**

* 
Joshua Ashton [Joshua-Ashton](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_image_view_min_lod] @Joshua-Ashton%0A*Here describe the issue or question you have about the VK_EXT_image_view_min_lod extension*)

**Last Modified Date**

2021-11-09

**IP Status**

No known IP claims.

**Contributors**

* 
Joshua Ashton, Valve

* 
Hans-Kristian Arntzen, Valve

* 
Samuel Iglesias Gonsalvez, Igalia

* 
Tobias Hector, AMD

* 
Faith Ekstrand, Intel

* 
Tom Olson, ARM

This extension allows applications to clamp the minimum LOD value during
[Image Level(s) Selection](../chapters/textures.html#textures-image-level-selection),
[Texel Gathering](../chapters/textures.html#textures-gather) and
[Integer Texel Coordinate Operations](../chapters/textures.html#textures-integer-coordinate-operations) with a given [VkImageView](../chapters/resources.html#VkImageView) by
[VkImageViewMinLodCreateInfoEXT](../chapters/resources.html#VkImageViewMinLodCreateInfoEXT)::`minLod`.

This extension may be useful to restrict a [VkImageView](../chapters/resources.html#VkImageView) to only mips
which have been uploaded, and the use of fractional `minLod` can be
useful for smoothly introducing new mip levels when using linear mipmap
filtering.

* 
Extending [VkImageViewCreateInfo](../chapters/resources.html#VkImageViewCreateInfo):

[VkImageViewMinLodCreateInfoEXT](../chapters/resources.html#VkImageViewMinLodCreateInfoEXT)

Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

* 
[VkPhysicalDeviceImageViewMinLodFeaturesEXT](../chapters/features.html#VkPhysicalDeviceImageViewMinLodFeaturesEXT)

* 
`VK_EXT_IMAGE_VIEW_MIN_LOD_EXTENSION_NAME`

* 
`VK_EXT_IMAGE_VIEW_MIN_LOD_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT`

* 
Revision 1, 2021-07-06 (Joshua Ashton)

Initial version

**Name String**

`VK_EXT_layer_settings`

**Extension Type**

Instance extension

**Registered Extension Number**

497

**Revision**

2

**Ratification Status**

Ratified

**Extension and Version Dependencies**

None

**Contact**

* 
Christophe Riccio [christophe](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_layer_settings] @christophe%0A*Here describe the issue or question you have about the VK_EXT_layer_settings extension*)

**Extension Proposal**

[VK_EXT_layer_settings](../../../features/latest/features/proposals/VK_EXT_layer_settings.html)

**Last Modified Date**

2023-09-23

**IP Status**

No known IP claims.

**Contributors**

* 
Christophe Riccio, LunarG

* 
Mark Lobodzinski, LunarG

* 
Charles Giessen, LunarG

* 
Spencer Fricke, LunarG

* 
Juan Ramos, LunarG

* 
Daniel Rakos, RasterGrid

* 
Shahbaz Youssefi, Google

* 
Lina Versace, Google

* 
Bill Hollings, The Brenwill Workshop

* 
Jon Leech, Khronos

* 
Tom Olson, Arm

This extension provides a mechanism for configuring programmatically through
the Vulkan API the behavior of layers.

This extension provides the [VkLayerSettingsCreateInfoEXT](../chapters/initialization.html#VkLayerSettingsCreateInfoEXT) structure
that can be included in the `pNext` chain of the
[VkInstanceCreateInfo](../chapters/initialization.html#VkInstanceCreateInfo) structure passed as the `pCreateInfo`
parameter of [vkCreateInstance](../chapters/initialization.html#vkCreateInstance).

The structure contains an array of [VkLayerSettingEXT](../chapters/initialization.html#VkLayerSettingEXT) structure values
that configure specific features of layers.

|  | The `[VK_EXT_layer_settings](#VK_EXT_layer_settings)` extension subsumes all the functionality
| --- | --- |
provided in the `[VK_EXT_validation_flags](#VK_EXT_validation_flags)` extension and the
`[VK_EXT_validation_features](#VK_EXT_validation_features)` extension. |

* 
[VkLayerSettingEXT](../chapters/initialization.html#VkLayerSettingEXT)

* 
Extending [VkInstanceCreateInfo](../chapters/initialization.html#VkInstanceCreateInfo):

[VkLayerSettingsCreateInfoEXT](../chapters/initialization.html#VkLayerSettingsCreateInfoEXT)

* 
[VkLayerSettingTypeEXT](../chapters/initialization.html#VkLayerSettingTypeEXT)

* 
`VK_EXT_LAYER_SETTINGS_EXTENSION_NAME`

* 
`VK_EXT_LAYER_SETTINGS_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT`

One example usage of `VK_EXT_layer_settings` is as implemented by the Vulkan
Profiles layer.

It allows the profiles layer tests used by the profiles layer C.I.
to programmatically configure the layer for each test without affecting the
C.I.
environment, allowing to run multiple tests concurrently.

const char* profile_file_data = JSON_TEST_FILES_PATH "VP_KHR_roadmap_2022.json";
const char* profile_name_data = "VP_KHR_roadmap_2022";
VkBool32 emulate_portability_data = VK_TRUE;
const char* simulate_capabilities[] = {
    "SIMULATE_API_VERSION_BIT",
    "SIMULATE_FEATURES_BIT",
    "SIMULATE_PROPERTIES_BIT",
    "SIMULATE_EXTENSIONS_BIT",
    "SIMULATE_FORMATS_BIT",
    "SIMULATE_QUEUE_FAMILY_PROPERTIES_BIT"
};
const char* debug_reports[] = {
    "DEBUG_REPORT_ERROR_BIT",
    "DEBUG_REPORT_WARNING_BIT",
    "DEBUG_REPORT_NOTIFICATION_BIT",
    "DEBUG_REPORT_DEBUG_BIT"
};

const VkLayerSettingEXT settings[] = {
     {kLayerName, kLayerSettingsProfileFile, VK_LAYER_SETTING_TYPE_STRING_EXT, 1, &profile_file_data},
     {kLayerName, kLayerSettingsProfileName, VK_LAYER_SETTING_TYPE_STRING_EXT, 1, &profile_name_data},
     {kLayerName, kLayerSettingsEmulatePortability, VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &emulate_portability_data},
     {kLayerName, kLayerSettingsSimulateCapabilities, VK_LAYER_SETTING_TYPE_STRING_EXT,
        static_cast(std::size(simulate_capabilities)), simulate_capabilities},
     {kLayerName, kLayerSettingsDebugReports, VK_LAYER_SETTING_TYPE_STRING_EXT,
        static_cast(std::size(debug_reports)), debug_reports}
};

const VkLayerSettingsCreateInfoEXT layer_settings_create_info{
    VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT, nullptr,
    static_cast(std::size(settings)), settings};

VkInstanceCreateInfo inst_create_info = {};
...
inst_create_info.pNext = &layer_settings_create_info;
vkCreateInstance(&inst_create_info, nullptr, &_instances);

* 
How should application developers figure out the list of available
settings?

This extension does not provide a reflection API for layer settings.
Layer settings are described in each layer JSON manifest and the
documentation of each layer which implements this extension.

* 
Revision 1, 2020-06-17 (Mark Lobodzinski)

Initial revision for Validation layer internal usages

Revision 2, 2023-09-26 (Christophe Riccio)

* 
Refactor APIs for any layer usages and public release

**Name String**

`VK_EXT_legacy_dithering`

**Extension Type**

Device extension

**Registered Extension Number**

466

**Revision**

2

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**API Interactions**

* 
Interacts with VK_VERSION_1_3

* 
Interacts with VK_VERSION_1_4

* 
Interacts with VK_KHR_dynamic_rendering

* 
Interacts with VK_KHR_maintenance5

**Special Use**

* 
[OpenGL / ES support](../chapters/extensions.html#extendingvulkan-compatibility-specialuse)

**Contact**

* 
Shahbaz Youssefi [syoussefi](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_legacy_dithering] @syoussefi%0A*Here describe the issue or question you have about the VK_EXT_legacy_dithering extension*)

**Extension Proposal**

[VK_EXT_legacy_dithering](../../../features/latest/features/proposals/VK_EXT_legacy_dithering.html)

**Last Modified Date**

2024-02-22

**Contributors**

* 
Shahbaz Youssefi, Google

* 
Graeme Leese, Broadcom

* 
Jan-Harald Fredriksen, Arm

This extension exposes a hardware feature used by some vendors to implement
OpenGLs dithering.
The purpose of this extension is to support layering OpenGL over Vulkan, by
allowing the layer to take advantage of the same hardware feature and
provide equivalent dithering to OpenGL applications.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceLegacyDitheringFeaturesEXT](../chapters/features.html#VkPhysicalDeviceLegacyDitheringFeaturesEXT)

* 
`VK_EXT_LEGACY_DITHERING_EXTENSION_NAME`

* 
`VK_EXT_LEGACY_DITHERING_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT`

Extending [VkSubpassDescriptionFlagBits](../chapters/renderpass.html#VkSubpassDescriptionFlagBits):

* 
`VK_SUBPASS_DESCRIPTION_ENABLE_LEGACY_DITHERING_BIT_EXT`

If [VK_KHR_dynamic_rendering](#VK_KHR_dynamic_rendering) or [Vulkan Version 1.3](versions.html#versions-1.3) and [VK_KHR_maintenance5](#VK_KHR_maintenance5) or [Vulkan Version 1.4](versions.html#versions-1.4) is supported:

* 
Extending [VkPipelineCreateFlagBits2](../chapters/pipelines.html#VkPipelineCreateFlagBits2):

`VK_PIPELINE_CREATE_2_ENABLE_LEGACY_DITHERING_BIT_EXT`

Extending [VkRenderingFlagBits](../chapters/renderpass.html#VkRenderingFlagBits):

* 
`VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT`

* 
Revision 1, 2022-03-31 (Shahbaz Youssefi)

Internal revisions

Revision 2, 2024-02-22 (Shahbaz Youssefi)

* 
Added pipeline create flag to support dynamic rendering

1) In OpenGL, the dither state can change dynamically.
Should this extension add a pipeline state for dither?

**RESOLVED**: No.
Changing dither state is rarely, if ever, done during rendering.
Every surveyed Android application either entirely disables dither,
explicitly enables it, or uses the default state (which is enabled).
Additionally, on some hardware dither can only be specified in a render pass
granularity, so a change in dither state would necessarily need to cause a
render pass break.
This extension considers dynamic changes in OpenGL dither state a
theoretical situation, and expects the layer to break the render pass in
such a situation without any practical downsides.

**Name String**

`VK_EXT_legacy_vertex_attributes`

**Extension Type**

Device extension

**Registered Extension Number**

496

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_EXT_vertex_input_dynamic_state](#VK_EXT_vertex_input_dynamic_state)

**Special Use**

* 
[OpenGL / ES support](../chapters/extensions.html#extendingvulkan-compatibility-specialuse)

**Contact**

* 
Mike Blumenkrantz [zmike](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_legacy_vertex_attributes] @zmike%0A*Here describe the issue or question you have about the VK_EXT_legacy_vertex_attributes extension*)

**Extension Proposal**

[VK_EXT_legacy_vertex_attributes](../../../features/latest/features/proposals/VK_EXT_legacy_vertex_attributes.html)

**Last Modified Date**

2024-02-23

**IP Status**

No known IP claims.

**Contributors**

* 
Mike Blumenkrantz, Valve

* 
Piers Daniell, NVIDIA

* 
Spencer Fricke, LunarG

* 
Alyssa Rosenzweig, Valve

This extension adds support for legacy features of (non-64-bit) vertex
attributes as found in OpenGL:

* 
Vertex attributes loaded from arbitrary buffer alignments

* 
Vertex attributes using arbitrary strides

* 
Vertex attributes where the component data type of the binding does not
match the component numeric type of the shader input

These features are only usable with dynamic vertex input.
Unaligned loads of vertex attributes may incur performance penalties,
indicated with a property.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT](../chapters/features.html#VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT](../chapters/limits.html#VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT)

* 
`VK_EXT_LEGACY_VERTEX_ATTRIBUTES_EXTENSION_NAME`

* 
`VK_EXT_LEGACY_VERTEX_ATTRIBUTES_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_FEATURES_EXT`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_PROPERTIES_EXT`

1.) Should implementations convert float/integer values?

**RESOLVED**: No.
When fetching an integer data type from float values or float data types
from integer values, the resulting shader values are
implementation-dependent.

* 
Revision 1, 2024-02-16 (Mike Blumenkrantz)

Initial revision

**Name String**

`VK_EXT_map_memory_placed`

**Extension Type**

Device extension

**Registered Extension Number**

273

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_map_memory2](#VK_KHR_map_memory2)

or

[Vulkan Version 1.4](versions.html#versions-1.4)

**Contact**

* 
Faith Ekstrand [gfxstrand](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_map_memory_placed] @gfxstrand%0A*Here describe the issue or question you have about the VK_EXT_map_memory_placed extension*)

**Extension Proposal**

[VK_EXT_map_memory_placed](../../../features/latest/features/proposals/VK_EXT_map_memory_placed.html)

**Last Modified Date**

2023-03-21

**IP Status**

No known IP claims.

**Interactions and External Dependencies**

* 
Depends on apitext:VK_KHR_map_memory2

* 
Interacts with apitext:VK_EXT_external_memory_host

**Contributors**

* 
Faith Ekstrand, Collabora

* 
Tobias Hector, AMD

* 
James Jones, NVIDIA

* 
Georg Lehmann, Valve

* 
Derek Lesho, Codeweavers

This extension allows an application to request that [vkMapMemory2KHR](../chapters/memory.html#vkMapMemory2KHR)
attempt to place the memory map at a particular virtual address.

* 
Extending [VkMemoryMapInfo](../chapters/memory.html#VkMemoryMapInfo):

[VkMemoryMapPlacedInfoEXT](../chapters/memory.html#VkMemoryMapPlacedInfoEXT)

Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

* 
[VkPhysicalDeviceMapMemoryPlacedFeaturesEXT](../chapters/features.html#VkPhysicalDeviceMapMemoryPlacedFeaturesEXT)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceMapMemoryPlacedPropertiesEXT](../chapters/limits.html#VkPhysicalDeviceMapMemoryPlacedPropertiesEXT)

* 
`VK_EXT_MAP_MEMORY_PLACED_EXTENSION_NAME`

* 
`VK_EXT_MAP_MEMORY_PLACED_SPEC_VERSION`

* 
Extending [VkMemoryMapFlagBits](../chapters/memory.html#VkMemoryMapFlagBits):

`VK_MEMORY_MAP_PLACED_BIT_EXT`

Extending [VkMemoryUnmapFlagBits](../chapters/memory.html#VkMemoryUnmapFlagBits):

* 
`VK_MEMORY_UNMAP_RESERVE_BIT_EXT`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_MEMORY_MAP_PLACED_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_FEATURES_EXT`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_PROPERTIES_EXT`

* 
Revision 1, 2024-01-14 (Faith Ekstrand)

Internal revisions

**Name String**

`VK_EXT_memory_budget`

**Extension Type**

Device extension

**Registered Extension Number**

238

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Contact**

* 
Jeff Bolz [jeffbolznv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_memory_budget] @jeffbolznv%0A*Here describe the issue or question you have about the VK_EXT_memory_budget extension*)

**Last Modified Date**

2018-10-08

**Contributors**

* 
Jeff Bolz, NVIDIA

* 
Jeff Juliano, NVIDIA

While running a Vulkan application, other processes on the machine might
also be attempting to use the same device memory, which can pose problems.
This extension adds support for querying the amount of memory used and the
total memory budget for a memory heap.
The values returned by this query are implementation-dependent and can
depend on a variety of factors including operating system and system load.

The [VkPhysicalDeviceMemoryBudgetPropertiesEXT](../chapters/memory.html#VkPhysicalDeviceMemoryBudgetPropertiesEXT)::`heapBudget` values
can be used as a guideline for how much total memory from each heap the
**current process** can use at any given time, before allocations may start
failing or causing performance degradation.
The values may change based on other activity in the system that is outside
the scope and control of the Vulkan implementation.

The [VkPhysicalDeviceMemoryBudgetPropertiesEXT](../chapters/memory.html#VkPhysicalDeviceMemoryBudgetPropertiesEXT)::`heapUsage` will
display the **current process** estimated heap usage.

With this information, the idea is for an application at some interval (once
per frame, per few seconds, etc) to query `heapBudget` and
`heapUsage`.
From here the application can notice if it is over budget and decide how it
wants to handle the memory situation (free it, move to host memory, changing
mipmap levels, etc).
This extension is designed to be used in concert with
`[VK_EXT_memory_priority](#VK_EXT_memory_priority)` to help with this part of memory management.

* 
Extending [VkPhysicalDeviceMemoryProperties2](../chapters/memory.html#VkPhysicalDeviceMemoryProperties2):

[VkPhysicalDeviceMemoryBudgetPropertiesEXT](../chapters/memory.html#VkPhysicalDeviceMemoryBudgetPropertiesEXT)

* 
`VK_EXT_MEMORY_BUDGET_EXTENSION_NAME`

* 
`VK_EXT_MEMORY_BUDGET_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT`

* 
Revision 1, 2018-10-08 (Jeff Bolz)

Initial revision

**Name String**

`VK_EXT_memory_priority`

**Extension Type**

Device extension

**Registered Extension Number**

239

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Contact**

* 
Jeff Bolz [jeffbolznv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_memory_priority] @jeffbolznv%0A*Here describe the issue or question you have about the VK_EXT_memory_priority extension*)

**Last Modified Date**

2018-10-08

**Contributors**

* 
Jeff Bolz, NVIDIA

* 
Jeff Juliano, NVIDIA

This extension adds a `priority` value specified at memory allocation
time.
On some systems with both device-local and non-device-local memory heaps,
the implementation may transparently move memory from one heap to another
when a heap becomes full (for example, when the total memory used across all
processes exceeds the size of the heap).
In such a case, this priority value may be used to determine which
allocations are more likely to remain in device-local memory.

* 
Extending [VkMemoryAllocateInfo](../chapters/memory.html#VkMemoryAllocateInfo):

[VkMemoryPriorityAllocateInfoEXT](../chapters/memory.html#VkMemoryPriorityAllocateInfoEXT)

Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

* 
[VkPhysicalDeviceMemoryPriorityFeaturesEXT](../chapters/features.html#VkPhysicalDeviceMemoryPriorityFeaturesEXT)

* 
`VK_EXT_MEMORY_PRIORITY_EXTENSION_NAME`

* 
`VK_EXT_MEMORY_PRIORITY_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT`

* 
Revision 1, 2018-10-08 (Jeff Bolz)

Initial revision

**Name String**

`VK_EXT_mesh_shader`

**Extension Type**

Device extension

**Registered Extension Number**

329

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_spirv_1_4](#VK_KHR_spirv_1_4)

or

[Vulkan Version 1.2](versions.html#versions-1.2)

**API Interactions**

* 
Interacts with VK_VERSION_1_2

* 
Interacts with VK_EXT_device_generated_commands

* 
Interacts with VK_KHR_draw_indirect_count

* 
Interacts with VK_KHR_fragment_shading_rate

* 
Interacts with VK_NV_device_generated_commands

* 
Interacts with VkPhysicalDeviceMeshShaderFeaturesEXT::primitiveFragmentShadingRateMeshShader

**SPIR-V Dependencies**

* 
[SPV_EXT_mesh_shader](https://github.khronos.org/SPIRV-Registry/extensions/EXT/SPV_EXT_mesh_shader.html)

**Contact**

* 
Christoph Kubisch [pixeljetstream](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_mesh_shader] @pixeljetstream%0A*Here describe the issue or question you have about the VK_EXT_mesh_shader extension*)

**Extension Proposal**

[VK_EXT_mesh_shader](../../../features/latest/features/proposals/VK_EXT_mesh_shader.html)

**Last Modified Date**

2022-01-20

**Interactions and External Dependencies**

* 
This extension provides API support for
[`GLSL_EXT_mesh_shader`](https://github.com/KhronosGroup/GLSL/blob/main/extensions/ext/GLSL_EXT_mesh_shader.txt)

* 
Interacts with Vulkan 1.1

* 
Interacts with `[VK_KHR_multiview](#VK_KHR_multiview)`

* 
Interacts with `[VK_KHR_fragment_shading_rate](#VK_KHR_fragment_shading_rate)`

**Contributors**

* 
Christoph Kubisch, NVIDIA

* 
Pat Brown, NVIDIA

* 
Jeff Bolz, NVIDIA

* 
Daniel Koch, NVIDIA

* 
Piers Daniell, NVIDIA

* 
Pierre Boudier, NVIDIA

* 
Patrick Mours, NVIDIA

* 
David Zhao Akeley, NVIDIA

* 
Kedarnath Thangudu, NVIDIA

* 
Timur Kristf, Valve

* 
Hans-Kristian Arntzen, Valve

* 
Philip Rebohle, Valve

* 
Mike Blumenkrantz, Valve

* 
Slawomir Grajewski, Intel

* 
Michal Pietrasiuk, Intel

* 
Mariusz Merecki, Intel

* 
Tom Olson, ARM

* 
Jan-Harald Fredriksen, ARM

* 
Sandeep Kakarlapudi, ARM

* 
Ruihao Zhang, QUALCOMM

* 
Ricardo Garcia, Igalia, S.L.

* 
Tobias Hector, AMD

* 
Stu Smith, AMD

This extension provides a new mechanism allowing applications to generate
collections of geometric primitives via programmable mesh shading.
It is an alternative to the existing programmable primitive shading
pipeline, which relied on generating input primitives by a fixed function
assembler as well as fixed function vertex fetch.

This extension also adds support for the following SPIR-V extension in
Vulkan:

* 
[`SPV_EXT_mesh_shader`](https://github.khronos.org/SPIRV-Registry/extensions/EXT/SPV_EXT_mesh_shader.html)

* 
[vkCmdDrawMeshTasksEXT](../chapters/drawing.html#vkCmdDrawMeshTasksEXT)

* 
[vkCmdDrawMeshTasksIndirectEXT](../chapters/drawing.html#vkCmdDrawMeshTasksIndirectEXT)

If [VK_KHR_draw_indirect_count](#VK_KHR_draw_indirect_count) or [Vulkan Version 1.2](versions.html#versions-1.2) is supported:

* 
[vkCmdDrawMeshTasksIndirectCountEXT](../chapters/drawing.html#vkCmdDrawMeshTasksIndirectCountEXT)

* 
[VkDrawMeshTasksIndirectCommandEXT](../chapters/drawing.html#VkDrawMeshTasksIndirectCommandEXT)

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceMeshShaderFeaturesEXT](../chapters/features.html#VkPhysicalDeviceMeshShaderFeaturesEXT)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceMeshShaderPropertiesEXT](../chapters/limits.html#VkPhysicalDeviceMeshShaderPropertiesEXT)

* 
`VK_EXT_MESH_SHADER_EXTENSION_NAME`

* 
`VK_EXT_MESH_SHADER_SPEC_VERSION`

* 
Extending [VkPipelineStageFlagBits](../chapters/synchronization.html#VkPipelineStageFlagBits):

`VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT`

* 
`VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT`

Extending [VkQueryPipelineStatisticFlagBits](../chapters/queries.html#VkQueryPipelineStatisticFlagBits):

* 
`VK_QUERY_PIPELINE_STATISTIC_MESH_SHADER_INVOCATIONS_BIT_EXT`

* 
`VK_QUERY_PIPELINE_STATISTIC_TASK_SHADER_INVOCATIONS_BIT_EXT`

Extending [VkQueryType](../chapters/queries.html#VkQueryType):

* 
`VK_QUERY_TYPE_MESH_PRIMITIVES_GENERATED_EXT`

Extending [VkShaderStageFlagBits](../chapters/pipelines.html#VkShaderStageFlagBits):

* 
`VK_SHADER_STAGE_MESH_BIT_EXT`

* 
`VK_SHADER_STAGE_TASK_BIT_EXT`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT`

If [VK_EXT_device_generated_commands](#VK_EXT_device_generated_commands) is supported:

* 
Extending [VkIndirectCommandsTokenTypeEXT](../chapters/device_generated_commands/generatedcommands.html#VkIndirectCommandsTokenTypeEXT):

`VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_COUNT_EXT`

* 
`VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_EXT`

If [VK_NV_device_generated_commands](#VK_NV_device_generated_commands) is supported:

* 
Extending [VkIndirectCommandsTokenTypeNV](../chapters/device_generated_commands/generatedcommands.html#VkIndirectCommandsTokenTypeNV):

`VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV`

* 
[CullPrimitiveEXT](../chapters/interfaces.html#interfaces-builtin-variables-cullprimitive)

* 
[PrimitivePointIndicesEXT](../chapters/interfaces.html#interfaces-builtin-variables-primitivepointindices)

* 
[PrimitiveLineIndicesEXT](../chapters/interfaces.html#interfaces-builtin-variables-primitivelineindices)

* 
[PrimitiveTriangleIndicesEXT](../chapters/interfaces.html#interfaces-builtin-variables-primitivetriangleindices)

* 
(modified)`Position`

* 
(modified)`PointSize`

* 
(modified)`ClipDistance`

* 
(modified)`CullDistance`

* 
(modified)`PrimitiveId`

* 
(modified)`Layer`

* 
(modified)`ViewportIndex`

* 
(modified)`NumWorkgroups`

* 
(modified)`WorkgroupSize`

* 
(modified)`WorkgroupId`

* 
(modified)`LocalInvocationId`

* 
(modified)`GlobalInvocationId`

* 
(modified)`LocalInvocationIndex`

* 
(modified)`NumSubgroups`

* 
(modified)`SubgroupId`

* 
(modified)`DrawIndex`

* 
(modified)`PrimitiveShadingRateKHR`

* 
(modified)`ViewIndex`

* 
[`MeshShadingEXT`](spirvenv.html#spirvenv-capabilities-table-MeshShadingEXT)

* 
Revision 1, 2022-03-08 (Christoph Kubisch, Daniel Koch, Patrick Mours)

Initial revision

**Name String**

`VK_EXT_metal_objects`

**Extension Type**

Device extension

**Registered Extension Number**

312

**Revision**

2

**Ratification Status**

Ratified

**Extension and Version Dependencies**

None

**Contact**

* 
Bill Hollings [billhollings](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_metal_objects] @billhollings%0A*Here describe the issue or question you have about the VK_EXT_metal_objects extension*)

**Extension Proposal**

[VK_EXT_metal_objects](../../../features/latest/features/proposals/VK_EXT_metal_objects.html)

**Last Modified Date**

2024-04-04

**IP Status**

No known IP claims.

**Contributors**

* 
Bill Hollings, The Brenwill Workshop Ltd.

* 
Dzmitry Malyshau, Mozilla Corp.

In a Vulkan implementation that is layered on top of Metal on Apple device
platforms, this extension provides the ability to import and export the
underlying Metal objects associated with specific Vulkan objects.

As detailed in the
[extension
proposal document](https://github.com/KhronosGroup/Vulkan-Docs/tree/main/proposals/VK_EXT_metal_objects.adoc), this extension adds one new Vulkan command,
[vkExportMetalObjectsEXT](../chapters/memory.html#vkExportMetalObjectsEXT), to export underlying Metal objects from
Vulkan objects, and supports importing the appropriate existing Metal
objects when creating Vulkan objects of types [VkDeviceMemory](../chapters/memory.html#VkDeviceMemory),
[VkImage](../chapters/resources.html#VkImage), [VkSemaphore](../chapters/synchronization.html#VkSemaphore), and [VkEvent](../chapters/synchronization.html#VkEvent),

The intent is that this extension will be advertised and supported only on
implementations that are layered on top of Metal on Apple device platforms.

* 
`IOSurfaceRef`

* 
`MTLBuffer_id`

* 
`MTLCommandQueue_id`

* 
`MTLDevice_id`

* 
`MTLSharedEvent_id`

* 
`MTLTexture_id`

* 
[vkExportMetalObjectsEXT](../chapters/memory.html#vkExportMetalObjectsEXT)

* 
[VkExportMetalObjectsInfoEXT](../chapters/memory.html#VkExportMetalObjectsInfoEXT)

* 
Extending [VkExportMetalObjectsInfoEXT](../chapters/memory.html#VkExportMetalObjectsInfoEXT):

[VkExportMetalBufferInfoEXT](../chapters/memory.html#VkExportMetalBufferInfoEXT)

* 
[VkExportMetalCommandQueueInfoEXT](../chapters/memory.html#VkExportMetalCommandQueueInfoEXT)

* 
[VkExportMetalDeviceInfoEXT](../chapters/memory.html#VkExportMetalDeviceInfoEXT)

* 
[VkExportMetalIOSurfaceInfoEXT](../chapters/memory.html#VkExportMetalIOSurfaceInfoEXT)

* 
[VkExportMetalSharedEventInfoEXT](../chapters/memory.html#VkExportMetalSharedEventInfoEXT)

* 
[VkExportMetalTextureInfoEXT](../chapters/memory.html#VkExportMetalTextureInfoEXT)

Extending [VkImageCreateInfo](../chapters/resources.html#VkImageCreateInfo):

* 
[VkImportMetalIOSurfaceInfoEXT](../chapters/memory.html#VkImportMetalIOSurfaceInfoEXT)

* 
[VkImportMetalTextureInfoEXT](../chapters/memory.html#VkImportMetalTextureInfoEXT)

Extending [VkInstanceCreateInfo](../chapters/initialization.html#VkInstanceCreateInfo), [VkMemoryAllocateInfo](../chapters/memory.html#VkMemoryAllocateInfo), [VkImageCreateInfo](../chapters/resources.html#VkImageCreateInfo), [VkImageViewCreateInfo](../chapters/resources.html#VkImageViewCreateInfo), [VkBufferViewCreateInfo](../chapters/resources.html#VkBufferViewCreateInfo), [VkSemaphoreCreateInfo](../chapters/synchronization.html#VkSemaphoreCreateInfo), [VkEventCreateInfo](../chapters/synchronization.html#VkEventCreateInfo):

* 
[VkExportMetalObjectCreateInfoEXT](../chapters/memory.html#VkExportMetalObjectCreateInfoEXT)

Extending [VkMemoryAllocateInfo](../chapters/memory.html#VkMemoryAllocateInfo):

* 
[VkImportMetalBufferInfoEXT](../chapters/memory.html#VkImportMetalBufferInfoEXT)

Extending [VkSemaphoreCreateInfo](../chapters/synchronization.html#VkSemaphoreCreateInfo), [VkEventCreateInfo](../chapters/synchronization.html#VkEventCreateInfo):

* 
[VkImportMetalSharedEventInfoEXT](../chapters/memory.html#VkImportMetalSharedEventInfoEXT)

* 
[VkExportMetalObjectTypeFlagBitsEXT](../chapters/memory.html#VkExportMetalObjectTypeFlagBitsEXT)

* 
[VkExportMetalObjectTypeFlagsEXT](../chapters/memory.html#VkExportMetalObjectTypeFlagsEXT)

* 
`VK_EXT_METAL_OBJECTS_EXTENSION_NAME`

* 
`VK_EXT_METAL_OBJECTS_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_EXPORT_METAL_BUFFER_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_EXPORT_METAL_COMMAND_QUEUE_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_EXPORT_METAL_DEVICE_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_EXPORT_METAL_IO_SURFACE_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECTS_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_EXPORT_METAL_SHARED_EVENT_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_EXPORT_METAL_TEXTURE_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_IMPORT_METAL_BUFFER_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT`

None.

* 
Revision 1, 2022-05-28 (Bill Hollings)

Initial draft.

* 
Incorporated feedback from review by the Vulkan Working Group.
Renamed many structures, moved import/export of MTLBuffer to
VkDeviceMemory, added export of MTLSharedEvent, added import of
MTLSharedEvent for VkSemaphore and VkEvent, and changed used bit mask
fields to individual bit fields to simplify Valid Usage rules.

Revision 2, 2024-04-04 (Bill Hollings)

* 
Add an `__unsafe_unretained` ownership qualifier to all Metal object
declarations, to support Automatic Reference Counting (ARC) on Apple
devices.

**Name String**

`VK_EXT_metal_surface`

**Extension Type**

Instance extension

**Registered Extension Number**

218

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_surface](#VK_KHR_surface)

**Contact**

* 
Dzmitry Malyshau [kvark](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_metal_surface] @kvark%0A*Here describe the issue or question you have about the VK_EXT_metal_surface extension*)

**Last Modified Date**

2018-10-01

**IP Status**

No known IP claims.

**Contributors**

* 
Dzmitry Malyshau, Mozilla Corp.

The `VK_EXT_metal_surface` extension is an instance extension.
It provides a mechanism to create a [VkSurfaceKHR](../chapters/VK_KHR_surface/wsi.html#VkSurfaceKHR) object (defined by
the `[VK_KHR_surface](#VK_KHR_surface)` extension) from `CAMetalLayer`, which is
the native rendering surface of Apples Metal framework.

* 
`CAMetalLayer`

* 
[vkCreateMetalSurfaceEXT](../chapters/VK_KHR_surface/wsi.html#vkCreateMetalSurfaceEXT)

* 
[VkMetalSurfaceCreateInfoEXT](../chapters/VK_KHR_surface/wsi.html#VkMetalSurfaceCreateInfoEXT)

* 
[VkMetalSurfaceCreateFlagsEXT](../chapters/VK_KHR_surface/wsi.html#VkMetalSurfaceCreateFlagsEXT)

* 
`VK_EXT_METAL_SURFACE_EXTENSION_NAME`

* 
`VK_EXT_METAL_SURFACE_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT`

* 
Revision 1, 2018-10-01 (Dzmitry Malyshau)

Initial version

**Name String**

`VK_EXT_multi_draw`

**Extension Type**

Device extension

**Registered Extension Number**

393

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Contact**

* 
Mike Blumenkrantz [zmike](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_multi_draw] @zmike%0A*Here describe the issue or question you have about the VK_EXT_multi_draw extension*)

**Last Modified Date**

2021-05-19

**Interactions and External Dependencies**

* 
Interacts with Vulkan 1.1.

* 
Interacts with `[VK_KHR_shader_draw_parameters](#VK_KHR_shader_draw_parameters)`.

**IP Status**

No known IP claims.

**Contributors**

* 
Mike Blumenkrantz, VALVE

* 
Piers Daniell, NVIDIA

* 
Faith Ekstrand, INTEL

* 
Spencer Fricke, SAMSUNG

* 
Ricardo Garcia, IGALIA

* 
Jon Leech, KHRONOS

* 
Stu Smith, AMD

Processing multiple draw commands in sequence incurs measurable overhead
within drivers due to repeated state checks and updates during dispatch.
This extension enables passing the entire sequence of draws directly to the
driver in order to avoid any such overhead, using an array of
[VkMultiDrawInfoEXT](../chapters/drawing.html#VkMultiDrawInfoEXT) or [VkMultiDrawIndexedInfoEXT](../chapters/drawing.html#VkMultiDrawIndexedInfoEXT) structs with
`vkCmdDrawMultiEXT` or `vkCmdDrawMultiIndexedEXT`, respectively.
These functions could be used any time multiple draw commands are being
recorded without any state changes between them in order to maximize
performance.

* 
[vkCmdDrawMultiEXT](../chapters/drawing.html#vkCmdDrawMultiEXT)

* 
[vkCmdDrawMultiIndexedEXT](../chapters/drawing.html#vkCmdDrawMultiIndexedEXT)

* 
[VkMultiDrawIndexedInfoEXT](../chapters/drawing.html#VkMultiDrawIndexedInfoEXT)

* 
[VkMultiDrawInfoEXT](../chapters/drawing.html#VkMultiDrawInfoEXT)

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceMultiDrawFeaturesEXT](../chapters/features.html#VkPhysicalDeviceMultiDrawFeaturesEXT)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceMultiDrawPropertiesEXT](../chapters/limits.html#VkPhysicalDeviceMultiDrawPropertiesEXT)

* 
`VK_EXT_MULTI_DRAW_EXTENSION_NAME`

* 
`VK_EXT_MULTI_DRAW_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT`

* 
(modified)`DrawIndex`

* 
Revision 1, 2021-01-20 (Mike Blumenkrantz)

Initial version

**Name String**

`VK_EXT_multisampled_render_to_single_sampled`

**Extension Type**

Device extension

**Registered Extension Number**

377

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

 [VK_KHR_create_renderpass2](#VK_KHR_create_renderpass2)

 and

 [VK_KHR_depth_stencil_resolve](#VK_KHR_depth_stencil_resolve)

or

[Vulkan Version 1.2](versions.html#versions-1.2)

**Contact**

* 
Shahbaz Youssefi [syoussefi](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_multisampled_render_to_single_sampled] @syoussefi%0A*Here describe the issue or question you have about the VK_EXT_multisampled_render_to_single_sampled extension*)

**Extension Proposal**

[VK_EXT_multisampled_render_to_single_sampled](../../../features/latest/features/proposals/VK_EXT_multisampled_render_to_single_sampled.html)

**Last Modified Date**

2021-04-16

**IP Status**

No known IP claims.

**Contributors**

* 
Shahbaz Youssefi, Google

* 
Jan-Harald Fredriksen, Arm

* 
Jrg Wagner, Arm

* 
Matthew Netsch, Qualcomm Technologies, Inc.

* 
Jarred Davies, Imagination Technologies

With careful usage of resolve attachments, multisampled image memory
allocated with `VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT`, `loadOp`
not equal to `VK_ATTACHMENT_LOAD_OP_LOAD` and `storeOp` not equal to
`VK_ATTACHMENT_STORE_OP_STORE`, a Vulkan application is able to
efficiently perform multisampled rendering without incurring any additional
memory penalty on some implementations.

Under certain circumstances however, the application may not be able to
complete its multisampled rendering within a single render pass; for example
if it does partial rasterization from frame to frame, blending on an image
from a previous frame, or in emulation of
GL_EXT_multisampled_render_to_texture.
In such cases, the application can use an initial subpass to effectively
load single-sampled data from the next subpasss resolve attachment and fill
in the multisampled attachment which otherwise uses `loadOp` equal to
`VK_ATTACHMENT_LOAD_OP_DONT_CARE`.
However, this is not always possible (for example for stencil in the absence
of VK_EXT_shader_stencil_export) and has multiple drawbacks.

Some implementations are able to perform said operation efficiently in
hardware, effectively loading a multisampled attachment from the contents of
a single sampled one.
Together with the ability to perform a resolve operation at the end of a
subpass, these implementations are able to perform multisampled rendering on
single-sampled attachments with no extra memory or bandwidth overhead.
This extension exposes this capability by allowing a framebuffer and render
pass to include single-sampled attachments while rendering is done with a
specified number of samples.

* 
Extending [VkFormatProperties2](../chapters/formats.html#VkFormatProperties2):

[VkSubpassResolvePerformanceQueryEXT](../chapters/formats.html#VkSubpassResolvePerformanceQueryEXT)

Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

* 
[VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT](../chapters/features.html#VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT)

Extending [VkSubpassDescription2](../chapters/renderpass.html#VkSubpassDescription2), [VkRenderingInfo](../chapters/renderpass.html#VkRenderingInfo):

* 
[VkMultisampledRenderToSingleSampledInfoEXT](../chapters/renderpass.html#VkMultisampledRenderToSingleSampledInfoEXT)

* 
`VK_EXT_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_EXTENSION_NAME`

* 
`VK_EXT_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_SPEC_VERSION`

* 
Extending [VkImageCreateFlagBits](../chapters/resources.html#VkImageCreateFlagBits):

`VK_IMAGE_CREATE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_BIT_EXT`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT`

* 
`VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT`

1) Could the multisampled attachment be initialized through some form of
copy?

**RESOLVED**: No.
Some implementations do not support copying between attachments in general,
and find expressing this operation through a copy unnatural.

2) Another way to achieve this is by introducing a new `loadOp` to load
the contents of the multisampled image from a single-sampled one.
Why is this extension preferred?

**RESOLVED**: Using this extension simplifies the application, as it does not
need to manage a secondary lazily-allocated image.
Additionally, using this extension leaves less room for error; for example a
single mistake in `loadOp` or `storeOp` would result in the
lazily-allocated image to actually take up memory, and remain so until
destruction.

3) There is no guarantee that multisampled data between two subpasses with
the same number of samples will be retained as the implementation may be
forced to split the render pass implicitly for various reasons.
Should this extension require that every subpass that uses
multisampled-render-to-single-sampled end in an implicit render pass split
(which results in a resolve operation)?

**RESOLVED**: No.
Not requiring this allows render passes with multiple
multisampled-render-to-single-sampled subpasses to potentially execute more
efficiently (though there is no guarantee).

* 
Revision 1, 2021-04-12 (Shahbaz Youssefi)

**Name String**

`VK_EXT_mutable_descriptor_type`

**Extension Type**

Device extension

**Registered Extension Number**

495

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_maintenance3](#VK_KHR_maintenance3)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Special Use**

* 
[D3D support](../chapters/extensions.html#extendingvulkan-compatibility-specialuse)

**Contact**

* 
Joshua Ashton [Joshua-Ashton](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_mutable_descriptor_type] @Joshua-Ashton%0A*Here describe the issue or question you have about the VK_EXT_mutable_descriptor_type extension*)

* 
Hans-Kristian Arntzen [HansKristian-Work](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_mutable_descriptor_type] @HansKristian-Work%0A*Here describe the issue or question you have about the VK_EXT_mutable_descriptor_type extension*)

**Extension Proposal**

[VK_EXT_mutable_descriptor_type](../../../features/latest/features/proposals/VK_EXT_mutable_descriptor_type.html)

**Last Modified Date**

2022-08-22

**IP Status**

No known IP claims.

**Contributors**

* 
Joshua Ashton, Valve

* 
Hans-Kristian Arntzen, Valve

This extension allows applications to reduce descriptor memory footprint by
allowing a descriptor to be able to mutate to a given list of descriptor
types depending on which descriptor types are written into, or copied into a
descriptor set.

The main use case this extension intends to address is descriptor indexing
with `VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT` where the
descriptor types are completely generic, as this means applications can
allocate one large descriptor set, rather than having one large descriptor
set per descriptor type, which significantly bloats descriptor memory usage
and causes performance issues.

This extension also adds a mechanism to declare that a descriptor pool, and
therefore the descriptor sets that are allocated from it, reside only in
host memory; as such these descriptors can only be updated/copied, but not
bound.

These features together allow much more efficient emulation of the raw D3D12
binding model.
This extension is primarily intended to be useful for API layering efforts.

* 
[VkMutableDescriptorTypeListEXT](../chapters/descriptorsets.html#VkMutableDescriptorTypeListEXT)

* 
Extending [VkDescriptorSetLayoutCreateInfo](../chapters/descriptorsets.html#VkDescriptorSetLayoutCreateInfo), [VkDescriptorPoolCreateInfo](../chapters/descriptorsets.html#VkDescriptorPoolCreateInfo):

[VkMutableDescriptorTypeCreateInfoEXT](../chapters/descriptorsets.html#VkMutableDescriptorTypeCreateInfoEXT)

Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

* 
[VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT](../chapters/features.html#VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT)

* 
`VK_EXT_MUTABLE_DESCRIPTOR_TYPE_EXTENSION_NAME`

* 
`VK_EXT_MUTABLE_DESCRIPTOR_TYPE_SPEC_VERSION`

* 
Extending [VkDescriptorPoolCreateFlagBits](../chapters/descriptorsets.html#VkDescriptorPoolCreateFlagBits):

`VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_EXT`

Extending [VkDescriptorSetLayoutCreateFlagBits](../chapters/descriptorsets.html#VkDescriptorSetLayoutCreateFlagBits):

* 
`VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_EXT`

Extending [VkDescriptorType](../chapters/descriptorsets.html#VkDescriptorType):

* 
`VK_DESCRIPTOR_TYPE_MUTABLE_EXT`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT`

* 
Revision 1, 2022-08-22 (Jon Leech)

Initial version, promoted from [VK_VALVE_mutable_descriptor_type](#VK_VALVE_mutable_descriptor_type).

**Name String**

`VK_EXT_nested_command_buffer`

**Extension Type**

Device extension

**Registered Extension Number**

452

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Contact**

* 
Piers Daniell [pdaniell-nv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_nested_command_buffer] @pdaniell-nv%0A*Here describe the issue or question you have about the VK_EXT_nested_command_buffer extension*)

**Last Modified Date**

2023-09-18

**Contributors**

* 
Daniel Story, Nintendo

* 
Peter Kohaut, NVIDIA

* 
Shahbaz Youssefi, Google

* 
Slawomir Grajewski, Intel

* 
Stu Smith, AMD

With core Vulkan it is not legal to call [vkCmdExecuteCommands](../chapters/cmdbuffers.html#vkCmdExecuteCommands) when
recording a secondary command buffer.
This extension relaxes that restriction, allowing secondary command buffers
to execute other secondary command buffers.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceNestedCommandBufferFeaturesEXT](../chapters/features.html#VkPhysicalDeviceNestedCommandBufferFeaturesEXT)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceNestedCommandBufferPropertiesEXT](../chapters/limits.html#VkPhysicalDeviceNestedCommandBufferPropertiesEXT)

* 
`VK_EXT_NESTED_COMMAND_BUFFER_EXTENSION_NAME`

* 
`VK_EXT_NESTED_COMMAND_BUFFER_SPEC_VERSION`

* 
Extending [VkRenderingFlagBits](../chapters/renderpass.html#VkRenderingFlagBits):

`VK_RENDERING_CONTENTS_INLINE_BIT_EXT`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_PROPERTIES_EXT`

Extending [VkSubpassContents](../chapters/renderpass.html#VkSubpassContents):

* 
`VK_SUBPASS_CONTENTS_INLINE_AND_SECONDARY_COMMAND_BUFFERS_EXT`

1) The Command Buffer Levels property for the Vulkan commands comes from the
`cmdbufferlevel` attribute in `vk.xml` for the command, and it is currently
not possible to modify this attribute based on whether an extension is
enabled.
For this extension we want the `cmdbufferlevel` attribute for
vkCmdExecuteCommands to be `primary,secondary` when this extension is
enabled and `primary` otherwise.

**RESOLVED**: The `cmdbufferlevel` attribute for [vkCmdExecuteCommands](../chapters/cmdbuffers.html#vkCmdExecuteCommands)
has been changed to `primary,secondary` and a new VUID added to prohibit
recording this command in a secondary command buffer unless this extension
is enabled.

* 
Revision 1, 2023-09-18 (Piers Daniell)

Internal revisions

**Name String**

`VK_EXT_non_seamless_cube_map`

**Extension Type**

Device extension

**Registered Extension Number**

423

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Special Uses**

* 
[D3D support](../chapters/extensions.html#extendingvulkan-compatibility-specialuse)

* 
[OpenGL / ES support](../chapters/extensions.html#extendingvulkan-compatibility-specialuse)

**Contact**

* 
Georg Lehmann [DadSchoorse](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_non_seamless_cube_map] @DadSchoorse%0A*Here describe the issue or question you have about the VK_EXT_non_seamless_cube_map extension*)

**Extension Proposal**

[VK_EXT_non_seamless_cube_map](../../../features/latest/features/proposals/VK_EXT_non_seamless_cube_map.html)

**Last Modified Date**

2021-09-04

**IP Status**

No known IP claims.

**Contributors**

* 
Georg Lehmann

This extension provides functionality to disable [cube map edge handling](../chapters/textures.html#textures-cubemapedge) on a per sampler level which matches the behavior
of other graphics APIs.

This extension may be useful for building translation layers for those APIs
or for porting applications that rely on this cube map behavior.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT](../chapters/features.html#VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT)

* 
`VK_EXT_NON_SEAMLESS_CUBE_MAP_EXTENSION_NAME`

* 
`VK_EXT_NON_SEAMLESS_CUBE_MAP_SPEC_VERSION`

* 
Extending [VkSamplerCreateFlagBits](../chapters/samplers.html#VkSamplerCreateFlagBits):

`VK_SAMPLER_CREATE_NON_SEAMLESS_CUBE_MAP_BIT_EXT`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT`

* 
Revision 1, 2021-09-04 (Georg Lehmann)

First Version

**Name String**

`VK_EXT_opacity_micromap`

**Extension Type**

Device extension

**Registered Extension Number**

397

**Revision**

2

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_acceleration_structure](#VK_KHR_acceleration_structure)

and

 [VK_KHR_synchronization2](#VK_KHR_synchronization2)

 or

 [Vulkan Version 1.3](versions.html#versions-1.3)

**SPIR-V Dependencies**

* 
[SPV_EXT_opacity_micromap](https://github.khronos.org/SPIRV-Registry/extensions/EXT/SPV_EXT_opacity_micromap.html)

**Contact**

* 
Christoph Kubisch [pixeljetstream](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_opacity_micromap] @pixeljetstream%0A*Here describe the issue or question you have about the VK_EXT_opacity_micromap extension*)

* 
Eric Werness

**Extension Proposal**

[VK_EXT_opacity_micromap](../../../features/latest/features/proposals/VK_EXT_opacity_micromap.html)

**Last Modified Date**

2022-08-24

**Interactions and External Dependencies**

* 
This extension provides API support for
[`GLSL_EXT_opacity_micromap`](https://github.com/KhronosGroup/GLSL/blob/main/extensions/ext/GLSL_EXT_opacity_micromap.txt)

**Contributors**

* 
Christoph Kubisch, NVIDIA

* 
Eric Werness, NVIDIA

* 
Josh Barczak, Intel

* 
Stu Smith, AMD

When adding transparency to a ray traced scene, an application can choose
between further tessellating the geometry or using an any-hit shader to
allow the ray through specific parts of the geometry.
These options have the downside of either significantly increasing memory
consumption or adding runtime overhead to run shader code in the middle of
traversal, respectively.

This extension adds the ability to add an *opacity micromap* to geometry
when building an acceleration structure.
The opacity micromap compactly encodes opacity information which can be read
by the implementation to mark parts of triangles as opaque or transparent.
The format is externally visible to allow the application to compress its
internal geometry and surface representations into the compressed format
ahead of time.
The compressed format subdivides each triangle into a set of subtriangles,
each of which can be assigned either two or four opacity values.
These opacity values can control if a ray hitting that subtriangle is
treated as an opaque hit, complete miss, or possible hit, depending on the
controls described in [Ray Opacity Micromap](../chapters/raytraversal.html#ray-opacity-micromap).

This extension provides:

* 
a [VkMicromapEXT](../chapters/resources.html#VkMicromapEXT) structure to store the micromap,

* 
functions similar to acceleration structure build functions to build the
opacity micromap array, and

* 
a structure to extend
[VkAccelerationStructureGeometryTrianglesDataKHR](../chapters/accelstructures.html#VkAccelerationStructureGeometryTrianglesDataKHR) to attach a
micromap to the geometry of the acceleration structure.

* 
[VkMicromapEXT](../chapters/resources.html#VkMicromapEXT)

* 
[vkBuildMicromapsEXT](../chapters/VK_EXT_opacity_micromap/micromaps.html#vkBuildMicromapsEXT)

* 
[vkCmdBuildMicromapsEXT](../chapters/VK_EXT_opacity_micromap/micromaps.html#vkCmdBuildMicromapsEXT)

* 
[vkCmdCopyMemoryToMicromapEXT](../chapters/VK_EXT_opacity_micromap/micromaps.html#vkCmdCopyMemoryToMicromapEXT)

* 
[vkCmdCopyMicromapEXT](../chapters/VK_EXT_opacity_micromap/micromaps.html#vkCmdCopyMicromapEXT)

* 
[vkCmdCopyMicromapToMemoryEXT](../chapters/VK_EXT_opacity_micromap/micromaps.html#vkCmdCopyMicromapToMemoryEXT)

* 
[vkCmdWriteMicromapsPropertiesEXT](../chapters/VK_EXT_opacity_micromap/micromaps.html#vkCmdWriteMicromapsPropertiesEXT)

* 
[vkCopyMemoryToMicromapEXT](../chapters/VK_EXT_opacity_micromap/micromaps.html#vkCopyMemoryToMicromapEXT)

* 
[vkCopyMicromapEXT](../chapters/VK_EXT_opacity_micromap/micromaps.html#vkCopyMicromapEXT)

* 
[vkCopyMicromapToMemoryEXT](../chapters/VK_EXT_opacity_micromap/micromaps.html#vkCopyMicromapToMemoryEXT)

* 
[vkCreateMicromapEXT](../chapters/resources.html#vkCreateMicromapEXT)

* 
[vkDestroyMicromapEXT](../chapters/resources.html#vkDestroyMicromapEXT)

* 
[vkGetDeviceMicromapCompatibilityEXT](../chapters/VK_EXT_opacity_micromap/micromaps.html#vkGetDeviceMicromapCompatibilityEXT)

* 
[vkGetMicromapBuildSizesEXT](../chapters/resources.html#vkGetMicromapBuildSizesEXT)

* 
[vkWriteMicromapsPropertiesEXT](../chapters/VK_EXT_opacity_micromap/micromaps.html#vkWriteMicromapsPropertiesEXT)

* 
[VkCopyMemoryToMicromapInfoEXT](../chapters/VK_EXT_opacity_micromap/micromaps.html#VkCopyMemoryToMicromapInfoEXT)

* 
[VkCopyMicromapInfoEXT](../chapters/VK_EXT_opacity_micromap/micromaps.html#VkCopyMicromapInfoEXT)

* 
[VkCopyMicromapToMemoryInfoEXT](../chapters/VK_EXT_opacity_micromap/micromaps.html#VkCopyMicromapToMemoryInfoEXT)

* 
[VkMicromapBuildInfoEXT](../chapters/VK_EXT_opacity_micromap/micromaps.html#VkMicromapBuildInfoEXT)

* 
[VkMicromapBuildSizesInfoEXT](../chapters/resources.html#VkMicromapBuildSizesInfoEXT)

* 
[VkMicromapCreateInfoEXT](../chapters/resources.html#VkMicromapCreateInfoEXT)

* 
[VkMicromapTriangleEXT](../chapters/VK_EXT_opacity_micromap/micromaps.html#VkMicromapTriangleEXT)

* 
[VkMicromapUsageEXT](../chapters/VK_EXT_opacity_micromap/micromaps.html#VkMicromapUsageEXT)

* 
[VkMicromapVersionInfoEXT](../chapters/VK_EXT_opacity_micromap/micromaps.html#VkMicromapVersionInfoEXT)

* 
Extending [VkAccelerationStructureGeometryTrianglesDataKHR](../chapters/accelstructures.html#VkAccelerationStructureGeometryTrianglesDataKHR):

[VkAccelerationStructureTrianglesOpacityMicromapEXT](../chapters/accelstructures.html#VkAccelerationStructureTrianglesOpacityMicromapEXT)

Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

* 
[VkPhysicalDeviceOpacityMicromapFeaturesEXT](../chapters/features.html#VkPhysicalDeviceOpacityMicromapFeaturesEXT)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceOpacityMicromapPropertiesEXT](../chapters/limits.html#VkPhysicalDeviceOpacityMicromapPropertiesEXT)

* 
[VkBuildMicromapFlagBitsEXT](../chapters/resources.html#VkBuildMicromapFlagBitsEXT)

* 
[VkBuildMicromapModeEXT](../chapters/VK_EXT_opacity_micromap/micromaps.html#VkBuildMicromapModeEXT)

* 
[VkCopyMicromapModeEXT](../chapters/VK_EXT_opacity_micromap/micromaps.html#VkCopyMicromapModeEXT)

* 
[VkMicromapCreateFlagBitsEXT](../chapters/resources.html#VkMicromapCreateFlagBitsEXT)

* 
[VkMicromapTypeEXT](../chapters/resources.html#VkMicromapTypeEXT)

* 
[VkOpacityMicromapFormatEXT](../chapters/VK_EXT_opacity_micromap/micromaps.html#VkOpacityMicromapFormatEXT)

* 
[VkOpacityMicromapSpecialIndexEXT](../chapters/accelstructures.html#VkOpacityMicromapSpecialIndexEXT)

* 
[VkBuildMicromapFlagsEXT](../chapters/resources.html#VkBuildMicromapFlagsEXT)

* 
[VkMicromapCreateFlagsEXT](../chapters/resources.html#VkMicromapCreateFlagsEXT)

* 
`VK_EXT_OPACITY_MICROMAP_EXTENSION_NAME`

* 
`VK_EXT_OPACITY_MICROMAP_SPEC_VERSION`

* 
Extending [VkAccessFlagBits2](../chapters/synchronization.html#VkAccessFlagBits2):

`VK_ACCESS_2_MICROMAP_READ_BIT_EXT`

* 
`VK_ACCESS_2_MICROMAP_WRITE_BIT_EXT`

Extending [VkBufferUsageFlagBits](../chapters/resources.html#VkBufferUsageFlagBits):

* 
`VK_BUFFER_USAGE_MICROMAP_BUILD_INPUT_READ_ONLY_BIT_EXT`

* 
`VK_BUFFER_USAGE_MICROMAP_STORAGE_BIT_EXT`

Extending [VkBuildAccelerationStructureFlagBitsKHR](../chapters/resources.html#VkBuildAccelerationStructureFlagBitsKHR):

* 
`VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISABLE_OPACITY_MICROMAPS_EXT`

* 
`VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_DATA_UPDATE_EXT`

* 
`VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_UPDATE_EXT`

Extending [VkGeometryInstanceFlagBitsKHR](../chapters/accelstructures.html#VkGeometryInstanceFlagBitsKHR):

* 
`VK_GEOMETRY_INSTANCE_DISABLE_OPACITY_MICROMAPS_EXT`

* 
`VK_GEOMETRY_INSTANCE_FORCE_OPACITY_MICROMAP_2_STATE_EXT`

Extending [VkObjectType](../chapters/debugging.html#VkObjectType):

* 
`VK_OBJECT_TYPE_MICROMAP_EXT`

Extending [VkPipelineCreateFlagBits](../chapters/pipelines.html#VkPipelineCreateFlagBits):

* 
`VK_PIPELINE_CREATE_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT`

Extending [VkPipelineStageFlagBits2](../chapters/synchronization.html#VkPipelineStageFlagBits2):

* 
`VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT`

Extending [VkQueryType](../chapters/queries.html#VkQueryType):

* 
`VK_QUERY_TYPE_MICROMAP_COMPACTED_SIZE_EXT`

* 
`VK_QUERY_TYPE_MICROMAP_SERIALIZATION_SIZE_EXT`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT`

* 
`VK_STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_MICROMAP_CREATE_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_MICROMAP_VERSION_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT`

uint32_t BarycentricsToSpaceFillingCurveIndex(float u, float v, uint32_t level)
{
    u = clamp(u, 0.0f, 1.0f);
    v = clamp(v, 0.0f, 1.0f);

    uint32_t iu, iv, iw;

    // Quantize barycentric coordinates
    float fu = u * (1u = (1u = (1u = (1u = 1.0f && iuv > 1u;
    f ^= f >> 2u;
    f ^= f >> 4u;
    f ^= f >> 8u;
    uint32_t b1 = ((f ^ iu) & ~b0) | t;

    // Interleave bits
    b0 = (b0 | (b0 

(1) Is the build actually similar to an acceleration structure build?

* 
Resolved: The build should be much lighter-weight than an acceleration
structure build, but the infrastructure is similar enough that it makes
sense to keep the concepts compatible.

(2) Why does VkMicromapUsageEXT not have type/pNext?

* 
Resolved: There can be a very large number of these structures, so
doubling the size of these can be significant memory consumption.
Also, an application may be loading these directly from a file which is
more compatible with it being a flat structure.
The including structures are extensible and are probably a more suitable
place to add extensibility.

(3) Why is there a SPIR-V extension?

* 
Resolved: There is a ray flag.
To be consistent with how the existing ray tracing extensions work that
ray flag needs its own extension.

(4) Should there be indirect micromap build?

* 
Resolved: Not for now.
There is more in-depth usage metadata required and it seems less likely
that something like a GPU culling system would need to change the counts
for a micromap.

(5) Should micromaps have a micromap device address?

* 
Resolved: There is no need right now (can just use the handle) but that
is a bit different from acceleration structures, though the two are not
completely parallel in their usage.

(6) Why are the alignment requirements defined as a mix of hardcoded values
and caps?

* 
Resolved: This is most parallel with the definition of
`[VK_KHR_acceleration_structure](#VK_KHR_acceleration_structure)` and maintaining commonality makes
it easier for applications to share memory.

* 
Revision 2, 2022-06-22 (Eric Werness)

EXTify and clean up for discussion

Revision 1, 2022-01-01 (Eric Werness)

* 
Initial revision

**Name String**

`VK_EXT_pageable_device_local_memory`

**Extension Type**

Device extension

**Registered Extension Number**

413

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_EXT_memory_priority](#VK_EXT_memory_priority)

**Contact**

* 
Piers Daniell [pdaniell-nv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_pageable_device_local_memory] @pdaniell-nv%0A*Here describe the issue or question you have about the VK_EXT_pageable_device_local_memory extension*)

**Last Modified Date**

2021-08-24

**Contributors**

* 
Hans-Kristian Arntzen, Valve

* 
Axel Gneiting, id Software

* 
Billy Khan, id Software

* 
Daniel Koch, NVIDIA

* 
Chris Lentini, NVIDIA

* 
Joshua Schnarr, NVIDIA

* 
Stu Smith, AMD

Vulkan is frequently implemented on multi-user and multi-process operating
systems where the device-local memory can be shared by more than one
process.
On such systems the size of the device-local memory available to the
application may not be the full size of the memory heap at all times.
In order for these operating systems to support multiple applications the
device-local memory is virtualized and paging is used to move memory between
device-local and host-local memory heaps, transparent to the application.

The current Vulkan specification does not expose this behavior well and may
cause applications to make suboptimal memory choices when allocating memory.
For example, in a system with multiple applications running, the application
may think that device-local memory is full and revert to making
performance-sensitive allocations from host-local memory.
In reality the memory heap might not have been full, it just appeared to be
at the time memory consumption was queried, and a device-local allocation
would have succeeded.
A well designed operating system that implements pageable device-local
memory will try to have all memory allocations for the foreground
application paged into device-local memory, and paged out for other
applications as needed when not in use.

When this extension is exposed by the Vulkan implementation it indicates to
the application that the operating system implements pageable device-local
memory and the application should adjust its memory allocation strategy
accordingly.
The extension also exposes a new [vkSetDeviceMemoryPriorityEXT](../chapters/memory.html#vkSetDeviceMemoryPriorityEXT) function
to allow the application to dynamically adjust the priority of existing
memory allocations based on its current needs.
This will help the operating system page out lower priority memory
allocations before higher priority allocations when needed.
It will also help the operating system decide which memory allocations to
page back into device-local memory first.

To take best advantage of pageable device-local memory the application must
create the Vulkan device with the
[VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT](../chapters/features.html#VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT)::`pageableDeviceLocalMemory`
feature enabled.
When enabled the Vulkan implementation will allow device-local memory
allocations to be paged in and out by the operating system, and **may** not
return VK_ERROR_OUT_OF_DEVICE_MEMORY even if device-local memory appears to
be full, but will instead page this, or other allocations, out to make room.
The Vulkan implementation will also ensure that host-local memory
allocations will never be promoted to device-local memory by the operating
system, or consume device-local memory.

* 
[vkSetDeviceMemoryPriorityEXT](../chapters/memory.html#vkSetDeviceMemoryPriorityEXT)

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT](../chapters/features.html#VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT)

* 
`VK_EXT_PAGEABLE_DEVICE_LOCAL_MEMORY_EXTENSION_NAME`

* 
`VK_EXT_PAGEABLE_DEVICE_LOCAL_MEMORY_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT`

* 
Revision 1, 2021-08-24 (Piers Daniell)

Initial revision

**Name String**

`VK_EXT_pci_bus_info`

**Extension Type**

Device extension

**Registered Extension Number**

213

**Revision**

2

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Contact**

* 
Matthaeus G. Chajdas [anteru](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_pci_bus_info] @anteru%0A*Here describe the issue or question you have about the VK_EXT_pci_bus_info extension*)

**Last Modified Date**

2018-12-10

**IP Status**

No known IP claims.

**Contributors**

* 
Matthaeus G. Chajdas, AMD

* 
Daniel Rakos, AMD

This extension adds a new query to obtain PCI bus information about a
physical device.

Not all physical devices have PCI bus information, either due to the device
not being connected to the system through a PCI interface or due to platform
specific restrictions and policies.
Thus this extension is only expected to be supported by physical devices
which can provide the information.

As a consequence, applications should always check for the presence of the
extension string for each individual physical device for which they intend
to issue the new query for and should not have any assumptions about the
availability of the extension on any given platform.

* 
Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

[VkPhysicalDevicePCIBusInfoPropertiesEXT](../chapters/devsandqueues.html#VkPhysicalDevicePCIBusInfoPropertiesEXT)

* 
`VK_EXT_PCI_BUS_INFO_EXTENSION_NAME`

* 
`VK_EXT_PCI_BUS_INFO_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT`

* 
Revision 2, 2018-12-10 (Daniel Rakos)

Changed all members of the new structure to have the uint32_t type

Revision 1, 2018-10-11 (Daniel Rakos)

* 
Initial revision

**Name String**

`VK_EXT_physical_device_drm`

**Extension Type**

Device extension

**Registered Extension Number**

354

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Contact**

* 
Simon Ser [emersion](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_physical_device_drm] @emersion%0A*Here describe the issue or question you have about the VK_EXT_physical_device_drm extension*)

**Last Modified Date**

2021-06-09

**IP Status**

No known IP claims.

**Contributors**

* 
Simon Ser

This extension provides new facilities to query DRM properties for physical
devices, enabling users to match Vulkan physical devices with DRM nodes on
Linux.

Its functionality closely overlaps with
`EGL_EXT_device_drm`[1](#VK_EXT_physical_device_drm-fn1).
Unlike the EGL extension, this extension does not expose a string containing
the name of the device file and instead exposes device minor numbers.

DRM defines multiple device node types.
Each physical device may have one primary node and one render node
associated.
Physical devices may have no primary node (e.g. if the device does not have
a display subsystem), may have no render node (e.g. if it is a software
rendering engine), or may have neither (e.g. if it is a software rendering
engine without a display subsystem).

To query DRM properties for a physical device, chain
[VkPhysicalDeviceDrmPropertiesEXT](../chapters/devsandqueues.html#VkPhysicalDeviceDrmPropertiesEXT) to [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2).

* 
Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

[VkPhysicalDeviceDrmPropertiesEXT](../chapters/devsandqueues.html#VkPhysicalDeviceDrmPropertiesEXT)

* 
`VK_EXT_PHYSICAL_DEVICE_DRM_EXTENSION_NAME`

* 
`VK_EXT_PHYSICAL_DEVICE_DRM_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT`

[`EGL_EXT_device_drm`](https://registry.khronos.org/EGL/extensions/EXT/EGL_EXT_device_drm.txt)

* 
Revision 1, 2021-06-09

First stable revision

**Name String**

`VK_EXT_pipeline_library_group_handles`

**Extension Type**

Device extension

**Registered Extension Number**

499

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_ray_tracing_pipeline](#VK_KHR_ray_tracing_pipeline)

and

[VK_KHR_pipeline_library](#VK_KHR_pipeline_library)

**Contact**

* 
Hans-Kristian Arntzen [HansKristian-Work](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_pipeline_library_group_handles] @HansKristian-Work%0A*Here describe the issue or question you have about the VK_EXT_pipeline_library_group_handles extension*)

**Extension Proposal**

[VK_EXT_pipeline_library_group_handles](../../../features/latest/features/proposals/VK_EXT_pipeline_library_group_handles.html)

**Last Modified Date**

2023-01-25

**IP Status**

No known IP claims.

**Contributors**

* 
Hans-Kristian Arntzen, Valve

* 
Stuart Smith, AMD

* 
Ricardo Garcia, Igalia

* 
Lionel Landwerlin, Intel

* 
Eric Werness, NVIDIA

* 
Daniel Koch, NVIDIA

When using pipeline libraries in ray tracing pipelines, a library might get
linked into different pipelines in an incremental way.
An application can have a strategy where a ray tracing pipeline is comprised
of N pipeline libraries and is later augmented by creating a new pipeline
with N + 1 libraries.
Without this extension, all group handles must be re-queried as the group
handle is tied to the pipeline, not the library.
This is problematic for applications which aim to decouple construction of
record buffers and the linkage of ray tracing pipelines.

To aid in this, this extension enables support for querying group handles
directly from pipeline libraries.
Group handles obtained from a library **must** remain bitwise identical in any
`VkPipeline` that links to the library.

With this feature, the extension also improves compatibility with DXR 1.1
AddToStateObject(), which guarantees that group handles returned remain
bitwise identical between parent and child pipelines.
In addition, querying group handles from COLLECTION objects is also
supported with that API.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT](../chapters/features.html#VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT)

* 
`VK_EXT_PIPELINE_LIBRARY_GROUP_HANDLES_EXTENSION_NAME`

* 
`VK_EXT_PIPELINE_LIBRARY_GROUP_HANDLES_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT`

* 
Revision 1, 2023-01-25 (Hans-Kristian Arntzen)

Initial draft

**Name String**

`VK_EXT_pipeline_properties`

**Extension Type**

Device extension

**Registered Extension Number**

373

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Contact**

* 
Mukund Keshava [mkeshavanv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_pipeline_properties] @mkeshavanv%0A*Here describe the issue or question you have about the VK_EXT_pipeline_properties extension*)

**Last Modified Date**

2022-04-19

**IP Status**

No known IP claims.

**Contributors**

* 
Mukund Keshava, NVIDIA

* 
Daniel Koch, NVIDIA

* 
Mark Bellamy, Arm

Vulkan SC requires offline compilation of pipelines.
In order to support this, the pipeline state is represented in a
[JSON schema](https://github.com/KhronosGroup/VulkanSC-Docs/wiki/JSON-schema)
that is read by an offline tool for compilation.

One method of developing a Vulkan SC application is to author a Vulkan
application and use a layer to record and serialize the pipeline state and
shaders for offline compilation.
Each pipeline is represented by a separate JSON file, and can be identified
with a `pipelineIdentifier`.

Once the pipelines have been compiled by the offline pipeline cache
compiler, the Vulkan SC application can then use this
`pipelineIdentifier` for identifying the pipeline via Vulkan SCs
`VkPipelineIdentifierInfo` structure.

This extension allows the Vulkan application to query the
`pipelineIdentifier` associated with each pipeline so that the
application can store this with its pipeline metadata and the Vulkan SC
application will then use to map the same state to an entry in the Vulkan SC
pipeline cache.

It is expected that this extension will initially be implemented in the json
generation layer, although we can envision that there might be future uses
for it in native Vulkan drivers as well.

* 
[vkGetPipelinePropertiesEXT](../chapters/pipelines.html#vkGetPipelinePropertiesEXT)

* 
[VkPipelineInfoEXT](../chapters/pipelines.html#VkPipelineInfoEXT)

* 
[VkPipelinePropertiesIdentifierEXT](../chapters/pipelines.html#VkPipelinePropertiesIdentifierEXT)

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDevicePipelinePropertiesFeaturesEXT](../chapters/features.html#VkPhysicalDevicePipelinePropertiesFeaturesEXT)

* 
`VK_EXT_PIPELINE_PROPERTIES_EXTENSION_NAME`

* 
`VK_EXT_PIPELINE_PROPERTIES_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT`

* 
`VK_STRUCTURE_TYPE_PIPELINE_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_PIPELINE_PROPERTIES_IDENTIFIER_EXT`

(1) This extension does not make sense on a strict Vulkan SC implementation.
It may however be of potential use in a non-strict Vulkan SC implementation.
Should this extension be enabled as part of Vulkan SC as well?

**RESOLVED**: No.
This extension will not be enabled for Vulkan SC.

(2) This is intended to be a general pipeline properties query, but is
currently only retrieving the pipeline identifier.
Should the pipeline identifier query be mandatory for this extension and for
all queries using this command?

**RESOLVED**: Use [VkBaseOutStructure](../chapters/fundamentals.html#VkBaseOutStructure) for the return parameter.
Currently this is required to actually be a
[VkPipelinePropertiesIdentifierEXT](../chapters/pipelines.html#VkPipelinePropertiesIdentifierEXT) structure, but that could be relaxed
in the future to allow other structure types or to allow other structures to
be chained in along with this one.

(3) Should there be a feature structure? Should it be required?

**RESOLVED**: Add a feature structure, and a feature for querying pipeline
identifier, but allow it to be optional so that this extension can be used
as the basis for other pipeline property queries without requiring the
pipeline identifier to be supported.

* 
Revision 1, 2022-04-19 (Mukund Keshava, Daniel Koch)

Initial draft

**Name String**

`VK_EXT_post_depth_coverage`

**Extension Type**

Device extension

**Registered Extension Number**

156

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

None

**SPIR-V Dependencies**

* 
[SPV_KHR_post_depth_coverage](https://github.khronos.org/SPIRV-Registry/extensions/KHR/SPV_KHR_post_depth_coverage.html)

**Contact**

* 
Daniel Koch [dgkoch](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_post_depth_coverage] @dgkoch%0A*Here describe the issue or question you have about the VK_EXT_post_depth_coverage extension*)

**Last Modified Date**

2017-07-17

**Interactions and External Dependencies**

* 
This extension provides API support for
[`GL_ARB_post_depth_coverage`](https://registry.khronos.org/OpenGL/extensions/ARB/ARB_post_depth_coverage.txt)
and
[`GL_EXT_post_depth_coverage`](https://registry.khronos.org/OpenGL/extensions/EXT/EXT_post_depth_coverage.txt)

**Contributors**

* 
Jeff Bolz, NVIDIA

This extension adds support for the following SPIR-V extension in Vulkan:

* 
`SPV_KHR_post_depth_coverage`

which allows the fragment shader to control whether values in the
`SampleMask` built-in input variable reflect the coverage after early
[depth](../chapters/fragops.html#fragops-depth) and [stencil](../chapters/fragops.html#fragops-stencil) tests are applied.

This extension adds a new `PostDepthCoverage` execution mode under the
`SampleMaskPostDepthCoverage` capability.
When this mode is specified along with `EarlyFragmentTests`, the value of
an input variable decorated with the
[`SampleMask`](../chapters/interfaces.html#interfaces-builtin-variables-samplemask) built-in
reflects the coverage after the early fragment tests are applied.
Otherwise, it reflects the coverage before the depth and stencil tests.

When using GLSL source-based shading languages, the `post_depth_coverage`
layout qualifier from GL_ARB_post_depth_coverage or
GL_EXT_post_depth_coverage maps to the `PostDepthCoverage` execution
mode.

* 
`VK_EXT_POST_DEPTH_COVERAGE_EXTENSION_NAME`

* 
`VK_EXT_POST_DEPTH_COVERAGE_SPEC_VERSION`

* 
[    `SampleMaskPostDepthCoverage`](spirvenv.html#spirvenv-capabilities-table-SampleMaskPostDepthCoverage)

* 
Revision 1, 2017-07-17 (Daniel Koch)

Internal revisions

**Name String**

`VK_EXT_present_mode_fifo_latest_ready`

**Extension Type**

Device extension

**Registered Extension Number**

362

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_swapchain](#VK_KHR_swapchain)

**Contact**

* 
Lionel Duc [nvlduc](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_present_mode_fifo_latest_ready] @nvlduc%0A*Here describe the issue or question you have about the VK_EXT_present_mode_fifo_latest_ready extension*)

**Extension Proposal**

[VK_EXT_present_mode_fifo_latest_ready](../../../features/latest/features/proposals/VK_EXT_present_mode_fifo_latest_ready.html)

**Last Modified Date**

2024-05-28

**IP Status**

No known IP claims.

**Contributors**

* 
James Jones, NVIDIA

* 
Lionel Duc, NVIDIA

This device extension adds a new present mode,
`VK_PRESENT_MODE_FIFO_LATEST_READY_EXT`.

This tear-free present mode behaves much like
`VK_PRESENT_MODE_FIFO_KHR`, except that each vertical blanking period
dequeues consecutive present requests until the latest ready is found to
update the current image.

While this seems similar in concept to `VK_PRESENT_MODE_MAILBOX_KHR`,
the fundamental difference is that the processing of the present requests is
done during vblank.
From the application perspective, this means for example, that in a
flip-based model, a single vblank **may** cause multiple swapchain images to be
released at once, while `VK_PRESENT_MODE_MAILBOX_KHR` **may** continuously
be releasing images as new requests become ready.

This additional present mode is useful when using a time-based present API.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDevicePresentModeFifoLatestReadyFeaturesEXT](../chapters/features.html#VkPhysicalDevicePresentModeFifoLatestReadyFeaturesEXT)

* 
`VK_EXT_PRESENT_MODE_FIFO_LATEST_READY_EXTENSION_NAME`

* 
`VK_EXT_PRESENT_MODE_FIFO_LATEST_READY_SPEC_VERSION`

* 
Extending [VkPresentModeKHR](../chapters/VK_KHR_surface/wsi.html#VkPresentModeKHR):

`VK_PRESENT_MODE_FIFO_LATEST_READY_EXT`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_EXT`

* 
Revision 1, 2024-05-28 (Lionel Duc)

Internal revisions

**Name String**

`VK_EXT_primitive_topology_list_restart`

**Extension Type**

Device extension

**Registered Extension Number**

357

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Special Use**

* 
[OpenGL / ES support](../chapters/extensions.html#extendingvulkan-compatibility-specialuse)

**Contact**

* 
Shahbaz Youssefi [syoussefi](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_primitive_topology_list_restart] @syoussefi%0A*Here describe the issue or question you have about the VK_EXT_primitive_topology_list_restart extension*)

**Last Modified Date**

2021-01-11

**IP Status**

No known IP claims.

**Contributors**

* 
Courtney Goeltzenleuchter, Google

* 
Shahbaz Youssefi, Google

This extension allows list primitives to use the primitive restart index
value.
This provides a more efficient implementation when layering OpenGL
functionality on Vulkan by avoiding emulation which incurs data copies.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT](../chapters/features.html#VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT)

* 
`VK_EXT_PRIMITIVE_TOPOLOGY_LIST_RESTART_EXTENSION_NAME`

* 
`VK_EXT_PRIMITIVE_TOPOLOGY_LIST_RESTART_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT`

* 
Revision 0, 2020-09-14 (Courtney Goeltzenleuchter)

Internal revisions

Revision 1, 2021-01-11 (Shahbaz Youssefi)

* 
Add the `primitiveTopologyPatchListRestart` feature

* 
Internal revisions

**Name String**

`VK_EXT_primitives_generated_query`

**Extension Type**

Device extension

**Registered Extension Number**

383

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_EXT_transform_feedback](#VK_EXT_transform_feedback)

**Special Use**

* 
[OpenGL / ES support](../chapters/extensions.html#extendingvulkan-compatibility-specialuse)

**Contact**

* 
Shahbaz Youssefi [syoussefi](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_primitives_generated_query] @syoussefi%0A*Here describe the issue or question you have about the VK_EXT_primitives_generated_query extension*)

**Extension Proposal**

[VK_EXT_primitives_generated_query](../../../features/latest/features/proposals/VK_EXT_primitives_generated_query.html)

**Last Modified Date**

2022-01-24

**Contributors**

* 
Shahbaz Youssefi, Google

* 
Piers Daniell, NVIDIA

* 
Faith Ekstrand, Collabora

* 
Jan-Harald Fredriksen, Arm

This extension adds support for a new query type to match OpenGLs
`GL_PRIMITIVES_GENERATED` to support layering.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT](../chapters/features.html#VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT)

* 
`VK_EXT_PRIMITIVES_GENERATED_QUERY_EXTENSION_NAME`

* 
`VK_EXT_PRIMITIVES_GENERATED_QUERY_SPEC_VERSION`

* 
Extending [VkQueryType](../chapters/queries.html#VkQueryType):

`VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT`

1) Can the query from `VK_EXT_transform_feedback` be used instead?

**RESOLVED**: No.
While the query from VK_EXT_transform_feedback can produce the same results
as in this extension, it is only available while transform feedback is
active.
The OpenGL `GL_PRIMITIVES_GENERATED` query is independent from transform
feedback.
Emulation through artificial transform feedback is unnecessarily
inefficient.

2) Can `VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT` be used
instead?

**RESOLVED**: It could, but we prefer the extension for simplicity.
Vulkan requires that only one query be active at a time.
If both the `GL_PRIMITIVES_GENERATED` and the
`GL_CLIPPING_INPUT_PRIMITIVES_ARB` queries need to be simultaneously
enabled, emulation of both through
`VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT` is inconvenient.

3) On some hardware, this query cannot be implemented if
`VkPipelineRasterizationStateCreateInfo`::`rasterizerDiscardEnable`
is enabled.
How will this be handled?

**RESOLVED**: A feature flag is exposed by this extension for this.
On said hardware, the GL implementation disables rasterizer-discard and
achieves the same effect through other means.
It will not be able to do the same in Vulkan due to lack of state
information.
A feature flag is exposed by this extension so the OpenGL implementation on
top of Vulkan would be able to implement a similar workaround.

4) On some hardware, this query cannot be implemented for non-zero query
indices.
How will this be handled?

**RESOLVED**: A feature flag is exposed by this extension for this.
If this feature is not present, the query from `VK_EXT_transform_feedback`
can be used to the same effect.

5) How is the interaction of this extension with
`transformFeedbackRasterizationStreamSelect` handled?

**RESOLVED**: Disallowed for non-zero streams.
In OpenGL, the rasterization stream is always stream zero.

* 
Revision 1, 2021-06-23 (Shahbaz Youssefi)

Internal revisions

**Name String**

`VK_EXT_provoking_vertex`

**Extension Type**

Device extension

**Registered Extension Number**

255

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Special Use**

* 
[OpenGL / ES support](../chapters/extensions.html#extendingvulkan-compatibility-specialuse)

**Contact**

* 
Jesse Hall [jessehall](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_provoking_vertex] @jessehall%0A*Here describe the issue or question you have about the VK_EXT_provoking_vertex extension*)

**Last Modified Date**

2021-02-22

**IP Status**

No known IP claims.

**Contributors**

* 
Alexis Htu, Google

* 
Bill Licea-Kane, Qualcomm

* 
Daniel Koch, Nvidia

* 
Jamie Madill, Google

* 
Jan-Harald Fredriksen, Arm

* 
Faith Ekstrand, Intel

* 
Jeff Bolz, Nvidia

* 
Jeff Leger, Qualcomm

* 
Jesse Hall, Google

* 
Jrg Wagner, Arm

* 
Matthew Netsch, Qualcomm

* 
Mike Blumenkrantz, Valve

* 
Piers Daniell, Nvidia

* 
Tobias Hector, AMD

This extension allows changing the provoking vertex convention between
Vulkans default convention (first vertex) and OpenGLs convention (last
vertex).

This extension is intended for use by API-translation layers that implement
APIs like OpenGL on top of Vulkan, and need to match the source APIs
provoking vertex convention.
Applications using Vulkan directly should use Vulkans default convention.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceProvokingVertexFeaturesEXT](../chapters/features.html#VkPhysicalDeviceProvokingVertexFeaturesEXT)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceProvokingVertexPropertiesEXT](../chapters/limits.html#VkPhysicalDeviceProvokingVertexPropertiesEXT)

Extending [VkPipelineRasterizationStateCreateInfo](../chapters/primsrast.html#VkPipelineRasterizationStateCreateInfo):

* 
[VkPipelineRasterizationProvokingVertexStateCreateInfoEXT](../chapters/vertexpostproc.html#VkPipelineRasterizationProvokingVertexStateCreateInfoEXT)

* 
[VkProvokingVertexModeEXT](../chapters/vertexpostproc.html#VkProvokingVertexModeEXT)

* 
`VK_EXT_PROVOKING_VERTEX_EXTENSION_NAME`

* 
`VK_EXT_PROVOKING_VERTEX_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT`

* 
`VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT`

1) At what granularity should this state be set?

**RESOLVED**: At pipeline bind, with an optional per-render pass restriction.

The most natural place to put this state is in the graphics pipeline object.
Some implementations require it to be known when creating the pipeline, and
pipeline state is convenient for implementing OpenGL 3.2s
glProvokingVertex, which can change the state between draw calls.
However, some implementations can only change it approximately render pass
granularity.
To accommodate both, provoking vertex will be pipeline state, but
implementations can require that only one mode is used within a render pass
instance; the render passs mode is chosen implicitly when the first
pipeline is bound.

2) Does the provoking vertex mode affect the order that vertices are written
to transform feedback buffers?

**RESOLVED**: Yes, to enable layered implementations of OpenGL and D3D.

All of OpenGL, OpenGL ES, and Direct3D 11 require that vertices are written
to transform feedback buffers such that flat-shaded attributes have the same
value when drawing the contents of the transform feedback buffer as they did
in the original drawing when the transform feedback buffer was written
(assuming the provoking vertex mode has not changed, in APIs that support
more than one mode).

* 
Revision 1, (1c) 2021-02-22 (Jesse Hall)

Added
VkPhysicalDeviceProvokingVertexPropertiesEXT::transformFeedbackPreservesTriangleFanProvokingVertex
to accommodate implementations that cannot change the transform
feedback vertex order for triangle fans.

Revision 1, (1b) 2020-06-14 (Jesse Hall)

* 
Added
VkPhysicalDeviceProvokingVertexFeaturesEXT::transformFeedbackPreservesProvokingVertex
and required that transform feedback write vertices so as to preserve
the provoking vertex of each primitive.

Revision 1, (1a) 2019-10-23 (Jesse Hall)

* 
Initial draft, based on a proposal by Alexis Htu

**Name String**

`VK_EXT_queue_family_foreign`

**Extension Type**

Device extension

**Registered Extension Number**

127

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_external_memory](#VK_KHR_external_memory)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Contact**

* 
Lina Versace [linyaa-kiwi](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_queue_family_foreign] @linyaa-kiwi%0A*Here describe the issue or question you have about the VK_EXT_queue_family_foreign extension*)

**Last Modified Date**

2017-11-01

**IP Status**

No known IP claims.

**Contributors**

* 
Lina Versace, Google

* 
James Jones, NVIDIA

* 
Faith Ekstrand, Intel

* 
Jesse Hall, Google

* 
Daniel Rakos, AMD

* 
Ray Smith, ARM

This extension defines a special queue family,
`VK_QUEUE_FAMILY_FOREIGN_EXT`, which can be used to transfer ownership
of resources backed by external memory to foreign, external queues.
This is similar to `VK_QUEUE_FAMILY_EXTERNAL_KHR`, defined in
`[VK_KHR_external_memory](#VK_KHR_external_memory)`.
The key differences between the two are:

* 
The queues represented by `VK_QUEUE_FAMILY_EXTERNAL_KHR` must share
the same physical device and the same driver version as the current
[VkInstance](../chapters/initialization.html#VkInstance).
`VK_QUEUE_FAMILY_FOREIGN_EXT` has no such restrictions.
It can represent devices and drivers from other vendors, and can even
represent non-Vulkan-capable devices.

* 
All resources backed by external memory support
`VK_QUEUE_FAMILY_EXTERNAL_KHR`.
Support for `VK_QUEUE_FAMILY_FOREIGN_EXT` is more restrictive.

* 
Applications should expect transitions to/from
`VK_QUEUE_FAMILY_FOREIGN_EXT` to be more expensive than transitions
to/from `VK_QUEUE_FAMILY_EXTERNAL_KHR`.

* 
`VK_EXT_QUEUE_FAMILY_FOREIGN_EXTENSION_NAME`

* 
`VK_EXT_QUEUE_FAMILY_FOREIGN_SPEC_VERSION`

* 
`VK_QUEUE_FAMILY_FOREIGN_EXT`

* 
Revision 1, 2017-11-01 (Lina Versace)

Squashed internal revisions

**Name String**

`VK_EXT_rasterization_order_attachment_access`

**Extension Type**

Device extension

**Registered Extension Number**

464

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Contact**

* 
Jan-Harald Fredriksen [janharaldfredriksen-arm](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_rasterization_order_attachment_access] @janharaldfredriksen-arm%0A*Here describe the issue or question you have about the VK_EXT_rasterization_order_attachment_access extension*)

**Extension Proposal**

[VK_EXT_rasterization_order_attachment_access](../../../features/latest/features/proposals/VK_EXT_rasterization_order_attachment_access.html)

**Last Modified Date**

2022-07-04

**IP Status**

No known IP claims.

**Contributors**

* 
Tobias Hector, AMD

* 
Jan-Harald Fredriksen, Arm

This extension extends the mechanism of input attachments to allow access to
framebuffer attachments that are used both as input and as color or
depth/stencil attachments from one fragment to the next, in rasterization
order, without explicit synchronization.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT](../chapters/features.html#VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT)

* 
[VkPipelineColorBlendStateCreateFlagBits](../chapters/framebuffer.html#VkPipelineColorBlendStateCreateFlagBits)

* 
[VkPipelineDepthStencilStateCreateFlagBits](../chapters/fragops.html#VkPipelineDepthStencilStateCreateFlagBits)

* 
`VK_EXT_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_EXTENSION_NAME`

* 
`VK_EXT_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_SPEC_VERSION`

* 
Extending [VkPipelineColorBlendStateCreateFlagBits](../chapters/framebuffer.html#VkPipelineColorBlendStateCreateFlagBits):

`VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_EXT`

Extending [VkPipelineDepthStencilStateCreateFlagBits](../chapters/fragops.html#VkPipelineDepthStencilStateCreateFlagBits):

* 
`VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT`

* 
`VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT`

Extending [VkSubpassDescriptionFlagBits](../chapters/renderpass.html#VkSubpassDescriptionFlagBits):

* 
`VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_EXT`

* 
`VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT`

* 
`VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT`

None.

* 
Revision 1, 2022-07-04 (Jan-Harald Fredriksen)

Initial draft

**Name String**

`VK_EXT_rgba10x6_formats`

**Extension Type**

Device extension

**Registered Extension Number**

345

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_sampler_ycbcr_conversion](#VK_KHR_sampler_ycbcr_conversion)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Contact**

* 
Jan-Harald Fredriksen [janharaldfredriksen-arm](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_rgba10x6_formats] @janharaldfredriksen-arm%0A*Here describe the issue or question you have about the VK_EXT_rgba10x6_formats extension*)

**Last Modified Date**

2021-09-29

**IP Status**

No known IP claims.

**Contributors**

* 
Jan-Harald Fredriksen, Arm

* 
Graeme Leese, Broadcom

* 
Spencer Fricke, Samsung

This extension enables the
`VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16` format to be used without
a [sampler YCBCR conversion](../chapters/samplers.html#samplers-YCbCr-conversion) enabled.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT](../chapters/features.html#VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT)

* 
`VK_EXT_RGBA10X6_FORMATS_EXTENSION_NAME`

* 
`VK_EXT_RGBA10X6_FORMATS_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT`

1) Should we reuse the existing format enumeration or introduce a new one?

**RESOLVED**: We reuse an existing format enumeration,
`VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16`, that was previously
exclusively used for YCbCr and therefore had a set of limitations related to
that usage.
The alternative was to introduce a new format token with exactly the same
bit representation as the existing token, but without the limitations.

2) Should we only introduce
`VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16` or also 1-3 component
variations?

**RESOLVED**: Only the 4-component format is introduced because the 1- and 2-
component variations are already not exclusive to YCbCr, and the 3-component
variation is not a good match for hardware capabilities.

* 
Revision 1, 2021-09-29 (Jan-Harald Fredriksen)

Initial EXT version

**Name String**

`VK_EXT_sample_locations`

**Extension Type**

Device extension

**Registered Extension Number**

144

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Contact**

* 
Daniel Rakos [drakos-amd](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_sample_locations] @drakos-amd%0A*Here describe the issue or question you have about the VK_EXT_sample_locations extension*)

**Last Modified Date**

2017-08-02

**Contributors**

* 
Mais Alnasser, AMD

* 
Matthaeus G. Chajdas, AMD

* 
Maciej Jesionowski, AMD

* 
Daniel Rakos, AMD

* 
Slawomir Grajewski, Intel

* 
Jeff Bolz, NVIDIA

* 
Bill Licea-Kane, Qualcomm

This extension allows an application to modify the locations of samples
within a pixel used in rasterization.
Additionally, it allows applications to specify different sample locations
for each pixel in a group of adjacent pixels, which **can** increase
antialiasing quality (particularly if a custom resolve shader is used that
takes advantage of these different locations).

It is common for implementations to optimize the storage of depth values by
storing values that **can** be used to reconstruct depth at each sample
location, rather than storing separate depth values for each sample.
For example, the depth values from a single triangle **may** be represented
using plane equations.
When the depth value for a sample is needed, it is automatically evaluated
at the sample location.
Modifying the sample locations causes the reconstruction to no longer
evaluate the same depth values as when the samples were originally
generated, thus the depth aspect of a depth/stencil attachment **must** be
cleared before rendering to it using different sample locations.

Some implementations **may** need to evaluate depth image values while
performing image layout transitions.
To accommodate this, instances of the [VkSampleLocationsInfoEXT](../chapters/primsrast.html#VkSampleLocationsInfoEXT)
structure **can** be specified for each situation where an explicit or
automatic layout transition has to take place.
[VkSampleLocationsInfoEXT](../chapters/primsrast.html#VkSampleLocationsInfoEXT) **can** be chained from
[VkImageMemoryBarrier](../chapters/synchronization.html#VkImageMemoryBarrier) structures to provide sample locations for layout
transitions performed by [vkCmdWaitEvents](../chapters/synchronization.html#vkCmdWaitEvents) and
[vkCmdPipelineBarrier](../chapters/synchronization.html#vkCmdPipelineBarrier) calls, and
[VkRenderPassSampleLocationsBeginInfoEXT](../chapters/renderpass.html#VkRenderPassSampleLocationsBeginInfoEXT) **can** be chained from
[VkRenderPassBeginInfo](../chapters/renderpass.html#VkRenderPassBeginInfo) to provide sample locations for layout
transitions performed implicitly by a render pass instance.

* 
[vkCmdSetSampleLocationsEXT](../chapters/primsrast.html#vkCmdSetSampleLocationsEXT)

* 
[vkGetPhysicalDeviceMultisamplePropertiesEXT](../chapters/limits.html#vkGetPhysicalDeviceMultisamplePropertiesEXT)

* 
[VkAttachmentSampleLocationsEXT](../chapters/renderpass.html#VkAttachmentSampleLocationsEXT)

* 
[VkMultisamplePropertiesEXT](../chapters/limits.html#VkMultisamplePropertiesEXT)

* 
[VkSampleLocationEXT](../chapters/primsrast.html#VkSampleLocationEXT)

* 
[VkSubpassSampleLocationsEXT](../chapters/renderpass.html#VkSubpassSampleLocationsEXT)

* 
Extending [VkImageMemoryBarrier](../chapters/synchronization.html#VkImageMemoryBarrier), [VkImageMemoryBarrier2](../chapters/synchronization.html#VkImageMemoryBarrier2):

[VkSampleLocationsInfoEXT](../chapters/primsrast.html#VkSampleLocationsInfoEXT)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceSampleLocationsPropertiesEXT](../chapters/limits.html#VkPhysicalDeviceSampleLocationsPropertiesEXT)

Extending [VkPipelineMultisampleStateCreateInfo](../chapters/primsrast.html#VkPipelineMultisampleStateCreateInfo):

* 
[VkPipelineSampleLocationsStateCreateInfoEXT](../chapters/primsrast.html#VkPipelineSampleLocationsStateCreateInfoEXT)

Extending [VkRenderPassBeginInfo](../chapters/renderpass.html#VkRenderPassBeginInfo):

* 
[VkRenderPassSampleLocationsBeginInfoEXT](../chapters/renderpass.html#VkRenderPassSampleLocationsBeginInfoEXT)

* 
`VK_EXT_SAMPLE_LOCATIONS_EXTENSION_NAME`

* 
`VK_EXT_SAMPLE_LOCATIONS_SPEC_VERSION`

* 
Extending [VkDynamicState](../chapters/pipelines.html#VkDynamicState):

`VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT`

Extending [VkImageCreateFlagBits](../chapters/resources.html#VkImageCreateFlagBits):

* 
`VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT`

* 
`VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT`

* 
Revision 1, 2017-08-02 (Daniel Rakos)

Internal revisions

**Name String**

`VK_EXT_shader_atomic_float`

**Extension Type**

Device extension

**Registered Extension Number**

261

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**API Interactions**

* 
Interacts with VkPhysicalDeviceShaderAtomicFloatFeaturesEXT::sparseImageFloat32AtomicAdd

* 
Interacts with VkPhysicalDeviceShaderAtomicFloatFeaturesEXT::sparseImageFloat32Atomics

**SPIR-V Dependencies**

* 
[SPV_EXT_shader_atomic_float_add](https://github.khronos.org/SPIRV-Registry/extensions/EXT/SPV_EXT_shader_atomic_float_add.html)

**Contact**

* 
Vikram Kushwaha [vkushwaha-nv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_shader_atomic_float] @vkushwaha-nv%0A*Here describe the issue or question you have about the VK_EXT_shader_atomic_float extension*)

**Last Modified Date**

2020-07-15

**IP Status**

No known IP claims.

**Interactions and External Dependencies**

* 
This extension provides API support for
[`GL_EXT_shader_atomic_float`](https://github.com/KhronosGroup/GLSL/blob/main/extensions/ext/GLSL_EXT_shader_atomic_float.txt)

**Contributors**

* 
Vikram Kushwaha, NVIDIA

* 
Jeff Bolz, NVIDIA

This extension allows a shader to contain floating-point atomic operations
on buffer, workgroup, and image memory.
It also advertises the SPIR-V `AtomicFloat32AddEXT` and
`AtomicFloat64AddEXT` capabilities that allows atomic addition on
floating-points numbers.
The supported operations include `OpAtomicFAddEXT`,
`OpAtomicExchange`, `OpAtomicLoad` and `OpAtomicStore`.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceShaderAtomicFloatFeaturesEXT](../chapters/features.html#VkPhysicalDeviceShaderAtomicFloatFeaturesEXT)

* 
`VK_EXT_SHADER_ATOMIC_FLOAT_EXTENSION_NAME`

* 
`VK_EXT_SHADER_ATOMIC_FLOAT_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT`

* 
[    `AtomicFloat32AddEXT`](spirvenv.html#spirvenv-capabilities-table-AtomicFloat32AddEXT)

* 
[    `AtomicFloat64AddEXT`](spirvenv.html#spirvenv-capabilities-table-AtomicFloat64AddEXT)

* 
Revision 1, 2020-07-15 (Vikram Kushwaha)

Internal revisions

**Name String**

`VK_EXT_shader_atomic_float2`

**Extension Type**

Device extension

**Registered Extension Number**

274

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_EXT_shader_atomic_float](#VK_EXT_shader_atomic_float)

**API Interactions**

* 
Interacts with VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT::sparseImageFloat32AtomicMinMax

**SPIR-V Dependencies**

* 
[SPV_EXT_shader_atomic_float16_add](https://github.khronos.org/SPIRV-Registry/extensions/EXT/SPV_EXT_shader_atomic_float16_add.html)

* 
[SPV_EXT_shader_atomic_float_min_max](https://github.khronos.org/SPIRV-Registry/extensions/EXT/SPV_EXT_shader_atomic_float_min_max.html)

**Contact**

* 
Faith Ekstrand [gfxstrand](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_shader_atomic_float2] @gfxstrand%0A*Here describe the issue or question you have about the VK_EXT_shader_atomic_float2 extension*)

**Last Modified Date**

2020-08-14

**IP Status**

No known IP claims.

**Interactions and External Dependencies**

* 
This extension provides API support for
[`GLSL_EXT_shader_atomic_float2`](https://github.com/KhronosGroup/GLSL/blob/main/extensions/ext/GLSL_EXT_shader_atomic_float2.txt)

**Contributors**

* 
Faith Ekstrand, Intel

This extension allows a shader to perform 16-bit floating-point atomic
operations on buffer and workgroup memory as well as floating-point atomic
minimum and maximum operations on buffer, workgroup, and image memory.
It advertises the SPIR-V `AtomicFloat16AddEXT` capability which allows
atomic add operations on 16-bit floating-point numbers and the SPIR-V
`AtomicFloat16MinMaxEXT`, `AtomicFloat32MinMaxEXT` and
`AtomicFloat64MinMaxEXT` capabilities which allow atomic minimum and
maximum operations on floating-point numbers.
The supported operations include `OpAtomicFAddEXT`, `OpAtomicFMinEXT`
and `OpAtomicFMaxEXT`.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT](../chapters/features.html#VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT)

* 
`VK_EXT_SHADER_ATOMIC_FLOAT_2_EXTENSION_NAME`

* 
`VK_EXT_SHADER_ATOMIC_FLOAT_2_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT`

1) Should this extension add support for 16-bit image atomics?

**RESOLVED**: No.
While Vulkan supports creating storage images with
`VK_FORMAT_R16_SFLOAT` and doing load and store on them, the data in the
shader has a 32-bit representation.
Vulkan currently has no facility for even basic reading or writing such
images using 16-bit float values in the shader.
Adding such functionality would be required before 16-bit image atomics
would make sense and is outside the scope of this extension.

* 
[    `AtomicFloat32MinMaxEXT`](spirvenv.html#spirvenv-capabilities-table-AtomicFloat16AddEXT)

* 
[    `AtomicFloat32MinMaxEXT`](spirvenv.html#spirvenv-capabilities-table-AtomicFloat16MinMaxEXT)

* 
[    `AtomicFloat32MinMaxEXT`](spirvenv.html#spirvenv-capabilities-table-AtomicFloat32MinMaxEXT)

* 
[    `AtomicFloat64MinMaxEXT`](spirvenv.html#spirvenv-capabilities-table-AtomicFloat64MinMaxEXT)

* 
Revision 1, 2020-08-14 (Faith Ekstrand)

Internal revisions

**Name String**

`VK_EXT_shader_image_atomic_int64`

**Extension Type**

Device extension

**Registered Extension Number**

235

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**SPIR-V Dependencies**

* 
[SPV_EXT_shader_image_int64](https://github.khronos.org/SPIRV-Registry/extensions/EXT/SPV_EXT_shader_image_int64.html)

**Contact**

* 
Tobias Hector [tobski](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_shader_image_atomic_int64] @tobski%0A*Here describe the issue or question you have about the VK_EXT_shader_image_atomic_int64 extension*)

**Last Modified Date**

2020-07-14

**IP Status**

No known IP claims.

**Interactions and External Dependencies**

* 
This extension provides API support for
[`GLSL_EXT_shader_image_int64`](https://github.com/KhronosGroup/GLSL/blob/main/extensions/ext/GLSL_EXT_shader_image_int64.txt)

**Contributors**

* 
Matthaeus Chajdas, AMD

* 
Graham Wihlidal, Epic Games

* 
Tobias Hector, AMD

* 
Jeff Bolz, Nvidia

* 
Faith Ekstrand, Intel

This extension extends existing 64-bit integer atomic support to enable
these operations on images as well.

When working with large 2- or 3-dimensional data sets (e.g. rasterization or
screen-space effects), image accesses are generally more efficient than
equivalent buffer accesses.
This extension allows applications relying on 64-bit integer atomics in this
manner to quickly improve performance with only relatively minor code
changes.

64-bit integer atomic support is guaranteed for optimally tiled images with
the `VK_FORMAT_R64_UINT` and `VK_FORMAT_R64_SINT` formats.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT](../chapters/features.html#VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT)

* 
`VK_EXT_SHADER_IMAGE_ATOMIC_INT64_EXTENSION_NAME`

* 
`VK_EXT_SHADER_IMAGE_ATOMIC_INT64_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT`

* 
Revision 1, 2020-07-14 (Tobias Hector)

Initial draft

**Name String**

`VK_EXT_shader_module_identifier`

**Extension Type**

Device extension

**Registered Extension Number**

463

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

 [VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

 or

 [Vulkan Version 1.1](versions.html#versions-1.1)

 and

 [VK_EXT_pipeline_creation_cache_control](#VK_EXT_pipeline_creation_cache_control)

or

[Vulkan Version 1.3](versions.html#versions-1.3)

**Contact**

* 
Hans-Kristian Arntzen [HansKristian-Work](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_shader_module_identifier] @HansKristian-Work%0A*Here describe the issue or question you have about the VK_EXT_shader_module_identifier extension*)

**Extension Proposal**

[VK_EXT_shader_module_identifier](../../../features/latest/features/proposals/VK_EXT_shader_module_identifier.html)

**Last Modified Date**

2022-05-16

**IP Status**

No known IP claims.

**Contributors**

* 
Hans-Kristian Arntzen, Valve

* 
Ricardo Garcia, Igalia

* 
Piers Daniell, NVIDIA

* 
Jan-Harald Fredriksen, Arm

* 
Tom Olson, Arm

* 
Faith Ekstrand, Collabora

Some applications generate SPIR-V code at runtime.
When pipeline caches are primed, either explicitly through e.g.
[VkPipelineCache](../chapters/pipelines.html#VkPipelineCache) mechanisms, or implicitly through driver managed
caches, having to re-generate SPIR-V modules is redundant.
SPIR-V modules could be cached on disk by an application, but the extra disk
size requirement might be prohibitive in some use cases.

This extension adds the ability for an application to query a small
identifier associated with a [VkShaderModule](../chapters/shaders.html#VkShaderModule).
On subsequent runs of the application, the same identifier **can** be provided
in lieu of a [VkShaderModule](../chapters/shaders.html#VkShaderModule) object.
A pipeline creation call with such a module **may** succeed if a pipeline could
be created without invoking compilation, and information inside the SPIR-V
module is not required by the implementation.

`VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT` **must** be used
if only the identifier is provided, and this use case is intended to work
like a non-blocking, speculative compile.
Applications **can** fallback as necessary.

The main motivation for identifying the module itself and not the entire
pipeline is that pipeline identifiers change when a driver is updated, but
module identifiers are expected to be stable for any particular driver
implementation.
This approach is helpful for shader pre-compilation systems which can prime
pipeline caches ahead of time.
When on-disk pipeline caches are updated, the same shader identifiers could
lead to a pipeline cache hit.

* 
[vkGetShaderModuleCreateInfoIdentifierEXT](../chapters/shaders.html#vkGetShaderModuleCreateInfoIdentifierEXT)

* 
[vkGetShaderModuleIdentifierEXT](../chapters/shaders.html#vkGetShaderModuleIdentifierEXT)

* 
[VkShaderModuleIdentifierEXT](../chapters/shaders.html#VkShaderModuleIdentifierEXT)

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT](../chapters/features.html#VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT](../chapters/limits.html#VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT)

Extending [VkPipelineShaderStageCreateInfo](../chapters/pipelines.html#VkPipelineShaderStageCreateInfo):

* 
[VkPipelineShaderStageModuleIdentifierCreateInfoEXT](../chapters/pipelines.html#VkPipelineShaderStageModuleIdentifierCreateInfoEXT)

* 
`VK_EXT_SHADER_MODULE_IDENTIFIER_EXTENSION_NAME`

* 
`VK_EXT_SHADER_MODULE_IDENTIFIER_SPEC_VERSION`

* 
`VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT`

* 
`VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT`

* 
Revision 1, 2022-03-16 (Hans-Kristian Arntzen)

Initial draft

**Name String**

`VK_EXT_shader_object`

**Extension Type**

Device extension

**Registered Extension Number**

483

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

 [VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

 or

 [Vulkan Version 1.1](versions.html#versions-1.1)

 and

 [VK_KHR_dynamic_rendering](#VK_KHR_dynamic_rendering)

or

[Vulkan Version 1.3](versions.html#versions-1.3)

**API Interactions**

* 
Interacts with VK_VERSION_1_1

* 
Interacts with VK_VERSION_1_3

* 
Interacts with VK_EXT_blend_operation_advanced

* 
Interacts with VK_EXT_conservative_rasterization

* 
Interacts with VK_EXT_depth_clamp_control

* 
Interacts with VK_EXT_depth_clip_control

* 
Interacts with VK_EXT_depth_clip_enable

* 
Interacts with VK_EXT_fragment_density_map

* 
Interacts with VK_EXT_line_rasterization

* 
Interacts with VK_EXT_mesh_shader

* 
Interacts with VK_EXT_provoking_vertex

* 
Interacts with VK_EXT_sample_locations

* 
Interacts with VK_EXT_subgroup_size_control

* 
Interacts with VK_EXT_transform_feedback

* 
Interacts with VK_KHR_device_group

* 
Interacts with VK_KHR_fragment_shading_rate

* 
Interacts with VK_NV_clip_space_w_scaling

* 
Interacts with VK_NV_coverage_reduction_mode

* 
Interacts with VK_NV_fragment_coverage_to_color

* 
Interacts with VK_NV_framebuffer_mixed_samples

* 
Interacts with VK_NV_mesh_shader

* 
Interacts with VK_NV_representative_fragment_test

* 
Interacts with VK_NV_shading_rate_image

* 
Interacts with VK_NV_viewport_swizzle

**Contact**

* 
Daniel Story [daniel-story](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_shader_object] @daniel-story%0A*Here describe the issue or question you have about the VK_EXT_shader_object extension*)

**Extension Proposal**

[VK_EXT_shader_object](../../../features/latest/features/proposals/VK_EXT_shader_object.html)

**Last Modified Date**

2023-03-30

**Interactions and External Dependencies**

* 
Interacts with `[VK_EXT_extended_dynamic_state](#VK_EXT_extended_dynamic_state)`

* 
Interacts with `[VK_EXT_extended_dynamic_state2](#VK_EXT_extended_dynamic_state2)`

* 
Interacts with `[VK_EXT_extended_dynamic_state3](#VK_EXT_extended_dynamic_state3)`

* 
Interacts with `[VK_EXT_vertex_input_dynamic_state](#VK_EXT_vertex_input_dynamic_state)`

**IP Status**

No known IP claims.

**Contributors**

* 
Piers Daniell, NVIDIA

* 
Sandy Jamieson, Nintendo

* 
iga Marku, LunarG

* 
Tobias Hector, AMD

* 
Alex Walters, Imagination

* 
Shahbaz Youssefi, Google

* 
Ralph Potter, Samsung

* 
Jan-Harald Fredriksen, ARM

* 
Connor Abott, Valve

* 
Arseny Kapoulkine, Roblox

* 
Patrick Doane, Activision

* 
Jeff Leger, Qualcomm

* 
Stu Smith, AMD

* 
Chris Glover, Google

* 
Ricardo Garcia, Igalia

* 
Faith Ekstrand, Collabora

* 
Timur Kristf, Valve

* 
Constantine Shablya, Collabora

* 
Daniel Koch, NVIDIA

* 
Alyssa Rosenzweig, Collabora

* 
Mike Blumenkrantz, Valve

* 
Samuel Pitoiset, Valve

* 
Qun Lin, AMD

* 
Spencer Fricke, LunarG

* 
Soroush Faghihi Kashani, Imagination

This extension introduces a new [VkShaderEXT](../chapters/shaders.html#VkShaderEXT) object type which
represents a single compiled shader stage.
Shader objects provide a more flexible alternative to [VkPipeline](../chapters/pipelines.html#VkPipeline)
objects, which may be helpful in certain use cases.

* 
[VkShaderEXT](../chapters/shaders.html#VkShaderEXT)

* 
[vkCmdBindShadersEXT](../chapters/shaders.html#vkCmdBindShadersEXT)

* 
[vkCmdBindVertexBuffers2EXT](../chapters/fxvertex.html#vkCmdBindVertexBuffers2EXT)

* 
[vkCmdSetAlphaToCoverageEnableEXT](../chapters/fragops.html#vkCmdSetAlphaToCoverageEnableEXT)

* 
[vkCmdSetAlphaToOneEnableEXT](../chapters/fragops.html#vkCmdSetAlphaToOneEnableEXT)

* 
[vkCmdSetColorBlendEnableEXT](../chapters/framebuffer.html#vkCmdSetColorBlendEnableEXT)

* 
[vkCmdSetColorBlendEquationEXT](../chapters/framebuffer.html#vkCmdSetColorBlendEquationEXT)

* 
[vkCmdSetColorWriteMaskEXT](../chapters/framebuffer.html#vkCmdSetColorWriteMaskEXT)

* 
[vkCmdSetCullModeEXT](../chapters/primsrast.html#vkCmdSetCullModeEXT)

* 
[vkCmdSetDepthBiasEnableEXT](../chapters/primsrast.html#vkCmdSetDepthBiasEnableEXT)

* 
[vkCmdSetDepthBoundsTestEnableEXT](../chapters/fragops.html#vkCmdSetDepthBoundsTestEnableEXT)

* 
[vkCmdSetDepthClampEnableEXT](../chapters/vertexpostproc.html#vkCmdSetDepthClampEnableEXT)

* 
[vkCmdSetDepthCompareOpEXT](../chapters/fragops.html#vkCmdSetDepthCompareOpEXT)

* 
[vkCmdSetDepthTestEnableEXT](../chapters/fragops.html#vkCmdSetDepthTestEnableEXT)

* 
[vkCmdSetDepthWriteEnableEXT](../chapters/fragops.html#vkCmdSetDepthWriteEnableEXT)

* 
[vkCmdSetFrontFaceEXT](../chapters/primsrast.html#vkCmdSetFrontFaceEXT)

* 
[vkCmdSetLogicOpEXT](../chapters/framebuffer.html#vkCmdSetLogicOpEXT)

* 
[vkCmdSetLogicOpEnableEXT](../chapters/framebuffer.html#vkCmdSetLogicOpEnableEXT)

* 
[vkCmdSetPatchControlPointsEXT](../chapters/shaders.html#vkCmdSetPatchControlPointsEXT)

* 
[vkCmdSetPolygonModeEXT](../chapters/primsrast.html#vkCmdSetPolygonModeEXT)

* 
[vkCmdSetPrimitiveRestartEnableEXT](../chapters/drawing.html#vkCmdSetPrimitiveRestartEnableEXT)

* 
[vkCmdSetPrimitiveTopologyEXT](../chapters/drawing.html#vkCmdSetPrimitiveTopologyEXT)

* 
[vkCmdSetRasterizationSamplesEXT](../chapters/primsrast.html#vkCmdSetRasterizationSamplesEXT)

* 
[vkCmdSetRasterizerDiscardEnableEXT](../chapters/primsrast.html#vkCmdSetRasterizerDiscardEnableEXT)

* 
[vkCmdSetSampleMaskEXT](../chapters/fragops.html#vkCmdSetSampleMaskEXT)

* 
[vkCmdSetScissorWithCountEXT](../chapters/vertexpostproc.html#vkCmdSetScissorWithCountEXT)

* 
[vkCmdSetStencilOpEXT](../chapters/fragops.html#vkCmdSetStencilOpEXT)

* 
[vkCmdSetStencilTestEnableEXT](../chapters/fragops.html#vkCmdSetStencilTestEnableEXT)

* 
[vkCmdSetTessellationDomainOriginEXT](../chapters/tessellation.html#vkCmdSetTessellationDomainOriginEXT)

* 
[vkCmdSetVertexInputEXT](../chapters/fxvertex.html#vkCmdSetVertexInputEXT)

* 
[vkCmdSetViewportWithCountEXT](../chapters/vertexpostproc.html#vkCmdSetViewportWithCountEXT)

* 
[vkCreateShadersEXT](../chapters/shaders.html#vkCreateShadersEXT)

* 
[vkDestroyShaderEXT](../chapters/shaders.html#vkDestroyShaderEXT)

* 
[vkGetShaderBinaryDataEXT](../chapters/shaders.html#vkGetShaderBinaryDataEXT)

If [VK_EXT_blend_operation_advanced](#VK_EXT_blend_operation_advanced) is supported:

* 
[vkCmdSetColorBlendAdvancedEXT](../chapters/framebuffer.html#vkCmdSetColorBlendAdvancedEXT)

If [VK_EXT_conservative_rasterization](#VK_EXT_conservative_rasterization) is supported:

* 
[vkCmdSetConservativeRasterizationModeEXT](../chapters/primsrast.html#vkCmdSetConservativeRasterizationModeEXT)

* 
[vkCmdSetExtraPrimitiveOverestimationSizeEXT](../chapters/primsrast.html#vkCmdSetExtraPrimitiveOverestimationSizeEXT)

If [VK_EXT_depth_clamp_control](#VK_EXT_depth_clamp_control) is supported:

* 
[vkCmdSetDepthClampRangeEXT](../chapters/fragops.html#vkCmdSetDepthClampRangeEXT)

If [VK_EXT_depth_clip_control](#VK_EXT_depth_clip_control) is supported:

* 
[vkCmdSetDepthClipNegativeOneToOneEXT](../chapters/vertexpostproc.html#vkCmdSetDepthClipNegativeOneToOneEXT)

If [VK_EXT_depth_clip_enable](#VK_EXT_depth_clip_enable) is supported:

* 
[vkCmdSetDepthClipEnableEXT](../chapters/vertexpostproc.html#vkCmdSetDepthClipEnableEXT)

If [VK_EXT_line_rasterization](#VK_EXT_line_rasterization) is supported:

* 
[vkCmdSetLineRasterizationModeEXT](../chapters/primsrast.html#vkCmdSetLineRasterizationModeEXT)

* 
[vkCmdSetLineStippleEnableEXT](../chapters/primsrast.html#vkCmdSetLineStippleEnableEXT)

If [VK_EXT_provoking_vertex](#VK_EXT_provoking_vertex) is supported:

* 
[vkCmdSetProvokingVertexModeEXT](../chapters/vertexpostproc.html#vkCmdSetProvokingVertexModeEXT)

If [VK_EXT_sample_locations](#VK_EXT_sample_locations) is supported:

* 
[vkCmdSetSampleLocationsEnableEXT](../chapters/primsrast.html#vkCmdSetSampleLocationsEnableEXT)

If [VK_EXT_transform_feedback](#VK_EXT_transform_feedback) is supported:

* 
[vkCmdSetRasterizationStreamEXT](../chapters/primsrast.html#vkCmdSetRasterizationStreamEXT)

If [VK_NV_clip_space_w_scaling](#VK_NV_clip_space_w_scaling) is supported:

* 
[vkCmdSetViewportWScalingEnableNV](../chapters/vertexpostproc.html#vkCmdSetViewportWScalingEnableNV)

If [VK_NV_coverage_reduction_mode](#VK_NV_coverage_reduction_mode) is supported:

* 
[vkCmdSetCoverageReductionModeNV](../chapters/fragops.html#vkCmdSetCoverageReductionModeNV)

If [VK_NV_fragment_coverage_to_color](#VK_NV_fragment_coverage_to_color) is supported:

* 
[vkCmdSetCoverageToColorEnableNV](../chapters/fragops.html#vkCmdSetCoverageToColorEnableNV)

* 
[vkCmdSetCoverageToColorLocationNV](../chapters/fragops.html#vkCmdSetCoverageToColorLocationNV)

If [VK_NV_framebuffer_mixed_samples](#VK_NV_framebuffer_mixed_samples) is supported:

* 
[vkCmdSetCoverageModulationModeNV](../chapters/fragops.html#vkCmdSetCoverageModulationModeNV)

* 
[vkCmdSetCoverageModulationTableEnableNV](../chapters/fragops.html#vkCmdSetCoverageModulationTableEnableNV)

* 
[vkCmdSetCoverageModulationTableNV](../chapters/fragops.html#vkCmdSetCoverageModulationTableNV)

If [VK_NV_representative_fragment_test](#VK_NV_representative_fragment_test) is supported:

* 
[vkCmdSetRepresentativeFragmentTestEnableNV](../chapters/fragops.html#vkCmdSetRepresentativeFragmentTestEnableNV)

If [VK_NV_shading_rate_image](#VK_NV_shading_rate_image) is supported:

* 
[vkCmdSetShadingRateImageEnableNV](../chapters/primsrast.html#vkCmdSetShadingRateImageEnableNV)

If [VK_NV_viewport_swizzle](#VK_NV_viewport_swizzle) is supported:

* 
[vkCmdSetViewportSwizzleNV](../chapters/vertexpostproc.html#vkCmdSetViewportSwizzleNV)

* 
[VkColorBlendAdvancedEXT](../chapters/framebuffer.html#VkColorBlendAdvancedEXT)

* 
[VkColorBlendEquationEXT](../chapters/framebuffer.html#VkColorBlendEquationEXT)

* 
[VkShaderCreateInfoEXT](../chapters/shaders.html#VkShaderCreateInfoEXT)

* 
[VkVertexInputAttributeDescription2EXT](../chapters/fxvertex.html#VkVertexInputAttributeDescription2EXT)

* 
[VkVertexInputBindingDescription2EXT](../chapters/fxvertex.html#VkVertexInputBindingDescription2EXT)

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceShaderObjectFeaturesEXT](../chapters/features.html#VkPhysicalDeviceShaderObjectFeaturesEXT)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceShaderObjectPropertiesEXT](../chapters/limits.html#VkPhysicalDeviceShaderObjectPropertiesEXT)

Extending [VkPipelineShaderStageCreateInfo](../chapters/pipelines.html#VkPipelineShaderStageCreateInfo), [VkShaderCreateInfoEXT](../chapters/shaders.html#VkShaderCreateInfoEXT):

* 
[VkShaderRequiredSubgroupSizeCreateInfoEXT](../chapters/pipelines.html#VkShaderRequiredSubgroupSizeCreateInfoEXT)

* 
[VkShaderCodeTypeEXT](../chapters/shaders.html#VkShaderCodeTypeEXT)

* 
[VkShaderCreateFlagBitsEXT](../chapters/shaders.html#VkShaderCreateFlagBitsEXT)

* 
[VkShaderCreateFlagsEXT](../chapters/shaders.html#VkShaderCreateFlagsEXT)

* 
`VK_EXT_SHADER_OBJECT_EXTENSION_NAME`

* 
`VK_EXT_SHADER_OBJECT_SPEC_VERSION`

* 
Extending [VkObjectType](../chapters/debugging.html#VkObjectType):

`VK_OBJECT_TYPE_SHADER_EXT`

Extending [VkResult](../chapters/fundamentals.html#VkResult):

* 
`VK_ERROR_INCOMPATIBLE_SHADER_BINARY_EXT`

* 
`VK_INCOMPATIBLE_SHADER_BINARY_EXT`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT`

* 
`VK_STRUCTURE_TYPE_SHADER_CREATE_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_SHADER_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT`

* 
`VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT`

If [VK_EXT_fragment_density_map](#VK_EXT_fragment_density_map) is supported:

* 
Extending [VkShaderCreateFlagBitsEXT](../chapters/shaders.html#VkShaderCreateFlagBitsEXT):

`VK_SHADER_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT`

If [VK_EXT_mesh_shader](#VK_EXT_mesh_shader) or [VK_NV_mesh_shader](#VK_NV_mesh_shader) is supported:

* 
Extending [VkShaderCreateFlagBitsEXT](../chapters/shaders.html#VkShaderCreateFlagBitsEXT):

`VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT`

If [VK_EXT_subgroup_size_control](#VK_EXT_subgroup_size_control) or [Vulkan Version 1.3](versions.html#versions-1.3) is supported:

* 
Extending [VkShaderCreateFlagBitsEXT](../chapters/shaders.html#VkShaderCreateFlagBitsEXT):

`VK_SHADER_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT`

* 
`VK_SHADER_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT`

If [VK_KHR_device_group](#VK_KHR_device_group) or [Vulkan Version 1.1](versions.html#versions-1.1) is supported:

* 
Extending [VkShaderCreateFlagBitsEXT](../chapters/shaders.html#VkShaderCreateFlagBitsEXT):

`VK_SHADER_CREATE_DISPATCH_BASE_BIT_EXT`

If [VK_KHR_fragment_shading_rate](#VK_KHR_fragment_shading_rate) is supported:

* 
Extending [VkShaderCreateFlagBitsEXT](../chapters/shaders.html#VkShaderCreateFlagBitsEXT):

`VK_SHADER_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_EXT`

**Example 1**

Create linked pair of vertex and fragment shaders.

// Logical device created with the shaderObject feature enabled
VkDevice device;

// SPIR-V shader code for a vertex shader, along with its size in bytes
void* pVertexSpirv;
size_t vertexSpirvSize;

// SPIR-V shader code for a fragment shader, along with its size in bytes
void* pFragmentSpirv;
size_t fragmentSpirvSize;

// Descriptor set layout compatible with the shaders
VkDescriptorSetLayout descriptorSetLayout;

VkShaderCreateInfoEXT shaderCreateInfos[2] =
{
    {
        .sType = VK_STRUCTURE_TYPE_SHADER_CREATE_INFO_EXT,
        .pNext = NULL,
        .flags = VK_SHADER_CREATE_LINK_STAGE_BIT_EXT,
        .stage = VK_SHADER_STAGE_VERTEX_BIT,
        .nextStage = VK_SHADER_STAGE_FRAGMENT_BIT,
        .codeType = VK_SHADER_CODE_TYPE_SPIRV_EXT,
        .codeSize = vertexSpirvSize,
        .pCode = pVertexSpirv,
        .pName = "main",
        .setLayoutCount = 1,
        .pSetLayouts = &descriptorSetLayout;
        .pushConstantRangeCount = 0,
        .pPushConstantRanges = NULL,
        .pSpecializationInfo = NULL
    },
    {
        .sType = VK_STRUCTURE_TYPE_SHADER_CREATE_INFO_EXT,
        .pNext = NULL,
        .flags = VK_SHADER_CREATE_LINK_STAGE_BIT_EXT,
        .stage = VK_SHADER_STAGE_FRAGMENT_BIT,
        .nextStage = 0,
        .codeType = VK_SHADER_CODE_TYPE_SPIRV_EXT,
        .codeSize = fragmentSpirvSize,
        .pCode = pFragmentSpirv,
        .pName = "main",
        .setLayoutCount = 1,
        .pSetLayouts = &descriptorSetLayout;
        .pushConstantRangeCount = 0,
        .pPushConstantRanges = NULL,
        .pSpecializationInfo = NULL
    }
};

VkResult result;
VkShaderEXT shaders[2];

result = vkCreateShadersEXT(device, 2, &shaderCreateInfos, NULL, shaders);
if (result != VK_SUCCESS)
{
    // Handle error
}

Later, during command buffer recording, bind the linked shaders and draw.

// Command buffer in the recording state
VkCommandBuffer commandBuffer;

// Vertex and fragment shader objects created above
VkShaderEXT shaders[2];

// Assume vertex buffers, descriptor sets, etc. have been bound, and existing
// state setting commands have been called to set all required state

const VkShaderStageFlagBits stages[2] =
{
    VK_SHADER_STAGE_VERTEX_BIT,
    VK_SHADER_STAGE_FRAGMENT_BIT
};

// Bind linked shaders
vkCmdBindShadersEXT(commandBuffer, 2, stages, shaders);

// Equivalent to the previous line. Linked shaders can be bound one at a time,
// in any order:
// vkCmdBindShadersEXT(commandBuffer, 1, &stages[1], &shaders[1]);
// vkCmdBindShadersEXT(commandBuffer, 1, &stages[0], &shaders[0]);

// The above is sufficient to draw if the device was created with the
// tessellationShader and geometryShader features disabled. Otherwise, since
// those stages should not execute, vkCmdBindShadersEXT() must be called at
// least once with each of their stages in pStages before drawing:

const VkShaderStageFlagBits unusedStages[3] =
{
    VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT,
    VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT,
    VK_SHADER_STAGE_GEOMETRY_BIT
};

// NULL pShaders is equivalent to an array of stageCount VK_NULL_HANDLE values,
// meaning no shaders are bound to those stages, and that any previously bound
// shaders are unbound
vkCmdBindShadersEXT(commandBuffer, 3, unusedStages, NULL);

// Graphics shader objects may only be used to draw inside dynamic render pass
// instances begun with vkCmdBeginRendering(), assume one has already been begun

// Draw a triangle
vkCmdDraw(commandBuffer, 3, 1, 0, 0);

**Example 2**

Create unlinked vertex, geometry, and fragment shaders.

// Logical device created with the shaderObject feature enabled
VkDevice device;

// SPIR-V shader code for vertex shaders, along with their sizes in bytes
void* pVertexSpirv[2];
size_t vertexSpirvSize[2];

// SPIR-V shader code for a geometry shader, along with its size in bytes
void pGeometrySpirv;
size_t geometrySpirvSize;

// SPIR-V shader code for fragment shaders, along with their sizes in bytes
void* pFragmentSpirv[2];
size_t fragmentSpirvSize[2];

// Descriptor set layout compatible with the shaders
VkDescriptorSetLayout descriptorSetLayout;

VkShaderCreateInfoEXT shaderCreateInfos[5] =
{
    // Stage order does not matter
    {
        .sType = VK_STRUCTURE_TYPE_SHADER_CREATE_INFO_EXT,
        .pNext = NULL,
        .flags = 0,
        .stage = VK_SHADER_STAGE_GEOMETRY_BIT,
        .nextStage = VK_SHADER_STAGE_FRAGMENT_BIT,
        .codeType = VK_SHADER_CODE_TYPE_SPIRV_EXT,
        .codeSize = pGeometrySpirv,
        .pCode = geometrySpirvSize,
        .pName = "main",
        .setLayoutCount = 1,
        .pSetLayouts = &descriptorSetLayout;
        .pushConstantRangeCount = 0,
        .pPushConstantRanges = NULL,
        .pSpecializationInfo = NULL
    },
    {
        .sType = VK_STRUCTURE_TYPE_SHADER_CREATE_INFO_EXT,
        .pNext = NULL,
        .flags = 0,
        .stage = VK_SHADER_STAGE_VERTEX_BIT,
        .nextStage = VK_SHADER_STAGE_GEOMETRY_BIT,
        .codeType = VK_SHADER_CODE_TYPE_SPIRV_EXT,
        .codeSize = vertexSpirvSize[0],
        .pCode = pVertexSpirv[0],
        .pName = "main",
        .setLayoutCount = 1,
        .pSetLayouts = &descriptorSetLayout;
        .pushConstantRangeCount = 0,
        .pPushConstantRanges = NULL,
        .pSpecializationInfo = NULL
    },
    {
        .sType = VK_STRUCTURE_TYPE_SHADER_CREATE_INFO_EXT,
        .pNext = NULL,
        .flags = 0,
        .stage = VK_SHADER_STAGE_FRAGMENT_BIT,
        .nextStage = 0,
        .codeType = VK_SHADER_CODE_TYPE_SPIRV_EXT,
        .codeSize = fragmentSpirvSize[0],
        .pCode = pFragmentSpirv[0],
        .pName = "main",
        .setLayoutCount = 1,
        .pSetLayouts = &descriptorSetLayout;
        .pushConstantRangeCount = 0,
        .pPushConstantRanges = NULL,
        .pSpecializationInfo = NULL
    },
    {
        .sType = VK_STRUCTURE_TYPE_SHADER_CREATE_INFO_EXT,
        .pNext = NULL,
        .flags = 0,
        .stage = VK_SHADER_STAGE_FRAGMENT_BIT,
        .nextStage = 0,
        .codeType = VK_SHADER_CODE_TYPE_SPIRV_EXT,
        .codeSize = fragmentSpirvSize[1],
        .pCode = pFragmentSpirv[1],
        .pName = "main",
        .setLayoutCount = 1,
        .pSetLayouts = &descriptorSetLayout;
        .pushConstantRangeCount = 0,
        .pPushConstantRanges = NULL,
        .pSpecializationInfo = NULL
    },
    {
        .sType = VK_STRUCTURE_TYPE_SHADER_CREATE_INFO_EXT,
        .pNext = NULL,
        .flags = 0,
        .stage = VK_SHADER_STAGE_VERTEX_BIT,
        // Suppose we want this vertex shader to be able to be followed by
        // either a geometry shader or fragment shader:
        .nextStage = VK_SHADER_STAGE_GEOMETRY_BIT | VK_SHADER_STAGE_FRAGMENT_BIT,
        .codeType = VK_SHADER_CODE_TYPE_SPIRV_EXT,
        .codeSize = vertexSpirvSize[1],
        .pCode = pVertexSpirv[1],
        .pName = "main",
        .setLayoutCount = 1,
        .pSetLayouts = &descriptorSetLayout;
        .pushConstantRangeCount = 0,
        .pPushConstantRanges = NULL,
        .pSpecializationInfo = NULL
    }
};

VkResult result;
VkShaderEXT shaders[5];

result = vkCreateShadersEXT(device, 5, &shaderCreateInfos, NULL, shaders);
if (result != VK_SUCCESS)
{
    // Handle error
}

Later, during command buffer recording, bind the linked shaders in different
combinations and draw.

// Command buffer in the recording state
VkCommandBuffer commandBuffer;

// Vertex, geometry, and fragment shader objects created above
VkShaderEXT shaders[5];

// Assume vertex buffers, descriptor sets, etc. have been bound, and existing
// state setting commands have been called to set all required state

const VkShaderStageFlagBits stages[3] =
{
    // Any order is allowed
    VK_SHADER_STAGE_FRAGMENT_BIT,
    VK_SHADER_STAGE_VERTEX_BIT,
    VK_SHADER_STAGE_GEOMETRY_BIT,
};

VkShaderEXT bindShaders[3] =
{
    shaders[2], // FS
    shaders[1], // VS
    shaders[0]  // GS
};

// Bind unlinked shaders
vkCmdBindShadersEXT(commandBuffer, 3, stages, bindShaders);

// Assume the tessellationShader feature is disabled, so vkCmdBindShadersEXT()
// need not have been called with either tessellation stage

// Graphics shader objects may only be used to draw inside dynamic render pass
// instances begun with vkCmdBeginRendering(), assume one has already been begun

// Draw a triangle
vkCmdDraw(commandBuffer, 3, 1, 0, 0);

// Bind a different unlinked fragment shader
const VkShaderStageFlagBits fragmentStage = VK_SHADER_STAGE_FRAGMENT_BIT;
vkCmdBindShadersEXT(commandBuffer, 1, &fragmentStage, &shaders[3]);

// Draw another triangle
vkCmdDraw(commandBuffer, 3, 1, 0, 0);

// Bind a different unlinked vertex shader
const VkShaderStageFlagBits vertexStage = VK_SHADER_STAGE_VERTEX_BIT;
vkCmdBindShadersEXT(commandBuffer, 1, &vertexStage, &shaders[4]);

// Draw another triangle
vkCmdDraw(commandBuffer, 3, 1, 0, 0);

* 
Revision 1, 2023-03-30 (Daniel Story)

Initial draft

**Name String**

`VK_EXT_shader_replicated_composites`

**Extension Type**

Device extension

**Registered Extension Number**

565

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

None

**SPIR-V Dependencies**

* 
[SPV_EXT_replicated_composites](https://github.khronos.org/SPIRV-Registry/extensions/EXT/SPV_EXT_replicated_composites.html)

**Contact**

* 
Kevin Petit [kpet](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_shader_replicated_composites] @kpet%0A*Here describe the issue or question you have about the VK_EXT_shader_replicated_composites extension*)

**Extension Proposal**

[VK_EXT_shader_replicated_composites](../../../features/latest/features/proposals/VK_EXT_shader_replicated_composites.html)

**Last Modified Date**

2024-02-08

**IP Status**

No known IP claims.

**Contributors**

* 
Kvin Petit, Arm Ltd.

* 
Jeff Bolz, NVIDIA

* 
Piers Daniell, NVIDIA

This extension adds support for creating composites from a single value in
SPIR-V modules, as defined by SPV_EXT_replicated_composites.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT](../chapters/features.html#VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT)

* 
`VK_EXT_SHADER_REPLICATED_COMPOSITES_EXTENSION_NAME`

* 
`VK_EXT_SHADER_REPLICATED_COMPOSITES_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_REPLICATED_COMPOSITES_FEATURES_EXT`

* 
[ReplicatedCompositesEXT](spirvenv.html#spirvenv-capabilities-table-ReplicatedCompositesEXT)

* 
Revision 1, 2024-02-08 (Kvin Petit)

Initial revision

**Name String**

`VK_EXT_shader_stencil_export`

**Extension Type**

Device extension

**Registered Extension Number**

141

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

None

**SPIR-V Dependencies**

* 
[SPV_EXT_shader_stencil_export](https://github.khronos.org/SPIRV-Registry/extensions/EXT/SPV_EXT_shader_stencil_export.html)

**Contact**

* 
Dominik Witczak [dominikwitczakamd](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_shader_stencil_export] @dominikwitczakamd%0A*Here describe the issue or question you have about the VK_EXT_shader_stencil_export extension*)

**Last Modified Date**

2017-07-19

**IP Status**

No known IP claims.

**Interactions and External Dependencies**

* 
This extension provides API support for
[`GL_ARB_shader_stencil_export`](https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_stencil_export.txt)

**Contributors**

* 
Dominik Witczak, AMD

* 
Daniel Rakos, AMD

* 
Rex Xu, AMD

This extension adds support for the SPIR-V extension
`SPV_EXT_shader_stencil_export`, providing a mechanism whereby a shader may
generate the stencil reference value per invocation.
When stencil testing is enabled, this allows the test to be performed
against the value generated in the shader.

* 
`VK_EXT_SHADER_STENCIL_EXPORT_EXTENSION_NAME`

* 
`VK_EXT_SHADER_STENCIL_EXPORT_SPEC_VERSION`

* 
Revision 1, 2017-07-19 (Dominik Witczak)

Initial draft

**Name String**

`VK_EXT_shader_tile_image`

**Extension Type**

Device extension

**Registered Extension Number**

396

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[Vulkan Version 1.3](versions.html#versions-1.3)

**SPIR-V Dependencies**

* 
[SPV_EXT_shader_tile_image](https://github.khronos.org/SPIRV-Registry/extensions/EXT/SPV_EXT_shader_tile_image.html)

**Contact**

* 
Jan-Harald Fredriksen [janharaldfredriksen-arm](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_shader_tile_image] @janharaldfredriksen-arm%0A*Here describe the issue or question you have about the VK_EXT_shader_tile_image extension*)

**Extension Proposal**

[VK_EXT_shader_tile_image](../../../features/latest/features/proposals/VK_EXT_shader_tile_image.html)

**Last Modified Date**

2023-03-23

**IP Status**

No known IP claims.

**Interactions and External Dependencies**

* 
This extension provides API support for
[`GL_EXT_shader_tile_image`](https://raw.githubusercontent.com/KhronosGroup/GLSL/main/extensions/ext/GLSL_EXT_shader_tile_image.txt)

**Contributors**

* 
Sandeep Kakarlapudi, Arm

* 
Jan-Harald Fredriksen, Arm

* 
James Fitzpatrick, Imagination

* 
Andrew Garrard, Imagination

* 
Jeff Leger, Qualcomm

* 
Huilong Wang, Huawei

* 
Graeme Leese, Broadcom

* 
Hans-Kristian Arntzen, Valve

* 
Tobias Hector, AMD

* 
Jeff Bolz, NVIDIA

* 
Shahbaz Youssefi, Google

This extension allows fragment shader invocations to read color, depth and
stencil values at their pixel location in rasterization order.
The functionality is only available when using dynamic render passes
introduced by VK_KHR_dynamic_rendering.
Example use cases are programmable blending and deferred shading.

See [fragment shader tile image reads](../chapters/fragops.html#fragops-shader-tileimage-reads) for
more information.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceShaderTileImageFeaturesEXT](../chapters/features.html#VkPhysicalDeviceShaderTileImageFeaturesEXT)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceShaderTileImagePropertiesEXT](../chapters/devsandqueues.html#VkPhysicalDeviceShaderTileImagePropertiesEXT)

* 
`VK_EXT_SHADER_TILE_IMAGE_EXTENSION_NAME`

* 
`VK_EXT_SHADER_TILE_IMAGE_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT`

None.

Color read example.

layout( location = 0 /* aliased to color attachment 0 */ ) tileImageEXT highp attachmentEXT color0;
layout( location = 1 /* aliased to color attachment 1 */ ) tileImageEXT highp attachmentEXT color1;

layout( location = 0 ) out vec4 fragColor;

void main()
{
    vec4 value = colorAttachmentReadEXT(color0) + colorAttachmentReadEXT(color1);
    fragColor = value;
}

Depth & Stencil read example.

void main()
{
    // read sample 0: works for non-MSAA or MSAA targets
    highp float last_depth = depthAttachmentReadEXT();
    lowp uint last_stencil = stencilAttachmentReadEXT();

    //..
}

* 
Revision 1, 2023-03-23 (Sandeep Kakarlapudi)

Initial version

**Name String**

`VK_EXT_subpass_merge_feedback`

**Extension Type**

Device extension

**Registered Extension Number**

459

**Revision**

2

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Contact**

* 
Ting Wei [catweiting](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_subpass_merge_feedback] @catweiting%0A*Here describe the issue or question you have about the VK_EXT_subpass_merge_feedback extension*)

**Extension Proposal**

[VK_EXT_subpass_merge_feedback](../../../features/latest/features/proposals/VK_EXT_subpass_merge_feedback.html)

**Last Modified Date**

2022-05-24

**IP Status**

No known IP claims.

**Contributors**

* 
Jan-Harald Fredriksen, Arm

* 
Jorg Wagner, Arm

* 
Ting Wei, Arm

This extension adds a mechanism to provide feedback to an application about
whether the subpasses specified on render pass creation are merged by the
implementation.
Additionally, it provides a control to enable or disable subpass merging in
the render pass.

* 
[VkRenderPassCreationFeedbackInfoEXT](../chapters/renderpass.html#VkRenderPassCreationFeedbackInfoEXT)

* 
[VkRenderPassSubpassFeedbackInfoEXT](../chapters/renderpass.html#VkRenderPassSubpassFeedbackInfoEXT)

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT](../chapters/features.html#VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT)

Extending [VkRenderPassCreateInfo2](../chapters/renderpass.html#VkRenderPassCreateInfo2):

* 
[VkRenderPassCreationFeedbackCreateInfoEXT](../chapters/renderpass.html#VkRenderPassCreationFeedbackCreateInfoEXT)

Extending [VkRenderPassCreateInfo2](../chapters/renderpass.html#VkRenderPassCreateInfo2), [VkSubpassDescription2](../chapters/renderpass.html#VkSubpassDescription2):

* 
[VkRenderPassCreationControlEXT](../chapters/renderpass.html#VkRenderPassCreationControlEXT)

Extending [VkSubpassDescription2](../chapters/renderpass.html#VkSubpassDescription2):

* 
[VkRenderPassSubpassFeedbackCreateInfoEXT](../chapters/renderpass.html#VkRenderPassSubpassFeedbackCreateInfoEXT)

* 
[VkSubpassMergeStatusEXT](../chapters/renderpass.html#VkSubpassMergeStatusEXT)

* 
`VK_EXT_SUBPASS_MERGE_FEEDBACK_EXTENSION_NAME`

* 
`VK_EXT_SUBPASS_MERGE_FEEDBACK_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT`

* 
`VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT`

* 
`VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT`

* 
Revision 1, 2022-03-10

Initial draft.

Revision 2, 2022-05-24

* 
Fix structextends and constness issues.

**Name String**

`VK_EXT_surface_maintenance1`

**Extension Type**

Instance extension

**Registered Extension Number**

275

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_surface](#VK_KHR_surface)

and

[VK_KHR_get_surface_capabilities2](#VK_KHR_get_surface_capabilities2)

**Contact**

* 
Shahbaz Youssefi [syoussefi](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_surface_maintenance1] @syoussefi%0A*Here describe the issue or question you have about the VK_EXT_surface_maintenance1 extension*)

**Extension Proposal**

[VK_EXT_surface_maintenance1](../../../features/latest/features/proposals/VK_EXT_surface_maintenance1.html)

**Last Modified Date**

2022-11-09

**Contributors**

* 
Jeff Juliano, NVIDIA

* 
Lionel Landwerlin, Intel

* 
Shahbaz Youssefi, Google

* 
Chris Forbes, Google

* 
Ian Elliott, Google

* 
Hans-Kristian Arntzen, Valve

* 
Daniel Stone, Collabora

`[VK_EXT_surface_maintenance1](#VK_EXT_surface_maintenance1)` adds a collection of window system
integration features that were intentionally left out or overlooked in the
original `[VK_KHR_surface](#VK_KHR_surface)` extension.

The new features are as follows:

* 
Allow querying number of min/max images from a surface for a particular
presentation mode.

* 
Allow querying a surfaces scaled presentation capabilities.

* 
Allow querying a surface for the set of presentation modes which can be
easily switched between without requiring swapchain recreation.

* 
Extending [VkPhysicalDeviceSurfaceInfo2KHR](../chapters/VK_KHR_surface/wsi.html#VkPhysicalDeviceSurfaceInfo2KHR):

[VkSurfacePresentModeEXT](../chapters/VK_KHR_surface/wsi.html#VkSurfacePresentModeEXT)

Extending [VkSurfaceCapabilities2KHR](../chapters/VK_KHR_surface/wsi.html#VkSurfaceCapabilities2KHR):

* 
[VkSurfacePresentModeCompatibilityEXT](../chapters/VK_KHR_surface/wsi.html#VkSurfacePresentModeCompatibilityEXT)

* 
[VkSurfacePresentScalingCapabilitiesEXT](../chapters/VK_KHR_surface/wsi.html#VkSurfacePresentScalingCapabilitiesEXT)

* 
[VkPresentGravityFlagBitsEXT](../chapters/VK_KHR_surface/wsi.html#VkPresentGravityFlagBitsEXT)

* 
[VkPresentScalingFlagBitsEXT](../chapters/VK_KHR_surface/wsi.html#VkPresentScalingFlagBitsEXT)

* 
[VkPresentGravityFlagsEXT](../chapters/VK_KHR_surface/wsi.html#VkPresentGravityFlagsEXT)

* 
[VkPresentScalingFlagsEXT](../chapters/VK_KHR_surface/wsi.html#VkPresentScalingFlagsEXT)

* 
`VK_EXT_SURFACE_MAINTENANCE_1_EXTENSION_NAME`

* 
`VK_EXT_SURFACE_MAINTENANCE_1_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_EXT`

* 
`VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_EXT`

* 
`VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_EXT`

* 
Revision 0, 2019-02-27 (Lionel Landwerlin)

Internal revisions

Revision 1, 2022-11-09 (Shahbaz Youssefi)

* 
Add functionality and complete spec

**Name String**

`VK_EXT_swapchain_colorspace`

**Extension Type**

Instance extension

**Registered Extension Number**

105

**Revision**

5

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_surface](#VK_KHR_surface)

**Contact**

* 
Courtney Goeltzenleuchter [courtney-g](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_swapchain_colorspace] @courtney-g%0A*Here describe the issue or question you have about the VK_EXT_swapchain_colorspace extension*)

**Last Modified Date**

2019-04-26

**IP Status**

No known IP claims.

**Contributors**

* 
Courtney Goeltzenleuchter, Google

This extension expands [VkColorSpaceKHR](../chapters/VK_KHR_surface/wsi.html#VkColorSpaceKHR) to add support for most
standard color spaces beyond `VK_COLOR_SPACE_SRGB_NONLINEAR_KHR`.
This extension also adds support for `VK_COLOR_SPACE_PASS_THROUGH_EXT`
which allows applications to use color spaces not explicitly enumerated in
[VkColorSpaceKHR](../chapters/VK_KHR_surface/wsi.html#VkColorSpaceKHR).

* 
`VK_EXT_SWAPCHAIN_COLOR_SPACE_EXTENSION_NAME`

* 
`VK_EXT_SWAPCHAIN_COLOR_SPACE_SPEC_VERSION`

* 
Extending [VkColorSpaceKHR](../chapters/VK_KHR_surface/wsi.html#VkColorSpaceKHR):

`VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT`

* 
`VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT`

* 
`VK_COLOR_SPACE_BT2020_LINEAR_EXT`

* 
`VK_COLOR_SPACE_BT709_LINEAR_EXT`

* 
`VK_COLOR_SPACE_BT709_NONLINEAR_EXT`

* 
`VK_COLOR_SPACE_DCI_P3_LINEAR_EXT`

* 
`VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT`

* 
`VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT`

* 
`VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT`

* 
`VK_COLOR_SPACE_DOLBYVISION_EXT`

* 
`VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT`

* 
`VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT`

* 
`VK_COLOR_SPACE_HDR10_HLG_EXT`

* 
`VK_COLOR_SPACE_HDR10_ST2084_EXT`

* 
`VK_COLOR_SPACE_PASS_THROUGH_EXT`

1) Does the spec need to specify which kinds of image formats support the
color spaces?

**RESOLVED**: Pixel format is independent of color space (though some color
spaces really want / need floating-point color components to be useful).
Therefore, do not plan on documenting what formats support which color
spaces.
An application **can** call [vkGetPhysicalDeviceSurfaceFormatsKHR](../chapters/VK_KHR_surface/wsi.html#vkGetPhysicalDeviceSurfaceFormatsKHR) to query
what a particular implementation supports.

2) How does application determine if HW supports appropriate transfer
function for a color space?

**RESOLVED**: Extension indicates that implementation **must** not do the OETF
encoding if it is not sRGB.
That responsibility falls to the application shaders.
Any other native OETF / EOTF functions supported by an implementation can be
described by separate extension.

* 
Revision 1, 2016-12-27 (Courtney Goeltzenleuchter)

Initial version

Revision 2, 2017-01-19 (Courtney Goeltzenleuchter)

* 
Add pass through and multiple options for BT2020.

* 
Clean up some issues with equations not displaying properly.

Revision 3, 2017-06-23 (Courtney Goeltzenleuchter)

* 
Add extended sRGB non-linear enum.

Revision 4, 2019-04-26 (Graeme Leese)

* 
Clarify color space transfer function usage.

* 
Refer to normative definitions in the Data Format Specification.

* 
Clarify DCI-P3 and Display P3 usage.

Revision 5, 2024-03-16 (Zehui Lin)

* 
Fix interchanged concepts of EOTF and OETF.

* 
Clarify that the presentation engine can accept the color spaces.

**Name String**

`VK_EXT_swapchain_maintenance1`

**Extension Type**

Device extension

**Registered Extension Number**

276

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_swapchain](#VK_KHR_swapchain)

and

[VK_EXT_surface_maintenance1](#VK_EXT_surface_maintenance1)

and

 [VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

 or

 [Vulkan Version 1.1](versions.html#versions-1.1)

**Contact**

* 
Shahbaz Youssefi [syoussefi](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_swapchain_maintenance1] @syoussefi%0A*Here describe the issue or question you have about the VK_EXT_swapchain_maintenance1 extension*)

**Extension Proposal**

[VK_EXT_swapchain_maintenance1](../../../features/latest/features/proposals/VK_EXT_swapchain_maintenance1.html)

**Last Modified Date**

2022-10-28

**Contributors**

* 
Jeff Juliano, NVIDIA

* 
Shahbaz Youssefi, Google

* 
Chris Forbes, Google

* 
Ian Elliott, Google

* 
Yiwei Zhang, Google

* 
Charlie Lao, Google

* 
Lina Versace, Google

* 
Ralph Potter, Samsung

* 
Igor Nazarov, Samsung

* 
Hyunchang Kim, Samsung

* 
Suenghwan Lee, Samsung

* 
Munseong Kang, Samsung

* 
Joonyong Park, Samsung

* 
Hans-Kristian Arntzen, Valve

* 
Lisa Wu, Arm

* 
Daniel Stone, Collabora

* 
Pan Gao, Huawei

`[VK_EXT_swapchain_maintenance1](#VK_EXT_swapchain_maintenance1)` adds a collection of window system
integration features that were intentionally left out or overlooked in the
original `[VK_KHR_swapchain](#VK_KHR_swapchain)` extension.

The new features are as follows:

* 
Specify a fence that will be signaled when the resources associated with
a present operation **can** be safely destroyed.

* 
Allow changing the present mode a swapchain is using at per-present
granularity.

* 
Allow applications to define the behavior when presenting a swapchain
image to a surface with different dimensions than the image.
Using this feature **may** allow implementations to avoid returning
`VK_ERROR_OUT_OF_DATE_KHR` in this situation.

* 
Allow applications to defer swapchain memory allocation for improved
startup time and memory footprint.

* 
Allow applications to release previously acquired images without
presenting them.

* 
[vkReleaseSwapchainImagesEXT](../chapters/VK_KHR_surface/wsi.html#vkReleaseSwapchainImagesEXT)

* 
[VkReleaseSwapchainImagesInfoEXT](../chapters/VK_KHR_surface/wsi.html#VkReleaseSwapchainImagesInfoEXT)

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT](../chapters/features.html#VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT)

Extending [VkPresentInfoKHR](../chapters/VK_KHR_surface/wsi.html#VkPresentInfoKHR):

* 
[VkSwapchainPresentFenceInfoEXT](../chapters/VK_KHR_surface/wsi.html#VkSwapchainPresentFenceInfoEXT)

* 
[VkSwapchainPresentModeInfoEXT](../chapters/VK_KHR_surface/wsi.html#VkSwapchainPresentModeInfoEXT)

Extending [VkSwapchainCreateInfoKHR](../chapters/VK_KHR_surface/wsi.html#VkSwapchainCreateInfoKHR):

* 
[VkSwapchainPresentModesCreateInfoEXT](../chapters/VK_KHR_surface/wsi.html#VkSwapchainPresentModesCreateInfoEXT)

* 
[VkSwapchainPresentScalingCreateInfoEXT](../chapters/VK_KHR_surface/wsi.html#VkSwapchainPresentScalingCreateInfoEXT)

* 
`VK_EXT_SWAPCHAIN_MAINTENANCE_1_EXTENSION_NAME`

* 
`VK_EXT_SWAPCHAIN_MAINTENANCE_1_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_EXT`

* 
`VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_EXT`

Extending [VkSwapchainCreateFlagBitsKHR](../chapters/VK_KHR_surface/wsi.html#VkSwapchainCreateFlagBitsKHR):

* 
`VK_SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_BIT_EXT`

* 
Revision 0, 2019-05-28

Initial revisions

Revision 1, 2022-08-21 (Shahbaz Youssefi)

* 
Add functionality and complete spec

**Name String**

`VK_EXT_transform_feedback`

**Extension Type**

Device extension

**Registered Extension Number**

29

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Special Uses**

* 
[OpenGL / ES support](../chapters/extensions.html#extendingvulkan-compatibility-specialuse)

* 
[D3D support](../chapters/extensions.html#extendingvulkan-compatibility-specialuse)

* 
[Developer tools](../chapters/extensions.html#extendingvulkan-compatibility-specialuse)

**Contact**

* 
Piers Daniell [pdaniell-nv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_transform_feedback] @pdaniell-nv%0A*Here describe the issue or question you have about the VK_EXT_transform_feedback extension*)

**Last Modified Date**

2018-10-09

**Contributors**

* 
Baldur Karlsson, Valve

* 
Boris Zanin, Mobica

* 
Daniel Rakos, AMD

* 
Donald Scorgie, Imagination

* 
Henri Verbeet, CodeWeavers

* 
Jan-Harald Fredriksen, Arm

* 
Faith Ekstrand, Intel

* 
Jeff Bolz, NVIDIA

* 
Jesse Barker, Unity

* 
Jesse Hall, Google

* 
Pierre-Loup Griffais, Valve

* 
Philip Rebohle, DXVK

* 
Ruihao Zhang, Qualcomm

* 
Samuel Pitoiset, Valve

* 
Slawomir Grajewski, Intel

* 
Stu Smith, Imagination Technologies

This extension adds transform feedback to the Vulkan API by exposing the
SPIR-V `TransformFeedback` and `GeometryStreams` capabilities to
capture vertex, tessellation or geometry shader outputs to one or more
buffers.
It adds API functionality to bind transform feedback buffers to capture the
primitives emitted by the graphics pipeline from SPIR-V outputs decorated
for transform feedback.
The transform feedback capture can be paused and resumed by way of storing
and retrieving a byte counter.
The captured data can be drawn again where the vertex count is derived from
the byte counter without CPU intervention.
If the implementation is capable, a vertex stream other than zero can be
rasterized.

All these features are designed to match the full capabilities of OpenGL
core transform feedback functionality and beyond.
Many of the features are optional to allow base OpenGL ES GPUs to also
implement this extension.

The primary purpose of the functionality exposed by this extension is to
support translation layers from other 3D APIs.
This functionality is not considered forward looking, and is not expected to
be promoted to a KHR extension or to core Vulkan.
Unless this is needed for translation, it is recommended that developers use
alternative techniques of using the GPU to process and capture vertex data.

* 
[vkCmdBeginQueryIndexedEXT](../chapters/queries.html#vkCmdBeginQueryIndexedEXT)

* 
[vkCmdBeginTransformFeedbackEXT](../chapters/vertexpostproc.html#vkCmdBeginTransformFeedbackEXT)

* 
[vkCmdBindTransformFeedbackBuffersEXT](../chapters/vertexpostproc.html#vkCmdBindTransformFeedbackBuffersEXT)

* 
[vkCmdDrawIndirectByteCountEXT](../chapters/drawing.html#vkCmdDrawIndirectByteCountEXT)

* 
[vkCmdEndQueryIndexedEXT](../chapters/queries.html#vkCmdEndQueryIndexedEXT)

* 
[vkCmdEndTransformFeedbackEXT](../chapters/vertexpostproc.html#vkCmdEndTransformFeedbackEXT)

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceTransformFeedbackFeaturesEXT](../chapters/features.html#VkPhysicalDeviceTransformFeedbackFeaturesEXT)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceTransformFeedbackPropertiesEXT](../chapters/limits.html#VkPhysicalDeviceTransformFeedbackPropertiesEXT)

Extending [VkPipelineRasterizationStateCreateInfo](../chapters/primsrast.html#VkPipelineRasterizationStateCreateInfo):

* 
[VkPipelineRasterizationStateStreamCreateInfoEXT](../chapters/primsrast.html#VkPipelineRasterizationStateStreamCreateInfoEXT)

* 
[VkPipelineRasterizationStateStreamCreateFlagsEXT](../chapters/primsrast.html#VkPipelineRasterizationStateStreamCreateFlagsEXT)

* 
`VK_EXT_TRANSFORM_FEEDBACK_EXTENSION_NAME`

* 
`VK_EXT_TRANSFORM_FEEDBACK_SPEC_VERSION`

* 
Extending [VkAccessFlagBits](../chapters/synchronization.html#VkAccessFlagBits):

`VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT`

* 
`VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT`

* 
`VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT`

Extending [VkBufferUsageFlagBits](../chapters/resources.html#VkBufferUsageFlagBits):

* 
`VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT`

* 
`VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT`

Extending [VkPipelineStageFlagBits](../chapters/synchronization.html#VkPipelineStageFlagBits):

* 
`VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT`

Extending [VkQueryType](../chapters/queries.html#VkQueryType):

* 
`VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT`

* 
`VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT`

1) Should we include pause/resume functionality?

**RESOLVED**: Yes, this is needed to ease layering other APIs which have this
functionality.
To pause use `vkCmdEndTransformFeedbackEXT` and provide valid buffer
handles in the `pCounterBuffers` array and offsets in the
`pCounterBufferOffsets` array for the implementation to save the resume
points.
Then to resume use `vkCmdBeginTransformFeedbackEXT` with the previous
`pCounterBuffers` and `pCounterBufferOffsets` values.
Between the pause and resume there needs to be a memory barrier for the
counter buffers with a source access of
`VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT` at pipeline stage
`VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT` to a destination access
of `VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT` at pipeline stage
`VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT`.

2) How does this interact with multiview?

**RESOLVED**: Transform feedback cannot be made active in a render pass with
multiview enabled.

3) How should queries be done?

**RESOLVED**: There is a new query type
`VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT`.
A query pool created with this type will capture 2 integers -
numPrimitivesWritten and numPrimitivesNeeded - for the specified vertex
stream output from the last
[pre-rasterization shader stage](../chapters/pipelines.html#pipelines-graphics-subsets-pre-rasterization).
The vertex stream output queried is zero by default, but can be specified
with the new `vkCmdBeginQueryIndexedEXT` and
`vkCmdEndQueryIndexedEXT` commands.

* 
Revision 1, 2018-10-09 (Piers Daniell)

Internal revisions

**Name String**

`VK_EXT_validation_cache`

**Extension Type**

Device extension

**Registered Extension Number**

161

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

None

**Contact**

* 
Cort Stratton [cdwfs](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_validation_cache] @cdwfs%0A*Here describe the issue or question you have about the VK_EXT_validation_cache extension*)

**Last Modified Date**

2017-08-29

**IP Status**

No known IP claims.

**Contributors**

* 
Cort Stratton, Google

* 
Chris Forbes, Google

This extension provides a mechanism for caching the results of potentially
expensive internal validation operations across multiple runs of a Vulkan
application.
At the core is the [VkValidationCacheEXT](../chapters/shaders.html#VkValidationCacheEXT) object type, which is managed
similarly to the existing [VkPipelineCache](../chapters/pipelines.html#VkPipelineCache).

The new structure [VkShaderModuleValidationCacheCreateInfoEXT](../chapters/shaders.html#VkShaderModuleValidationCacheCreateInfoEXT) can be
included in the `pNext` chain at [vkCreateShaderModule](../chapters/shaders.html#vkCreateShaderModule) time.
It contains a [VkValidationCacheEXT](../chapters/shaders.html#VkValidationCacheEXT) to use when validating the
[VkShaderModule](../chapters/shaders.html#VkShaderModule).

* 
[VkValidationCacheEXT](../chapters/shaders.html#VkValidationCacheEXT)

* 
[vkCreateValidationCacheEXT](../chapters/shaders.html#vkCreateValidationCacheEXT)

* 
[vkDestroyValidationCacheEXT](../chapters/shaders.html#vkDestroyValidationCacheEXT)

* 
[vkGetValidationCacheDataEXT](../chapters/shaders.html#vkGetValidationCacheDataEXT)

* 
[vkMergeValidationCachesEXT](../chapters/shaders.html#vkMergeValidationCachesEXT)

* 
[VkValidationCacheCreateInfoEXT](../chapters/shaders.html#VkValidationCacheCreateInfoEXT)

* 
Extending [VkShaderModuleCreateInfo](../chapters/shaders.html#VkShaderModuleCreateInfo), [VkPipelineShaderStageCreateInfo](../chapters/pipelines.html#VkPipelineShaderStageCreateInfo):

[VkShaderModuleValidationCacheCreateInfoEXT](../chapters/shaders.html#VkShaderModuleValidationCacheCreateInfoEXT)

* 
[VkValidationCacheHeaderVersionEXT](../chapters/shaders.html#VkValidationCacheHeaderVersionEXT)

* 
[VkValidationCacheCreateFlagsEXT](../chapters/shaders.html#VkValidationCacheCreateFlagsEXT)

* 
`VK_EXT_VALIDATION_CACHE_EXTENSION_NAME`

* 
`VK_EXT_VALIDATION_CACHE_SPEC_VERSION`

* 
Extending [VkObjectType](../chapters/debugging.html#VkObjectType):

`VK_OBJECT_TYPE_VALIDATION_CACHE_EXT`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT`

* 
Revision 1, 2017-08-29 (Cort Stratton)

Initial draft

**Name String**

`VK_EXT_vertex_attribute_robustness`

**Extension Type**

Device extension

**Registered Extension Number**

609

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Contact**

* 
Piers Daniell [pdaniell-nv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_vertex_attribute_robustness] @pdaniell-nv%0A*Here describe the issue or question you have about the VK_EXT_vertex_attribute_robustness extension*)

**Last Modified Date**

2024-11-01

**IP Status**

No known IP claims.

**Contributors**

* 
Daniel Story, Nintendo

It can be detrimental to performance for applications to have to define fake
vertex attribute locations and buffer bindings for vertex shaders that may
reference attribute locations for which there is no vertex data.

This extension allows applications to not have to specify fake vertex
attribute locations, and if the vertex shader reads those attributes it will
read (0,0,0,0) or (0,0,0,1).

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT](../chapters/features.html#VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT)

* 
`VK_EXT_VERTEX_ATTRIBUTE_ROBUSTNESS_EXTENSION_NAME`

* 
`VK_EXT_VERTEX_ATTRIBUTE_ROBUSTNESS_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_ROBUSTNESS_FEATURES_EXT`

None

* 
Revision 1, 2024-11-01 (Piers Daniell)

Internal revisions

**Name String**

`VK_EXT_vertex_input_dynamic_state`

**Extension Type**

Device extension

**Registered Extension Number**

353

**Revision**

2

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Contact**

* 
Piers Daniell [pdaniell-nv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_vertex_input_dynamic_state] @pdaniell-nv%0A*Here describe the issue or question you have about the VK_EXT_vertex_input_dynamic_state extension*)

**Last Modified Date**

2020-08-21

**IP Status**

No known IP claims.

**Contributors**

* 
Jeff Bolz, NVIDIA

* 
Spencer Fricke, Samsung

* 
Stu Smith, AMD

One of the states that contributes to the combinatorial explosion of
pipeline state objects that need to be created, is the vertex input binding
and attribute descriptions.
By allowing them to be dynamic applications may reduce the number of
pipeline objects they need to create.

This extension adds dynamic state support for what is normally static state
in [VkPipelineVertexInputStateCreateInfo](../chapters/fxvertex.html#VkPipelineVertexInputStateCreateInfo).

* 
[vkCmdSetVertexInputEXT](../chapters/fxvertex.html#vkCmdSetVertexInputEXT)

* 
[VkVertexInputAttributeDescription2EXT](../chapters/fxvertex.html#VkVertexInputAttributeDescription2EXT)

* 
[VkVertexInputBindingDescription2EXT](../chapters/fxvertex.html#VkVertexInputBindingDescription2EXT)

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT](../chapters/features.html#VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT)

* 
`VK_EXT_VERTEX_INPUT_DYNAMIC_STATE_EXTENSION_NAME`

* 
`VK_EXT_VERTEX_INPUT_DYNAMIC_STATE_SPEC_VERSION`

* 
Extending [VkDynamicState](../chapters/pipelines.html#VkDynamicState):

`VK_DYNAMIC_STATE_VERTEX_INPUT_EXT`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT`

* 
`VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT`

* 
`VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT`

* 
Revision 2, 2020-11-05 (Piers Daniell)

Make [VkVertexInputBindingDescription2EXT](../chapters/fxvertex.html#VkVertexInputBindingDescription2EXT) extensible

* 
Add new [VkVertexInputAttributeDescription2EXT](../chapters/fxvertex.html#VkVertexInputAttributeDescription2EXT) structure for the
`pVertexAttributeDescriptions` parameter to
[vkCmdSetVertexInputEXT](../chapters/fxvertex.html#vkCmdSetVertexInputEXT) so it is also extensible

Revision 1, 2020-08-21 (Piers Daniell)

* 
Internal revisions

**Name String**

`VK_EXT_ycbcr_image_arrays`

**Extension Type**

Device extension

**Registered Extension Number**

253

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_sampler_ycbcr_conversion](#VK_KHR_sampler_ycbcr_conversion)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Contact**

* 
Piers Daniell [pdaniell-nv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_ycbcr_image_arrays] @pdaniell-nv%0A*Here describe the issue or question you have about the VK_EXT_ycbcr_image_arrays extension*)

**Last Modified Date**

2019-01-15

**Contributors**

* 
Piers Daniell, NVIDIA

This extension allows images of a format that requires
[YCBCR conversion](../chapters/formats.html#formats-requiring-sampler-ycbcr-conversion) to be
created with multiple array layers, which is otherwise restricted.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceYcbcrImageArraysFeaturesEXT](../chapters/features.html#VkPhysicalDeviceYcbcrImageArraysFeaturesEXT)

* 
`VK_EXT_YCBCR_IMAGE_ARRAYS_EXTENSION_NAME`

* 
`VK_EXT_YCBCR_IMAGE_ARRAYS_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT`

* 
Revision 1, 2019-01-15 (Piers Daniell)

Initial revision

**Name String**

`VK_EXT_zero_initialize_device_memory`

**Extension Type**

Device extension

**Registered Extension Number**

621

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Contact**

* 
Mike Blumenkrantz [zmike](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_zero_initialize_device_memory] @zmike%0A*Here describe the issue or question you have about the VK_EXT_zero_initialize_device_memory extension*)

**Extension Proposal**

[VK_EXT_zero_initialize_device_memory](../../../features/latest/features/proposals/VK_EXT_zero_initialize_device_memory.html)

**Last Modified Date**

2025-04-09

**Interactions and External Dependencies**

* 
Interacts with Vulkan 1.1.

* 
Interacts with `[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)`.

**IP Status**

No known IP claims.

**Contributors**

* 
Hans-Kristian Arntzen, VALVE

* 
Mike Blumenkrantz, VALVE

* 
Tobias Hector, AMD

* 
Faith Ekstrand, Collabora

* 
Ricardo Garcia, Igalia

* 
Jan-Harald Fredriksen, ARM

* 
Spencer Fricke, LunarG

By default, Vulkan provides no guarantees that device memory allocated
through vkAllocateMemory is cleared to zero.
This means that applications wanting resources to be zero-initialized must
execute a command such as vkCmdFillBuffer or vkCmdClearColorImage on the
device to ensure a deterministic result.
This can be wasteful if the underlying platform either:

* 
Already performs that zero clear anyway, due to e.g. security concerns.

* 
Can be performed more efficiently in implementation, by e.g. clearing
pages to zero in the background after device memory is freed.

This extension also has uses in API layering and porting efforts, where zero
memory behavior may be more strict than Vulkan.
Different OS platforms also have wildly different behaviors here, which
leads to implementations needing to apply workarounds to paper over these
issues in the wild.
If an extension exists to make allocation behavior explicit, we hopefully
achieve a more robust ecosystem for Vulkan.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT](../chapters/features.html#VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT)

* 
`VK_EXT_ZERO_INITIALIZE_DEVICE_MEMORY_EXTENSION_NAME`

* 
`VK_EXT_ZERO_INITIALIZE_DEVICE_MEMORY_SPEC_VERSION`

* 
Extending [VkImageLayout](../chapters/resources.html#VkImageLayout):

`VK_IMAGE_LAYOUT_ZERO_INITIALIZED_EXT`

Extending [VkMemoryAllocateFlagBits](../chapters/memory.html#VkMemoryAllocateFlagBits):

* 
`VK_MEMORY_ALLOCATE_ZERO_INITIALIZE_BIT_EXT`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_DEVICE_MEMORY_FEATURES_EXT`

* 
Revision 1, 2025-03-10 (Mike Blumenkrantz)

Initial version

**Name String**

`VK_AMD_anti_lag`

**Extension Type**

Device extension

**Registered Extension Number**

477

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

None

**Contact**

* 
Stu Smith

**Extension Proposal**

[VK_AMD_anti_lag](../../../features/latest/features/proposals/VK_AMD_anti_lag.html)

**Last Modified Date**

2024-06-06

**IP Status**

No known IP claims.

**Contributors**

* 
Tobias Hector, AMD

* 
Stuart Smith, AMD

* 
Arkadiusz Sarwa, AMD

This extension automatically paces the CPU to make sure it does not get too
far ahead of the GPU, reducing the latency between inputs received and
updates on the screen.
Additionally, Anti-Lag+ offers applications the ability to inform the driver
when input processing begins, in order to align the timing of display
updates, enabling even lower latency between receiving input and displaying
on the screen.

* 
[vkAntiLagUpdateAMD](../chapters/VK_KHR_surface/wsi.html#vkAntiLagUpdateAMD)

* 
[VkAntiLagDataAMD](../chapters/VK_KHR_surface/wsi.html#VkAntiLagDataAMD)

* 
[VkAntiLagPresentationInfoAMD](../chapters/VK_KHR_surface/wsi.html#VkAntiLagPresentationInfoAMD)

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceAntiLagFeaturesAMD](../chapters/features.html#VkPhysicalDeviceAntiLagFeaturesAMD)

* 
[VkAntiLagModeAMD](../chapters/VK_KHR_surface/wsi.html#VkAntiLagModeAMD)

* 
[VkAntiLagStageAMD](../chapters/VK_KHR_surface/wsi.html#VkAntiLagStageAMD)

* 
`VK_AMD_ANTI_LAG_EXTENSION_NAME`

* 
`VK_AMD_ANTI_LAG_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_ANTI_LAG_DATA_AMD`

* 
`VK_STRUCTURE_TYPE_ANTI_LAG_PRESENTATION_INFO_AMD`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ANTI_LAG_FEATURES_AMD`

* 
Revision 1, 2024-06-06 (Arkadiusz Sarw)

Initial version

**Name String**

`VK_AMD_buffer_marker`

**Extension Type**

Device extension

**Registered Extension Number**

180

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

None

**API Interactions**

* 
Interacts with VK_VERSION_1_3

* 
Interacts with VK_KHR_synchronization2

**Special Use**

* 
[Developer tools](../chapters/extensions.html#extendingvulkan-compatibility-specialuse)

**Contact**

* 
Daniel Rakos [drakos-amd](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_AMD_buffer_marker] @drakos-amd%0A*Here describe the issue or question you have about the VK_AMD_buffer_marker extension*)

**Last Modified Date**

2018-01-26

**IP Status**

No known IP claims.

**Contributors**

* 
Matthaeus G. Chajdas, AMD

* 
Jaakko Konttinen, AMD

* 
Daniel Rakos, AMD

This extension adds a new operation to execute pipelined writes of small
marker values into a `VkBuffer` object.

The primary purpose of these markers is to facilitate the development of
debugging tools for tracking which pipelined command contributed to device
loss.

* 
[vkCmdWriteBufferMarkerAMD](../chapters/copies.html#vkCmdWriteBufferMarkerAMD)

If [Vulkan Version 1.3](versions.html#versions-1.3) or [VK_KHR_synchronization2](#VK_KHR_synchronization2) is supported:

* 
[vkCmdWriteBufferMarker2AMD](../chapters/copies.html#vkCmdWriteBufferMarker2AMD)

* 
`VK_AMD_BUFFER_MARKER_EXTENSION_NAME`

* 
`VK_AMD_BUFFER_MARKER_SPEC_VERSION`

None.

* 
Revision 1, 2018-01-26 (Jaakko Konttinen)

Initial revision

**Name String**

`VK_AMD_device_coherent_memory`

**Extension Type**

Device extension

**Registered Extension Number**

230

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Contact**

* 
Tobias Hector [tobski](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_AMD_device_coherent_memory] @tobski%0A*Here describe the issue or question you have about the VK_AMD_device_coherent_memory extension*)

**Last Modified Date**

2019-02-04

**Contributors**

* 
Ping Fu, AMD

* 
Timothy Lottes, AMD

* 
Tobias Hector, AMD

This extension adds the device coherent and device uncached memory types.
Any device accesses to device coherent memory are automatically made visible
to any other device access.
Device uncached memory indicates to applications that caches are disabled
for a particular memory type, which guarantees device coherence.

Device coherent and uncached memory are expected to have lower performance
for general access than non-device coherent memory, but can be useful in
certain scenarios; particularly so for debugging.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceCoherentMemoryFeaturesAMD](../chapters/features.html#VkPhysicalDeviceCoherentMemoryFeaturesAMD)

* 
`VK_AMD_DEVICE_COHERENT_MEMORY_EXTENSION_NAME`

* 
`VK_AMD_DEVICE_COHERENT_MEMORY_SPEC_VERSION`

* 
Extending [VkMemoryPropertyFlagBits](../chapters/memory.html#VkMemoryPropertyFlagBits):

`VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD`

* 
`VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD`

* 
Revision 1, 2019-02-04 (Tobias Hector)

Initial revision

**Name String**

`VK_AMD_display_native_hdr`

**Extension Type**

Device extension

**Registered Extension Number**

214

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

 [VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

 or

 [Vulkan Version 1.1](versions.html#versions-1.1)

and

[VK_KHR_get_surface_capabilities2](#VK_KHR_get_surface_capabilities2)

and

[VK_KHR_swapchain](#VK_KHR_swapchain)

**Contact**

* 
Matthaeus G. Chajdas [anteru](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_AMD_display_native_hdr] @anteru%0A*Here describe the issue or question you have about the VK_AMD_display_native_hdr extension*)

**Last Modified Date**

2018-12-18

**IP Status**

No known IP claims.

**Contributors**

* 
Matthaeus G. Chajdas, AMD

* 
Aaron Hagan, AMD

* 
Aric Cyr, AMD

* 
Timothy Lottes, AMD

* 
Derrick Owens, AMD

* 
Daniel Rakos, AMD

This extension introduces the following display native HDR features to
Vulkan:

* 
A new [VkColorSpaceKHR](../chapters/VK_KHR_surface/wsi.html#VkColorSpaceKHR) enum for setting the native display color
space.
For example, this color space would be set by the swapchain to use the
native color space in Freesync2 displays.

* 
Local dimming control

* 
[vkSetLocalDimmingAMD](../chapters/VK_KHR_surface/wsi.html#vkSetLocalDimmingAMD)

* 
Extending [VkSurfaceCapabilities2KHR](../chapters/VK_KHR_surface/wsi.html#VkSurfaceCapabilities2KHR):

[VkDisplayNativeHdrSurfaceCapabilitiesAMD](../chapters/VK_KHR_surface/wsi.html#VkDisplayNativeHdrSurfaceCapabilitiesAMD)

Extending [VkSwapchainCreateInfoKHR](../chapters/VK_KHR_surface/wsi.html#VkSwapchainCreateInfoKHR):

* 
[VkSwapchainDisplayNativeHdrCreateInfoAMD](../chapters/VK_KHR_surface/wsi.html#VkSwapchainDisplayNativeHdrCreateInfoAMD)

* 
`VK_AMD_DISPLAY_NATIVE_HDR_EXTENSION_NAME`

* 
`VK_AMD_DISPLAY_NATIVE_HDR_SPEC_VERSION`

* 
Extending [VkColorSpaceKHR](../chapters/VK_KHR_surface/wsi.html#VkColorSpaceKHR):

`VK_COLOR_SPACE_DISPLAY_NATIVE_AMD`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD`

* 
`VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD`

None.

None.

* 
Revision 1, 2018-12-18 (Daniel Rakos)

Initial revision

**Name String**

`VK_AMD_gcn_shader`

**Extension Type**

Device extension

**Registered Extension Number**

26

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

None

**SPIR-V Dependencies**

* 
[SPV_AMD_gcn_shader](https://github.khronos.org/SPIRV-Registry/extensions/AMD/SPV_AMD_gcn_shader.html)

**Contact**

* 
Dominik Witczak [dominikwitczakamd](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_AMD_gcn_shader] @dominikwitczakamd%0A*Here describe the issue or question you have about the VK_AMD_gcn_shader extension*)

**Last Modified Date**

2016-05-30

**IP Status**

No known IP claims.

**Interactions and External Dependencies**

* 
This extension provides API support for
[`GL_AMD_gcn_shader`](https://registry.khronos.org/OpenGL/extensions/AMD/AMD_gcn_shader.txt)

**Contributors**

* 
Dominik Witczak, AMD

* 
Daniel Rakos, AMD

* 
Rex Xu, AMD

* 
Graham Sellers, AMD

This extension adds support for the following SPIR-V extension in Vulkan:

* 
[`SPV_AMD_gcn_shader`](https://github.khronos.org/SPIRV-Registry/extensions/AMD/SPV_AMD_gcn_shader.html)

* 
`VK_AMD_GCN_SHADER_EXTENSION_NAME`

* 
`VK_AMD_GCN_SHADER_SPEC_VERSION`

* 
Revision 1, 2016-05-30 (Dominik Witczak)

Initial draft

**Name String**

`VK_AMD_memory_overallocation_behavior`

**Extension Type**

Device extension

**Registered Extension Number**

190

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

None

**Contact**

* 
Martin Dinkov [mdinkov](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_AMD_memory_overallocation_behavior] @mdinkov%0A*Here describe the issue or question you have about the VK_AMD_memory_overallocation_behavior extension*)

**Last Modified Date**

2018-09-19

**IP Status**

No known IP claims.

**Contributors**

* 
Martin Dinkov, AMD

* 
Matthaeus Chajdas, AMD

* 
Daniel Rakos, AMD

* 
Jon Campbell, AMD

This extension allows controlling whether explicit overallocation beyond the
device memory heap sizes (reported by
[VkPhysicalDeviceMemoryProperties](../chapters/memory.html#VkPhysicalDeviceMemoryProperties)) is allowed or not.
Overallocation may lead to performance loss and is not supported for all
platforms.

* 
Extending [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkDeviceMemoryOverallocationCreateInfoAMD](../chapters/devsandqueues.html#VkDeviceMemoryOverallocationCreateInfoAMD)

* 
[VkMemoryOverallocationBehaviorAMD](../chapters/devsandqueues.html#VkMemoryOverallocationBehaviorAMD)

* 
`VK_AMD_MEMORY_OVERALLOCATION_BEHAVIOR_EXTENSION_NAME`

* 
`VK_AMD_MEMORY_OVERALLOCATION_BEHAVIOR_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD`

* 
Revision 1, 2018-09-19 (Martin Dinkov)

Initial draft.

**Name String**

`VK_AMD_mixed_attachment_samples`

**Extension Type**

Device extension

**Registered Extension Number**

137

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

None

**API Interactions**

* 
Interacts with VK_VERSION_1_3

* 
Interacts with VK_KHR_dynamic_rendering

**Contact**

* 
Matthaeus G. Chajdas [anteru](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_AMD_mixed_attachment_samples] @anteru%0A*Here describe the issue or question you have about the VK_AMD_mixed_attachment_samples extension*)

**Last Modified Date**

2017-07-24

**Contributors**

* 
Mais Alnasser, AMD

* 
Matthaeus G. Chajdas, AMD

* 
Maciej Jesionowski, AMD

* 
Daniel Rakos, AMD

This extension enables applications to use multisampled rendering with a
depth/stencil sample count that is larger than the color sample count.
Having a depth/stencil sample count larger than the color sample count
allows maintaining geometry and coverage information at a higher sample rate
than color information.
All samples are depth/stencil tested, but only the first color sample count
number of samples get a corresponding color output.

If [Vulkan Version 1.3](versions.html#versions-1.3) or [VK_KHR_dynamic_rendering](#VK_KHR_dynamic_rendering) is supported:

* 
Extending [VkCommandBufferInheritanceInfo](../chapters/cmdbuffers.html#VkCommandBufferInheritanceInfo), [VkGraphicsPipelineCreateInfo](../chapters/pipelines.html#VkGraphicsPipelineCreateInfo):

[VkAttachmentSampleCountInfoAMD](../chapters/cmdbuffers.html#VkAttachmentSampleCountInfoAMD)

* 
`VK_AMD_MIXED_ATTACHMENT_SAMPLES_EXTENSION_NAME`

* 
`VK_AMD_MIXED_ATTACHMENT_SAMPLES_SPEC_VERSION`

If [Vulkan Version 1.3](versions.html#versions-1.3) or [VK_KHR_dynamic_rendering](#VK_KHR_dynamic_rendering) is supported:

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD`

None.

* 
Revision 1, 2017-07-24 (Daniel Rakos)

Internal revisions

**Name String**

`VK_AMD_pipeline_compiler_control`

**Extension Type**

Device extension

**Registered Extension Number**

184

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

None

**Contact**

* 
Matthaeus G. Chajdas [anteru](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_AMD_pipeline_compiler_control] @anteru%0A*Here describe the issue or question you have about the VK_AMD_pipeline_compiler_control extension*)

**Last Modified Date**

2019-07-26

**IP Status**

No known IP claims.

**Contributors**

* 
Matthaeus G. Chajdas, AMD

* 
Daniel Rakos, AMD

* 
Maciej Jesionowski, AMD

* 
Tobias Hector, AMD

This extension introduces [VkPipelineCompilerControlCreateInfoAMD](../chapters/pipelines.html#VkPipelineCompilerControlCreateInfoAMD)
structure that can be chained to a pipelines creation information to
specify additional flags that affect pipeline compilation.

* 
Extending [VkGraphicsPipelineCreateInfo](../chapters/pipelines.html#VkGraphicsPipelineCreateInfo), [VkComputePipelineCreateInfo](../chapters/pipelines.html#VkComputePipelineCreateInfo), [VkExecutionGraphPipelineCreateInfoAMDX](../chapters/executiongraphs.html#VkExecutionGraphPipelineCreateInfoAMDX):

[VkPipelineCompilerControlCreateInfoAMD](../chapters/pipelines.html#VkPipelineCompilerControlCreateInfoAMD)

* 
[VkPipelineCompilerControlFlagBitsAMD](../chapters/pipelines.html#VkPipelineCompilerControlFlagBitsAMD)

* 
[VkPipelineCompilerControlFlagsAMD](../chapters/pipelines.html#VkPipelineCompilerControlFlagsAMD)

* 
`VK_AMD_PIPELINE_COMPILER_CONTROL_EXTENSION_NAME`

* 
`VK_AMD_PIPELINE_COMPILER_CONTROL_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD`

None.

None.

* 
Revision 1, 2019-07-26 (Tobias Hector)

Initial revision.

**Name String**

`VK_AMD_rasterization_order`

**Extension Type**

Device extension

**Registered Extension Number**

19

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

None

**Contact**

* 
Daniel Rakos [drakos-amd](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_AMD_rasterization_order] @drakos-amd%0A*Here describe the issue or question you have about the VK_AMD_rasterization_order extension*)

**Last Modified Date**

2016-04-25

**IP Status**

No known IP claims.

**Contributors**

* 
Matthaeus G. Chajdas, AMD

* 
Jaakko Konttinen, AMD

* 
Daniel Rakos, AMD

* 
Graham Sellers, AMD

* 
Dominik Witczak, AMD

This extension introduces the possibility for the application to control the
order of primitive rasterization.
In unextended Vulkan, the following stages are guaranteed to execute in *API
order*:

* 
depth bounds test

* 
stencil test, stencil op, and stencil write

* 
depth test and depth write

* 
occlusion queries

* 
blending, logic op, and color write

This extension enables applications to opt into a relaxed, implementation
defined primitive rasterization order that may allow better parallel
processing of primitives and thus enabling higher primitive throughput.
It is applicable in cases where the primitive rasterization order is known
to not affect the output of the rendering or any differences caused by a
different rasterization order are not a concern from the point of view of
the applications purpose.

A few examples of cases when using the relaxed primitive rasterization order
would not have an effect on the final rendering:

* 
If the primitives rendered are known to not overlap in framebuffer
space.

* 
If depth testing is used with a comparison operator of
`VK_COMPARE_OP_LESS`, `VK_COMPARE_OP_LESS_OR_EQUAL`,
`VK_COMPARE_OP_GREATER`, or `VK_COMPARE_OP_GREATER_OR_EQUAL`,
and the primitives rendered are known to not overlap in clip space.

* 
If depth testing is not used and blending is enabled for all attachments
with a commutative blend operator.

* 
Extending [VkPipelineRasterizationStateCreateInfo](../chapters/primsrast.html#VkPipelineRasterizationStateCreateInfo):

[VkPipelineRasterizationStateRasterizationOrderAMD](../chapters/primsrast.html#VkPipelineRasterizationStateRasterizationOrderAMD)

* 
[VkRasterizationOrderAMD](../chapters/primsrast.html#VkRasterizationOrderAMD)

* 
`VK_AMD_RASTERIZATION_ORDER_EXTENSION_NAME`

* 
`VK_AMD_RASTERIZATION_ORDER_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD`

1) How is this extension useful to application developers?

**RESOLVED**: Allows them to increase primitive throughput for cases when
strict API order rasterization is not important due to the nature of the
content, the configuration used, or the requirements towards the output of
the rendering.

2) How does this extension interact with content optimizations aiming to
reduce overdraw by appropriately ordering the input primitives?

**RESOLVED**: While the relaxed rasterization order might somewhat limit the
effectiveness of such content optimizations, most of the benefits of it are
expected to be retained even when the relaxed rasterization order is used,
so applications **should** still apply these optimizations even if they intend
to use the extension.

3) Are there any guarantees about the primitive rasterization order when
using the new relaxed mode?

**RESOLVED**: No.
In this case the rasterization order is completely implementation-dependent,
but in practice it is expected to partially still follow the order of
incoming primitives.

4) Does the new relaxed rasterization order have any adverse effect on
repeatability and other invariance rules of the API?

**RESOLVED**: Yes, in the sense that it extends the list of exceptions when
the repeatability requirement does not apply.

None

None

* 
Revision 1, 2016-04-25 (Daniel Rakos)

Initial draft.

**Name String**

`VK_AMD_shader_ballot`

**Extension Type**

Device extension

**Registered Extension Number**

38

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

None

**SPIR-V Dependencies**

* 
[SPV_AMD_shader_ballot](https://github.khronos.org/SPIRV-Registry/extensions/AMD/SPV_AMD_shader_ballot.html)

**Contact**

* 
Dominik Witczak [dominikwitczakamd](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_AMD_shader_ballot] @dominikwitczakamd%0A*Here describe the issue or question you have about the VK_AMD_shader_ballot extension*)

**Last Modified Date**

2016-09-19

**IP Status**

No known IP claims.

**Interactions and External Dependencies**

* 
This extension provides API support for
[`GL_AMD_shader_ballot`](https://registry.khronos.org/OpenGL/extensions/AMD/AMD_shader_ballot.txt)

**Contributors**

* 
Qun Lin, AMD

* 
Graham Sellers, AMD

* 
Daniel Rakos, AMD

* 
Rex Xu, AMD

* 
Dominik Witczak, AMD

* 
Matthus G. Chajdas, AMD

This extension adds support for the following SPIR-V extension in Vulkan:

* 
[`SPV_AMD_shader_ballot`](https://github.khronos.org/SPIRV-Registry/extensions/AMD/SPV_AMD_shader_ballot.html)

* 
`VK_AMD_SHADER_BALLOT_EXTENSION_NAME`

* 
`VK_AMD_SHADER_BALLOT_SPEC_VERSION`

* 
Revision 1, 2016-09-19 (Dominik Witczak)

Initial draft

**Name String**

`VK_AMD_shader_core_properties`

**Extension Type**

Device extension

**Registered Extension Number**

186

**Revision**

2

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Contact**

* 
Martin Dinkov [mdinkov](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_AMD_shader_core_properties] @mdinkov%0A*Here describe the issue or question you have about the VK_AMD_shader_core_properties extension*)

**Last Modified Date**

2019-06-25

**IP Status**

No known IP claims.

**Contributors**

* 
Martin Dinkov, AMD

* 
Matthaeus G. Chajdas, AMD

This extension exposes shader core properties for a target physical device
through the `[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)` extension.
Please refer to the example below for proper usage.

* 
Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

[VkPhysicalDeviceShaderCorePropertiesAMD](../chapters/limits.html#VkPhysicalDeviceShaderCorePropertiesAMD)

* 
`VK_AMD_SHADER_CORE_PROPERTIES_EXTENSION_NAME`

* 
`VK_AMD_SHADER_CORE_PROPERTIES_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD`

This example retrieves the shader core properties for a physical device.

extern VkInstance       instance;

PFN_vkGetPhysicalDeviceProperties2 pfnVkGetPhysicalDeviceProperties2 =
    reinterpret_cast
    (vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceProperties2") );

VkPhysicalDeviceProperties2             general_props;
VkPhysicalDeviceShaderCorePropertiesAMD shader_core_properties;

shader_core_properties.pNext = nullptr;
shader_core_properties.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD;

general_props.pNext = &shader_core_properties;
general_props.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2;

// After this call, shader_core_properties has been populated
pfnVkGetPhysicalDeviceProperties2(device, &general_props);

printf("Number of shader engines: %d\n",
    m_shader_core_properties.shader_engine_count =
    shader_core_properties.shaderEngineCount;
printf("Number of shader arrays: %d\n",
    m_shader_core_properties.shader_arrays_per_engine_count =
    shader_core_properties.shaderArraysPerEngineCount;
printf("Number of CUs per shader array: %d\n",
    m_shader_core_properties.compute_units_per_shader_array =
    shader_core_properties.computeUnitsPerShaderArray;
printf("Number of SIMDs per compute unit: %d\n",
    m_shader_core_properties.simd_per_compute_unit =
    shader_core_properties.simdPerComputeUnit;
printf("Number of wavefront slots in each SIMD: %d\n",
    m_shader_core_properties.wavefronts_per_simd =
    shader_core_properties.wavefrontsPerSimd;
printf("Number of threads per wavefront: %d\n",
    m_shader_core_properties.wavefront_size =
    shader_core_properties.wavefrontSize;
printf("Number of physical SGPRs per SIMD: %d\n",
    m_shader_core_properties.sgprs_per_simd =
    shader_core_properties.sgprsPerSimd;
printf("Minimum number of SGPRs that can be allocated by a wave: %d\n",
    m_shader_core_properties.min_sgpr_allocation =
    shader_core_properties.minSgprAllocation;
printf("Number of available SGPRs: %d\n",
    m_shader_core_properties.max_sgpr_allocation =
    shader_core_properties.maxSgprAllocation;
printf("SGPRs are allocated in groups of this size: %d\n",
    m_shader_core_properties.sgpr_allocation_granularity =
    shader_core_properties.sgprAllocationGranularity;
printf("Number of physical VGPRs per SIMD: %d\n",
    m_shader_core_properties.vgprs_per_simd =
    shader_core_properties.vgprsPerSimd;
printf("Minimum number of VGPRs that can be allocated by a wave: %d\n",
    m_shader_core_properties.min_vgpr_allocation =
    shader_core_properties.minVgprAllocation;
printf("Number of available VGPRs: %d\n",
    m_shader_core_properties.max_vgpr_allocation =
    shader_core_properties.maxVgprAllocation;
printf("VGPRs are allocated in groups of this size: %d\n",
    m_shader_core_properties.vgpr_allocation_granularity =
    shader_core_properties.vgprAllocationGranularity;

* 
Revision 2, 2019-06-25 (Matthaeus G. Chajdas)

Clarified the meaning of a few fields.

Revision 1, 2018-02-15 (Martin Dinkov)

* 
Initial draft.

**Name String**

`VK_AMD_shader_core_properties2`

**Extension Type**

Device extension

**Registered Extension Number**

228

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_AMD_shader_core_properties](#VK_AMD_shader_core_properties)

**Contact**

* 
Matthaeus G. Chajdas [anteru](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_AMD_shader_core_properties2] @anteru%0A*Here describe the issue or question you have about the VK_AMD_shader_core_properties2 extension*)

**Last Modified Date**

2019-07-26

**IP Status**

No known IP claims.

**Contributors**

* 
Matthaeus G. Chajdas, AMD

* 
Tobias Hector, AMD

This extension exposes additional shader core properties for a target
physical device through the `[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)`
extension.

* 
Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

[VkPhysicalDeviceShaderCoreProperties2AMD](../chapters/limits.html#VkPhysicalDeviceShaderCoreProperties2AMD)

* 
[VkShaderCorePropertiesFlagBitsAMD](../chapters/limits.html#VkShaderCorePropertiesFlagBitsAMD)

* 
[VkShaderCorePropertiesFlagsAMD](../chapters/limits.html#VkShaderCorePropertiesFlagsAMD)

* 
`VK_AMD_SHADER_CORE_PROPERTIES_2_EXTENSION_NAME`

* 
`VK_AMD_SHADER_CORE_PROPERTIES_2_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD`

None.

* 
Revision 1, 2019-07-26 (Matthaeus G. Chajdas)

Initial draft.

**Name String**

`VK_AMD_shader_early_and_late_fragment_tests`

**Extension Type**

Device extension

**Registered Extension Number**

322

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**SPIR-V Dependencies**

* 
[SPV_AMD_shader_early_and_late_fragment_tests](https://github.khronos.org/SPIRV-Registry/extensions/AMD/SPV_AMD_shader_early_and_late_fragment_tests.html)

**Contact**

* 
Tobias Hector [tobski](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_AMD_shader_early_and_late_fragment_tests] @tobski%0A*Here describe the issue or question you have about the VK_AMD_shader_early_and_late_fragment_tests extension*)

**Extension Proposal**

[VK_AMD_shader_early_and_late_fragment_tests](../../../features/latest/features/proposals/VK_AMD_shader_early_and_late_fragment_tests.html)

**Last Modified Date**

2021-09-14

**Interactions and External Dependencies**

* 
This extension interacts with `[VK_EXT_shader_stencil_export](#VK_EXT_shader_stencil_export)`

**Contributors**

* 
Tobias Hector, AMD

This extension adds support for the
[`SPV_AMD_shader_early_and_late_fragment_tests`](https://github.khronos.org/SPIRV-Registry/extensions/AMD/SPV_AMD_shader_early_and_late_fragment_tests.html)
extension, allowing shaders to explicitly opt in to allowing both early
*and* late fragment tests with the `EarlyAndLateFragmentTestsAMD`
execution mode.

If the `[VK_EXT_shader_stencil_export](#VK_EXT_shader_stencil_export)` extension is supported,
additional execution modes allowing early depth tests similar to
`DepthUnchanged`, `DepthLess`, and `DepthGreater` are provided.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD](../chapters/features.html#VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD)

* 
`VK_AMD_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_EXTENSION_NAME`

* 
`VK_AMD_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD`

* 
Revision 1, 2021-09-14 (Tobias Hector)

Initial draft

**Name String**

`VK_AMD_shader_explicit_vertex_parameter`

**Extension Type**

Device extension

**Registered Extension Number**

22

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

None

**SPIR-V Dependencies**

* 
[SPV_AMD_shader_explicit_vertex_parameter](https://github.khronos.org/SPIRV-Registry/extensions/AMD/SPV_AMD_shader_explicit_vertex_parameter.html)

**Contact**

* 
Qun Lin [linqun](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_AMD_shader_explicit_vertex_parameter] @linqun%0A*Here describe the issue or question you have about the VK_AMD_shader_explicit_vertex_parameter extension*)

**Last Modified Date**

2016-05-10

**IP Status**

No known IP claims.

**Interactions and External Dependencies**

* 
This extension provides API support for
[`GL_AMD_shader_explicit_vertex_parameter`](https://registry.khronos.org/OpenGL/extensions/AMD/AMD_shader_explicit_vertex_parameter.txt)

**Contributors**

* 
Matthaeus G. Chajdas, AMD

* 
Qun Lin, AMD

* 
Daniel Rakos, AMD

* 
Graham Sellers, AMD

* 
Rex Xu, AMD

This extension adds support for the following SPIR-V extension in Vulkan:

* 
[`SPV_AMD_shader_explicit_vertex_parameter`](https://github.khronos.org/SPIRV-Registry/extensions/AMD/SPV_AMD_shader_explicit_vertex_parameter.html)

* 
`VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_EXTENSION_NAME`

* 
`VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_SPEC_VERSION`

* 
Revision 1, 2016-05-10 (Daniel Rakos)

Initial draft

**Name String**

`VK_AMD_shader_fragment_mask`

**Extension Type**

Device extension

**Registered Extension Number**

138

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

None

**SPIR-V Dependencies**

* 
[SPV_AMD_shader_fragment_mask](https://github.khronos.org/SPIRV-Registry/extensions/AMD/SPV_AMD_shader_fragment_mask.html)

**Contact**

* 
Aaron Hagan [AaronHaganAMD](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_AMD_shader_fragment_mask] @AaronHaganAMD%0A*Here describe the issue or question you have about the VK_AMD_shader_fragment_mask extension*)

**Last Modified Date**

2017-08-16

**IP Status**

No known IP claims.

**Interactions and External Dependencies**

* 
This extension provides API support for
[`GL_AMD_shader_fragment_mask`](https://github.com/KhronosGroup/GLSL/blob/main/extensions/amd/GL_AMD_shader_fragment_mask.txt)

**Contributors**

* 
Aaron Hagan, AMD

* 
Daniel Rakos, AMD

* 
Timothy Lottes, AMD

This extension provides efficient read access to the fragment mask in
compressed multisampled color surfaces.
The fragment mask is a lookup table that associates color samples with color
fragment values.

From a shader, the fragment mask can be fetched with a call to
`fragmentMaskFetchAMD`, which returns a single `uint` where each
subsequent four bits specify the color fragment index corresponding to the
color sample, starting from the least significant bit.
For example, when eight color samples are used, the color fragment index for
color sample 0 will be in bits 0-3 of the fragment mask, for color sample 7
the index will be in bits 28-31.

The color fragment for a particular color sample may then be fetched with
the corresponding fragment mask value using the `fragmentFetchAMD` shader
function.

* 
`VK_AMD_SHADER_FRAGMENT_MASK_EXTENSION_NAME`

* 
`VK_AMD_SHADER_FRAGMENT_MASK_SPEC_VERSION`

* 
[`FragmentMaskAMD`](spirvenv.html#spirvenv-capabilities-table-FragmentMaskAMD)

This example shows a shader that queries the fragment mask from a
multisampled compressed surface and uses it to query fragment values.

#version 450 core

#extension GL_AMD_shader_fragment_mask: enable

layout(binding = 0) uniform sampler2DMS       s2DMS;
layout(binding = 1) uniform isampler2DMSArray is2DMSArray;

layout(binding = 2, input_attachment_index = 0) uniform usubpassInputMS usubpassMS;

layout(location = 0) out vec4 fragColor;

void main()
{
    vec4 fragOne = vec4(0.0);

    uint fragMask = fragmentMaskFetchAMD(s2DMS, ivec2(2, 3));
    uint fragIndex = (fragMask & 0xF0) >> 4;
    fragOne += fragmentFetchAMD(s2DMS, ivec2(2, 3), 1);

    fragMask = fragmentMaskFetchAMD(is2DMSArray, ivec3(2, 3, 1));
    fragIndex = (fragMask & 0xF0) >> 4;
    fragOne += fragmentFetchAMD(is2DMSArray, ivec3(2, 3, 1), fragIndex);

    fragMask = fragmentMaskFetchAMD(usubpassMS);
    fragIndex = (fragMask & 0xF0) >> 4;
    fragOne += fragmentFetchAMD(usubpassMS, fragIndex);

    fragColor = fragOne;
}

* 
Revision 1, 2017-08-16 (Aaron Hagan)

Initial draft

**Name String**

`VK_AMD_shader_image_load_store_lod`

**Extension Type**

Device extension

**Registered Extension Number**

47

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

None

**SPIR-V Dependencies**

* 
[SPV_AMD_shader_image_load_store_lod](https://github.khronos.org/SPIRV-Registry/extensions/AMD/SPV_AMD_shader_image_load_store_lod.html)

**Contact**

* 
Dominik Witczak [dominikwitczakamd](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_AMD_shader_image_load_store_lod] @dominikwitczakamd%0A*Here describe the issue or question you have about the VK_AMD_shader_image_load_store_lod extension*)

**Last Modified Date**

2017-08-21

**Interactions and External Dependencies**

* 
This extension provides API support for
[`GL_AMD_shader_image_load_store_lod`](https://registry.khronos.org/OpenGL/extensions/AMD/AMD_shader_image_load_store_lod.txt)

**IP Status**

No known IP claims.

**Contributors**

* 
Dominik Witczak, AMD

* 
Qun Lin, AMD

* 
Rex Xu, AMD

This extension adds support for the following SPIR-V extension in Vulkan:

* 
[`SPV_AMD_shader_image_load_store_lod`](https://github.khronos.org/SPIRV-Registry/extensions/AMD/SPV_AMD_shader_image_load_store_lod.html)

* 
`VK_AMD_SHADER_IMAGE_LOAD_STORE_LOD_EXTENSION_NAME`

* 
`VK_AMD_SHADER_IMAGE_LOAD_STORE_LOD_SPEC_VERSION`

* 
Revision 1, 2017-08-21 (Dominik Witczak)

Initial draft

**Name String**

`VK_AMD_shader_info`

**Extension Type**

Device extension

**Registered Extension Number**

43

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

None

**Special Use**

* 
[Developer tools](../chapters/extensions.html#extendingvulkan-compatibility-specialuse)

**Contact**

* 
Jaakko Konttinen [jaakkoamd](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_AMD_shader_info] @jaakkoamd%0A*Here describe the issue or question you have about the VK_AMD_shader_info extension*)

**Last Modified Date**

2017-10-09

**IP Status**

No known IP claims.

**Contributors**

* 
Jaakko Konttinen, AMD

This extension adds a way to query certain information about a compiled
shader which is part of a pipeline.
This information may include shader disassembly, shader binary and various
statistics about a shaders resource usage.

While this extension provides a mechanism for extracting this information,
the details regarding the contents or format of this information are not
specified by this extension and may be provided by the vendor externally.

Furthermore, all information types are optionally supported, and users
should not assume every implementation supports querying every type of
information.

* 
[vkGetShaderInfoAMD](../chapters/pipelines.html#vkGetShaderInfoAMD)

* 
[VkShaderResourceUsageAMD](../chapters/pipelines.html#VkShaderResourceUsageAMD)

* 
[VkShaderStatisticsInfoAMD](../chapters/pipelines.html#VkShaderStatisticsInfoAMD)

* 
[VkShaderInfoTypeAMD](../chapters/pipelines.html#VkShaderInfoTypeAMD)

* 
`VK_AMD_SHADER_INFO_EXTENSION_NAME`

* 
`VK_AMD_SHADER_INFO_SPEC_VERSION`

This example extracts the register usage of a fragment shader within a
particular graphics pipeline:

extern VkDevice device;
extern VkPipeline gfxPipeline;

PFN_vkGetShaderInfoAMD pfnGetShaderInfoAMD = (PFN_vkGetShaderInfoAMD)vkGetDeviceProcAddr(
    device, "vkGetShaderInfoAMD");

VkShaderStatisticsInfoAMD statistics = {};

size_t dataSize = sizeof(statistics);

if (pfnGetShaderInfoAMD(device,
    gfxPipeline,
    VK_SHADER_STAGE_FRAGMENT_BIT,
    VK_SHADER_INFO_TYPE_STATISTICS_AMD,
    &dataSize,
    &statistics) == VK_SUCCESS)
{
    printf("VGPR usage: %d\n", statistics.resourceUsage.numUsedVgprs);
    printf("SGPR usage: %d\n", statistics.resourceUsage.numUsedSgprs);
}

The following example continues the previous example by subsequently
attempting to query and print shader disassembly about the fragment shader:

// Query disassembly size (if available)
if (pfnGetShaderInfoAMD(device,
    gfxPipeline,
    VK_SHADER_STAGE_FRAGMENT_BIT,
    VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD,
    &dataSize,
    nullptr) == VK_SUCCESS)
{
    printf("Fragment shader disassembly:\n");

    void* disassembly = malloc(dataSize);

    // Query disassembly and print
    if (pfnGetShaderInfoAMD(device,
        gfxPipeline,
        VK_SHADER_STAGE_FRAGMENT_BIT,
        VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD,
        &dataSize,
        disassembly) == VK_SUCCESS)
    {
        printf((char*)disassembly);
    }

    free(disassembly);
}

* 
Revision 1, 2017-10-09 (Jaakko Konttinen)

Initial revision

**Name String**

`VK_AMD_shader_trinary_minmax`

**Extension Type**

Device extension

**Registered Extension Number**

21

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

None

**SPIR-V Dependencies**

* 
[SPV_AMD_shader_trinary_minmax](https://github.khronos.org/SPIRV-Registry/extensions/AMD/SPV_AMD_shader_trinary_minmax.html)

**Contact**

* 
Qun Lin [linqun](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_AMD_shader_trinary_minmax] @linqun%0A*Here describe the issue or question you have about the VK_AMD_shader_trinary_minmax extension*)

**Last Modified Date**

2016-05-10

**IP Status**

No known IP claims.

**Interactions and External Dependencies**

* 
This extension provides API support for
[`GL_AMD_shader_trinary_minmax`](https://registry.khronos.org/OpenGL/extensions/AMD/AMD_shader_trinary_minmax.txt)

**Contributors**

* 
Matthaeus G. Chajdas, AMD

* 
Qun Lin, AMD

* 
Daniel Rakos, AMD

* 
Graham Sellers, AMD

* 
Rex Xu, AMD

This extension adds support for the following SPIR-V extension in Vulkan:

* 
[`SPV_AMD_shader_trinary_minmax`](https://github.khronos.org/SPIRV-Registry/extensions/AMD/SPV_AMD_shader_trinary_minmax.html)

* 
`VK_AMD_SHADER_TRINARY_MINMAX_EXTENSION_NAME`

* 
`VK_AMD_SHADER_TRINARY_MINMAX_SPEC_VERSION`

* 
Revision 1, 2016-05-10 (Daniel Rakos)

Initial draft

**Name String**

`VK_AMD_texture_gather_bias_lod`

**Extension Type**

Device extension

**Registered Extension Number**

42

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**SPIR-V Dependencies**

* 
[SPV_AMD_texture_gather_bias_lod](https://github.khronos.org/SPIRV-Registry/extensions/AMD/SPV_AMD_texture_gather_bias_lod.html)

**Contact**

* 
Rex Xu [amdrexu](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_AMD_texture_gather_bias_lod] @amdrexu%0A*Here describe the issue or question you have about the VK_AMD_texture_gather_bias_lod extension*)

**Last Modified Date**

2017-03-21

**IP Status**

No known IP claims.

**Interactions and External Dependencies**

* 
This extension provides API support for
[`GL_AMD_texture_gather_bias_lod`](https://registry.khronos.org/OpenGL/extensions/AMD/AMD_texture_gather_bias_lod.txt)

**Contributors**

* 
Dominik Witczak, AMD

* 
Daniel Rakos, AMD

* 
Graham Sellers, AMD

* 
Matthaeus G. Chajdas, AMD

* 
Qun Lin, AMD

* 
Rex Xu, AMD

* 
Timothy Lottes, AMD

This extension adds two related features.

Firstly, support for the following SPIR-V extension in Vulkan is added:

* 
`SPV_AMD_texture_gather_bias_lod`

Secondly, the extension allows the application to query which formats can be
used together with the new function prototypes introduced by the SPIR-V
extension.

* 
Extending [VkImageFormatProperties2](../chapters/capabilities.html#VkImageFormatProperties2):

[VkTextureLODGatherFormatPropertiesAMD](../chapters/capabilities.html#VkTextureLODGatherFormatPropertiesAMD)

* 
`VK_AMD_TEXTURE_GATHER_BIAS_LOD_EXTENSION_NAME`

* 
`VK_AMD_TEXTURE_GATHER_BIAS_LOD_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD`

* 
[    `ImageGatherBiasLodAMD`](spirvenv.html#spirvenv-capabilities-table-ImageGatherBiasLodAMD)

struct VkTextureLODGatherFormatPropertiesAMD
{
    VkStructureType sType;
    const void*     pNext;
    VkBool32        supportsTextureGatherLODBiasAMD;
};

// ----------------------------------------------------------------------------------------
// How to detect if an image format can be used with the new function prototypes.
VkPhysicalDeviceImageFormatInfo2   formatInfo;
VkImageFormatProperties2           formatProps;
VkTextureLODGatherFormatPropertiesAMD textureLODGatherSupport;

textureLODGatherSupport.sType = VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD;
textureLODGatherSupport.pNext = nullptr;

formatInfo.sType  = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2;
formatInfo.pNext  = nullptr;
formatInfo.format = ...;
formatInfo.type   = ...;
formatInfo.tiling = ...;
formatInfo.usage  = ...;
formatInfo.flags  = ...;

formatProps.sType = VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2;
formatProps.pNext = &textureLODGatherSupport;

vkGetPhysicalDeviceImageFormatProperties2(physical_device, &formatInfo, &formatProps);

if (textureLODGatherSupport.supportsTextureGatherLODBiasAMD == VK_TRUE)
{
    // physical device supports SPV_AMD_texture_gather_bias_lod for the specified
    // format configuration.
}
else
{
    // physical device does not support SPV_AMD_texture_gather_bias_lod for the
    // specified format configuration.
}

* 
Revision 1, 2017-03-21 (Dominik Witczak)

Initial draft

**Name String**

`VK_ANDROID_external_format_resolve`

**Extension Type**

Device extension

**Registered Extension Number**

469

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_ANDROID_external_memory_android_hardware_buffer](#VK_ANDROID_external_memory_android_hardware_buffer)

**API Interactions**

* 
Interacts with VK_VERSION_1_3

* 
Interacts with VK_KHR_dynamic_rendering

**Special Use**

* 
[OpenGL / ES support](../chapters/extensions.html#extendingvulkan-compatibility-specialuse)

**Contact**

* 
Chris Forbes [chrisforbes](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_ANDROID_external_format_resolve] @chrisforbes%0A*Here describe the issue or question you have about the VK_ANDROID_external_format_resolve extension*)

**Extension Proposal**

[VK_ANDROID_external_format_resolve](../../../features/latest/features/proposals/VK_ANDROID_external_format_resolve.html)

**Last Modified Date**

2023-05-03

**IP Status**

No known IP claims.

**Contributors**

* 
Tobias Hector, AMD

* 
Chris Forbes, Google

* 
Jan-Harald Fredriksen, Arm

* 
Shahbaz Youssefi, Google

* 
Matthew Netsch, Qualcomm

* 
Tony Zlatsinki, Nvidia

* 
Daniel Koch, Nvidia

* 
Jeff Leger, Qualcomm

* 
Alex Walters, Imagination

* 
Andrew Garrard, Imagination

* 
Ralph Potter, Samsung

* 
Ian Elliott, Google

This extension enables rendering to Android Hardware Buffers with external
formats which cannot be directly represented as renderable in Vulkan,
including YCBCR formats.

* 
Extending [VkAndroidHardwareBufferPropertiesANDROID](../chapters/memory.html#VkAndroidHardwareBufferPropertiesANDROID):

[VkAndroidHardwareBufferFormatResolvePropertiesANDROID](../chapters/memory.html#VkAndroidHardwareBufferFormatResolvePropertiesANDROID)

Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

* 
[VkPhysicalDeviceExternalFormatResolveFeaturesANDROID](../chapters/features.html#VkPhysicalDeviceExternalFormatResolveFeaturesANDROID)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceExternalFormatResolvePropertiesANDROID](../chapters/limits.html#VkPhysicalDeviceExternalFormatResolvePropertiesANDROID)

* 
`VK_ANDROID_EXTERNAL_FORMAT_RESOLVE_EXTENSION_NAME`

* 
`VK_ANDROID_EXTERNAL_FORMAT_RESOLVE_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_RESOLVE_PROPERTIES_ANDROID`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_FEATURES_ANDROID`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_PROPERTIES_ANDROID`

If [VK_KHR_dynamic_rendering](#VK_KHR_dynamic_rendering) or [Vulkan Version 1.3](versions.html#versions-1.3) is supported:

* 
Extending [VkResolveModeFlagBits](../chapters/renderpass.html#VkResolveModeFlagBits):

`VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID`

* 
Revision 1, 2023-05-34 (Tobias Hector)

Initial version

**Name String**

`VK_ANDROID_external_memory_android_hardware_buffer`

**Extension Type**

Device extension

**Registered Extension Number**

130

**Revision**

5

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

 [VK_KHR_sampler_ycbcr_conversion](#VK_KHR_sampler_ycbcr_conversion)

 and

 [VK_KHR_external_memory](#VK_KHR_external_memory)

 and

 [VK_KHR_dedicated_allocation](#VK_KHR_dedicated_allocation)

 or

 [Vulkan Version 1.1](versions.html#versions-1.1)

and

[VK_EXT_queue_family_foreign](#VK_EXT_queue_family_foreign)

**API Interactions**

* 
Interacts with VK_VERSION_1_3

* 
Interacts with VK_KHR_format_feature_flags2

**Contact**

* 
Jesse Hall [critsec](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_ANDROID_external_memory_android_hardware_buffer] @critsec%0A*Here describe the issue or question you have about the VK_ANDROID_external_memory_android_hardware_buffer extension*)

**Last Modified Date**

2021-09-30

**IP Status**

No known IP claims.

**Contributors**

* 
Ray Smith, ARM

* 
Lina Versace, Google

* 
Jesse Hall, Google

* 
Tobias Hector, Imagination

* 
James Jones, NVIDIA

* 
Tony Zlatinski, NVIDIA

* 
Matthew Netsch, Qualcomm

* 
Andrew Garrard, Samsung

This extension enables an application to import Android
`AHardwareBuffer` objects created outside of the Vulkan device into
Vulkan memory objects, where they **can** be bound to images and buffers.
It also allows exporting an `AHardwareBuffer` from a Vulkan memory
object for symmetry with other operating systems.
But since not all `AHardwareBuffer` usages and formats have Vulkan
equivalents, exporting from Vulkan provides strictly less functionality than
creating the `AHardwareBuffer` externally and importing it.

Some `AHardwareBuffer` images have implementation-defined *external
formats* that **may** not correspond to Vulkan formats.
Sampler YCBCR conversion **can** be used to sample from these images and
convert them to a known color space.

* 
`AHardwareBuffer`

* 
[vkGetAndroidHardwareBufferPropertiesANDROID](../chapters/memory.html#vkGetAndroidHardwareBufferPropertiesANDROID)

* 
[vkGetMemoryAndroidHardwareBufferANDROID](../chapters/memory.html#vkGetMemoryAndroidHardwareBufferANDROID)

* 
[VkAndroidHardwareBufferPropertiesANDROID](../chapters/memory.html#VkAndroidHardwareBufferPropertiesANDROID)

* 
[VkMemoryGetAndroidHardwareBufferInfoANDROID](../chapters/memory.html#VkMemoryGetAndroidHardwareBufferInfoANDROID)

* 
Extending [VkAndroidHardwareBufferPropertiesANDROID](../chapters/memory.html#VkAndroidHardwareBufferPropertiesANDROID):

[VkAndroidHardwareBufferFormatPropertiesANDROID](../chapters/memory.html#VkAndroidHardwareBufferFormatPropertiesANDROID)

Extending [VkImageCreateInfo](../chapters/resources.html#VkImageCreateInfo), [VkSamplerYcbcrConversionCreateInfo](../chapters/samplers.html#VkSamplerYcbcrConversionCreateInfo), [VkAttachmentDescription2](../chapters/renderpass.html#VkAttachmentDescription2), [VkGraphicsPipelineCreateInfo](../chapters/pipelines.html#VkGraphicsPipelineCreateInfo), [VkCommandBufferInheritanceInfo](../chapters/cmdbuffers.html#VkCommandBufferInheritanceInfo):

* 
[VkExternalFormatANDROID](../chapters/resources.html#VkExternalFormatANDROID)

Extending [VkImageFormatProperties2](../chapters/capabilities.html#VkImageFormatProperties2):

* 
[VkAndroidHardwareBufferUsageANDROID](../chapters/capabilities.html#VkAndroidHardwareBufferUsageANDROID)

Extending [VkMemoryAllocateInfo](../chapters/memory.html#VkMemoryAllocateInfo):

* 
[VkImportAndroidHardwareBufferInfoANDROID](../chapters/memory.html#VkImportAndroidHardwareBufferInfoANDROID)

If [VK_KHR_format_feature_flags2](#VK_KHR_format_feature_flags2) or [Vulkan Version 1.3](versions.html#versions-1.3) is supported:

* 
Extending [VkAndroidHardwareBufferPropertiesANDROID](../chapters/memory.html#VkAndroidHardwareBufferPropertiesANDROID):

[VkAndroidHardwareBufferFormatProperties2ANDROID](../chapters/memory.html#VkAndroidHardwareBufferFormatProperties2ANDROID)

* 
`VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_EXTENSION_NAME`

* 
`VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_SPEC_VERSION`

* 
Extending [VkExternalMemoryHandleTypeFlagBits](../chapters/capabilities.html#VkExternalMemoryHandleTypeFlagBits):

`VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID`

* 
`VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID`

* 
`VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID`

* 
`VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID`

* 
`VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID`

* 
`VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID`

If [VK_KHR_format_feature_flags2](#VK_KHR_format_feature_flags2) or [Vulkan Version 1.3](versions.html#versions-1.3) is supported:

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID`

1) Other external memory objects are represented as weakly-typed handles
(e.g. Win32 `HANDLE` or POSIX file descriptor), and require a handle type
parameter along with handles.
`AHardwareBuffer` is strongly typed, so naming the handle type is
redundant.
Does symmetry justify adding handle type parameters/fields anyway?

**RESOLVED**: No.
The handle type is already provided in places that treat external memory
objects generically.
In the places we would add it, the application code that would have to
provide the handle type value is already dealing with
`AHardwareBuffer`-specific commands/structures; the extra symmetry
would not be enough to make that code generic.

2) The internal layout and therefore size of a `AHardwareBuffer`
image may depend on native usage flags that do not have corresponding Vulkan
counterparts.
Do we provide this information to [vkCreateImage](../chapters/resources.html#vkCreateImage) somehow, or allow the
allocation size reported by [vkGetImageMemoryRequirements](../chapters/resources.html#vkGetImageMemoryRequirements) to be
approximate?

**RESOLVED**: Allow the allocation size to be unspecified when allocating the
memory.
It has to work this way for exported image memory anyway, since
`AHardwareBuffer` allocation happens in [vkAllocateMemory](../chapters/memory.html#vkAllocateMemory), and
internally is performed by a separate HAL, not the Vulkan implementation
itself.
There is a similar issue with [vkGetImageSubresourceLayout](../chapters/resources.html#vkGetImageSubresourceLayout): the layout
is determined by the allocator HAL, so it is not known until the image is
bound to memory.

3) Should the result of sampling an external-format image with the suggested
YCBCR conversion parameters yield the same results as using a
`samplerExternalOES` in OpenGL ES?

**RESOLVED**: This would be desirable, so that apps converting from OpenGL ES
to Vulkan could get the same output given the same input.
But since sampling and conversion from YCBCR images is so loosely defined
in OpenGL ES, multiple implementations do it in a way that does not conform
to Vulkans requirements.
Modifying the OpenGL ES implementation would be difficult, and would change
the output of existing unmodified applications.
Changing the output only for applications that are being modified gives
developers the chance to notice and mitigate any problems.
Implementations are encouraged to minimize differences as much as possible
without causing compatibility problems for existing OpenGL ES applications
or violating Vulkan requirements.

4) Should an `AHardwareBuffer` with `AHARDWAREBUFFER_USAGE_CPU_*`
usage be mappable in Vulkan? Should it be possible to export an
`AHardwareBuffers` with such usage?

**RESOLVED**: Optional, and mapping in Vulkan is not the same as
`AHardwareBuffer_lock`.
The semantics of these are different: mapping in memory is persistent, just
gives a raw view of the memory contents, and does not involve ownership.
`AHardwareBuffer_lock` gives the host exclusive access to the buffer, is
temporary, and allows for reformatting copy-in/copy-out.
Implementations are not required to support host-visible memory types for
imported Android hardware buffers or resources backed by them.
If a host-visible memory type is supported and used, the memory can be
mapped in Vulkan, but doing so follows Vulkan semantics: it is just a raw
view of the data and does not imply ownership (this means implementations
must not internally call `AHardwareBuffer_lock` to implement
[vkMapMemory](../chapters/memory.html#vkMapMemory), or assume the application has done so).
Implementations are not required to support linear-tiled images backed by
Android hardware buffers, even if the `AHardwareBuffer` has CPU
usage.
There is no reliable way to allocate memory in Vulkan that can be exported
to a `AHardwareBuffer` with CPU usage.

5) Android may add new `AHardwareBuffer` formats and usage flags over
time.
Can reference to them be added to this extension, or do they need a new
extension?

**RESOLVED**: This extension can document the interaction between the new AHB
formats/usages and existing Vulkan features.
No new Vulkan features or implementation requirements can be added.
The extension version number will be incremented when this additional
documentation is added, but the version number does not indicate that an
implementation supports Vulkan memory or resources that map to the new
`AHardwareBuffer` features: support for that must be queried with
[vkGetPhysicalDeviceImageFormatProperties2](../chapters/capabilities.html#vkGetPhysicalDeviceImageFormatProperties2) or is implied by
successfully allocating a `AHardwareBuffer` outside of Vulkan that
uses the new feature and has a GPU usage flag.

In essence, these are new features added to a new Android API level, rather
than new Vulkan features.
The extension will only document how existing Vulkan features map to that
new Android feature.

* 
Revision 5, 2022-02-04 (Chris Forbes)

Describe mapping of flags for storage image support

Revision 4, 2021-09-30 (Jon Leech)

* 
Add interaction with `[VK_KHR_format_feature_flags2](#VK_KHR_format_feature_flags2)` to `vk.xml`

Revision 3, 2019-08-27 (Jon Leech)

* 
Update revision history to correspond to XML version number

Revision 2, 2018-04-09 (Petr Kraus)

* 
Markup fixes and remove incorrect Draft status

Revision 1, 2018-03-04 (Jesse Hall)

* 
Initial version

**Name String**

`VK_ARM_format_pack`

**Extension Type**

Device extension

**Registered Extension Number**

610

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

None

**Contact**

* 
Jan-Harald Fredriksen [janharaldfredriksen-arm](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_ARM_format_pack] @janharaldfredriksen-arm%0A*Here describe the issue or question you have about the VK_ARM_format_pack extension*)

**Last Modified Date**

2025-03-24

**Interactions and External Dependencies**
**Contributors**

* 
Jan-Harald Fredriksen, Arm

* 
Lisa Wu, Arm

* 
Oivind Boge, Arm

This extension adds support for additional 1-, 2- and 4-component formats
with 10, 12, or 14 bits of components in 16-bit containers.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceFormatPackFeaturesARM](../chapters/features.html#VkPhysicalDeviceFormatPackFeaturesARM)

* 
`VK_ARM_FORMAT_PACK_EXTENSION_NAME`

* 
`VK_ARM_FORMAT_PACK_SPEC_VERSION`

* 
Extending [VkFormat](../chapters/formats.html#VkFormat):

`VK_FORMAT_G14X2_B14X2R14X2_2PLANE_420_UNORM_3PACK16_ARM`

* 
`VK_FORMAT_G14X2_B14X2R14X2_2PLANE_422_UNORM_3PACK16_ARM`

* 
`VK_FORMAT_R10X6G10X6B10X6A10X6_UINT_4PACK16_ARM`

* 
`VK_FORMAT_R10X6G10X6_UINT_2PACK16_ARM`

* 
`VK_FORMAT_R10X6_UINT_PACK16_ARM`

* 
`VK_FORMAT_R12X4G12X4B12X4A12X4_UINT_4PACK16_ARM`

* 
`VK_FORMAT_R12X4G12X4_UINT_2PACK16_ARM`

* 
`VK_FORMAT_R12X4_UINT_PACK16_ARM`

* 
`VK_FORMAT_R14X2G14X2B14X2A14X2_UINT_4PACK16_ARM`

* 
`VK_FORMAT_R14X2G14X2B14X2A14X2_UNORM_4PACK16_ARM`

* 
`VK_FORMAT_R14X2G14X2_UINT_2PACK16_ARM`

* 
`VK_FORMAT_R14X2G14X2_UNORM_2PACK16_ARM`

* 
`VK_FORMAT_R14X2_UINT_PACK16_ARM`

* 
`VK_FORMAT_R14X2_UNORM_PACK16_ARM`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FORMAT_PACK_FEATURES_ARM`

**RESOLVED**

Many existing extension have the format in the name, but in this case we
want to expose multiple formats.

We will describe this set of formats as a "pack".

**RESOLVED**

Should these additional formats be in the same compatibility class as any
other formats? For single-plane formats, we put formats with the same number
of bits (but different types) in the same class.
Each multi-plane or subsampled format gets its own compatibility class.
This is consistent with how existing formats are handled.

**RESOLVED**

The format feature queries could be used to determine what is supported on
any given implementation, but it may be useful to establish a baseline
requirement in the specification.
For that purpose, we require a set of format features - sufficient to enable
texture operations - to be supported for the added unsigned integer
single-plane formats.
Other formats and format features are optional.

* 
Revision 1, 2025-03-24

Initial revision

**Name String**

`VK_ARM_pipeline_opacity_micromap`

**Extension Type**

Device extension

**Registered Extension Number**

597

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_EXT_opacity_micromap](#VK_EXT_opacity_micromap)

**Contact**

* 
Mathieu Robart [mathieurobart-arm](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_ARM_pipeline_opacity_micromap] @mathieurobart-arm%0A*Here describe the issue or question you have about the VK_ARM_pipeline_opacity_micromap extension*)

**Extension Proposal**

[VK_ARM_pipeline_opacity_micromap](../../../features/latest/features/proposals/VK_ARM_pipeline_opacity_micromap.html)

**Last Modified Date**

2025-01-07

**IP Status**

No known IP claims.

**Contributors**

* 
Mathieu Robart, Arm

* 
Marius Bjorge, Arm

* 
Yaozhong Zhang, Arm

* 
Jan-Harald Fredriksen, Arm

The Opacity Micromap extension `VK_EXT_opacity_micromap` supports the new
pipeline creation flag
`VK_PIPELINE_CREATE_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT`, indicating that
the ray tracing pipeline may be used with acceleration structures
referencing micromaps.
This allows for possible optimizations, knowing beforehand that opacity
micromaps may be used with the pipeline.

An equivalent flag does not exist for pipelines supporting Ray Query with
opacity micromaps, such as graphics and compute.
Consequently, it is currently not possible to optimize such pipelines for
no-opacity, e.g. when opacity micromaps are supported by an application but
not used by the pipeline.
This may lead to performance degradation.

This extension adds a new flag,
`VK_PIPELINE_CREATE_2_DISALLOW_OPACITY_MICROMAP_BIT_ARM`, indicating that a
pipeline will NOT be used with an acceleration structure referencing an
opacity micromap, therefore allowing possible pipeline optimizations.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDevicePipelineOpacityMicromapFeaturesARM](../chapters/features.html#VkPhysicalDevicePipelineOpacityMicromapFeaturesARM)

* 
`VK_ARM_PIPELINE_OPACITY_MICROMAP_EXTENSION_NAME`

* 
`VK_ARM_PIPELINE_OPACITY_MICROMAP_SPEC_VERSION`

* 
Extending [VkPipelineCreateFlagBits2](../chapters/pipelines.html#VkPipelineCreateFlagBits2):

`VK_PIPELINE_CREATE_2_DISALLOW_OPACITY_MICROMAP_BIT_ARM`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_OPACITY_MICROMAP_FEATURES_ARM`

None.

None.

* 
Revision 1, 2025-01-07 (Mathieu Robart)

Initial draft

**Name String**

`VK_ARM_render_pass_striped`

**Extension Type**

Device extension

**Registered Extension Number**

425

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

 [VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

 or

 [Vulkan Version 1.1](versions.html#versions-1.1)

 and

 [VK_KHR_synchronization2](#VK_KHR_synchronization2)

or

[Vulkan Version 1.3](versions.html#versions-1.3)

**Contact**

* 
Jan-Harald Fredriksen [janharaldfredriksen-arm](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_ARM_render_pass_striped] @janharaldfredriksen-arm%0A*Here describe the issue or question you have about the VK_ARM_render_pass_striped extension*)

**Extension Proposal**

[VK_ARM_render_pass_striped](../../../features/latest/features/proposals/VK_ARM_render_pass_striped.html)

**Last Modified Date**

2023-11-21

**IP Status**

No known IP claims.

**Contributors**

* 
Jan-Harald Fredriksen, Arm

* 
Lisa Wu, Arm

* 
Torbjorn Nilsson, Arm

* 
Ying-Chieh Chen, Mediatek

* 
Jim Chiu, Mediatek

This extension adds the ability to split a render pass instance into
stripes, and to get a notification when rendering has completed for each
stripe.

* 
[VkRenderPassStripeInfoARM](../chapters/renderpass.html#VkRenderPassStripeInfoARM)

* 
Extending [VkCommandBufferSubmitInfo](../chapters/cmdbuffers.html#VkCommandBufferSubmitInfo):

[VkRenderPassStripeSubmitInfoARM](../chapters/cmdbuffers.html#VkRenderPassStripeSubmitInfoARM)

Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

* 
[VkPhysicalDeviceRenderPassStripedFeaturesARM](../chapters/features.html#VkPhysicalDeviceRenderPassStripedFeaturesARM)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceRenderPassStripedPropertiesARM](../chapters/limits.html#VkPhysicalDeviceRenderPassStripedPropertiesARM)

Extending [VkRenderingInfo](../chapters/renderpass.html#VkRenderingInfo), [VkRenderPassBeginInfo](../chapters/renderpass.html#VkRenderPassBeginInfo):

* 
[VkRenderPassStripeBeginInfoARM](../chapters/renderpass.html#VkRenderPassStripeBeginInfoARM)

* 
`VK_ARM_RENDER_PASS_STRIPED_EXTENSION_NAME`

* 
`VK_ARM_RENDER_PASS_STRIPED_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_FEATURES_ARM`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_PROPERTIES_ARM`

* 
`VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_BEGIN_INFO_ARM`

* 
`VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_INFO_ARM`

* 
`VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_SUBMIT_INFO_ARM`

None.

* 
Revision 1, 2023-11-21

Initial revision

**Name String**

`VK_ARM_scheduling_controls`

**Extension Type**

Device extension

**Registered Extension Number**

418

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_ARM_shader_core_builtins](#VK_ARM_shader_core_builtins)

**Contact**

* 
Kevin Petit [kpet](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_ARM_scheduling_controls] @kpet%0A*Here describe the issue or question you have about the VK_ARM_scheduling_controls extension*)

**Last Modified Date**

2023-08-23

**Interactions and External Dependencies**

None

**IP Status**

No known IP claims.

**Contributors**

* 
Kvin Petit, Arm Ltd.

* 
Jan-Harald Fredriksen, Arm Ltd.

* 
Mikel Garai, Arm Ltd.

This extension exposes a collection of controls to modify the scheduling
behavior of Arm Mali devices.

* 
Extending [VkDeviceQueueCreateInfo](../chapters/devsandqueues.html#VkDeviceQueueCreateInfo), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkDeviceQueueShaderCoreControlCreateInfoARM](../chapters/devsandqueues.html#VkDeviceQueueShaderCoreControlCreateInfoARM)

Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

* 
[VkPhysicalDeviceSchedulingControlsFeaturesARM](../chapters/features.html#VkPhysicalDeviceSchedulingControlsFeaturesARM)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceSchedulingControlsPropertiesARM](../chapters/devsandqueues.html#VkPhysicalDeviceSchedulingControlsPropertiesARM)

* 
[VkPhysicalDeviceSchedulingControlsFlagBitsARM](../chapters/devsandqueues.html#VkPhysicalDeviceSchedulingControlsFlagBitsARM)

* 
[VkPhysicalDeviceSchedulingControlsFlagsARM](../chapters/devsandqueues.html#VkPhysicalDeviceSchedulingControlsFlagsARM)

* 
`VK_ARM_SCHEDULING_CONTROLS_EXTENSION_NAME`

* 
`VK_ARM_SCHEDULING_CONTROLS_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_DEVICE_QUEUE_SHADER_CORE_CONTROL_CREATE_INFO_ARM`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_FEATURES_ARM`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_PROPERTIES_ARM`

None.

None.

* 
Revision 1, 2023-08-23 (Kvin Petit)

Initial revision

**Name String**

`VK_ARM_shader_core_builtins`

**Extension Type**

Device extension

**Registered Extension Number**

498

**Revision**

2

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**SPIR-V Dependencies**

* 
[SPV_ARM_core_builtins](https://github.khronos.org/SPIRV-Registry/extensions/ARM/SPV_ARM_core_builtins.html)

**Contact**

* 
Kevin Petit [kpet](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_ARM_shader_core_builtins] @kpet%0A*Here describe the issue or question you have about the VK_ARM_shader_core_builtins extension*)

**Last Modified Date**

2022-10-05

**Interactions and External Dependencies**

* 
This extension provides API support for
[`GL_ARM_shader_core_builtins`](https://github.com/KhronosGroup/GLSL/blob/main/extensions/arm/GLSL_ARM_shader_core_builtins.txt)

**Contributors**

* 
Kevin Petit, Arm Ltd.

* 
Jan-Harald Fredriksen, Arm Ltd.

This extension provides the ability to determine device-specific properties
on Arm GPUs.
It exposes properties for the number of shader cores, the maximum number of
warps that can run on a shader core, and shader builtins to enable
invocations to identify which core and warp a shader invocation is executing
on.

This extension enables support for the SPIR-V `CoreBuiltinsARM`
capability.

These properties and built-ins can be used for debugging or performance
optimization purposes.
A typical optimization example would be to use `CoreIDARM` to select a
per-shader-core instance of a data structure in algorithms that use atomics
so as to reduce contention.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM](../chapters/features.html#VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM](../chapters/limits.html#VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM)

* 
`VK_ARM_SHADER_CORE_BUILTINS_EXTENSION_NAME`

* 
`VK_ARM_SHADER_CORE_BUILTINS_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM`

* 
[`CoreCountARM`](../chapters/interfaces.html#interfaces-builtin-variables-corecountarm)

* 
[`CoreMaxIDARM`](../chapters/interfaces.html#interfaces-builtin-variables-coremaxidarm)

* 
[`CoreIDARM`](../chapters/interfaces.html#interfaces-builtin-variables-coreidarm)

* 
[`WarpsMaxIDARM`](../chapters/interfaces.html#interfaces-builtin-variables-warpmaxidarm)

* 
[`WarpIDARM`](../chapters/interfaces.html#interfaces-builtin-variables-warpidarm)

* 
[`CoreBuiltinsARM`](spirvenv.html#spirvenv-capabilities-table-CoreBuiltinsARM)

None.

* 
Revision 1, 2022-10-05 (Kevin Petit)

Initial revision

Revision 2, 2022-10-26 (Kevin Petit)

* 
Add `shaderCoreMask` property

**Name String**

`VK_ARM_shader_core_properties`

**Extension Type**

Device extension

**Registered Extension Number**

416

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[Vulkan Version 1.1](versions.html#versions-1.1)

**Contact**

* 
Jan-Harald Fredriksen [janharaldfredriksen-arm](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_ARM_shader_core_properties] @janharaldfredriksen-arm%0A*Here describe the issue or question you have about the VK_ARM_shader_core_properties extension*)

**Last Modified Date**

2023-02-07

**IP Status**

No known IP claims.

**Contributors**

* 
Jan-Harald Fredriksen, Arm Ltd.

This extension provides the ability to determine device-specific performance
properties of Arm GPUs.

It exposes properties for the number of texel, pixel, and fused multiply-add
operations per clock per shader core.
This can be used in combination with the
`[VK_ARM_shader_core_builtins](#VK_ARM_shader_core_builtins)` extension that provides the ability to
query the number of shader cores on the physical device.

* 
Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

[VkPhysicalDeviceShaderCorePropertiesARM](../chapters/limits.html#VkPhysicalDeviceShaderCorePropertiesARM)

* 
`VK_ARM_SHADER_CORE_PROPERTIES_EXTENSION_NAME`

* 
`VK_ARM_SHADER_CORE_PROPERTIES_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM`

* 
Revision 1, 2023-02-07 (Jan-Harald Fredriksen)

Initial draft.

**Name String**

`VK_FUCHSIA_buffer_collection`

**Extension Type**

Device extension

**Registered Extension Number**

367

**Revision**

2

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_FUCHSIA_external_memory](#VK_FUCHSIA_external_memory)

and

 [VK_KHR_sampler_ycbcr_conversion](#VK_KHR_sampler_ycbcr_conversion)

 or

 [Vulkan Version 1.1](versions.html#versions-1.1)

**API Interactions**

* 
Interacts with VK_EXT_debug_report

**Contact**

* 
John Rosasco [rosasco](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_FUCHSIA_buffer_collection] @rosasco%0A*Here describe the issue or question you have about the VK_FUCHSIA_buffer_collection extension*)

**Last Modified Date**

2021-09-23

**IP Status**

No known IP claims.

**Contributors**

* 
Craig Stout, Google

* 
John Bauman, Google

* 
John Rosasco, Google

A buffer collection is a collection of one or more buffers which were
allocated together as a group and which all have the same properties.
These properties describe the buffers' internal representation such as its
dimensions and memory layout.
This ensures that all of the buffers can be used interchangeably by tasks
that require swapping among multiple buffers, such as double-buffered
graphics rendering.

By sharing such a collection of buffers between components, communication
about buffer lifecycle can be made much simpler and more efficient.
For example, when a content producer finishes writing to a buffer, it can
message the consumer of the buffer with the buffer index, rather than
passing a handle to the shared memory.

On Fuchsia, the Sysmem service uses buffer collections as a core construct
in its design.
VK_FUCHSIA_buffer_collection is the Vulkan extension that allows Vulkan
applications to interoperate with the Sysmem service on Fuchsia.

* 
[VkBufferCollectionFUCHSIA](../chapters/resources.html#VkBufferCollectionFUCHSIA)

* 
[vkCreateBufferCollectionFUCHSIA](../chapters/resources.html#vkCreateBufferCollectionFUCHSIA)

* 
[vkDestroyBufferCollectionFUCHSIA](../chapters/resources.html#vkDestroyBufferCollectionFUCHSIA)

* 
[vkGetBufferCollectionPropertiesFUCHSIA](../chapters/resources.html#vkGetBufferCollectionPropertiesFUCHSIA)

* 
[vkSetBufferCollectionBufferConstraintsFUCHSIA](../chapters/resources.html#vkSetBufferCollectionBufferConstraintsFUCHSIA)

* 
[vkSetBufferCollectionImageConstraintsFUCHSIA](../chapters/resources.html#vkSetBufferCollectionImageConstraintsFUCHSIA)

* 
[VkBufferCollectionConstraintsInfoFUCHSIA](../chapters/resources.html#VkBufferCollectionConstraintsInfoFUCHSIA)

* 
[VkBufferCollectionCreateInfoFUCHSIA](../chapters/resources.html#VkBufferCollectionCreateInfoFUCHSIA)

* 
[VkBufferCollectionPropertiesFUCHSIA](../chapters/resources.html#VkBufferCollectionPropertiesFUCHSIA)

* 
[VkBufferConstraintsInfoFUCHSIA](../chapters/resources.html#VkBufferConstraintsInfoFUCHSIA)

* 
[VkImageConstraintsInfoFUCHSIA](../chapters/resources.html#VkImageConstraintsInfoFUCHSIA)

* 
[VkImageFormatConstraintsInfoFUCHSIA](../chapters/resources.html#VkImageFormatConstraintsInfoFUCHSIA)

* 
[VkSysmemColorSpaceFUCHSIA](../chapters/resources.html#VkSysmemColorSpaceFUCHSIA)

* 
Extending [VkBufferCreateInfo](../chapters/resources.html#VkBufferCreateInfo):

[VkBufferCollectionBufferCreateInfoFUCHSIA](../chapters/resources.html#VkBufferCollectionBufferCreateInfoFUCHSIA)

Extending [VkImageCreateInfo](../chapters/resources.html#VkImageCreateInfo):

* 
[VkBufferCollectionImageCreateInfoFUCHSIA](../chapters/resources.html#VkBufferCollectionImageCreateInfoFUCHSIA)

Extending [VkMemoryAllocateInfo](../chapters/memory.html#VkMemoryAllocateInfo):

* 
[VkImportMemoryBufferCollectionFUCHSIA](../chapters/resources.html#VkImportMemoryBufferCollectionFUCHSIA)

* 
[VkImageConstraintsInfoFlagBitsFUCHSIA](../chapters/resources.html#VkImageConstraintsInfoFlagBitsFUCHSIA)

* 
[VkImageConstraintsInfoFlagsFUCHSIA](../chapters/resources.html#VkImageConstraintsInfoFlagsFUCHSIA)

* 
[VkImageFormatConstraintsFlagsFUCHSIA](../chapters/resources.html#VkImageFormatConstraintsFlagsFUCHSIA)

* 
`VK_FUCHSIA_BUFFER_COLLECTION_EXTENSION_NAME`

* 
`VK_FUCHSIA_BUFFER_COLLECTION_SPEC_VERSION`

* 
Extending [VkObjectType](../chapters/debugging.html#VkObjectType):

`VK_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA`

* 
`VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA`

* 
`VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CREATE_INFO_FUCHSIA`

* 
`VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA`

* 
`VK_STRUCTURE_TYPE_BUFFER_COLLECTION_PROPERTIES_FUCHSIA`

* 
`VK_STRUCTURE_TYPE_BUFFER_CONSTRAINTS_INFO_FUCHSIA`

* 
`VK_STRUCTURE_TYPE_IMAGE_CONSTRAINTS_INFO_FUCHSIA`

* 
`VK_STRUCTURE_TYPE_IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA`

* 
`VK_STRUCTURE_TYPE_IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA`

* 
`VK_STRUCTURE_TYPE_SYSMEM_COLOR_SPACE_FUCHSIA`

If [VK_EXT_debug_report](#VK_EXT_debug_report) is supported:

* 
Extending [VkDebugReportObjectTypeEXT](../chapters/debugging.html#VkDebugReportObjectTypeEXT):

`VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA_EXT`

1) When configuring a [VkImageConstraintsInfoFUCHSIA](../chapters/resources.html#VkImageConstraintsInfoFUCHSIA) structure for
constraint setting, should a NULL `pFormatConstraints` parameter be
allowed ?

**RESOLVED**: No.
Specifying a NULL `pFormatConstraints` results in logical complexity of
interpreting the relationship between the
[VkImageCreateInfo](../chapters/resources.html#VkImageCreateInfo)::`usage` settings of the elements of the
`pImageCreateInfos` array and the implied or desired
[VkFormatFeatureFlags](../chapters/formats.html#VkFormatFeatureFlags).

The explicit requirement for `pFormatConstraints` to be non-NULL
simplifies the implied logic of the implementation and expectations for the
Vulkan application.

* 
Revision 2, 2021-09-23 (John Rosasco)

Review passes

Revision 1, 2021-03-09 (John Rosasco)

* 
Initial revision

**Name String**

`VK_FUCHSIA_external_memory`

**Extension Type**

Device extension

**Registered Extension Number**

365

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

 [VK_KHR_external_memory_capabilities](#VK_KHR_external_memory_capabilities)

 and

 [VK_KHR_external_memory](#VK_KHR_external_memory)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Contact**

* 
John Rosasco [rosasco](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_FUCHSIA_external_memory] @rosasco%0A*Here describe the issue or question you have about the VK_FUCHSIA_external_memory extension*)

**Last Modified Date**

2021-03-01

**IP Status**

No known IP claims.

**Contributors**

* 
Craig Stout, Google

* 
John Bauman, Google

* 
John Rosasco, Google

Vulkan apps may wish to export or import device memory handles to or from
other logical devices, instances or APIs.

This memory sharing can eliminate copies of memory buffers when different
subsystems need to interoperate on them.
Sharing memory buffers may also facilitate a better distribution of
processing workload for more complex memory manipulation pipelines.

* 
[vkGetMemoryZirconHandleFUCHSIA](../chapters/memory.html#vkGetMemoryZirconHandleFUCHSIA)

* 
[vkGetMemoryZirconHandlePropertiesFUCHSIA](../chapters/memory.html#vkGetMemoryZirconHandlePropertiesFUCHSIA)

* 
[VkMemoryGetZirconHandleInfoFUCHSIA](../chapters/memory.html#VkMemoryGetZirconHandleInfoFUCHSIA)

* 
[VkMemoryZirconHandlePropertiesFUCHSIA](../chapters/memory.html#VkMemoryZirconHandlePropertiesFUCHSIA)

* 
Extending [VkMemoryAllocateInfo](../chapters/memory.html#VkMemoryAllocateInfo):

[VkImportMemoryZirconHandleInfoFUCHSIA](../chapters/memory.html#VkImportMemoryZirconHandleInfoFUCHSIA)

* 
`VK_FUCHSIA_EXTERNAL_MEMORY_EXTENSION_NAME`

* 
`VK_FUCHSIA_EXTERNAL_MEMORY_SPEC_VERSION`

* 
Extending [VkExternalMemoryHandleTypeFlagBits](../chapters/capabilities.html#VkExternalMemoryHandleTypeFlagBits):

`VK_EXTERNAL_MEMORY_HANDLE_TYPE_ZIRCON_VMO_BIT_FUCHSIA`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA`

* 
`VK_STRUCTURE_TYPE_MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA`

* 
`VK_STRUCTURE_TYPE_MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA`

See `[VK_KHR_external_memory](#VK_KHR_external_memory)` issues list for further information.

* 
Revision 1, 2021-03-01 (John Rosasco)

Initial draft

**Name String**

`VK_FUCHSIA_external_semaphore`

**Extension Type**

Device extension

**Registered Extension Number**

366

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_external_semaphore_capabilities](#VK_KHR_external_semaphore_capabilities)

and

[VK_KHR_external_semaphore](#VK_KHR_external_semaphore)

**Contact**

* 
John Rosasco [rosasco](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_FUCHSIA_external_semaphore] @rosasco%0A*Here describe the issue or question you have about the VK_FUCHSIA_external_semaphore extension*)

**Last Modified Date**

2021-03-08

**IP Status**

No known IP claims.

**Contributors**

* 
Craig Stout, Google

* 
John Bauman, Google

* 
John Rosasco, Google

An application using external memory may wish to synchronize access to that
memory using semaphores.
This extension enables an application to export semaphore payload to and
import semaphore payload from Zircon event handles.

* 
[vkGetSemaphoreZirconHandleFUCHSIA](../chapters/synchronization.html#vkGetSemaphoreZirconHandleFUCHSIA)

* 
[vkImportSemaphoreZirconHandleFUCHSIA](../chapters/synchronization.html#vkImportSemaphoreZirconHandleFUCHSIA)

* 
[VkImportSemaphoreZirconHandleInfoFUCHSIA](../chapters/synchronization.html#VkImportSemaphoreZirconHandleInfoFUCHSIA)

* 
[VkSemaphoreGetZirconHandleInfoFUCHSIA](../chapters/synchronization.html#VkSemaphoreGetZirconHandleInfoFUCHSIA)

* 
`VK_FUCHSIA_EXTERNAL_SEMAPHORE_EXTENSION_NAME`

* 
`VK_FUCHSIA_EXTERNAL_SEMAPHORE_SPEC_VERSION`

* 
Extending [VkExternalSemaphoreHandleTypeFlagBits](../chapters/capabilities.html#VkExternalSemaphoreHandleTypeFlagBits):

`VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_ZIRCON_EVENT_BIT_FUCHSIA`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA`

* 
`VK_STRUCTURE_TYPE_SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA`

1) Does the application need to close the Zircon event handle returned by
[vkGetSemaphoreZirconHandleFUCHSIA](../chapters/synchronization.html#vkGetSemaphoreZirconHandleFUCHSIA)?

**RESOLVED**: Yes, unless it is passed back in to a driver instance to import
the semaphore.
A successful get call transfers ownership of the Zircon event handle to the
application, and a successful import transfers it back to the driver.
Destroying the original semaphore object will not close the Zircon event
handle nor remove its reference to the underlying semaphore resource
associated with it.

* 
Revision 1, 2021-03-08 (John Rosasco)

Initial revision

**Name String**

`VK_FUCHSIA_imagepipe_surface`

**Extension Type**

Instance extension

**Registered Extension Number**

215

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_surface](#VK_KHR_surface)

**Contact**

* 
Craig Stout [cdotstout](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_FUCHSIA_imagepipe_surface] @cdotstout%0A*Here describe the issue or question you have about the VK_FUCHSIA_imagepipe_surface extension*)

**Last Modified Date**

2018-07-27

**IP Status**

No known IP claims.

**Contributors**

* 
Craig Stout, Google

* 
Ian Elliott, Google

* 
Jesse Hall, Google

The `VK_FUCHSIA_imagepipe_surface` extension is an instance extension.
It provides a mechanism to create a [VkSurfaceKHR](../chapters/VK_KHR_surface/wsi.html#VkSurfaceKHR) object (defined by
the `[VK_KHR_surface](#VK_KHR_surface)` extension) that refers to a Fuchsia
`imagePipeHandle`.

* 
[vkCreateImagePipeSurfaceFUCHSIA](../chapters/VK_KHR_surface/wsi.html#vkCreateImagePipeSurfaceFUCHSIA)

* 
[VkImagePipeSurfaceCreateInfoFUCHSIA](../chapters/VK_KHR_surface/wsi.html#VkImagePipeSurfaceCreateInfoFUCHSIA)

* 
[VkImagePipeSurfaceCreateFlagsFUCHSIA](../chapters/VK_KHR_surface/wsi.html#VkImagePipeSurfaceCreateFlagsFUCHSIA)

* 
`VK_FUCHSIA_IMAGEPIPE_SURFACE_EXTENSION_NAME`

* 
`VK_FUCHSIA_IMAGEPIPE_SURFACE_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA`

* 
Revision 1, 2018-07-27 (Craig Stout)

Initial draft.

**Name String**

`VK_GGP_frame_token`

**Extension Type**

Device extension

**Registered Extension Number**

192

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_swapchain](#VK_KHR_swapchain)

and

[VK_GGP_stream_descriptor_surface](#VK_GGP_stream_descriptor_surface)

**Contact**

* 
Jean-Francois Roy [jfroy](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_GGP_frame_token] @jfroy%0A*Here describe the issue or question you have about the VK_GGP_frame_token extension*)

**Last Modified Date**

2019-01-28

**IP Status**

No known IP claims.

**Contributors**

* 
Jean-Francois Roy, Google

* 
Richard OGrady, Google

This extension allows an application that uses the `[VK_KHR_swapchain](#VK_KHR_swapchain)`
extension in combination with a Google Games Platform surface provided by
the `[VK_GGP_stream_descriptor_surface](#VK_GGP_stream_descriptor_surface)` extension to associate a
Google Games Platform frame token with a present operation.

* 
Extending [VkPresentInfoKHR](../chapters/VK_KHR_surface/wsi.html#VkPresentInfoKHR):

[VkPresentFrameTokenGGP](../chapters/VK_KHR_surface/wsi.html#VkPresentFrameTokenGGP)

* 
`VK_GGP_FRAME_TOKEN_EXTENSION_NAME`

* 
`VK_GGP_FRAME_TOKEN_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP`

* 
Revision 1, 2018-11-26 (Jean-Francois Roy)

Initial revision.

**Name String**

`VK_GGP_stream_descriptor_surface`

**Extension Type**

Instance extension

**Registered Extension Number**

50

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_surface](#VK_KHR_surface)

**Contact**

* 
Jean-Francois Roy [jfroy](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_GGP_stream_descriptor_surface] @jfroy%0A*Here describe the issue or question you have about the VK_GGP_stream_descriptor_surface extension*)

**Last Modified Date**

2019-01-28

**IP Status**

No known IP claims.

**Contributors**

* 
Jean-Francois Roy, Google

* 
Brad Grantham, Google

* 
Connor Smith, Google

* 
Cort Stratton, Google

* 
Hai Nguyen, Google

* 
Ian Elliott, Google

* 
Jesse Hall, Google

* 
Jim Ray, Google

* 
Katherine Wu, Google

* 
Kaye Mason, Google

* 
Kuangye Guo, Google

* 
Mark Segal, Google

* 
Nicholas Vining, Google

* 
Paul Lalonde, Google

* 
Richard OGrady, Google

The `VK_GGP_stream_descriptor_surface` extension is an instance extension.
It provides a mechanism to create a [VkSurfaceKHR](../chapters/VK_KHR_surface/wsi.html#VkSurfaceKHR) object (defined by
the `[VK_KHR_surface](#VK_KHR_surface)` extension) that refers to a Google Games
Platform `GgpStreamDescriptor`.

* 
[vkCreateStreamDescriptorSurfaceGGP](../chapters/VK_KHR_surface/wsi.html#vkCreateStreamDescriptorSurfaceGGP)

* 
[VkStreamDescriptorSurfaceCreateInfoGGP](../chapters/VK_KHR_surface/wsi.html#VkStreamDescriptorSurfaceCreateInfoGGP)

* 
[VkStreamDescriptorSurfaceCreateFlagsGGP](../chapters/VK_KHR_surface/wsi.html#VkStreamDescriptorSurfaceCreateFlagsGGP)

* 
`VK_GGP_STREAM_DESCRIPTOR_SURFACE_EXTENSION_NAME`

* 
`VK_GGP_STREAM_DESCRIPTOR_SURFACE_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP`

* 
Revision 1, 2018-11-26 (Jean-Francois Roy)

Initial revision.

**Name String**

`VK_GOOGLE_decorate_string`

**Extension Type**

Device extension

**Registered Extension Number**

225

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

None

**SPIR-V Dependencies**

* 
[SPV_GOOGLE_decorate_string](https://github.khronos.org/SPIRV-Registry/extensions/GOOGLE/SPV_GOOGLE_decorate_string.html)

**Contact**

* 
Hai Nguyen [chaoticbob](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_GOOGLE_decorate_string] @chaoticbob%0A*Here describe the issue or question you have about the VK_GOOGLE_decorate_string extension*)

**Last Modified Date**

2018-07-09

**IP Status**

No known IP claims.

**Contributors**

* 
Hai Nguyen, Google

* 
Neil Henning, AMD

The `VK_GOOGLE_decorate_string` extension allows use of the
`SPV_GOOGLE_decorate_string` extension in SPIR-V shader modules.

* 
`VK_GOOGLE_DECORATE_STRING_EXTENSION_NAME`

* 
`VK_GOOGLE_DECORATE_STRING_SPEC_VERSION`

* 
Revision 1, 2018-07-09 (Neil Henning)

Initial draft

**Name String**

`VK_GOOGLE_display_timing`

**Extension Type**

Device extension

**Registered Extension Number**

93

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_swapchain](#VK_KHR_swapchain)

**Contact**

* 
Ian Elliott [ianelliottus](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_GOOGLE_display_timing] @ianelliottus%0A*Here describe the issue or question you have about the VK_GOOGLE_display_timing extension*)

**Last Modified Date**

2017-02-14

**IP Status**

No known IP claims.

**Contributors**

* 
Ian Elliott, Google

* 
Jesse Hall, Google

This device extension allows an application that uses the
`[VK_KHR_swapchain](#VK_KHR_swapchain)` extension to obtain information about the
presentation engines display, to obtain timing information about each
present, and to schedule a present to happen no earlier than a desired time.
An application can use this to minimize various visual anomalies (e.g.
stuttering).

Traditional game and real-time animation applications need to correctly
position their geometry for when the presentable image will be presented to
the user.
To accomplish this, applications need various timing information about the
presentation engines display.
They need to know when presentable images were actually presented, and when
they could have been presented.
Applications also need to tell the presentation engine to display an image
no sooner than a given time.
This allows the application to avoid stuttering, so the animation looks
smooth to the user.

This extension treats variable-refresh-rate (VRR) displays as if they are
fixed-refresh-rate (FRR) displays.

* 
[vkGetPastPresentationTimingGOOGLE](../chapters/VK_KHR_surface/wsi.html#vkGetPastPresentationTimingGOOGLE)

* 
[vkGetRefreshCycleDurationGOOGLE](../chapters/VK_KHR_surface/wsi.html#vkGetRefreshCycleDurationGOOGLE)

* 
[VkPastPresentationTimingGOOGLE](../chapters/VK_KHR_surface/wsi.html#VkPastPresentationTimingGOOGLE)

* 
[VkPresentTimeGOOGLE](../chapters/VK_KHR_surface/wsi.html#VkPresentTimeGOOGLE)

* 
[VkRefreshCycleDurationGOOGLE](../chapters/VK_KHR_surface/wsi.html#VkRefreshCycleDurationGOOGLE)

* 
Extending [VkPresentInfoKHR](../chapters/VK_KHR_surface/wsi.html#VkPresentInfoKHR):

[VkPresentTimesInfoGOOGLE](../chapters/VK_KHR_surface/wsi.html#VkPresentTimesInfoGOOGLE)

* 
`VK_GOOGLE_DISPLAY_TIMING_EXTENSION_NAME`

* 
`VK_GOOGLE_DISPLAY_TIMING_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE`

|  | The example code for the this extension (like the `[VK_KHR_surface](#VK_KHR_surface)`
| --- | --- |
and `VK_GOOGLE_display_timing` extensions) is contained in the cube demo
that is shipped with the official Khronos SDK, and is being kept up-to-date
in that location (see:
[https://github.com/KhronosGroup/Vulkan-Tools/blob/main/cube/cube.c](https://github.com/KhronosGroup/Vulkan-Tools/blob/main/cube/cube.c) ). |

* 
Revision 1, 2017-02-14 (Ian Elliott)

Internal revisions

**Name String**

`VK_GOOGLE_hlsl_functionality1`

**Extension Type**

Device extension

**Registered Extension Number**

224

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

None

**SPIR-V Dependencies**

* 
[SPV_GOOGLE_hlsl_functionality1](https://github.khronos.org/SPIRV-Registry/extensions/GOOGLE/SPV_GOOGLE_hlsl_functionality1.html)

**Contact**

* 
Hai Nguyen [chaoticbob](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_GOOGLE_hlsl_functionality1] @chaoticbob%0A*Here describe the issue or question you have about the VK_GOOGLE_hlsl_functionality1 extension*)

**Last Modified Date**

2018-07-09

**IP Status**

No known IP claims.

**Contributors**

* 
Hai Nguyen, Google

* 
Neil Henning, AMD

The `VK_GOOGLE_hlsl_functionality1` extension allows use of the
`SPV_GOOGLE_hlsl_functionality1` extension in SPIR-V shader modules.

* 
`VK_GOOGLE_HLSL_FUNCTIONALITY1_EXTENSION_NAME`

* 
`VK_GOOGLE_HLSL_FUNCTIONALITY1_SPEC_VERSION`

* 
`VK_GOOGLE_HLSL_FUNCTIONALITY_1_EXTENSION_NAME`

* 
`VK_GOOGLE_HLSL_FUNCTIONALITY_1_SPEC_VERSION`

* 
Revision 1, 2018-07-09 (Neil Henning)

Initial draft

**Name String**

`VK_GOOGLE_surfaceless_query`

**Extension Type**

Instance extension

**Registered Extension Number**

434

**Revision**

2

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_surface](#VK_KHR_surface)

**Special Use**

* 
[OpenGL / ES support](../chapters/extensions.html#extendingvulkan-compatibility-specialuse)

**Contact**

* 
Shahbaz Youssefi [syoussefi](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_GOOGLE_surfaceless_query] @syoussefi%0A*Here describe the issue or question you have about the VK_GOOGLE_surfaceless_query extension*)

**Extension Proposal**

[VK_GOOGLE_surfaceless_query](../../../features/latest/features/proposals/VK_GOOGLE_surfaceless_query.html)

**Last Modified Date**

2022-08-03

**IP Status**

No known IP claims.

**Contributors**

* 
Ian Elliott, Google

* 
Shahbaz Youssefi, Google

* 
James Jones, NVIDIA

This extension allows the [vkGetPhysicalDeviceSurfaceFormatsKHR](../chapters/VK_KHR_surface/wsi.html#vkGetPhysicalDeviceSurfaceFormatsKHR) and
[vkGetPhysicalDeviceSurfacePresentModesKHR](../chapters/VK_KHR_surface/wsi.html#vkGetPhysicalDeviceSurfacePresentModesKHR) functions to accept
[VK_NULL_HANDLE](boilerplate.html#VK_NULL_HANDLE) as their `surface` parameter, allowing potential
surface formats, color spaces and present modes to be queried without
providing a surface.
Identically, [vkGetPhysicalDeviceSurfaceFormats2KHR](../chapters/VK_KHR_surface/wsi.html#vkGetPhysicalDeviceSurfaceFormats2KHR),
[vkGetPhysicalDeviceSurfacePresentModes2EXT](../chapters/VK_KHR_surface/wsi.html#vkGetPhysicalDeviceSurfacePresentModes2EXT), and
[vkGetPhysicalDeviceSurfaceCapabilities2KHR](../chapters/VK_KHR_surface/wsi.html#vkGetPhysicalDeviceSurfaceCapabilities2KHR) would accept
[VK_NULL_HANDLE](boilerplate.html#VK_NULL_HANDLE) in
[VkPhysicalDeviceSurfaceInfo2KHR](../chapters/VK_KHR_surface/wsi.html#VkPhysicalDeviceSurfaceInfo2KHR)::`surface`.
**This can only be supported on platforms where the results of these queries
are surface-agnostic and a single presentation engine is the implicit target
of all present operations**.

* 
`VK_GOOGLE_SURFACELESS_QUERY_EXTENSION_NAME`

* 
`VK_GOOGLE_SURFACELESS_QUERY_SPEC_VERSION`

* 
Revision 1, 2021-12-14 (Shahbaz Youssefi)

Internal revisions

Revision 2, 2022-08-03 (Shahbaz Youssefi)

* 
Precisions to which parts of the query responses are defined when
surfaceless

**Name String**

`VK_GOOGLE_user_type`

**Extension Type**

Device extension

**Registered Extension Number**

290

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

None

**SPIR-V Dependencies**

* 
[SPV_GOOGLE_user_type](https://github.khronos.org/SPIRV-Registry/extensions/GOOGLE/SPV_GOOGLE_user_type.html)

**Contact**

* 
Kaye Mason [chaleur](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_GOOGLE_user_type] @chaleur%0A*Here describe the issue or question you have about the VK_GOOGLE_user_type extension*)

**Last Modified Date**

2019-07-09

**IP Status**

No known IP claims.

**Contributors**

* 
Kaye Mason, Google

* 
Hai Nguyen, Google

The `VK_GOOGLE_user_type` extension allows use of the `SPV_GOOGLE_user_type`
extension in SPIR-V shader modules.

* 
`VK_GOOGLE_USER_TYPE_EXTENSION_NAME`

* 
`VK_GOOGLE_USER_TYPE_SPEC_VERSION`

* 
Revision 1, 2019-09-07 (Kaye Mason)

Initial draft

**Name String**

`VK_HUAWEI_cluster_culling_shader`

**Extension Type**

Device extension

**Registered Extension Number**

405

**Revision**

3

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**SPIR-V Dependencies**

* 
[SPV_HUAWEI_cluster_culling_shader](https://github.khronos.org/SPIRV-Registry/extensions/HUAWEI/SPV_HUAWEI_cluster_culling_shader.html)

**Contact**

* 
Yuchang Wang [richard_Wang2](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_HUAWEI_cluster_culling_shader] @richard_Wang2%0A*Here describe the issue or question you have about the VK_HUAWEI_cluster_culling_shader extension*)

**Extension Proposal**

[VK_HUAWEI_cluster_culling_shader](../../../features/latest/features/proposals/VK_HUAWEI_cluster_culling_shader.html)

**Last Modified Date**

2023-08-16

**Interactions and External Dependencies**

* 
This extension provides API support for
[`GL_HUAWEI_cluster_culling_shader`](https://github.com/KhronosGroup/GLSL/blob/main/extensions/huawei/GLSL_HUAWEI_cluster_culling_shader.txt).

**Contributors**

* 
Yuchang Wang, Huawei

* 
Juntao Li, Huawei

* 
Pan Gao, Huawei

* 
Jie Cao, Huawei

* 
Yunjin Zhang, Huawei

* 
Shujie Zhou, Huawei

* 
Chaojun Wang, Huawei

* 
Jiajun Hu, Huawei

* 
Cong Zhang, Huawei

Cluster Culling Shaders (CCS) are similar to the existing compute shaders.
Their main purpose is to provide an execution environment in order to
perform coarse-level geometry culling and LOD selection more efficiently on
the GPU.

The traditional 2-pass GPU culling solution using a compute shader sometimes
needs a pipeline barrier between compute and graphics pipeline to optimize
performance.
An additional compaction process may also be required.
This extension addresses these shortcomings, allowing compute shaders to
directly emit visible clusters to the following graphics pipeline.

A set of new built-in output variables are used to express a visible
cluster, including per-cluster shading rate.
In addition, a new built-in function is used to emit these variables from
CCS to the IA stage.
The IA stage can use these variables to fetch vertices of a visible cluster
and drive vertex shaders to shading these vertices.

Note that CCS do not work with geometry or tessellation shaders, but both IA
and vertex shaders are preserved.
Vertex shaders are still used for vertex position shading, instead of
directly outputting transformed vertices from the compute shader.
This makes CCS more suitable for mobile GPUs.

* 
[vkCmdDrawClusterHUAWEI](../chapters/drawing.html#vkCmdDrawClusterHUAWEI)

* 
[vkCmdDrawClusterIndirectHUAWEI](../chapters/drawing.html#vkCmdDrawClusterIndirectHUAWEI)

* 
Extending [VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI](../chapters/features.html#VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI):

[VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI](../chapters/features.html#VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI)

Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

* 
[VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI](../chapters/features.html#VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI](../chapters/limits.html#VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI)

* 
`VK_HUAWEI_CLUSTER_CULLING_SHADER_EXTENSION_NAME`

* 
`VK_HUAWEI_CLUSTER_CULLING_SHADER_SPEC_VERSION`

* 
Extending [VkPipelineStageFlagBits2](../chapters/synchronization.html#VkPipelineStageFlagBits2):

`VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI`

Extending [VkQueryPipelineStatisticFlagBits](../chapters/queries.html#VkQueryPipelineStatisticFlagBits):

* 
`VK_QUERY_PIPELINE_STATISTIC_CLUSTER_CULLING_SHADER_INVOCATIONS_BIT_HUAWEI`

Extending [VkShaderStageFlagBits](../chapters/pipelines.html#VkShaderStageFlagBits):

* 
`VK_SHADER_STAGE_CLUSTER_CULLING_BIT_HUAWEI`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_VRS_FEATURES_HUAWEI`

* 
[IndexCountHUAWEI](../chapters/interfaces.html#interfaces-builtin-variables-indexcounthuawei)

* 
[VertexCountHUAWEI](../chapters/interfaces.html#interfaces-builtin-variables-vertexcounthuawei)

* 
[InstanceCountHUAWEI](../chapters/interfaces.html#interfaces-builtin-variables-instancecounthuawei)

* 
[FirstIndexHUAWEI](../chapters/interfaces.html#interfaces-builtin-variables-firstindexhuawei)

* 
[FirstVertexHUAWEI](../chapters/interfaces.html#interfaces-builtin-variables-firstvertexhuawei)

* 
[VertexOffsetHUAWEI](../chapters/interfaces.html#interfaces-builtin-variables-vertexoffsethuawei)

* 
[FirstInstanceHUAWEI](../chapters/interfaces.html#interfaces-builtin-variables-firstinstancehuawei)

* 
[ClusterIDHUAWEI](../chapters/interfaces.html#interfaces-builtin-variables-clusteridhuawei)

* 
[ClusterShadingRateHUAWEI](../chapters/interfaces.html#interfaces-builtin-variables-clustershadingratehuawei)

* 
[    `ClusterCullingShadingHUAWEI`](spirvenv.html#spirvenv-capabilities-table-ClusterCullingShadingHUAWEI)

Example of cluster culling in a GLSL shader

#extension GL_HUAWEI_cluster_culling_shader: enable

#define GPU_WARP_SIZE                   32
#define GPU_GROUP_SIZE                  GPU_WARP_SIZE

#define GPU_CLUSTER_PER_INVOCATION      1
#define GPU_CLUSTER_PER_WORKGROUP       (GPU_GROUP_SIZE * GPU_CLUSTER_PER_INVOCATION)

// Number of threads per workgroup
// - 1D only
// - warpsize = 32
layout(local_size_x=GPU_GROUP_SIZE, local_size_y=1, local_size_z=1) in;

#define GPU_DRAW_BUFFER_BINDING             0
#define GPU_INSTANCE_DESCRIPTOR_BINDING     1

struct BoundingSphere
{
  vec3 center;
  float radius;
};

struct InstanceData
{
  mat4 mvp_matrix;                      // mvp matrix.
  vec4 frustum_planes[6];               // six frustum planes
  mat4 model_matrix_transpose_inverse;  // inverse transpose of model matrix.
  vec3 view_origin;                     // view original
};

struct InstanceDescriptor
{
  uint begin;
  uint end;
  uint cluster_count;
  uint debug;
  BoundingSphere sphere;
  InstanceData instance_data;
};

struct DrawElementsCommand{
  uint indexcount;
  uint instanceCount;
  uint firstIndex;
  int  vertexoffset;
  uint firstInstance;
  uint cluster_id;
};

// indexed mode
out gl_PerClusterHUAWEI{
  uint gl_IndexCountHUAWEI;
  uint gl_InstanceCountHUAWEI;
  uint gl_FirstIndexHUAWEI;
  int  gl_VertexOffsetHUAWEI;
  uint gl_FirstInstanceHUAWEI;
  uint gl_ClusterIDHUAWEI;
  uint gl_ClusterShadingRateHUAWEI;
};

layout(binding = GPU_DRAW_BUFFER_BINDING, std430) buffer draw_indirect_ssbo
{
        DrawElementsCommand draw_commands[];
};

layout(binding = GPU_INSTANCE_DESCRIPTOR_BINDING, std430) buffer instance_descriptor_ssbo
{
        InstanceDescriptor instance_descriptors[];
};

float Distance(uint instance_id)
{
    vec3 v = normalize(instance_descriptor[instance_id].sphere.center -
                     instance_descriptor[instance_id].instance_data.view_origin);
    float dist = sqrt(dot(v,v));

    return dist;
}

bool isSphereOutsideFrustum( vec3 sphere_center, float sphere_radius )
{
  bool isInside = false;

  for(int i = 0; i  0.7)
            gl_ClusterShadingRateHUAWEI =
                gl_ShadingRateFlag4VerticalPixelsEXT | gl_ShadingRateFlag4HorizontalPixelsEXT;
        else if(distance > 0.3)
            gl_ClusterShadingRateHUAWEI =
                gl_ShadingRateFlag2VerticalPixelsEXT | gl_ShadingRateFlag2HorizontalPixelsEXT;
        else
            gl_ClusterShadingRateHUAWEI = 0;

        // this is a visible cluster, update built-in output variable.
        // in case of indexed mode:
        gl_IndexCountHUAWEI     = draw_commands[cluster_id].indexcount;
        gl_InstanceCountHUAWEI  = draw_commands[cluster_id].instanceCount;
        gl_FirstIndexHUAWEI     = draw_commands[cluster_id].firstIndex;
        gl_VertexOffsetHUAWEI   = draw_commands[cluster_id].vertexoffset;
        gl_FirstInstanceHUAWEI  = draw_commands[cluster_id].firstInstance;
        gl_ClusterIDHUAWEI      = draw_commands[cluster_id].cluster_id;

        // emit built-in output variables as a drawing command to subsequent
        // rendering pipeline.
        dispatchClusterHUAWEI();
    }
}

Example of graphics pipeline creation with cluster culling shader

// create a cluster culling shader stage info structure.
VkPipelineShaderStageCreateInfo ccsStageInfo{};
ccsStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
ccsStageInfo.stage = VK_SHADER_STAGE_CLUSTER_CULLING_BIT_HUAWEI;
ccsStageInfo.module = clustercullingshaderModule;
ccsStageInfo.pName =  "main";

// pipeline shader stage creation
VkPipelineShaderStageCreateInfo shaderStages[] = { ccsStageInfo, vertexShaderStageInfo, fragmentShaderStageInfo };

// create graphics pipeline
VkGraphicsPipelineCreateInfo pipelineInfo{};
pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
pipelineInfo.stageCount = 3;
pipelineInfo.pStage = shaderStages;
pipelineInfo.pVertexInputState = &vertexInputInfo;
// ...
VkPipeline graphicsPipeline;
VkCreateGraphicsPipelines(device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &graphicsPipeline);

Example of launching the execution of cluster culling shader

vkCmdBindPipeline(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, graphicsPipeline);
vkCmdDrawClusterHUAWEI(commandBuffer, groupCountX, 1, 1);
vkCmdEndRenderPass(commandBuffer);

* 
Revision 1, 2022-11-18 (YuChang Wang)

Internal revisions

Revision 2, 2023-04-02 (Jon Leech)

* 
Grammar edits.

Revision 3, 2023-08-21 (YuChang Wang)

* 
Add per-cluster shading rate.

**Name String**

`VK_HUAWEI_hdr_vivid`

**Extension Type**

Device extension

**Registered Extension Number**

591

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

 [VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

 or

 [Vulkan Version 1.1](versions.html#versions-1.1)

and

[VK_KHR_swapchain](#VK_KHR_swapchain)

and

[VK_EXT_hdr_metadata](#VK_EXT_hdr_metadata)

**Contact**

* 
Zehui Lin [bactlink](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_HUAWEI_hdr_vivid] @bactlink%0A*Here describe the issue or question you have about the VK_HUAWEI_hdr_vivid extension*)

**Last Modified Date**

2024-10-08

**IP Status**

No known IP claims.

**Contributors**

* 
Juntao Li, Huawei

* 
Pan Gao, Huawei

* 
Xiufeng Zhang, Huawei

* 
Zehui Lin, Huawei

This extension allows applications to assign HDR Vivid (T/UWA 005.1-2022)
metadata to swapchains.

HDR Vivid is an HDR standard released by UWA (UHD World Association).
It defines tone mapping from the metadata to better preserve the creators
intentions and achieve better consistency across devices with different
display capabilities.

* 
Extending [VkHdrMetadataEXT](../chapters/VK_KHR_surface/wsi.html#VkHdrMetadataEXT):

[VkHdrVividDynamicMetadataHUAWEI](../chapters/VK_KHR_surface/wsi.html#VkHdrVividDynamicMetadataHUAWEI)

Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

* 
[VkPhysicalDeviceHdrVividFeaturesHUAWEI](../chapters/features.html#VkPhysicalDeviceHdrVividFeaturesHUAWEI)

* 
`VK_HUAWEI_HDR_VIVID_EXTENSION_NAME`

* 
`VK_HUAWEI_HDR_VIVID_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_HDR_VIVID_DYNAMIC_METADATA_HUAWEI`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HDR_VIVID_FEATURES_HUAWEI`

* 
Revision 1, 2024-10-08 (Zehui Lin)

Initial version

**Name String**

`VK_HUAWEI_invocation_mask`

**Extension Type**

Device extension

**Registered Extension Number**

371

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_ray_tracing_pipeline](#VK_KHR_ray_tracing_pipeline)

and

 [VK_KHR_synchronization2](#VK_KHR_synchronization2)

 or

 [Vulkan Version 1.3](versions.html#versions-1.3)

**Contact**

* 
Pan Gao [PanGao-h](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_HUAWEI_invocation_mask] @PanGao-h%0A*Here describe the issue or question you have about the VK_HUAWEI_invocation_mask extension*)

**Extension Proposal**

[VK_HUAWEI_invocation_mask](../../../features/latest/features/proposals/VK_HUAWEI_invocation_mask.html)

**Last Modified Date**

2021-05-27

**Interactions and External Dependencies**

* 
This extension requires `[VK_KHR_ray_tracing_pipeline](#VK_KHR_ray_tracing_pipeline)`, which
allow to bind an invocation mask image before the ray tracing command

* 
This extension requires `[VK_KHR_synchronization2](#VK_KHR_synchronization2)`, which allows
new pipeline stage for the invocation mask image

**Contributors**

* 
Yunpeng Zhu

* 
Juntao Li, Huawei

* 
Liang Chen, Huawei

* 
Shaozhuang Shi, Huawei

* 
Hailong Chu, Huawei

The rays to trace may be sparse in some use cases.
For example, the scene only have a few regions to reflect.
Providing an invocation mask image to the ray tracing commands could
potentially give the hardware the hint to do certain optimization without
invoking an additional pass to compact the ray buffer.

* 
[vkCmdBindInvocationMaskHUAWEI](../chapters/raytracing.html#vkCmdBindInvocationMaskHUAWEI)

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceInvocationMaskFeaturesHUAWEI](../chapters/features.html#VkPhysicalDeviceInvocationMaskFeaturesHUAWEI)

* 
`VK_HUAWEI_INVOCATION_MASK_EXTENSION_NAME`

* 
`VK_HUAWEI_INVOCATION_MASK_SPEC_VERSION`

* 
Extending [VkAccessFlagBits2](../chapters/synchronization.html#VkAccessFlagBits2):

`VK_ACCESS_2_INVOCATION_MASK_READ_BIT_HUAWEI`

Extending [VkImageUsageFlagBits](../chapters/resources.html#VkImageUsageFlagBits):

* 
`VK_IMAGE_USAGE_INVOCATION_MASK_BIT_HUAWEI`

Extending [VkPipelineStageFlagBits2](../chapters/synchronization.html#VkPipelineStageFlagBits2):

* 
`VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI`

RT mask is updated before each traceRay.

Step 1.
Generate InvocationMask.

//the rt mask image bind as color attachment in the fragment shader
Layout(location = 2) out vec4 outRTmask
vec4 mask = vec4(x,x,x,x);
outRTmask = mask;

Step 2.
traceRay with InvocationMask

vkCmdBindPipeline(
    commandBuffers[imageIndex],
    VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR, m_rtPipeline);
    vkCmdBindDescriptorSets(commandBuffers[imageIndex],
    VK_PIPELINE_BIND_POINT_RAY_TRACING_NV,
    m_rtPipelineLayout, 0, 1, &m_rtDescriptorSet,
    0, nullptr);

vkCmdBindInvocationMaskHUAWEI(
    commandBuffers[imageIndex],
    InvocationMaskimageView,
    InvocationMaskimageLayout);
    vkCmdTraceRaysKHR(commandBuffers[imageIndex],
    pRaygenShaderBindingTable,
    pMissShaderBindingTable,
    swapChainExtent.width,
    swapChainExtent.height, 1);

* 
Revision 1, 2021-05-27 (Yunpeng Zhu)

Initial draft.

**Name String**

`VK_HUAWEI_subpass_shading`

**Extension Type**

Device extension

**Registered Extension Number**

370

**Revision**

3

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

 [VK_KHR_create_renderpass2](#VK_KHR_create_renderpass2)

 or

 [Vulkan Version 1.2](versions.html#versions-1.2)

 and

 [VK_KHR_synchronization2](#VK_KHR_synchronization2)

or

[Vulkan Version 1.3](versions.html#versions-1.3)

**SPIR-V Dependencies**

* 
[SPV_HUAWEI_subpass_shading](https://github.khronos.org/SPIRV-Registry/extensions/HUAWEI/SPV_HUAWEI_subpass_shading.html)

**Contact**

* 
Pan Gao [PanGao-h](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_HUAWEI_subpass_shading] @PanGao-h%0A*Here describe the issue or question you have about the VK_HUAWEI_subpass_shading extension*)

**Last Modified Date**

2021-06-01

**Interactions and External Dependencies**

* 
This extension provides API support for
[`GL_HUAWEI_subpass_shading`](https://github.com/KhronosGroup/GLSL/blob/main/extensions/huawei/GLSL_HUAWEI_subpass_shading.txt).

**Contributors**

* 
Hueilong Wang

* 
Juntao Li, Huawei

* 
Renmiao Lu, Huawei

* 
Pan Gao, Huawei

This extension allows applications to execute a subpass shading pipeline in
a subpass of a render pass in order to save memory bandwidth for algorithms
like tile-based deferred rendering and forward plus.
A subpass shading pipeline is a pipeline with the compute pipeline ability,
allowed to read values from input attachments, and only allowed to be
dispatched inside a stand-alone subpass.
Its work dimension is defined by the render passs render area size.
Its workgroup size (width, height) shall be a power-of-two number in width
or height, with minimum value from 8, and maximum value shall be decided
from the render pass attachments and sample counts but depends on
implementation.

The `GlobalInvocationId.xy` of a subpass shading pipeline is equal to the
`FragCoord.xy` of a graphic pipeline in the same render pass subtracted
the [`offset`](../chapters/fundamentals.html#VkRect2D) of the
[VkRenderPassBeginInfo](../chapters/renderpass.html#VkRenderPassBeginInfo)::`renderArea`.
`GlobalInvocationId.z` is mapped to the Layer if
`[VK_EXT_shader_viewport_index_layer](#VK_EXT_shader_viewport_index_layer)` is supported.
The `GlobalInvocationId.xy` is equal to the index of the local workgroup
multiplied by the size of the local workgroup plus the
`LocalInvocationId` and the [`offset`](../chapters/fundamentals.html#VkRect2D) of the
[VkRenderPassBeginInfo](../chapters/renderpass.html#VkRenderPassBeginInfo)::`renderArea`.

This extension allows a subpasss pipeline bind point to be
`VK_PIPELINE_BIND_POINT_SUBPASS_SHADING_HUAWEI`.

* 
[vkCmdSubpassShadingHUAWEI](../chapters/dispatch.html#vkCmdSubpassShadingHUAWEI)

* 
[vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI](../chapters/pipelines.html#vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI)

* 
Extending [VkComputePipelineCreateInfo](../chapters/pipelines.html#VkComputePipelineCreateInfo):

[VkSubpassShadingPipelineCreateInfoHUAWEI](../chapters/pipelines.html#VkSubpassShadingPipelineCreateInfoHUAWEI)

Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

* 
[VkPhysicalDeviceSubpassShadingFeaturesHUAWEI](../chapters/features.html#VkPhysicalDeviceSubpassShadingFeaturesHUAWEI)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceSubpassShadingPropertiesHUAWEI](../chapters/limits.html#VkPhysicalDeviceSubpassShadingPropertiesHUAWEI)

* 
`VK_HUAWEI_SUBPASS_SHADING_EXTENSION_NAME`

* 
`VK_HUAWEI_SUBPASS_SHADING_SPEC_VERSION`

* 
Extending [VkPipelineBindPoint](../chapters/pipelines.html#VkPipelineBindPoint):

`VK_PIPELINE_BIND_POINT_SUBPASS_SHADING_HUAWEI`

Extending [VkPipelineStageFlagBits2](../chapters/synchronization.html#VkPipelineStageFlagBits2):

* 
`VK_PIPELINE_STAGE_2_SUBPASS_SHADER_BIT_HUAWEI`

* 
`VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI`

Extending [VkShaderStageFlagBits](../chapters/pipelines.html#VkShaderStageFlagBits):

* 
`VK_SHADER_STAGE_SUBPASS_SHADING_BIT_HUAWEI`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI`

* 
`VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI`

Example of subpass shading in a GLSL shader

#extension GL_HUAWEI_subpass_shading: enable
#extension GL_KHR_shader_subgroup_arithmetic: enable

layout(constant_id = 0) const uint tileWidth = 8;
layout(constant_id = 1) const uint tileHeight = 8;
layout(local_size_x_id = 0, local_size_y_id = 1, local_size_z = 1) in;
layout(set=0, binding=0, input_attachment_index=0) uniform subpassInput depth;

void main()
{
  float d = subpassLoad(depth).x;
  float minD = subgroupMin(d);
  float maxD = subgroupMax(d);
}

Example of subpass shading dispatching in a subpass

vkCmdNextSubpass(commandBuffer, VK_SUBPASS_CONTENTS_INLINE);
vkCmdBindPipeline(commandBuffer, VK_PIPELINE_BIND_POINT_SUBPASS_SHADING_HUAWEI, subpassShadingPipeline);
vkCmdBindDescriptorSets(commandBuffer, VK_PIPELINE_BIND_POINT_SUBPASS_SHADING_HUAWEI, subpassShadingPipelineLayout,
  firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount, pDynamicOffsets);
vkCmdSubpassShadingHUAWEI(commandBuffer)
vkCmdEndRenderPass(commandBuffer);

Example of subpass shading render pass creation

VkAttachmentDescription2 attachments[] = {
  {
    VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2, NULL,
    0, VK_FORMAT_R8G8B8A8_UNORM, VK_SAMPLE_COUNT_1_BIT,
    VK_ATTACHMENT_LOAD_OP_CLEAR, VK_ATTACHMENT_STORE_OP_DONT_CARE,
    VK_ATTACHMENT_LOAD_OP_DONT_CARE, VK_ATTACHMENT_LOAD_OP_DONT_CARE,
    VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL
  },
  {
    VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2, NULL,
    0, VK_FORMAT_R8G8B8A8_UNORM, VK_SAMPLE_COUNT_1_BIT,
    VK_ATTACHMENT_LOAD_OP_CLEAR, VK_ATTACHMENT_STORE_OP_DONT_CARE,
    VK_ATTACHMENT_LOAD_OP_DONT_CARE, VK_ATTACHMENT_LOAD_OP_DONT_CARE,
    VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL
  },
  {
    VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2, NULL,
    0, VK_FORMAT_R8G8B8A8_UNORM, VK_SAMPLE_COUNT_1_BIT,
    VK_ATTACHMENT_LOAD_OP_CLEAR, VK_ATTACHMENT_STORE_OP_DONT_CARE,
    VK_ATTACHMENT_LOAD_OP_DONT_CARE, VK_ATTACHMENT_LOAD_OP_DONT_CARE,
    VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL
  },
  {
    VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2, NULL,
    0, VK_FORMAT_D24_UNORM_S8_UINT, VK_SAMPLE_COUNT_1_BIT,
    VK_ATTACHMENT_LOAD_OP_CLEAR, VK_ATTACHMENT_STORE_OP_DONT_CARE,
    VK_ATTACHMENT_LOAD_OP_CLEAR, VK_ATTACHMENT_LOAD_OP_DONT_CARE,
    VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL
  },
  {
    VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2, NULL,
    0, VK_FORMAT_R8G8B8A8_UNORM, VK_SAMPLE_COUNT_1_BIT,
    VK_ATTACHMENT_LOAD_OP_CLEAR, VK_ATTACHMENT_STORE_OP_STORE,
    VK_ATTACHMENT_LOAD_OP_DONT_CARE, VK_ATTACHMENT_LOAD_OP_DONT_CARE,
    VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL
  }
};

VkAttachmentReference2 gBufferAttachmentReferences[] = {
  { VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2, NULL, 0, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, VK_IMAGE_ASPECT_COLOR_BIT },
  { VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2, NULL, 1, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, VK_IMAGE_ASPECT_COLOR_BIT },
  { VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2, NULL, 2, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, VK_IMAGE_ASPECT_COLOR_BIT }
};
VkAttachmentReference2 gBufferDepthStencilAttachmentReferences =
  { VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2, NULL, 3, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, VK_IMAGE_ASPECT_DEPTH_BIT|VK_IMAGE_ASPECT_STENCIL_BIT };
VkAttachmentReference2 depthInputAttachmentReferences[] = {
  { VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2, NULL, 3, VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL, VK_IMAGE_ASPECT_DEPTH_BIT|VK_IMAGE_ASPECT_STENCIL_BIT };
};
VkAttachmentReference2 preserveAttachmentReferences[] = {
  { VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2, NULL, 0, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, VK_IMAGE_ASPECT_COLOR_BIT },
  { VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2, NULL, 1, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, VK_IMAGE_ASPECT_COLOR_BIT },
  { VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2, NULL, 2, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, VK_IMAGE_ASPECT_COLOR_BIT },
  { VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2, NULL, 3, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, VK_IMAGE_ASPECT_DEPTH_BIT|VK_IMAGE_ASPECT_STENCIL_BIT }
}; // G buffer including depth/stencil
VkAttachmentReference2 colorAttachmentReferences[] = {
  { VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2, NULL, 4, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, VK_IMAGE_ASPECT_COLOR_BIT }
};
VkAttachmentReference2 resolveAttachmentReference =
  { VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2, NULL, 4, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, VK_IMAGE_ASPECT_COLOR_BIT };

VkSubpassDescription2 subpasses[] = {
  {
    VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2, NULL, 0, VK_PIPELINE_BIND_POINT_GRAPHICS, 0,
    0, NULL, // input
    sizeof(gBufferAttachmentReferences)/sizeof(gBufferAttachmentReferences[0]), gBufferAttachmentReferences, // color
    NULL, &gBufferDepthStencilAttachmentReferences, // resolve & DS
    0, NULL
  },
  {
    VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2, NULL, 0, VK_PIPELINE_BIND_POINT_SUBPASS_SHADING_HUAWEI , 0,
    sizeof(depthInputAttachmentReferences)/sizeof(depthInputAttachmentReferences[0]), depthInputAttachmentReferences, // input
    0, NULL, // color
    NULL, NULL, // resolve & DS
    sizeof(preserveAttachmentReferences)/sizeof(preserveAttachmentReferences[0]), preserveAttachmentReferences,
  },
  {
    VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2, NULL, 0, VK_PIPELINE_BIND_POINT_GRAPHICS, 0,
    sizeof(gBufferAttachmentReferences)/sizeof(gBufferAttachmentReferences[0]), gBufferAttachmentReferences, // input
    sizeof(colorAttachmentReferences)/sizeof(colorAttachmentReferences[0]), colorAttachmentReferences, // color
    &resolveAttachmentReference, &gBufferDepthStencilAttachmentReferences, // resolve & DS
    0, NULL
  },
};

VkMemoryBarrier2KHR fragmentToSubpassShading = {
  VK_STRUCTURE_TYPE_MEMORY_BARRIER_2_KHR, NULL,
  VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT_KHR, VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT|VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT,
  VK_PIPELINE_STAGE_2_SUBPASS_SHADER_BIT_HUAWEI, VK_ACCESS_INPUT_ATTACHMENT_READ_BIT
};

VkMemoryBarrier2KHR subpassShadingToFragment = {
  VK_STRUCTURE_TYPE_MEMORY_BARRIER_2_KHR, NULL,
  VK_PIPELINE_STAGE_2_SUBPASS_SHADER_BIT_HUAWEI, VK_ACCESS_SHADER_WRITE_BIT,
  VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT_KHR, VK_ACCESS_SHADER_READ_BIT
};

VkSubpassDependency2 dependencies[] = {
  {
    VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2, &fragmentToSubpassShading,
    0, 1,
    0, 0, 0, 0,
    0, 0
  },
  {
    VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2, &subpassShadingToFragment,
    1, 2,
    0, 0, 0, 0,
    0, 0
  },
};

VkRenderPassCreateInfo2 renderPassCreateInfo = {
  VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2, NULL, 0,
    sizeof(attachments)/sizeof(attachments[0]), attachments,
    sizeof(subpasses)/sizeof(subpasses[0]), subpasses,
    sizeof(dependencies)/sizeof(dependencies[0]), dependencies,
    0, NULL
};
VKRenderPass renderPass;
vkCreateRenderPass2(device, &renderPassCreateInfo, NULL, &renderPass);

Example of subpass shading pipeline creation

VkExtent2D maxWorkgroupSize;

VkSpecializationMapEntry subpassShadingConstantMapEntries[] = {
  { 0, 0 * sizeof(uint32_t), sizeof(uint32_t) },
  { 1, 1 * sizeof(uint32_t), sizeof(uint32_t) }
};

VkSpecializationInfo subpassShadingConstants = {
  2, subpassShadingConstantMapEntries,
  sizeof(VkExtent2D), &maxWorkgroupSize
};

VkSubpassShadingPipelineCreateInfoHUAWEI subpassShadingPipelineCreateInfo {
  VK_STRUCTURE_TYPE_SUBPASSS_SHADING_PIPELINE_CREATE_INFO_HUAWEI, NULL,
  renderPass, 1
};

VkPipelineShaderStageCreateInfo subpassShadingPipelineStageCreateInfo {
  VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO, NULL,
  0, VK_SHADER_STAGE_SUBPASS_SHADING_BIT_HUAWEI,
  shaderModule, "main",
  &subpassShadingConstants
};

VkComputePipelineCreateInfo subpassShadingComputePipelineCreateInfo = {
  VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO, &subpassShadingPipelineCreateInfo,
  0, &subpassShadingPipelineStageCreateInfo,
  pipelineLayout, basePipelineHandle, basePipelineIndex
};

VKPipeline pipeline;

vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(device, renderPass, &maxWorkgroupSize);
vkCreateComputePipelines(device, pipelineCache, 1, &subpassShadingComputePipelineCreateInfo, NULL, &pipeline);

* 
Revision 3, 2023-06-19 (Pan Gao)

Rename `VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI` to
`VK_PIPELINE_STAGE_2_SUBPASS_SHADER_BIT_HUAWEI` to better aligned with
naming of other pipeline stages

Revision 2, 2021-06-28 (Hueilong Wang)

* 
Change vkGetSubpassShadingMaxWorkgroupSizeHUAWEI to
vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI to resolve issue
[`pub1564`](https://github.com/KhronosGroup/Vulkan-Docs/issues/1564)

Revision 1, 2020-12-15 (Hueilong Wang)

* 
Initial draft.

**Name String**

`VK_IMG_filter_cubic`

**Extension Type**

Device extension

**Registered Extension Number**

16

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

None

**Contact**

* 
Tobias Hector [tobski](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_IMG_filter_cubic] @tobski%0A*Here describe the issue or question you have about the VK_IMG_filter_cubic extension*)

**Last Modified Date**

2016-02-23

**Contributors**

* 
Tobias Hector, Imagination Technologies

`VK_IMG_filter_cubic` adds an additional, high quality cubic filtering mode
to Vulkan, using a Catmull-Rom bicubic filter.
Performing this kind of filtering can be done in a shader by using 16
samples and a number of instructions, but this can be inefficient.
The cubic filter mode exposes an optimized high quality texture sampling
using fixed texture sampling functionality.

* 
`VK_IMG_FILTER_CUBIC_EXTENSION_NAME`

* 
`VK_IMG_FILTER_CUBIC_SPEC_VERSION`

* 
Extending [VkFilter](../chapters/samplers.html#VkFilter):

`VK_FILTER_CUBIC_IMG`

Extending [VkFormatFeatureFlagBits](../chapters/formats.html#VkFormatFeatureFlagBits):

* 
`VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG`

Creating a sampler with the new filter for both magnification and
minification

    VkSamplerCreateInfo createInfo =
    {
        .sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO,
        // Other members set to application-desired values
    };

    createInfo.magFilter = VK_FILTER_CUBIC_IMG;
    createInfo.minFilter = VK_FILTER_CUBIC_IMG;

    VkSampler sampler;
    VkResult result = vkCreateSampler(
        device,
        &createInfo,
        &sampler);

* 
Revision 1, 2016-02-23 (Tobias Hector)

Initial version

**Name String**

`VK_IMG_relaxed_line_rasterization`

**Extension Type**

Device extension

**Registered Extension Number**

111

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Special Use**

* 
[OpenGL / ES support](../chapters/extensions.html#extendingvulkan-compatibility-specialuse)

**Contact**

* 
James Fitzpatrick [jamesfitzpatrick](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_IMG_relaxed_line_rasterization] @jamesfitzpatrick%0A*Here describe the issue or question you have about the VK_IMG_relaxed_line_rasterization extension*)

**Last Modified Date**

2023-10-22

**IP Status**

No known IP claims.

**Contributors**

* 
James Fitzpatrick, Imagination

* 
Andrew Garrard, Imagination

* 
Alex Walters, Imagination

OpenGL specifies that implementations should rasterize lines using the
diamond exit rule (a slightly modified version of Bresenhams algorithm).
To implement OpenGL some implementations have a device-level compatibility
mode to rasterize lines according to the OpenGL specification.

This extension allows OpenGL emulation layers to enable the OpenGL
compatible line rasterization mode of such implementations.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG](../chapters/features.html#VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG)

* 
`VK_IMG_RELAXED_LINE_RASTERIZATION_EXTENSION_NAME`

* 
`VK_IMG_RELAXED_LINE_RASTERIZATION_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG`

None.

* 
Revision 1, 2023-10-22 (James Fitzpatrick)

Initial version

**Name String**

`VK_INTEL_performance_query`

**Extension Type**

Device extension

**Registered Extension Number**

211

**Revision**

2

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

None

**Special Use**

* 
[Developer tools](../chapters/extensions.html#extendingvulkan-compatibility-specialuse)

**Contact**

* 
Lionel Landwerlin [llandwerlin](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_INTEL_performance_query] @llandwerlin%0A*Here describe the issue or question you have about the VK_INTEL_performance_query extension*)

**Last Modified Date**

2018-05-16

**IP Status**

No known IP claims.

**Contributors**

* 
Lionel Landwerlin, Intel

* 
Piotr Maciejewski, Intel

This extension allows an application to capture performance data to be
interpreted by an external application or library.

Such a library is available at : [https://github.com/intel/metrics-discovery](https://github.com/intel/metrics-discovery)

Performance analysis tools such as
[Graphics
Performance Analyzers](https://www.intel.com/content/www/us/en/developer/tools/graphics-performance-analyzers/overview.html) make use of this extension and the metrics-discovery
library to present the data in a human readable way.

* 
[VkPerformanceConfigurationINTEL](../chapters/queries.html#VkPerformanceConfigurationINTEL)

* 
[vkAcquirePerformanceConfigurationINTEL](../chapters/queries.html#vkAcquirePerformanceConfigurationINTEL)

* 
[vkCmdSetPerformanceMarkerINTEL](../chapters/queries.html#vkCmdSetPerformanceMarkerINTEL)

* 
[vkCmdSetPerformanceOverrideINTEL](../chapters/queries.html#vkCmdSetPerformanceOverrideINTEL)

* 
[vkCmdSetPerformanceStreamMarkerINTEL](../chapters/queries.html#vkCmdSetPerformanceStreamMarkerINTEL)

* 
[vkGetPerformanceParameterINTEL](../chapters/queries.html#vkGetPerformanceParameterINTEL)

* 
[vkInitializePerformanceApiINTEL](../chapters/queries.html#vkInitializePerformanceApiINTEL)

* 
[vkQueueSetPerformanceConfigurationINTEL](../chapters/queries.html#vkQueueSetPerformanceConfigurationINTEL)

* 
[vkReleasePerformanceConfigurationINTEL](../chapters/queries.html#vkReleasePerformanceConfigurationINTEL)

* 
[vkUninitializePerformanceApiINTEL](../chapters/queries.html#vkUninitializePerformanceApiINTEL)

* 
[VkInitializePerformanceApiInfoINTEL](../chapters/queries.html#VkInitializePerformanceApiInfoINTEL)

* 
[VkPerformanceConfigurationAcquireInfoINTEL](../chapters/queries.html#VkPerformanceConfigurationAcquireInfoINTEL)

* 
[VkPerformanceMarkerInfoINTEL](../chapters/queries.html#VkPerformanceMarkerInfoINTEL)

* 
[VkPerformanceOverrideInfoINTEL](../chapters/queries.html#VkPerformanceOverrideInfoINTEL)

* 
[VkPerformanceStreamMarkerInfoINTEL](../chapters/queries.html#VkPerformanceStreamMarkerInfoINTEL)

* 
[VkPerformanceValueINTEL](../chapters/queries.html#VkPerformanceValueINTEL)

* 
Extending [VkQueryPoolCreateInfo](../chapters/queries.html#VkQueryPoolCreateInfo):

[VkQueryPoolCreateInfoINTEL](../chapters/queries.html#VkQueryPoolCreateInfoINTEL)

* 
[VkQueryPoolPerformanceQueryCreateInfoINTEL](../chapters/queries.html#VkQueryPoolPerformanceQueryCreateInfoINTEL)

* 
[VkPerformanceValueDataINTEL](../chapters/queries.html#VkPerformanceValueDataINTEL)

* 
[VkPerformanceConfigurationTypeINTEL](../chapters/queries.html#VkPerformanceConfigurationTypeINTEL)

* 
[VkPerformanceOverrideTypeINTEL](../chapters/queries.html#VkPerformanceOverrideTypeINTEL)

* 
[VkPerformanceParameterTypeINTEL](../chapters/queries.html#VkPerformanceParameterTypeINTEL)

* 
[VkPerformanceValueTypeINTEL](../chapters/queries.html#VkPerformanceValueTypeINTEL)

* 
[VkQueryPoolSamplingModeINTEL](../chapters/queries.html#VkQueryPoolSamplingModeINTEL)

* 
`VK_INTEL_PERFORMANCE_QUERY_EXTENSION_NAME`

* 
`VK_INTEL_PERFORMANCE_QUERY_SPEC_VERSION`

* 
Extending [VkObjectType](../chapters/debugging.html#VkObjectType):

`VK_OBJECT_TYPE_PERFORMANCE_CONFIGURATION_INTEL`

Extending [VkQueryType](../chapters/queries.html#VkQueryType):

* 
`VK_QUERY_TYPE_PERFORMANCE_QUERY_INTEL`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL`

* 
`VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL`

* 
`VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL`

* 
`VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL`

* 
`VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL`

* 
`VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO_INTEL`

* 
`VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL`

// A previously created device
VkDevice device;

// A queue derived from the device
VkQueue queue;

VkInitializePerformanceApiInfoINTEL performanceApiInfoIntel = {
  VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL,
  NULL,
  NULL
};

vkInitializePerformanceApiINTEL(
  device,
  &performanceApiInfoIntel);

VkQueryPoolPerformanceQueryCreateInfoINTEL queryPoolIntel = {
  VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO_INTEL,
  NULL,
  VK_QUERY_POOL_SAMPLING_MODE_MANUAL_INTEL,
};

VkQueryPoolCreateInfo queryPoolCreateInfo = {
  VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO,
  &queryPoolIntel,
  0,
  VK_QUERY_TYPE_PERFORMANCE_QUERY_INTEL,
  1,
  0
};

VkQueryPool queryPool;

VkResult result = vkCreateQueryPool(
  device,
  &queryPoolCreateInfo,
  NULL,
  &queryPool);

assert(VK_SUCCESS == result);

// A command buffer we want to record counters on
VkCommandBuffer commandBuffer;

VkCommandBufferBeginInfo commandBufferBeginInfo = {
  VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO,
  NULL,
  VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT,
  NULL
};

result = vkBeginCommandBuffer(commandBuffer, &commandBufferBeginInfo);

assert(VK_SUCCESS == result);

vkCmdResetQueryPool(
  commandBuffer,
  queryPool,
  0,
  1);

vkCmdBeginQuery(
  commandBuffer,
  queryPool,
  0,
  0);

// Perform the commands you want to get performance information on
// ...

// Perform a barrier to ensure all previous commands were complete before
// ending the query
vkCmdPipelineBarrier(commandBuffer,
  VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT,
  VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT,
  0,
  0,
  NULL,
  0,
  NULL,
  0,
  NULL);

vkCmdEndQuery(
  commandBuffer,
  queryPool,
  0);

result = vkEndCommandBuffer(commandBuffer);

assert(VK_SUCCESS == result);

VkPerformanceConfigurationAcquireInfoINTEL performanceConfigurationAcquireInfo = {
  VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL,
  NULL,
  VK_PERFORMANCE_CONFIGURATION_TYPE_COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED_INTEL
};

VkPerformanceConfigurationINTEL performanceConfigurationIntel;

result = vkAcquirePerformanceConfigurationINTEL(
  device,
  &performanceConfigurationAcquireInfo,
  &performanceConfigurationIntel);

vkQueueSetPerformanceConfigurationINTEL(queue, performanceConfigurationIntel);

assert(VK_SUCCESS == result);

// Submit the command buffer and wait for its completion
// ...

result = vkReleasePerformanceConfigurationINTEL(
  device,
  performanceConfigurationIntel);

assert(VK_SUCCESS == result);

// Get the report size from metrics-discovery's QueryReportSize

result = vkGetQueryPoolResults(
  device,
  queryPool,
  0, 1, QueryReportSize,
  data, QueryReportSize, 0);

assert(VK_SUCCESS == result);

// The data can then be passed back to metrics-discovery from which
// human readable values can be queried.

* 
Revision 2, 2020-03-06 (Lionel Landwerlin)

Rename VkQueryPoolCreateInfoINTEL in
VkQueryPoolPerformanceQueryCreateInfoINTEL

Revision 1, 2018-05-16 (Lionel Landwerlin)

* 
Initial revision

**Name String**

`VK_INTEL_shader_integer_functions2`

**Extension Type**

Device extension

**Registered Extension Number**

210

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**SPIR-V Dependencies**

* 
[SPV_INTEL_shader_integer_functions2](https://github.khronos.org/SPIRV-Registry/extensions/INTEL/SPV_INTEL_shader_integer_functions2.html)

**Contact**

* 
Ian Romanick [ianromanick](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_INTEL_shader_integer_functions2] @ianromanick%0A*Here describe the issue or question you have about the VK_INTEL_shader_integer_functions2 extension*)

**Last Modified Date**

2019-04-30

**IP Status**

No known IP claims.

**Interactions and External Dependencies**

* 
This extension provides API support for
[`GL_INTEL_shader_integer_functions2`](https://registry.khronos.org/OpenGL/extensions/INTEL/INTEL_shader_integer_functions2.txt).

**Contributors**

* 
Ian Romanick, Intel

* 
Ben Ashbaugh, Intel

This extension adds support for several new integer instructions in SPIR-V
for use in graphics shaders.
Many of these instructions have pre-existing counterparts in the Kernel
environment.

The added integer functions are defined by the
[`SPV_INTEL_shader_integer_functions2`](https://github.khronos.org/SPIRV-Registry/extensions/INTEL/SPV_INTEL_shader_integer_functions2.html)
SPIR-V extension and can be used with the
`GL_INTEL_shader_integer_functions2` GLSL extension.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL](../chapters/features.html#VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL)

* 
`VK_INTEL_SHADER_INTEGER_FUNCTIONS_2_EXTENSION_NAME`

* 
`VK_INTEL_SHADER_INTEGER_FUNCTIONS_2_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL`

* 
[    `IntegerFunctions2INTEL`](spirvenv.html#spirvenv-capabilities-table-IntegerFunctions2INTEL)

* 
Revision 1, 2019-04-30 (Ian Romanick)

Initial draft

**Name String**

`VK_LUNARG_direct_driver_loading`

**Extension Type**

Instance extension

**Registered Extension Number**

460

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

None

**Contact**

* 
Charles Giessen [charles-lunarg](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_LUNARG_direct_driver_loading] @charles-lunarg%0A*Here describe the issue or question you have about the VK_LUNARG_direct_driver_loading extension*)

**Extension Proposal**

[VK_LUNARG_direct_driver_loading](../../../features/latest/features/proposals/VK_LUNARG_direct_driver_loading.html)

**Last Modified Date**

2022-11-29

**Contributors**

* 
Charles Giessen, LunarG

This extension provides a mechanism for applications to add drivers to the
implementation.
This allows drivers to be included with an application without requiring
installation and is capable of being used in any execution environment, such
as a process running with elevated privileges.

* 
[VkDirectDriverLoadingInfoLUNARG](../chapters/initialization.html#VkDirectDriverLoadingInfoLUNARG)

* 
Extending [VkInstanceCreateInfo](../chapters/initialization.html#VkInstanceCreateInfo):

[VkDirectDriverLoadingListLUNARG](../chapters/initialization.html#VkDirectDriverLoadingListLUNARG)

* 
[PFN_vkGetInstanceProcAddrLUNARG](../chapters/initialization.html#PFN_vkGetInstanceProcAddrLUNARG)

* 
[VkDirectDriverLoadingModeLUNARG](../chapters/initialization.html#VkDirectDriverLoadingModeLUNARG)

* 
[VkDirectDriverLoadingFlagsLUNARG](../chapters/initialization.html#VkDirectDriverLoadingFlagsLUNARG)

* 
`VK_LUNARG_DIRECT_DRIVER_LOADING_EXTENSION_NAME`

* 
`VK_LUNARG_DIRECT_DRIVER_LOADING_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_INFO_LUNARG`

* 
`VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_LIST_LUNARG`

* 
Revision 1, 2022-11-29 (Charles Giessen)

Initial version

**Name String**

`VK_MESA_image_alignment_control`

**Extension Type**

Device extension

**Registered Extension Number**

576

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Special Use**

* 
[D3D support](../chapters/extensions.html#extendingvulkan-compatibility-specialuse)

**Contact**

* 
Hans-Kristian Arntzen [HansKristian-Work](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_MESA_image_alignment_control] @HansKristian-Work%0A*Here describe the issue or question you have about the VK_MESA_image_alignment_control extension*)

**Last Modified Date**

2024-05-03

**IP Status**

No known IP claims.

**Contributors**

* 
Hans-Kristian Arntzen, Valve

This extension allows applications to request a narrower alignment for
images than an implementation would otherwise require.
Some implementations internally support multiple image layouts in
`VK_IMAGE_TILING_OPTIMAL`, each with different alignment requirements
and performance trade-offs.
In some API layering use cases such as D3D12, it is beneficial to be able to
control the alignment, since certain alignments for placed resources are
guaranteed to be supported, and emulating that expectation requires
unnecessary padding of allocations.

[VkImageAlignmentControlCreateInfoMESA](../chapters/resources.html#VkImageAlignmentControlCreateInfoMESA) **can** be chained to
[VkImageCreateInfo](../chapters/resources.html#VkImageCreateInfo), requesting that the alignment is no more than the
provided alignment.
If the requested alignment is not supported for a given
[VkImageCreateInfo](../chapters/resources.html#VkImageCreateInfo), a larger alignment **may** be returned.

While something similar could be achieved with
`[VK_EXT_image_drm_format_modifier](#VK_EXT_image_drm_format_modifier)` in theory, this is not the
intended way to use that extension.
Format modifiers are generally used for externally shareable images, and
would not be platform portable.
It is also a cumbersome API to use just to lower the alignment.

* 
Extending [VkImageCreateInfo](../chapters/resources.html#VkImageCreateInfo):

[VkImageAlignmentControlCreateInfoMESA](../chapters/resources.html#VkImageAlignmentControlCreateInfoMESA)

Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

* 
[VkPhysicalDeviceImageAlignmentControlFeaturesMESA](../chapters/features.html#VkPhysicalDeviceImageAlignmentControlFeaturesMESA)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceImageAlignmentControlPropertiesMESA](../chapters/limits.html#VkPhysicalDeviceImageAlignmentControlPropertiesMESA)

* 
`VK_MESA_IMAGE_ALIGNMENT_CONTROL_EXTENSION_NAME`

* 
`VK_MESA_IMAGE_ALIGNMENT_CONTROL_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_FEATURES_MESA`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_PROPERTIES_MESA`

* 
Revision 1, 2024-04-05 (Hans-Kristian Arntzen)

Initial specification

**Name String**

`VK_MSFT_layered_driver`

**Extension Type**

Device extension

**Registered Extension Number**

531

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Contact**

* 
Jesse Natalie [jenatali](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_MSFT_layered_driver] @jenatali%0A*Here describe the issue or question you have about the VK_MSFT_layered_driver extension*)

**Extension Proposal**

[VK_MSFT_layered_driver](../../../features/latest/features/proposals/VK_MSFT_layered_driver.html)

**Last Modified Date**

2023-06-21

**IP Status**

No known IP claims.

**Contributors**

* 
Jesse Natalie, Microsoft

This extension adds new physical device properties to allow applications and
the Vulkan ICD loader to understand when a physical device is implemented as
a layered driver on top of another underlying API.

* 
Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

[VkPhysicalDeviceLayeredDriverPropertiesMSFT](../chapters/devsandqueues.html#VkPhysicalDeviceLayeredDriverPropertiesMSFT)

* 
[VkLayeredDriverUnderlyingApiMSFT](../chapters/devsandqueues.html#VkLayeredDriverUnderlyingApiMSFT)

* 
`VK_MSFT_LAYERED_DRIVER_EXTENSION_NAME`

* 
`VK_MSFT_LAYERED_DRIVER_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT`

None.

* 
Revision 1, 2023-06-21 (Jesse Natalie)

Initial revision

**Name String**

`VK_NN_vi_surface`

**Extension Type**

Instance extension

**Registered Extension Number**

63

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_surface](#VK_KHR_surface)

**Contact**

* 
Mathias Heyer mheyer

**Last Modified Date**

2016-12-02

**IP Status**

No known IP claims.

**Contributors**

* 
Mathias Heyer, NVIDIA

* 
Michael Chock, NVIDIA

* 
Yasuhiro Yoshioka, Nintendo

* 
Daniel Koch, NVIDIA

The `VK_NN_vi_surface` extension is an instance extension.
It provides a mechanism to create a [VkSurfaceKHR](../chapters/VK_KHR_surface/wsi.html#VkSurfaceKHR) object (defined by
the `[VK_KHR_surface](#VK_KHR_surface)` extension) associated with an
`nn`::`vi`::`Layer`.

* 
[vkCreateViSurfaceNN](../chapters/VK_KHR_surface/wsi.html#vkCreateViSurfaceNN)

* 
[VkViSurfaceCreateInfoNN](../chapters/VK_KHR_surface/wsi.html#VkViSurfaceCreateInfoNN)

* 
[VkViSurfaceCreateFlagsNN](../chapters/VK_KHR_surface/wsi.html#VkViSurfaceCreateFlagsNN)

* 
`VK_NN_VI_SURFACE_EXTENSION_NAME`

* 
`VK_NN_VI_SURFACE_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN`

1) Does VI need a way to query for compatibility between a particular
physical device (and queue family?) and a specific VI display?

**RESOLVED**: No.
It is currently always assumed that the device and display will always be
compatible.

2) [VkViSurfaceCreateInfoNN](../chapters/VK_KHR_surface/wsi.html#VkViSurfaceCreateInfoNN)::`window` is intended to store an
`nn`::`vi`::`NativeWindowHandle`, but its declared type is a bare
`void*` to store the window handle.
Why the discrepancy?

**RESOLVED**: It is for C compatibility.
The definition for the VI native window handle type is defined inside the
`nn`::`vi` C++ namespace.
This prevents its use in C source files.
`nn`::`vi`::`NativeWindowHandle` is always defined to be
`void*`, so this extension uses `void*` to match.

* 
Revision 1, 2016-12-2 (Michael Chock)

Initial draft.

**Name String**

`VK_NV_acquire_winrt_display`

**Extension Type**

Device extension

**Registered Extension Number**

346

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_EXT_direct_mode_display](#VK_EXT_direct_mode_display)

**Contact**

* 
Jeff Juliano [jjuliano](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NV_acquire_winrt_display] @jjuliano%0A*Here describe the issue or question you have about the VK_NV_acquire_winrt_display extension*)

**Last Modified Date**

2020-09-29

**IP Status**

No known IP claims.

**Contributors**

* 
Jeff Juliano, NVIDIA

This extension allows an application to take exclusive control of a display
on Windows 10 provided that the display is not already controlled by a
compositor.
Examples of compositors include the Windows desktop compositor, other
applications using this Vulkan extension, and applications that
[Acquire](https://docs.microsoft.com/en-us/uwp/api/windows.devices.display.core.displaymanager.tryacquiretarget)
a
[DisplayTarget](https://docs.microsoft.com/en-us/uwp/api/windows.devices.display.core.displaytarget)
using a [WinRT](https://docs.microsoft.com/en-us/uwp/api/) command such as
[winrt::Windows::Devices::Display::Core::DisplayManager.TryAcquireTarget()](https://docs.microsoft.com/en-us/uwp/api/windows.devices.display.core.displaymanager.tryacquiretarget).

When control is acquired the application has exclusive access to the display
until control is released or the application terminates.
An applications attempt to acquire is denied if a different application has
already acquired the display.

* 
[vkAcquireWinrtDisplayNV](../chapters/VK_KHR_surface/wsi.html#vkAcquireWinrtDisplayNV)

* 
[vkGetWinrtDisplayNV](../chapters/VK_KHR_surface/wsi.html#vkGetWinrtDisplayNV)

* 
`VK_NV_ACQUIRE_WINRT_DISPLAY_EXTENSION_NAME`

* 
`VK_NV_ACQUIRE_WINRT_DISPLAY_SPEC_VERSION`

1) What should the platform substring be for this extension:

**RESOLVED**: The platform substring is Winrt.

The substring Winrt matches the fact that the OS API exposing the
acquire and release functionality is called WinRT.

The substring Win32 is wrong because the related WinRT API is
explicitly **not** a Win32 API.
WinRT is a competing API family to the Win32 API family.

The substring Windows is suboptimal because there could be more than one
relevant API on the Windows platform.
There is preference to use the more-specific substring Winrt.

2) Should [vkAcquireWinrtDisplayNV](../chapters/VK_KHR_surface/wsi.html#vkAcquireWinrtDisplayNV) take a winRT DisplayTarget, or a
Vulkan display handle as input?

**RESOLVED**: A Vulkan display handle.
This matches the design of [vkAcquireXlibDisplayEXT](../chapters/VK_KHR_surface/wsi.html#vkAcquireXlibDisplayEXT).

3) Should the acquire command be platform-independent named
vkAcquireDisplayNV, or platform-specific named
vkAcquireWinrtDisplayNV?

**RESOLVED**: Add a platform-specific command.

The inputs to the Acquire command are all Vulkan types.
None are WinRT types.
This opens the possibility of the winrt extension defining a
platform-independent acquire command.

The X11 acquire command does need to accept a platform-specific parameter.
This could be handled by adding to a platform-independent acquire command a
params structure to which platform-dependent types can be chained by
`pNext` pointer.

The prevailing opinion is that it would be odd to create a second
platform-independent function that is used on the Windows 10 platform, but
that is not used for the X11 platform.
Since a Windows 10 platform-specific command is needed anyway for converting
between vkDisplayKHR and platform-native handles, opinion was to create a
platform-specific acquire function.

4) Should the [vkGetWinrtDisplayNV](../chapters/VK_KHR_surface/wsi.html#vkGetWinrtDisplayNV) parameter identifying a display be
named deviceRelativeId or adapterRelativeId?

**RESOLVED**: The WinRT name is AdapterRelativeId.
The name adapter is the Windows analog to a Vulkan physical device.
Vulkan already has precedent to use the name `deviceLUID` for the
concept that Windows APIs call AdapterLuid.
Keeping form with this precedent, the name deviceRelativeId is chosen.

5) Does [vkAcquireWinrtDisplayNV](../chapters/VK_KHR_surface/wsi.html#vkAcquireWinrtDisplayNV) cause the Windows desktop compositor
to release a display?

**RESOLVED**: No.
[vkAcquireWinrtDisplayNV](../chapters/VK_KHR_surface/wsi.html#vkAcquireWinrtDisplayNV) does not itself cause the Windows desktop
compositor to release a display.
This action must be performed outside of Vulkan.

Beginning with Windows 10 version 2004 it is possible to cause the Windows
desktop compositor to release a display by using the Advanced display
settings sub-page of the Display settings control panel.
See
[https://docs.microsoft.com/en-us/windows-hardware/drivers/display/specialized-monitors](https://docs.microsoft.com/en-us/windows-hardware/drivers/display/specialized-monitors)

6) Where can one find additional information about custom compositors for
Windows 10?

**RESOLVED**: Relevant references are as follows.

According to Microsofts documentation on
["building
a custom compositor"](https://docs.microsoft.com/en-us/windows-hardware/drivers/display/specialized-monitors-compositor), the ability to write a custom compositor is not a
replacement for a fullscreen desktop window.
The feature is for writing compositor apps that drive specialized hardware.

Only certain editions of Windows 10 support custom compositors,
["documented
here"](https://docs.microsoft.com/en-us/windows-hardware/drivers/display/specialized-monitors#windows-10-version-2004).
The product type can be queried from Windows 10.
See
[https://docs.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-getproductinfo](https://docs.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-getproductinfo)

* 
Revision 1, 2020-09-29 (Jeff Juliano)

Initial draft

**Name String**

`VK_NV_clip_space_w_scaling`

**Extension Type**

Device extension

**Registered Extension Number**

88

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

None

**Contact**

* 
Eric Werness [ewerness-nv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NV_clip_space_w_scaling] @ewerness-nv%0A*Here describe the issue or question you have about the VK_NV_clip_space_w_scaling extension*)

**Last Modified Date**

2017-02-15

**Contributors**

* 
Eric Werness, NVIDIA

* 
Kedarnath Thangudu, NVIDIA

Virtual Reality (VR) applications often involve a post-processing step to
apply a barrel distortion to the rendered image to correct the
pincushion distortion introduced by the optics in a VR device.
The barrel distorted image has lower resolution along the edges compared to
the center.
Since the original image is rendered at high resolution, which is uniform
across the complete image, a lot of pixels towards the edges do not make it
to the final post-processed image.

This extension provides a mechanism to render VR scenes at a non-uniform
resolution, in particular a resolution that falls linearly from the center
towards the edges.
This is achieved by scaling the w coordinate of the vertices in the
clip space before perspective divide.
The clip space w coordinate of the vertices **can** be offset as of a
function of x and y coordinates as follows:

w' = w +  Ax +  By

In the intended use case for viewport position scaling, an application
should use a set of four viewports, one for each of the four quadrants of a
Cartesian coordinate system.
Each viewport is set to the dimension of the image, but is scissored to the
quadrant it represents.
The application should specify A and B coefficients of the
w-scaling equation above, that have the same value, but different
signs, for each of the viewports.
The signs of A and B should match the signs of x and
y for the quadrant that they represent such that the value of w'
will always be greater than or equal to the original w value for the
entire image.
Since the offset to w, (Ax +  By), is always positive, and
increases with the absolute values of x and y, the effective
resolution will fall off linearly from the center of the image to its edges.

* 
[vkCmdSetViewportWScalingNV](../chapters/vertexpostproc.html#vkCmdSetViewportWScalingNV)

* 
[VkViewportWScalingNV](../chapters/vertexpostproc.html#VkViewportWScalingNV)

* 
Extending [VkPipelineViewportStateCreateInfo](../chapters/vertexpostproc.html#VkPipelineViewportStateCreateInfo):

[VkPipelineViewportWScalingStateCreateInfoNV](../chapters/vertexpostproc.html#VkPipelineViewportWScalingStateCreateInfoNV)

* 
`VK_NV_CLIP_SPACE_W_SCALING_EXTENSION_NAME`

* 
`VK_NV_CLIP_SPACE_W_SCALING_SPEC_VERSION`

* 
Extending [VkDynamicState](../chapters/pipelines.html#VkDynamicState):

`VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV`

1) Is the pipeline structure name too long?

**RESOLVED**: It fits with the naming convention.

2) Separate W scaling section or fold into coordinate transformations?

**RESOLVED**: Leaving it as its own section for now.

VkViewport viewports[4];
VkRect2D scissors[4];
VkViewportWScalingNV scalings[4];

for (int i = 0; i 

Example shader to read from a w-scaled texture:

// Vertex Shader
// Draw a triangle that covers the whole screen
const vec4 positions[3] = vec4[3](vec4(-1, -1, 0, 1),
                                  vec4( 3, -1, 0, 1),
                                  vec4(-1,  3, 0, 1));
out vec2 uv;
void main()
{
    vec4 pos = positions[ gl_VertexID ];
    gl_Position = pos;
    uv = pos.xy;
}

// Fragment Shader
uniform sampler2D tex;
uniform float xcoeff;
uniform float ycoeff;
out vec4 Color;
in vec2 uv;

void main()
{
    // Handle uv as if upper right quadrant
    vec2 uvabs = abs(uv);

    // unscale: transform w-scaled image into an unscaled image
    //   scale: transform unscaled image int a w-scaled image
    float unscale = 1.0 / (1 + xcoeff * uvabs.x + xcoeff * uvabs.y);
    //float scale = 1.0 / (1 - xcoeff * uvabs.x - xcoeff * uvabs.y);

    vec2 P = vec2(unscale * uvabs.x, unscale * uvabs.y);

    // Go back to the right quadrant
    P *= sign(uv);

    Color = texture(tex, P * 0.5 + 0.5);
}

* 
Revision 1, 2017-02-15 (Eric Werness)

Internal revisions

**Name String**

`VK_NV_cluster_acceleration_structure`

**Extension Type**

Device extension

**Registered Extension Number**

570

**Revision**

2

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_acceleration_structure](#VK_KHR_acceleration_structure)

**API Interactions**

* 
Interacts with VK_EXT_opacity_micromap

* 
Interacts with VK_KHR_ray_tracing_pipeline

**SPIR-V Dependencies**

* 
[SPV_NV_cluster_acceleration_structure](https://github.khronos.org/SPIRV-Registry/extensions/NV/SPV_NV_cluster_acceleration_structure.html)

**Contact**

* 
Vikram Kushwaha [vkushwaha](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NV_cluster_acceleration_structure] @vkushwaha%0A*Here describe the issue or question you have about the VK_NV_cluster_acceleration_structure extension*)

**Extension Proposal**

[VK_NV_cluster_acceleration_structure](../../../features/latest/features/proposals/VK_NV_cluster_acceleration_structure.html)

**Last Modified Date**

2024-09-09

**Contributors**

* 
Vikram Kushwaha, NVIDIA

* 
Eric Werness, NVIDIA

* 
Christoph Kubisch, NVIDIA

* 
Jan Schmid, NVIDIA

* 
Pyarelal Knowles, NVIDIA

Acceleration structure build times can become a bottleneck in ray tracing
applications dealing with extensive dynamic geometry.
This extension addresses the problem by enabling applications to construct
bottom-level acceleration structures (BLAS) from pre-generated acceleration
structures based on clusters of triangles (CLAS), leading to significant
improvements in build times.

It provides a host-side query function to fetch the requirements and a
versatile multi-indirect call for managing cluster geometry.
This call enables applications to generate cluster geometry, construct
Cluster BLAS from CLAS lists, and move or copy CLAS and BLAS.
By sourcing inputs from device memory and processing multiple elements
simultaneously, the call reduces the host-side costs associated with
traditional acceleration structure functions.

This extension adds support for the following SPIR-V extension in Vulkan:

* 
`SPV_NV_cluster_acceleration_structure`

* 
[vkCmdBuildClusterAccelerationStructureIndirectNV](../chapters/accelstructures.html#vkCmdBuildClusterAccelerationStructureIndirectNV)

* 
[vkGetClusterAccelerationStructureBuildSizesNV](../chapters/accelstructures.html#vkGetClusterAccelerationStructureBuildSizesNV)

* 
[VkClusterAccelerationStructureBuildClustersBottomLevelInfoNV](../chapters/accelstructures.html#VkClusterAccelerationStructureBuildClustersBottomLevelInfoNV)

* 
[VkClusterAccelerationStructureBuildTriangleClusterInfoNV](../chapters/accelstructures.html#VkClusterAccelerationStructureBuildTriangleClusterInfoNV)

* 
[VkClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV](../chapters/accelstructures.html#VkClusterAccelerationStructureBuildTriangleClusterTemplateInfoNV)

* 
[VkClusterAccelerationStructureClustersBottomLevelInputNV](../chapters/accelstructures.html#VkClusterAccelerationStructureClustersBottomLevelInputNV)

* 
[VkClusterAccelerationStructureCommandsInfoNV](../chapters/accelstructures.html#VkClusterAccelerationStructureCommandsInfoNV)

* 
[VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV](../chapters/accelstructures.html#VkClusterAccelerationStructureGeometryIndexAndGeometryFlagsNV)

* 
[VkClusterAccelerationStructureInputInfoNV](../chapters/accelstructures.html#VkClusterAccelerationStructureInputInfoNV)

* 
[VkClusterAccelerationStructureInstantiateClusterInfoNV](../chapters/accelstructures.html#VkClusterAccelerationStructureInstantiateClusterInfoNV)

* 
[VkClusterAccelerationStructureMoveObjectsInfoNV](../chapters/accelstructures.html#VkClusterAccelerationStructureMoveObjectsInfoNV)

* 
[VkClusterAccelerationStructureMoveObjectsInputNV](../chapters/accelstructures.html#VkClusterAccelerationStructureMoveObjectsInputNV)

* 
[VkClusterAccelerationStructureTriangleClusterInputNV](../chapters/accelstructures.html#VkClusterAccelerationStructureTriangleClusterInputNV)

* 
[VkStridedDeviceAddressNV](../chapters/accelstructures.html#VkStridedDeviceAddressNV)

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceClusterAccelerationStructureFeaturesNV](../chapters/features.html#VkPhysicalDeviceClusterAccelerationStructureFeaturesNV)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceClusterAccelerationStructurePropertiesNV](../chapters/limits.html#VkPhysicalDeviceClusterAccelerationStructurePropertiesNV)

If [VK_KHR_ray_tracing_pipeline](#VK_KHR_ray_tracing_pipeline) is supported:

* 
Extending [VkRayTracingPipelineCreateInfoKHR](../chapters/pipelines.html#VkRayTracingPipelineCreateInfoKHR):

[VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV](../chapters/pipelines.html#VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV)

* 
[VkClusterAccelerationStructureOpInputNV](../chapters/accelstructures.html#VkClusterAccelerationStructureOpInputNV)

* 
[VkClusterAccelerationStructureAddressResolutionFlagBitsNV](../chapters/accelstructures.html#VkClusterAccelerationStructureAddressResolutionFlagBitsNV)

* 
[VkClusterAccelerationStructureClusterFlagBitsNV](../chapters/accelstructures.html#VkClusterAccelerationStructureClusterFlagBitsNV)

* 
[VkClusterAccelerationStructureGeometryFlagBitsNV](../chapters/accelstructures.html#VkClusterAccelerationStructureGeometryFlagBitsNV)

* 
[VkClusterAccelerationStructureIndexFormatFlagBitsNV](../chapters/accelstructures.html#VkClusterAccelerationStructureIndexFormatFlagBitsNV)

* 
[VkClusterAccelerationStructureOpModeNV](../chapters/accelstructures.html#VkClusterAccelerationStructureOpModeNV)

* 
[VkClusterAccelerationStructureOpTypeNV](../chapters/accelstructures.html#VkClusterAccelerationStructureOpTypeNV)

* 
[VkClusterAccelerationStructureTypeNV](../chapters/accelstructures.html#VkClusterAccelerationStructureTypeNV)

* 
[VkClusterAccelerationStructureAddressResolutionFlagsNV](../chapters/accelstructures.html#VkClusterAccelerationStructureAddressResolutionFlagsNV)

* 
[VkClusterAccelerationStructureClusterFlagsNV](../chapters/accelstructures.html#VkClusterAccelerationStructureClusterFlagsNV)

* 
[VkClusterAccelerationStructureGeometryFlagsNV](../chapters/accelstructures.html#VkClusterAccelerationStructureGeometryFlagsNV)

* 
[VkClusterAccelerationStructureIndexFormatFlagsNV](../chapters/accelstructures.html#VkClusterAccelerationStructureIndexFormatFlagsNV)

* 
`VK_NV_CLUSTER_ACCELERATION_STRUCTURE_EXTENSION_NAME`

* 
`VK_NV_CLUSTER_ACCELERATION_STRUCTURE_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_CLUSTERS_BOTTOM_LEVEL_INPUT_NV`

* 
`VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_COMMANDS_INFO_NV`

* 
`VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_INPUT_INFO_NV`

* 
`VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_MOVE_OBJECTS_INPUT_NV`

* 
`VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_TRIANGLE_CLUSTER_INPUT_NV`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_FEATURES_NV`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_PROPERTIES_NV`

* 
`VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CLUSTER_ACCELERATION_STRUCTURE_CREATE_INFO_NV`

If [VK_EXT_opacity_micromap](#VK_EXT_opacity_micromap) is supported:

* 
Extending [VkOpacityMicromapSpecialIndexEXT](../chapters/accelstructures.html#VkOpacityMicromapSpecialIndexEXT):

`VK_OPACITY_MICROMAP_SPECIAL_INDEX_CLUSTER_GEOMETRY_DISABLE_OPACITY_MICROMAP_NV`

* 
[`ClusterIDNV`](../chapters/interfaces.html#interfaces-builtin-variables-clusteridnv)

* 
[    `RayTracingClusterAccelerationStructureNV`](spirvenv.html#spirvenv-capabilities-table-RayTracingClusterAccelerationStructureNV)

* 
Revision 2, 2024-09-09 (Vikram Kushwaha)

Changes to some structures causing incompatibility with Revision 1

Revision 1, 2024-08-29 (Vikram Kushwaha)

* 
Initial draft

**Name String**

`VK_NV_command_buffer_inheritance`

**Extension Type**

Device extension

**Registered Extension Number**

560

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

None

**Contact**

* 
Lujin Wang [lujinwangnv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NV_command_buffer_inheritance] @lujinwangnv%0A*Here describe the issue or question you have about the VK_NV_command_buffer_inheritance extension*)

**Last Modified Date**

2024-02-15

**IP Status**

No known IP claims.

**Contributors**

* 
Piers Daniell, NVIDIA

* 
Daniel Story, Nintendo

This extension allows applications to take advantage of the graphics and
compute state that remains valid in the queue between executions of
submitted command buffers.
This works across both primary and secondary command buffers.

The state inherited includes the previously bound pipeline state, previously
bound shader objects, previously bound vertex and index buffers, previously
bound descriptor sets and push constants, and all previously set dynamic
state.

This extension relaxes the requirement that all that state needs to be bound
and set after begin command buffer and before the next draw or dispatch.

By not having to set state that has been inherited applications can save
both CPU and GPU cycles by not having to set state redundantly, and also
have improved flexibility when reusing secondary command buffers.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceCommandBufferInheritanceFeaturesNV](../chapters/features.html#VkPhysicalDeviceCommandBufferInheritanceFeaturesNV)

* 
`VK_NV_COMMAND_BUFFER_INHERITANCE_EXTENSION_NAME`

* 
`VK_NV_COMMAND_BUFFER_INHERITANCE_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMMAND_BUFFER_INHERITANCE_FEATURES_NV`

1) How can the validation layer know when state is valid at draw or dispatch
time if it is inherited at execution time?

**RESOLVED**: Validation of invalid state at draw and dispatch time cannot be
done while recording those commands.
Instead the validation layer will need to keep track of any unset state when
draw and dispatch commands are recorded, but not report an error at that
time.
It should also keep track of what state is valid at the end of each recorded
command buffer.
When secondary command buffer execution is recorded the validation layer can
update its unset state tracking for that command buffer, and also for draw
and dispatch commands recorded after execution of the secondary as they will
inherit state from the executed secondary.
This can be done recursively so every recorded primary command buffer has a
final tally of any unset state used at draw and dispatch time.
Finally when the primary is submitted to the queue the validation layer will
know the previous primaries submitted to the queue and will know if there is
any unset state used and can report the error then.

* 
Revision 1, 2024-02-15 (Lujin Wang)

Internal revisions

**Name String**

`VK_NV_cooperative_matrix`

**Extension Type**

Device extension

**Registered Extension Number**

250

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**SPIR-V Dependencies**

* 
[SPV_NV_cooperative_matrix](https://github.khronos.org/SPIRV-Registry/extensions/NV/SPV_NV_cooperative_matrix.html)

**Contact**

* 
Jeff Bolz [jeffbolznv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NV_cooperative_matrix] @jeffbolznv%0A*Here describe the issue or question you have about the VK_NV_cooperative_matrix extension*)

**Last Modified Date**

2019-02-05

**Interactions and External Dependencies**

* 
This extension provides API support for
[`GL_NV_cooperative_matrix`](https://github.com/KhronosGroup/GLSL/blob/main/extensions/nv/GLSL_NV_cooperative_matrix.txt)

**Contributors**

* 
Jeff Bolz, NVIDIA

* 
Markus Tavenrath, NVIDIA

* 
Daniel Koch, NVIDIA

This extension adds support for using cooperative matrix types in SPIR-V.
Cooperative matrix types are medium-sized matrices that are primarily
supported in compute shaders, where the storage for the matrix is spread
across all invocations in some scope (usually a subgroup) and those
invocations cooperate to efficiently perform matrix multiplies.

Cooperative matrix types are defined by the
[`SPV_NV_cooperative_matrix`](https://github.khronos.org/SPIRV-Registry/extensions/NV/SPV_NV_cooperative_matrix.html)
SPIR-V extension and can be used with the
[`GL_NV_cooperative_matrix`](https://github.com/KhronosGroup/GLSL/blob/main/extensions/nv/GLSL_NV_cooperative_matrix.txt)
GLSL extension.

This extension includes support for enumerating the matrix types and
dimensions that are supported by the implementation.

* 
[vkGetPhysicalDeviceCooperativeMatrixPropertiesNV](../chapters/shaders.html#vkGetPhysicalDeviceCooperativeMatrixPropertiesNV)

* 
[VkCooperativeMatrixPropertiesNV](../chapters/shaders.html#VkCooperativeMatrixPropertiesNV)

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceCooperativeMatrixFeaturesNV](../chapters/features.html#VkPhysicalDeviceCooperativeMatrixFeaturesNV)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceCooperativeMatrixPropertiesNV](../chapters/limits.html#VkPhysicalDeviceCooperativeMatrixPropertiesNV)

* 
[VkComponentTypeNV](../chapters/shaders.html#VkComponentTypeNV)

* 
[VkScopeNV](../chapters/shaders.html#VkScopeNV)

* 
`VK_NV_COOPERATIVE_MATRIX_EXTENSION_NAME`

* 
`VK_NV_COOPERATIVE_MATRIX_SPEC_VERSION`

* 
Extending [VkComponentTypeKHR](../chapters/shaders.html#VkComponentTypeKHR):

`VK_COMPONENT_TYPE_FLOAT16_NV`

* 
`VK_COMPONENT_TYPE_FLOAT32_NV`

* 
`VK_COMPONENT_TYPE_FLOAT64_NV`

* 
`VK_COMPONENT_TYPE_SINT16_NV`

* 
`VK_COMPONENT_TYPE_SINT32_NV`

* 
`VK_COMPONENT_TYPE_SINT64_NV`

* 
`VK_COMPONENT_TYPE_SINT8_NV`

* 
`VK_COMPONENT_TYPE_UINT16_NV`

* 
`VK_COMPONENT_TYPE_UINT32_NV`

* 
`VK_COMPONENT_TYPE_UINT64_NV`

* 
`VK_COMPONENT_TYPE_UINT8_NV`

Extending [VkScopeKHR](../chapters/shaders.html#VkScopeKHR):

* 
`VK_SCOPE_DEVICE_NV`

* 
`VK_SCOPE_QUEUE_FAMILY_NV`

* 
`VK_SCOPE_SUBGROUP_NV`

* 
`VK_SCOPE_WORKGROUP_NV`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV`

* 
[    `CooperativeMatrixNV`](spirvenv.html#spirvenv-capabilities-table-CooperativeMatrixNV)

(1) What matrix properties will be supported in practice?

**RESOLVED**: In NVIDIAs initial implementation, we will support:

* 
AType = BType = fp16 CType = DType = fp16 MxNxK = 16x8x16 scope =
Subgroup

* 
AType = BType = fp16 CType = DType = fp16 MxNxK = 16x8x8 scope =
Subgroup

* 
AType = BType = fp16 CType = DType = fp32 MxNxK = 16x8x16 scope =
Subgroup

* 
AType = BType = fp16 CType = DType = fp32 MxNxK = 16x8x8 scope =
Subgroup

* 
Revision 1, 2019-02-05 (Jeff Bolz)

Internal revisions

**Name String**

`VK_NV_cooperative_matrix2`

**Extension Type**

Device extension

**Registered Extension Number**

594

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_cooperative_matrix](#VK_KHR_cooperative_matrix)

**SPIR-V Dependencies**

* 
[SPV_NV_cooperative_matrix2](https://github.khronos.org/SPIRV-Registry/extensions/NV/SPV_NV_cooperative_matrix2.html)

* 
[SPV_NV_tensor_addressing](https://github.khronos.org/SPIRV-Registry/extensions/NV/SPV_NV_tensor_addressing.html)

**Contact**

* 
Jeff Bolz [jeffbolznv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NV_cooperative_matrix2] @jeffbolznv%0A*Here describe the issue or question you have about the VK_NV_cooperative_matrix2 extension*)

**Extension Proposal**

[VK_NV_cooperative_matrix2](../../../features/latest/features/proposals/VK_NV_cooperative_matrix2.html)

**Last Modified Date**

2024-08-01

**Interactions and External Dependencies**

* 
This extension provides API support for
[`GLSL_NV_cooperative_matrix2`](https://github.com/KhronosGroup/GLSL/blob/main/extensions/nv/GLSL_NV_cooperative_matrix2.txt)

**Contributors**

* 
Jeff Bolz, NVIDIA

* 
Karthik Vaidyanathan, NVIDIA

This extension adds several new features building on the cooperative matrix
types added in VK_KHR_cooperative_matrix.
The goal is to add and accelerate features beyond just simple GEMM kernels,
including adding support for type/use conversions, reductions, per-element
operations, and tensor addressing, and also to improve usability and
out-of-the-box performance by adding support for more flexible matrix sizes,
and workgroup scope matrices with compiler-managed staging through shared
memory.

The new functionality is defined by the
[`SPV_NV_tensor_addressing`](https://github.khronos.org/SPIRV-Registry/extensions/NV/SPV_NV_tensor_addressing.html) and
[`SPV_NV_cooperative_matrix2`](https://github.khronos.org/SPIRV-Registry/extensions/NV/SPV_NV_cooperative_matrix2.html)
SPIR-V extensions and can be used with the
[`GLSL_NV_cooperative_matrix2`](https://github.com/KhronosGroup/GLSL/blob/main/extensions/nv/GLSL_NV_cooperative_matrix2.txt)
GLSL extension.

This extension includes support for enumerating the matrix types and
dimensions that are supported by the implementation, and which specific
features are supported.

* 
[vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV](../chapters/shaders.html#vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV)

* 
[VkCooperativeMatrixFlexibleDimensionsPropertiesNV](../chapters/shaders.html#VkCooperativeMatrixFlexibleDimensionsPropertiesNV)

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceCooperativeMatrix2FeaturesNV](../chapters/features.html#VkPhysicalDeviceCooperativeMatrix2FeaturesNV)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceCooperativeMatrix2PropertiesNV](../chapters/limits.html#VkPhysicalDeviceCooperativeMatrix2PropertiesNV)

* 
`VK_NV_COOPERATIVE_MATRIX_2_EXTENSION_NAME`

* 
`VK_NV_COOPERATIVE_MATRIX_2_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_FLEXIBLE_DIMENSIONS_PROPERTIES_NV`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_FEATURES_NV`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_PROPERTIES_NV`

* 
[TensorAddressingNV](spirvenv.html#spirvenv-capabilities-table-TensorAddressingNV)

* 
[CooperativeMatrixReductionsNV](spirvenv.html#spirvenv-capabilities-table-CooperativeMatrixReductionsNV)

* 
[CooperativeMatrixConversionsNV](spirvenv.html#spirvenv-capabilities-table-CooperativeMatrixConversionsNV)

* 
[CooperativeMatrixPerElementOperationsNV](spirvenv.html#spirvenv-capabilities-table-CooperativeMatrixPerElementOperationsNV)

* 
[CooperativeMatrixTensorAddressingNV](spirvenv.html#spirvenv-capabilities-table-CooperativeMatrixTensorAddressingNV)

* 
[CooperativeMatrixBlockLoadsNV](spirvenv.html#spirvenv-capabilities-table-CooperativeMatrixBlockLoadsNV)

* 
Revision 1, 2024-08-01 (Jeff Bolz)

Initial revision

**Name String**

`VK_NV_cooperative_vector`

**Extension Type**

Device extension

**Registered Extension Number**

492

**Revision**

4

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

None

**SPIR-V Dependencies**

* 
[SPV_NV_cooperative_vector](https://github.khronos.org/SPIRV-Registry/extensions/NV/SPV_NV_cooperative_vector.html)

**Contact**

* 
Jeff Bolz [jeffbolznv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NV_cooperative_vector] @jeffbolznv%0A*Here describe the issue or question you have about the VK_NV_cooperative_vector extension*)

**Extension Proposal**

[VK_NV_cooperative_vector](../../../features/latest/features/proposals/VK_NV_cooperative_vector.html)

**Last Modified Date**

2024-05-23

**Interactions and External Dependencies**

* 
This extension requires
[`SPV_NV_cooperative_vector`](https://github.khronos.org/SPIRV-Registry/extensions/NV/SPV_NV_cooperative_vector.html)

* 
This extension provides API support for
[`GL_NV_cooperative_vector`](https://github.com/KhronosGroup/GLSL/blob/main/extensions/nv/GLSL_NV_cooperative_vector.txt)

**Contributors**

* 
Jeff Bolz, NVIDIA

This extension adds support for using cooperative vector types in SPIR-V.
Unlike cooperative matrix types, a variable with a cooperative vector type
is logically stored in the invocation it belongs to, but they can cooperate
behind the scenes when performing matrix-vector multiplies.
Cooperative vectors do not require a fully occupied subgroup or uniform
control flow like cooperative matrices, although these do increase the
likelihood of being on the fast path.
And unlike normal vector types, they have arbitrary length and support a
relatively limited set of operations.
These types are intended to help accelerate the evaluation of small neural
networks, where each invocation is performing its own independent evaluation
of the network.

Cooperative vector types are defined by the
[`SPV_NV_cooperative_vector`](https://github.khronos.org/SPIRV-Registry/extensions/NV/SPV_NV_cooperative_vector.html)
SPIR-V extension and can be used with the
[`GL_NV_cooperative_vector`](https://github.com/KhronosGroup/GLSL/blob/main/extensions/nv/GLSL_NV_cooperative_vector.txt)
GLSL extension.

This extension includes support for enumerating the combinations of types
that are supported by the implementation, and for converting matrix data to
and from an optimized opaque layout.

* 
[vkCmdConvertCooperativeVectorMatrixNV](../chapters/shaders.html#vkCmdConvertCooperativeVectorMatrixNV)

* 
[vkConvertCooperativeVectorMatrixNV](../chapters/shaders.html#vkConvertCooperativeVectorMatrixNV)

* 
[vkGetPhysicalDeviceCooperativeVectorPropertiesNV](../chapters/shaders.html#vkGetPhysicalDeviceCooperativeVectorPropertiesNV)

* 
[VkConvertCooperativeVectorMatrixInfoNV](../chapters/shaders.html#VkConvertCooperativeVectorMatrixInfoNV)

* 
[VkCooperativeVectorPropertiesNV](../chapters/shaders.html#VkCooperativeVectorPropertiesNV)

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceCooperativeVectorFeaturesNV](../chapters/features.html#VkPhysicalDeviceCooperativeVectorFeaturesNV)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceCooperativeVectorPropertiesNV](../chapters/limits.html#VkPhysicalDeviceCooperativeVectorPropertiesNV)

* 
[VkDeviceOrHostAddressConstKHR](../chapters/accelstructures.html#VkDeviceOrHostAddressConstKHR)

* 
[VkDeviceOrHostAddressKHR](../chapters/accelstructures.html#VkDeviceOrHostAddressKHR)

* 
[VkComponentTypeKHR](../chapters/shaders.html#VkComponentTypeKHR)

* 
[VkCooperativeVectorMatrixLayoutNV](../chapters/shaders.html#VkCooperativeVectorMatrixLayoutNV)

* 
`VK_NV_COOPERATIVE_VECTOR_EXTENSION_NAME`

* 
`VK_NV_COOPERATIVE_VECTOR_SPEC_VERSION`

* 
Extending [VkComponentTypeKHR](../chapters/shaders.html#VkComponentTypeKHR):

`VK_COMPONENT_TYPE_FLOAT_E4M3_NV`

* 
`VK_COMPONENT_TYPE_FLOAT_E5M2_NV`

* 
`VK_COMPONENT_TYPE_SINT8_PACKED_NV`

* 
`VK_COMPONENT_TYPE_UINT8_PACKED_NV`

Extending [VkPipelineStageFlagBits2](../chapters/synchronization.html#VkPipelineStageFlagBits2):

* 
`VK_PIPELINE_STAGE_2_CONVERT_COOPERATIVE_VECTOR_MATRIX_BIT_NV`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_CONVERT_COOPERATIVE_VECTOR_MATRIX_INFO_NV`

* 
`VK_STRUCTURE_TYPE_COOPERATIVE_VECTOR_PROPERTIES_NV`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_FEATURES_NV`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_PROPERTIES_NV`

* 
[CooperativeVectorNV](spirvenv.html#spirvenv-capabilities-table-CooperativeVectorNV)

* 
Revision 4, 2024-05-23 (Jeff Bolz)

Add maxCooperativeVectorComponents

Revision 3, 2024-05-23 (Jeff Bolz)

* 
Add training functions

Revision 2, 2024-02-10 (Jeff Bolz)

* 
Add device-side matrix conversion

Revision 1, 2023-12-13 (Jeff Bolz)

* 
Initial revisions

**Name String**

`VK_NV_copy_memory_indirect`

**Extension Type**

Device extension

**Registered Extension Number**

427

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

 [VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

 or

 [Vulkan Version 1.1](versions.html#versions-1.1)

 and

 [VK_KHR_buffer_device_address](#VK_KHR_buffer_device_address)

or

[Vulkan Version 1.2](versions.html#versions-1.2)

**Contact**

* 
Vikram Kushwaha [vkushwaha-nv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NV_copy_memory_indirect] @vkushwaha-nv%0A*Here describe the issue or question you have about the VK_NV_copy_memory_indirect extension*)

**Last Modified Date**

2022-10-14

**Contributors**

* 
Vikram Kushwaha, NVIDIA

* 
Jeff Bolz, NVIDIA

* 
Christoph Kubisch, NVIDIA

* 
Daniel Koch, NVIDIA

This extension adds support for performing copies between memory and image
regions using indirect parameters that are read by the device from a buffer
during execution.
This functionality **may** be useful for performing copies where the copy
parameters are not known during the command buffer creation time.

* 
[vkCmdCopyMemoryIndirectNV](../chapters/copies.html#vkCmdCopyMemoryIndirectNV)

* 
[vkCmdCopyMemoryToImageIndirectNV](../chapters/copies.html#vkCmdCopyMemoryToImageIndirectNV)

* 
[VkCopyMemoryIndirectCommandNV](../chapters/copies.html#VkCopyMemoryIndirectCommandNV)

* 
[VkCopyMemoryToImageIndirectCommandNV](../chapters/copies.html#VkCopyMemoryToImageIndirectCommandNV)

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceCopyMemoryIndirectFeaturesNV](../chapters/features.html#VkPhysicalDeviceCopyMemoryIndirectFeaturesNV)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceCopyMemoryIndirectPropertiesNV](../chapters/limits.html#VkPhysicalDeviceCopyMemoryIndirectPropertiesNV)

* 
`VK_NV_COPY_MEMORY_INDIRECT_EXTENSION_NAME`

* 
`VK_NV_COPY_MEMORY_INDIRECT_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV`

* 
Revision 1, 2022-10-14 (Vikram Kushwaha)

Initial draft

**Name String**

`VK_NV_corner_sampled_image`

**Extension Type**

Device extension

**Registered Extension Number**

51

**Revision**

2

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Contact**

* 
Daniel Koch [dgkoch](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NV_corner_sampled_image] @dgkoch%0A*Here describe the issue or question you have about the VK_NV_corner_sampled_image extension*)

**Last Modified Date**

2018-08-13

**Contributors**

* 
Jeff Bolz, NVIDIA

* 
Pat Brown, NVIDIA

* 
Chris Lentini, NVIDIA

This extension adds support for a new image organization, which this
extension refers to as corner-sampled images.
A corner-sampled image differs from a conventional image in the following
ways:

* 
Texels are centered on integer coordinates.
See [Unnormalized Texel Coordinate    Operations](../chapters/textures.html#textures-unnormalized-to-integer)

* 
Normalized coordinates are scaled using coord  (dim - 1)
rather than coord  dim, where dim is the size of one
dimension of the image.
See [normalized texel coordinate    transform](../chapters/textures.html#textures-normalized-to-unnormalized).

* 
Partial derivatives are scaled using coord  (dim - 1)
rather than coord  dim.
See [Scale Factor Operation](../chapters/textures.html#textures-scale-factor).

* 
Calculation of the next higher LOD size goes according to
dim / 2 rather than dim / 2.
See [Image Mip Level Sizing](../chapters/resources.html#resources-image-mip-level-sizing).

* 
The minimum level size is 2x2 for 2D images and 2x2x2 for 3D images.
See [Image Mip Level Sizing](../chapters/resources.html#resources-image-mip-level-sizing).

This image organization is designed to facilitate a system like Ptex with
separate textures for each face of a subdivision or polygon mesh.
Placing sample locations at pixel corners allows applications to maintain
continuity between adjacent patches by duplicating values along shared
edges.
Additionally, using the modified mipmapping logic along with texture
dimensions of the form 2n+1 allows continuity across shared edges
even if the adjacent patches use different LOD values.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceCornerSampledImageFeaturesNV](../chapters/features.html#VkPhysicalDeviceCornerSampledImageFeaturesNV)

* 
`VK_NV_CORNER_SAMPLED_IMAGE_EXTENSION_NAME`

* 
`VK_NV_CORNER_SAMPLED_IMAGE_SPEC_VERSION`

* 
Extending [VkImageCreateFlagBits](../chapters/resources.html#VkImageCreateFlagBits):

`VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV`

What should this extension be named?

**DISCUSSION**: While naming this extension, we chose the most distinctive
aspect of the image organization and referred to such images as
corner-sampled images.
As a result, we decided to name the extension NV_corner_sampled_image.

Do we need a format feature flag so formats can advertise if they support corner-sampling?

**DISCUSSION**: Currently NVIDIA supports this for all 2D and 3D formats, but
not for cube maps or depth-stencil formats.
A format feature might be useful if other vendors would only support this on
some formats.

Do integer texel coordinates have a different range for corner-sampled images?

**RESOLVED**: No, these are unchanged.

Do unnormalized sampler coordinates work with corner-sampled images? Are there any functional differences?

**RESOLVED**: Yes.
Unnormalized coordinates are treated as already scaled for corner-sample
usage.

Should we have a diagram in the Image Operations chapter demonstrating different texel sampling locations?

**UNRESOLVED**: Probably, but later.

* 
Revision 1, 2018-08-14 (Daniel Koch)

Internal revisions

Revision 2, 2018-08-14 (Daniel Koch)

* 
???

**Name String**

`VK_NV_coverage_reduction_mode`

**Extension Type**

Device extension

**Registered Extension Number**

251

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_NV_framebuffer_mixed_samples](#VK_NV_framebuffer_mixed_samples)

and

 [VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

 or

 [Vulkan Version 1.1](versions.html#versions-1.1)

**Contact**

* 
Kedarnath Thangudu [kthangudu](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NV_coverage_reduction_mode] @kthangudu%0A*Here describe the issue or question you have about the VK_NV_coverage_reduction_mode extension*)

**Last Modified Date**

2019-01-29

**Contributors**

* 
Kedarnath Thangudu, NVIDIA

* 
Jeff Bolz, NVIDIA

When using a framebuffer with mixed samples, a per-fragment coverage
reduction operation is performed which generates color sample coverage from
the pixel coverage.
This extension defines the following modes to control how this reduction is
performed.

* 
Merge: When there are more samples in the pixel coverage than color
samples, there is an implementation-dependent association of each pixel
coverage sample to a color sample.
In the merge mode, the color sample coverage is computed such that only
if any associated sample in the pixel coverage is covered, the color
sample is covered.
This is the default mode.

* 
Truncate: When there are more raster samples (N) than color samples(M),
there is one to one association of the first M raster samples to the M
color samples; other raster samples are ignored.

When the number of raster samples is equal to the color samples, there is a
one to one mapping between them in either of the above modes.

The new command
[vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV](../chapters/fragops.html#vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV) can
be used to query the various raster, color, depth/stencil sample count and
reduction mode combinations that are supported by the implementation.
This extension would allow an implementation to support the behavior of both
`VK_NV_framebuffer_mixed_samples` and `VK_AMD_mixed_attachment_samples`
extensions simultaneously.

* 
[vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV](../chapters/fragops.html#vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV)

* 
[VkFramebufferMixedSamplesCombinationNV](../chapters/fragops.html#VkFramebufferMixedSamplesCombinationNV)

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceCoverageReductionModeFeaturesNV](../chapters/features.html#VkPhysicalDeviceCoverageReductionModeFeaturesNV)

Extending [VkPipelineMultisampleStateCreateInfo](../chapters/primsrast.html#VkPipelineMultisampleStateCreateInfo):

* 
[VkPipelineCoverageReductionStateCreateInfoNV](../chapters/fragops.html#VkPipelineCoverageReductionStateCreateInfoNV)

* 
[VkCoverageReductionModeNV](../chapters/fragops.html#VkCoverageReductionModeNV)

* 
[VkPipelineCoverageReductionStateCreateFlagsNV](../chapters/fragops.html#VkPipelineCoverageReductionStateCreateFlagsNV)

* 
`VK_NV_COVERAGE_REDUCTION_MODE_EXTENSION_NAME`

* 
`VK_NV_COVERAGE_REDUCTION_MODE_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV`

* 
`VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV`

* 
Revision 1, 2019-01-29 (Kedarnath Thangudu)

Internal revisions

**Name String**

`VK_NV_dedicated_allocation_image_aliasing`

**Extension Type**

Device extension

**Registered Extension Number**

241

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

 [VK_KHR_dedicated_allocation](#VK_KHR_dedicated_allocation)

 and

 [VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Contact**

* 
Nuno Subtil [nsubtil](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NV_dedicated_allocation_image_aliasing] @nsubtil%0A*Here describe the issue or question you have about the VK_NV_dedicated_allocation_image_aliasing extension*)

**Last Modified Date**

2019-01-04

**Contributors**

* 
Nuno Subtil, NVIDIA

* 
Jeff Bolz, NVIDIA

* 
Eric Werness, NVIDIA

* 
Axel Gneiting, id Software

This extension allows applications to alias images on dedicated allocations,
subject to specific restrictions: the extent and the number of layers in the
image being aliased must be smaller than or equal to those of the original
image for which the allocation was created, and every other image parameter
must match.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV](../chapters/features.html#VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV)

* 
`VK_NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_EXTENSION_NAME`

* 
`VK_NV_DEDICATED_ALLOCATION_IMAGE_ALIASING_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV`

* 
Revision 1, 2019-01-04 (Nuno Subtil)

Internal revisions

**Name String**

`VK_NV_descriptor_pool_overallocation`

**Extension Type**

Device extension

**Registered Extension Number**

547

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[Vulkan Version 1.1](versions.html#versions-1.1)

**Contact**

* 
Piers Daniell [pdaniell-nv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NV_descriptor_pool_overallocation] @pdaniell-nv%0A*Here describe the issue or question you have about the VK_NV_descriptor_pool_overallocation extension*)

**Last Modified Date**

2023-08-30

**Contributors**

* 
Jeff Bolz, NVIDIA

There are scenarios where the application does not know ahead of time how
many descriptor sets it may need to allocate from a descriptor pool, or how
many descriptors of any of the descriptor types it may need to allocate from
the descriptor pool.

This extension gives applications the ability to request the implementation
allow more sets or descriptors to be allocated than initially specified at
descriptor pool creation time, subject to available resources.

The `VK_DESCRIPTOR_POOL_CREATE_ALLOW_OVERALLOCATION_SETS_BIT_NV` flag
lets the application allocate more than
[VkDescriptorPoolCreateInfo](../chapters/descriptorsets.html#VkDescriptorPoolCreateInfo)::`maxSets` descriptor sets, and the
`VK_DESCRIPTOR_POOL_CREATE_ALLOW_OVERALLOCATION_POOLS_BIT_NV` lets the
application allocate more descriptors than initially specified by
[VkDescriptorPoolSize](../chapters/descriptorsets.html#VkDescriptorPoolSize)::`descriptorCount` for any descriptor types.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV](../chapters/features.html#VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV)

* 
`VK_NV_DESCRIPTOR_POOL_OVERALLOCATION_EXTENSION_NAME`

* 
`VK_NV_DESCRIPTOR_POOL_OVERALLOCATION_SPEC_VERSION`

* 
Extending [VkDescriptorPoolCreateFlagBits](../chapters/descriptorsets.html#VkDescriptorPoolCreateFlagBits):

`VK_DESCRIPTOR_POOL_CREATE_ALLOW_OVERALLOCATION_POOLS_BIT_NV`

* 
`VK_DESCRIPTOR_POOL_CREATE_ALLOW_OVERALLOCATION_SETS_BIT_NV`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV`

* 
Revision 1, 2023-08-30 (Piers Daniell)

Internal revisions

**Name String**

`VK_NV_device_diagnostic_checkpoints`

**Extension Type**

Device extension

**Registered Extension Number**

207

**Revision**

2

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**API Interactions**

* 
Interacts with VK_VERSION_1_3

* 
Interacts with VK_KHR_synchronization2

**Contact**

* 
Nuno Subtil [nsubtil](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NV_device_diagnostic_checkpoints] @nsubtil%0A*Here describe the issue or question you have about the VK_NV_device_diagnostic_checkpoints extension*)

**Last Modified Date**

2018-07-16

**Contributors**

* 
Oleg Kuznetsov, NVIDIA

* 
Alex Dunn, NVIDIA

* 
Jeff Bolz, NVIDIA

* 
Eric Werness, NVIDIA

* 
Daniel Koch, NVIDIA

This extension allows applications to insert markers in the command stream
and associate them with custom data.

If a device lost error occurs, the application **may** then query the
implementation for the last markers to cross specific implementation-defined
pipeline stages, in order to narrow down which commands were executing at
the time and might have caused the failure.

* 
[vkCmdSetCheckpointNV](../chapters/debugging.html#vkCmdSetCheckpointNV)

* 
[vkGetQueueCheckpointDataNV](../chapters/debugging.html#vkGetQueueCheckpointDataNV)

If [Vulkan Version 1.3](versions.html#versions-1.3) or [VK_KHR_synchronization2](#VK_KHR_synchronization2) is supported:

* 
[vkGetQueueCheckpointData2NV](../chapters/debugging.html#vkGetQueueCheckpointData2NV)

* 
[VkCheckpointDataNV](../chapters/debugging.html#VkCheckpointDataNV)

* 
Extending [VkQueueFamilyProperties2](../chapters/devsandqueues.html#VkQueueFamilyProperties2):

[VkQueueFamilyCheckpointPropertiesNV](../chapters/devsandqueues.html#VkQueueFamilyCheckpointPropertiesNV)

If [Vulkan Version 1.3](versions.html#versions-1.3) or [VK_KHR_synchronization2](#VK_KHR_synchronization2) is supported:

* 
[VkCheckpointData2NV](../chapters/debugging.html#VkCheckpointData2NV)

* 
Extending [VkQueueFamilyProperties2](../chapters/devsandqueues.html#VkQueueFamilyProperties2):

[VkQueueFamilyCheckpointProperties2NV](../chapters/devsandqueues.html#VkQueueFamilyCheckpointProperties2NV)

* 
`VK_NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_EXTENSION_NAME`

* 
`VK_NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV`

* 
`VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV`

If [Vulkan Version 1.3](versions.html#versions-1.3) or [VK_KHR_synchronization2](#VK_KHR_synchronization2) is supported:

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV`

* 
`VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV`

* 
Revision 1, 2018-07-16 (Nuno Subtil)

Internal revisions

Revision 2, 2018-07-16 (Nuno Subtil)

* 
???

**Name String**

`VK_NV_device_diagnostics_config`

**Extension Type**

Device extension

**Registered Extension Number**

301

**Revision**

2

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Contact**

* 
Kedarnath Thangudu [kthangudu](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NV_device_diagnostics_config] @kthangudu%0A*Here describe the issue or question you have about the VK_NV_device_diagnostics_config extension*)

**Last Modified Date**

2022-04-06

**Contributors**

* 
Kedarnath Thangudu, NVIDIA

* 
Thomas Klein, NVIDIA

Applications using Nvidia Nsight Aftermath SDK for Vulkan to integrate
device crash dumps into their error reporting mechanisms, **may** use this
extension to configure options related to device crash dump creation.

Version 2 of this extension adds
`VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_ERROR_REPORTING_BIT_NV`
which when set enables enhanced reporting of shader execution errors.

* 
Extending [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkDeviceDiagnosticsConfigCreateInfoNV](../chapters/devsandqueues.html#VkDeviceDiagnosticsConfigCreateInfoNV)

Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

* 
[VkPhysicalDeviceDiagnosticsConfigFeaturesNV](../chapters/features.html#VkPhysicalDeviceDiagnosticsConfigFeaturesNV)

* 
[VkDeviceDiagnosticsConfigFlagBitsNV](../chapters/devsandqueues.html#VkDeviceDiagnosticsConfigFlagBitsNV)

* 
[VkDeviceDiagnosticsConfigFlagsNV](../chapters/devsandqueues.html#VkDeviceDiagnosticsConfigFlagsNV)

* 
`VK_NV_DEVICE_DIAGNOSTICS_CONFIG_EXTENSION_NAME`

* 
`VK_NV_DEVICE_DIAGNOSTICS_CONFIG_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV`

* 
Revision 1, 2019-11-21 (Kedarnath Thangudu)

Internal revisions

Revision 2, 2022-04-06 (Kedarnath Thangudu)

* 
Added a config bit
`VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_ERROR_REPORTING_BIT_NV`

**Name String**

`VK_NV_device_generated_commands`

**Extension Type**

Device extension

**Registered Extension Number**

278

**Revision**

3

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

 [Vulkan Version 1.1](versions.html#versions-1.1)

 and

 [VK_KHR_buffer_device_address](#VK_KHR_buffer_device_address)

or

[Vulkan Version 1.2](versions.html#versions-1.2)

**Contact**

* 
Christoph Kubisch [pixeljetstream](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NV_device_generated_commands] @pixeljetstream%0A*Here describe the issue or question you have about the VK_NV_device_generated_commands extension*)

**Last Modified Date**

2020-02-20

**Interactions and External Dependencies**

* 
This extension requires Vulkan 1.1

* 
This extension requires `VK_EXT_buffer_device_address` or
`VK_KHR_buffer_device_address` or Vulkan 1.2 for the ability to bind
vertex and index buffers on the device.

* 
This extension interacts with `VK_NV_mesh_shader`.
If the latter extension is not supported, remove the command token to
initiate mesh tasks drawing in this extension.

**Contributors**

* 
Christoph Kubisch, NVIDIA

* 
Pierre Boudier, NVIDIA

* 
Jeff Bolz, NVIDIA

* 
Eric Werness, NVIDIA

* 
Yuriy ODonnell, Epic Games

* 
Baldur Karlsson, Valve

* 
Mathias Schott, NVIDIA

* 
Tyson Smith, NVIDIA

* 
Ingo Esser, NVIDIA

This extension allows the device to generate a number of critical graphics
commands for command buffers.

When rendering a large number of objects, the device can be leveraged to
implement a number of critical functions, like updating matrices, or
implementing occlusion culling, frustum culling, front to back sorting, etc.
Implementing those on the device does not require any special extension,
since an application is free to define its own data structures, and just
process them using shaders.

However, if the application desires to quickly kick off the rendering of the
final stream of objects, then unextended Vulkan forces the application to
read back the processed stream and issue graphics command from the host.
For very large scenes, the synchronization overhead and cost to generate the
command buffer can become the bottleneck.
This extension allows an application to generate a device side stream of
state changes and commands, and convert it efficiently into a command buffer
without having to read it back to the host.

Furthermore, it allows incremental changes to such command buffers by
manipulating only partial sections of a command streamfor example
pipeline bindings.
Unextended Vulkan requires re-creation of entire command buffers in such a
scenario, or updates synchronized on the host.

The intended usage for this extension is for the application to:

* 
create `VkBuffer` objects and retrieve physical addresses from them
via [vkGetBufferDeviceAddressEXT](../chapters/descriptorsets.html#vkGetBufferDeviceAddressEXT)

* 
create a graphics pipeline using
`VkGraphicsPipelineShaderGroupsCreateInfoNV` for the ability to
change shaders on the device.

* 
create a [VkIndirectCommandsLayoutNV](../chapters/device_generated_commands/generatedcommands.html#VkIndirectCommandsLayoutNV), which lists the
[VkIndirectCommandsTokenTypeNV](../chapters/device_generated_commands/generatedcommands.html#VkIndirectCommandsTokenTypeNV) it wants to dynamically execute as
an atomic command sequence.
This step likely involves some internal device code compilation, since
the intent is for the GPU to generate the command buffer in the
pipeline.

* 
fill the input stream buffers with the data for each of the inputs it
needs.
Each input is an array that will be filled with token-dependent data.

* 
set up a preprocess `VkBuffer` that uses memory according to the
information retrieved via
[vkGetGeneratedCommandsMemoryRequirementsNV](../chapters/device_generated_commands/generatedcommands.html#vkGetGeneratedCommandsMemoryRequirementsNV).

* 
optionally preprocess the generated content using
[vkCmdPreprocessGeneratedCommandsNV](../chapters/device_generated_commands/generatedcommands.html#vkCmdPreprocessGeneratedCommandsNV), for example on an asynchronous
compute queue, or for the purpose of reusing the data in multiple
executions.

* 
call [vkCmdExecuteGeneratedCommandsNV](../chapters/device_generated_commands/generatedcommands.html#vkCmdExecuteGeneratedCommandsNV) to create and execute the
actual device commands for all sequences based on the inputs provided.

For each draw in a sequence, the following can be specified:

* 
a different shader group

* 
a number of vertex buffer bindings

* 
a different index buffer, with an optional dynamic offset and index type

* 
a number of different push constants

* 
a flag that encodes the primitive winding

While the GPU can be faster than a CPU to generate the commands, it will not
happen asynchronously to the device, therefore the primary use case is
generating less total work (occlusion culling, classification to use
specialized shaders, etc.).

* 
[VkIndirectCommandsLayoutNV](../chapters/device_generated_commands/generatedcommands.html#VkIndirectCommandsLayoutNV)

* 
[vkCmdBindPipelineShaderGroupNV](../chapters/pipelines.html#vkCmdBindPipelineShaderGroupNV)

* 
[vkCmdExecuteGeneratedCommandsNV](../chapters/device_generated_commands/generatedcommands.html#vkCmdExecuteGeneratedCommandsNV)

* 
[vkCmdPreprocessGeneratedCommandsNV](../chapters/device_generated_commands/generatedcommands.html#vkCmdPreprocessGeneratedCommandsNV)

* 
[vkCreateIndirectCommandsLayoutNV](../chapters/device_generated_commands/generatedcommands.html#vkCreateIndirectCommandsLayoutNV)

* 
[vkDestroyIndirectCommandsLayoutNV](../chapters/device_generated_commands/generatedcommands.html#vkDestroyIndirectCommandsLayoutNV)

* 
[vkGetGeneratedCommandsMemoryRequirementsNV](../chapters/device_generated_commands/generatedcommands.html#vkGetGeneratedCommandsMemoryRequirementsNV)

* 
[VkBindIndexBufferIndirectCommandNV](../chapters/device_generated_commands/generatedcommands.html#VkBindIndexBufferIndirectCommandNV)

* 
[VkBindShaderGroupIndirectCommandNV](../chapters/device_generated_commands/generatedcommands.html#VkBindShaderGroupIndirectCommandNV)

* 
[VkBindVertexBufferIndirectCommandNV](../chapters/device_generated_commands/generatedcommands.html#VkBindVertexBufferIndirectCommandNV)

* 
[VkGeneratedCommandsInfoNV](../chapters/device_generated_commands/generatedcommands.html#VkGeneratedCommandsInfoNV)

* 
[VkGeneratedCommandsMemoryRequirementsInfoNV](../chapters/device_generated_commands/generatedcommands.html#VkGeneratedCommandsMemoryRequirementsInfoNV)

* 
[VkGraphicsShaderGroupCreateInfoNV](../chapters/pipelines.html#VkGraphicsShaderGroupCreateInfoNV)

* 
[VkIndirectCommandsLayoutCreateInfoNV](../chapters/device_generated_commands/generatedcommands.html#VkIndirectCommandsLayoutCreateInfoNV)

* 
[VkIndirectCommandsLayoutTokenNV](../chapters/device_generated_commands/generatedcommands.html#VkIndirectCommandsLayoutTokenNV)

* 
[VkIndirectCommandsStreamNV](../chapters/device_generated_commands/generatedcommands.html#VkIndirectCommandsStreamNV)

* 
[VkSetStateFlagsIndirectCommandNV](../chapters/device_generated_commands/generatedcommands.html#VkSetStateFlagsIndirectCommandNV)

* 
Extending [VkGraphicsPipelineCreateInfo](../chapters/pipelines.html#VkGraphicsPipelineCreateInfo):

[VkGraphicsPipelineShaderGroupsCreateInfoNV](../chapters/pipelines.html#VkGraphicsPipelineShaderGroupsCreateInfoNV)

Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

* 
[VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV](../chapters/features.html#VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV](../chapters/limits.html#VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV)

* 
[VkIndirectCommandsLayoutUsageFlagBitsNV](../chapters/device_generated_commands/generatedcommands.html#VkIndirectCommandsLayoutUsageFlagBitsNV)

* 
[VkIndirectCommandsTokenTypeNV](../chapters/device_generated_commands/generatedcommands.html#VkIndirectCommandsTokenTypeNV)

* 
[VkIndirectStateFlagBitsNV](../chapters/device_generated_commands/generatedcommands.html#VkIndirectStateFlagBitsNV)

* 
[VkIndirectCommandsLayoutUsageFlagsNV](../chapters/device_generated_commands/generatedcommands.html#VkIndirectCommandsLayoutUsageFlagsNV)

* 
[VkIndirectStateFlagsNV](../chapters/device_generated_commands/generatedcommands.html#VkIndirectStateFlagsNV)

* 
`VK_NV_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME`

* 
`VK_NV_DEVICE_GENERATED_COMMANDS_SPEC_VERSION`

* 
Extending [VkAccessFlagBits](../chapters/synchronization.html#VkAccessFlagBits):

`VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_NV`

* 
`VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_NV`

Extending [VkObjectType](../chapters/debugging.html#VkObjectType):

* 
`VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NV`

Extending [VkPipelineCreateFlagBits](../chapters/pipelines.html#VkPipelineCreateFlagBits):

* 
`VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV`

Extending [VkPipelineStageFlagBits](../chapters/synchronization.html#VkPipelineStageFlagBits):

* 
`VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV`

* 
`VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV`

* 
`VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV`

* 
`VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV`

* 
`VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV`

* 
`VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV`

1) How to name this extension ?

`VK_NV_device_generated_commands`

As usual, one of the hardest issues ;)

Alternatives: `VK_gpu_commands`, `VK_execute_commands`,
`VK_device_commands`, `VK_device_execute_commands`, `VK_device_execute`,
`VK_device_created_commands`, `VK_device_recorded_commands`,
`VK_device_generated_commands` `VK_indirect_generated_commands`

2) Should we use a serial stateful token stream or stateless sequence
descriptions?

Similarly to [VkPipeline](../chapters/pipelines.html#VkPipeline), fixed layouts have the most likelihood to be
cross-vendor adoptable.
They also benefit from being processable in parallel.
This is a different design choice compared to the serial command stream
generated through `GL_NV_command_list`.

3) How to name a sequence description?

`VkIndirectCommandsLayout` as in the NVX extension predecessor.

Alternative: `VkGeneratedCommandsLayout`

4) Do we want to provide `indirectCommands` inputs with layout or at
`indirectCommands` time?

Separate layout from data as Vulkan does.
Provide full flexibility for `indirectCommands`.

5) Should the input be provided as SoA or AoS?

Both ways are desirable.
AoS can provide portability to other APIs and easier to setup, while SoA
allows to update individual inputs in a cache-efficient manner, when others
remain static.

6) How do we make developers aware of the memory requirements of
implementation-dependent data used for the generated commands?

Make the API explicit and introduce a `preprocess` [VkBuffer](../chapters/resources.html#VkBuffer).
Developers have to allocate it using
[vkGetGeneratedCommandsMemoryRequirementsNV](../chapters/device_generated_commands/generatedcommands.html#vkGetGeneratedCommandsMemoryRequirementsNV).

In the NVX version the requirements were hidden implicitly as part of the
command buffer reservation process, however as the memory requirements can
be substantial, we want to give developers the ability to budget the memory
themselves.
By lowering the `maxSequencesCount` the memory consumption can be reduced.
Furthermore reuse of the memory is possible, for example for doing explicit
preprocessing and execution in a ping-pong fashion.

The actual buffer size is implementation-dependent and may be zero, i.e. not
always required.

When making use of Graphics Shader Groups, the programs should behave
similar with regards to vertex inputs, clipping and culling outputs of the
geometry stage, as well as sample shading behavior in fragment shaders, to
reduce the amount of the worst-case memory approximation.

7) Should we allow additional per-sequence dynamic state changes?

Yes

Introduced a lightweight indirect state flag
[VkIndirectStateFlagBitsNV](../chapters/device_generated_commands/generatedcommands.html#VkIndirectStateFlagBitsNV).
So far only switching front face winding state is exposed.
Especially in CAD/DCC mirrored transforms that require such changes are
common, and similar flexibility is given in the ray tracing instance
description.

The flag could be extended further, for example to switch between
primitive-lists or -strips, or make other state modifications.

Furthermore, as new tokens can be added easily, future extension could add
the ability to change any [VkDynamicState](../chapters/pipelines.html#VkDynamicState).

8) How do we allow reusing already generated `indirectCommands`?

Expose a `preprocessBuffer` to reuse implementation-dependencyFlags data.
Set `isPreprocessed` to `VK_TRUE` in
[vkCmdExecuteGeneratedCommandsNV](../chapters/device_generated_commands/generatedcommands.html#vkCmdExecuteGeneratedCommandsNV).

9) Under which conditions is [vkCmdExecuteGeneratedCommandsNV](../chapters/device_generated_commands/generatedcommands.html#vkCmdExecuteGeneratedCommandsNV) legal?

It behaves like a regular draw call command.

10) Is [vkCmdPreprocessGeneratedCommandsNV](../chapters/device_generated_commands/generatedcommands.html#vkCmdPreprocessGeneratedCommandsNV) copying the input data or
referencing it?

There are multiple implementations possible:

* 
one could have some emulation code that parses the inputs, and generates
an output command buffer, therefore copying the inputs.

* 
one could just reference the inputs, and have the processing done in
pipe at execution time.

If the data is mandated to be copied, then it puts a penalty on
implementation that could process the inputs directly in pipe.
If the data is referenced, then it allows both types of implementation.

The inputs are referenced, and **must** not be modified after the call to
[vkCmdExecuteGeneratedCommandsNV](../chapters/device_generated_commands/generatedcommands.html#vkCmdExecuteGeneratedCommandsNV) has completed.

11) Which buffer usage flags are required for the buffers referenced by
`VkGeneratedCommandsInfoNV` ?

Reuse existing `VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT`

* 
[VkGeneratedCommandsInfoNV](../chapters/device_generated_commands/generatedcommands.html#VkGeneratedCommandsInfoNV)::`preprocessBuffer`

* 
[VkGeneratedCommandsInfoNV](../chapters/device_generated_commands/generatedcommands.html#VkGeneratedCommandsInfoNV)::`sequencesCountBuffer`

* 
[VkGeneratedCommandsInfoNV](../chapters/device_generated_commands/generatedcommands.html#VkGeneratedCommandsInfoNV)::`sequencesIndexBuffer`

* 
[VkIndirectCommandsStreamNV](../chapters/device_generated_commands/generatedcommands.html#VkIndirectCommandsStreamNV)::`buffer`

12) In which pipeline stage does the device generated command expansion
happen?

[vkCmdPreprocessGeneratedCommandsNV](../chapters/device_generated_commands/generatedcommands.html#vkCmdPreprocessGeneratedCommandsNV) is treated as if it occurs in a
separate logical pipeline from either graphics or compute, and that pipeline
only includes `VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT`, a new stage
`VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV`, and
`VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT`.
This new stage has two corresponding new access types,
`VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_NV` and
`VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_NV`, used to synchronize reading
the buffer inputs and writing the preprocess memory output.

The generated output written in the preprocess buffer memory by
[vkCmdExecuteGeneratedCommandsNV](../chapters/device_generated_commands/generatedcommands.html#vkCmdExecuteGeneratedCommandsNV) is considered to be consumed by the
`VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT` pipeline stage.

Thus, to synchronize from writing the input buffers to preprocessing via
[vkCmdPreprocessGeneratedCommandsNV](../chapters/device_generated_commands/generatedcommands.html#vkCmdPreprocessGeneratedCommandsNV), use:

* 
`dstStageMask` = `VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV`

* 
`dstAccessMask` = `VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_NV`

To synchronize from [vkCmdPreprocessGeneratedCommandsNV](../chapters/device_generated_commands/generatedcommands.html#vkCmdPreprocessGeneratedCommandsNV) to executing
the generated commands by [vkCmdExecuteGeneratedCommandsNV](../chapters/device_generated_commands/generatedcommands.html#vkCmdExecuteGeneratedCommandsNV), use:

* 
`srcStageMask` = `VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_NV`

* 
`srcAccessMask` = `VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_NV`

* 
`dstStageMask` = `VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT`

* 
`dstAccessMask` = `VK_ACCESS_INDIRECT_COMMAND_READ_BIT`

When [vkCmdExecuteGeneratedCommandsNV](../chapters/device_generated_commands/generatedcommands.html#vkCmdExecuteGeneratedCommandsNV) is used with a
`isPreprocessed` of `VK_FALSE`, the generated commands are implicitly
preprocessed, therefore one only needs to synchronize the inputs via:

* 
`dstStageMask` = `VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT`

* 
`dstAccessMask` = `VK_ACCESS_INDIRECT_COMMAND_READ_BIT`

13) What if most token data is static, but we frequently want to render
a subsection?

Added sequencesIndexBuffer.
This allows to easier sort and filter what should actually be executed.

14) What are the changes compared to the previous NVX extension?

* 
Compute dispatch support was removed (was never implemented in drivers).
There are different approaches how dispatching from the device should
work, hence we defer this to a future extension.

* 
The `ObjectTableNVX` was replaced by using physical buffer addresses and
introducing Shader Groups for the graphics pipeline.

* 
Less state changes are possible overall, but the important operations
are still there (reduces complexity of implementation).

* 
The API was redesigned so all inputs must be passed at both
preprocessing and execution time (this was implicit in NVX, now it is
explicit)

* 
The reservation of intermediate command space is now mandatory and
explicit through a preprocess buffer.

* 
The [VkIndirectStateFlagBitsNV](../chapters/device_generated_commands/generatedcommands.html#VkIndirectStateFlagBitsNV) were introduced

15) When porting from other APIs, their indirect buffers may use different
    enums, for example for index buffer types.
    How to solve this?

Added pIndexTypeValues to map custom `uint32_t` values to corresponding
`VkIndexType`.

16) Do we need more shader group state overrides?

The NVX version allowed all PSO states to be different, however as the goal
is not to replace all state setup, but focus on highly-frequent state
changes for drawing lots of objects, we reduced the amount of state
overrides.
Especially VkPipelineLayout as well as VkRenderPass configuration should be
left static, the rest is still open for discussion.

The current focus is just to allow VertexInput changes as well as shaders,
while all shader groups use the same shader stages.

Too much flexibility will increase the test coverage requirement as well.
However, further extensions could allow more dynamic state as well.

17) Do we need more detailed physical device feature queries/enables?

An EXT version would need detailed implementor feedback to come up with a
good set of features.
Please contact us if you are interested, we are happy to make more features
optional, or add further restrictions to reduce the minimum feature set of
an EXT.

18) Is there an interaction with VK_KHR_pipeline_library planned?

Yes, a future version of this extension will detail the interaction, once
VK_KHR_pipeline_library is no longer provisional.

Open-Source samples illustrating the usage of the extension can be found at
the following location (may not yet exist at time of writing):

[https://github.com/nvpro-samples/vk_device_generated_cmds](https://github.com/nvpro-samples/vk_device_generated_cmds)

* 
Revision 1, 2020-02-20 (Christoph Kubisch)

Initial version

Revision 2, 2020-03-09 (Christoph Kubisch)

* 
Remove VK_EXT_debug_report interactions

Revision 3, 2020-03-09 (Christoph Kubisch)

* 
Fix naming VkPhysicalDeviceGenerated to VkPhysicalDeviceDeviceGenerated

**Name String**

`VK_NV_device_generated_commands_compute`

**Extension Type**

Device extension

**Registered Extension Number**

429

**Revision**

2

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_NV_device_generated_commands](#VK_NV_device_generated_commands)

**Contact**

* 
Vikram Kushwaha [vkushwaha-nv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NV_device_generated_commands_compute] @vkushwaha-nv%0A*Here describe the issue or question you have about the VK_NV_device_generated_commands_compute extension*)

**Last Modified Date**

2023-07-21

**Contributors**

* 
Vikram Kushwaha, NVIDIA

* 
Jeff Bolz, NVIDIA

* 
Christoph Kubisch, NVIDIA

* 
Piers Daniell, NVIDIA

* 
Daniel Koch, NVIDIA

* 
Hans-Kristian Arntzen, Valve

* 
Mike Blumenkrantz, VALVE

This extension allows the device to generate commands for binding compute
pipelines, setting push constants and launching compute dispatches.

* 
[vkCmdUpdatePipelineIndirectBufferNV](../chapters/pipelines.html#vkCmdUpdatePipelineIndirectBufferNV)

* 
[vkGetPipelineIndirectDeviceAddressNV](../chapters/device_generated_commands/generatedcommands.html#vkGetPipelineIndirectDeviceAddressNV)

* 
[vkGetPipelineIndirectMemoryRequirementsNV](../chapters/device_generated_commands/generatedcommands.html#vkGetPipelineIndirectMemoryRequirementsNV)

* 
[VkBindPipelineIndirectCommandNV](../chapters/device_generated_commands/generatedcommands.html#VkBindPipelineIndirectCommandNV)

* 
[VkPipelineIndirectDeviceAddressInfoNV](../chapters/device_generated_commands/generatedcommands.html#VkPipelineIndirectDeviceAddressInfoNV)

* 
Extending [VkComputePipelineCreateInfo](../chapters/pipelines.html#VkComputePipelineCreateInfo):

[VkComputePipelineIndirectBufferInfoNV](../chapters/pipelines.html#VkComputePipelineIndirectBufferInfoNV)

Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

* 
[VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV](../chapters/features.html#VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV)

* 
`VK_NV_DEVICE_GENERATED_COMMANDS_COMPUTE_EXTENSION_NAME`

* 
`VK_NV_DEVICE_GENERATED_COMMANDS_COMPUTE_SPEC_VERSION`

* 
Extending [VkDescriptorSetLayoutCreateFlagBits](../chapters/descriptorsets.html#VkDescriptorSetLayoutCreateFlagBits):

`VK_DESCRIPTOR_SET_LAYOUT_CREATE_INDIRECT_BINDABLE_BIT_NV`

Extending [VkIndirectCommandsTokenTypeNV](../chapters/device_generated_commands/generatedcommands.html#VkIndirectCommandsTokenTypeNV):

* 
`VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NV`

* 
`VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NV`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_INDIRECT_BUFFER_INFO_NV`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV`

* 
`VK_STRUCTURE_TYPE_PIPELINE_INDIRECT_DEVICE_ADDRESS_INFO_NV`

* 
Revision 2, 2023-07-21 (Vikram Kushwaha)

Rename vkCmdUpdatePipelineIndirectBuffer to
vkCmdUpdatePipelineIndirectBufferNV

Revision 1, 2023-06-09 (Vikram Kushwaha)

* 
First Revision

**Name String**

`VK_NV_display_stereo`

**Extension Type**

Instance extension

**Registered Extension Number**

552

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_display](#VK_KHR_display)

and

[VK_KHR_get_display_properties2](#VK_KHR_get_display_properties2)

**Contact**

* 
Russell Chou [russellcnv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NV_display_stereo] @russellcnv%0A*Here describe the issue or question you have about the VK_NV_display_stereo extension*)

**Extension Proposal**

[VK_NV_display_stereo](../../../features/latest/features/proposals/VK_NV_display_stereo.html)

**Last Modified Date**

2024-11-20

**Contributors**

* 
Russell Chou, NVIDIA

* 
Jeff Juliano, NVIDIA

* 
James Jones, NVIDIA

This extension allows the application to choose which type of 3D stereo
hardware it wants to use so the driver can configure it properly.
This configuration is useful for swapchains created from display surfaces
because some environments do not have an intermediate windowing system
available for easy configuration.
This extension will override any stereo type configuration in the windowing
system.

For HDMI 3D, only some display modes support stereo rendering, and a new
structure is needed to expose that information to the application.

* 
Extending [VkDisplayModeProperties2KHR](../chapters/VK_KHR_surface/wsi.html#VkDisplayModeProperties2KHR):

[VkDisplayModeStereoPropertiesNV](../chapters/VK_KHR_surface/wsi.html#VkDisplayModeStereoPropertiesNV)

Extending [VkDisplaySurfaceCreateInfoKHR](../chapters/VK_KHR_surface/wsi.html#VkDisplaySurfaceCreateInfoKHR):

* 
[VkDisplaySurfaceStereoCreateInfoNV](../chapters/VK_KHR_surface/wsi.html#VkDisplaySurfaceStereoCreateInfoNV)

* 
[VkDisplaySurfaceStereoTypeNV](../chapters/VK_KHR_surface/wsi.html#VkDisplaySurfaceStereoTypeNV)

* 
`VK_NV_DISPLAY_STEREO_EXTENSION_NAME`

* 
`VK_NV_DISPLAY_STEREO_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_DISPLAY_MODE_STEREO_PROPERTIES_NV`

* 
`VK_STRUCTURE_TYPE_DISPLAY_SURFACE_STEREO_CREATE_INFO_NV`

* 
Revision 1, 2024-11-20 (Russell Chou)

Initial release

**Name String**

`VK_NV_extended_sparse_address_space`

**Extension Type**

Device extension

**Registered Extension Number**

493

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

None

**Contact**

* 
Russell Chou [russellcnv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NV_extended_sparse_address_space] @russellcnv%0A*Here describe the issue or question you have about the VK_NV_extended_sparse_address_space extension*)

**Last Modified Date**

2023-10-03

**Contributors**

* 
Russell Chou, NVIDIA

* 
Christoph Kubisch, NVIDIA

* 
Eric Werness, NVIDIA

* 
Jeff Bolz, NVIDIA

Implementations may be able to support an extended address space for sparse
memory resources, but only for a certain set of usages.

This extension adds a query for the extended limit, and the supported usages
that are allowed for that limit.
This limit is an increase to
[VkPhysicalDeviceLimits](../chapters/limits.html#VkPhysicalDeviceLimits)::`sparseAddressSpaceSize` when the
[VkImage](../chapters/resources.html#VkImage) or [VkBuffer](../chapters/resources.html#VkBuffer) uses only usages that are supported.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV](../chapters/features.html#VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV](../chapters/limits.html#VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV)

* 
`VK_NV_EXTENDED_SPARSE_ADDRESS_SPACE_EXTENSION_NAME`

* 
`VK_NV_EXTENDED_SPARSE_ADDRESS_SPACE_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_PROPERTIES_NV`

* 
Revision 1, 2023-10-03 (Russell Chou)

Initial draft

**Name String**

`VK_NV_external_compute_queue`

**Extension Type**

Device extension

**Registered Extension Number**

557

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

None

**Contact**

* 
Chris Lentini [clentini](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NV_external_compute_queue] @clentini%0A*Here describe the issue or question you have about the VK_NV_external_compute_queue extension*)

**Extension Proposal**

[VK_NV_external_compute_queue](../../../features/latest/features/proposals/VK_NV_external_compute_queue.html)

**Last Modified Date**

2025-03-24

**Contributors**

* 
Chris Lentini, NVIDIA

* 
Eric Werness, NVIDIA

* 
James Jones, NVIDIA

* 
Jeff Juliano, NVIDIA

* 
Liam Middlebrook, NVIDIA

* 
Lionel Duc, NVIDIA

This extension gives applications the ability to join compatible external
compute APIs to a `VkDevice`.
In this way, the extension allows an application to achieve simultaneous
execution between work submitted from these compatible external APIs and
work that has been submitted through the Vulkan API.

At device creation time, an application **must** supply a
[VkExternalComputeQueueDeviceCreateInfoNV](#undefined.adoc#VkExternalComputeQueueDeviceCreateInfoNV).
This communicates to the implementation the maximum number of external
queues that the application **can** create at once.
This information **may** be used by the implementation to aid in decisions made
during device creation.

After device creation, the function [vkCreateExternalComputeQueueNV](#undefined.adoc#vkCreateExternalComputeQueueNV) is
used by an application to create a new `VkExternalComputeQueueNV`
object.
The `VkExternalComputeQueueNV` object holds information and reserves
resources necessary for a compatible external API to be able to join a
`VkDevice`.
This information can be queried through the
[vkGetExternalComputeQueueDataNV](#undefined.adoc#vkGetExternalComputeQueueDataNV) function, returning an opaque blob of
data which can be passed to compatible external APIs.
The application **must** finally call [vkDestroyExternalComputeQueueNV](#undefined.adoc#vkDestroyExternalComputeQueueNV)
when it is done in order to release the reserved resources.

This extension introduces a new properties structure,
[VkPhysicalDeviceExternalComputeQueuePropertiesNV](#undefined.adoc#VkPhysicalDeviceExternalComputeQueuePropertiesNV), which can be queried
through [vkGetPhysicalDeviceProperties2](../chapters/devsandqueues.html#vkGetPhysicalDeviceProperties2).
The structure provides information on functional limits to the extension as
well as a way of querying the size of the application allocated memory which
**must** be passed to the [vkGetExternalComputeQueueDataNV](#undefined.adoc#vkGetExternalComputeQueueDataNV) function.

When creating a `VkExternalComputeQueueNV` through
[vkCreateExternalComputeQueueNV](#undefined.adoc#vkCreateExternalComputeQueueNV), the
[VkExternalComputeQueueCreateInfoNV](#undefined.adoc#VkExternalComputeQueueCreateInfoNV) structure requires an application
to supply a `VkQueue` to aid in external compute queue creation.
The supplied `VkQueue` is a strong scheduling hint about which queue it
expects to submit graphics workloads to and with which it expects
simultaneous execution of compute workloads submitted through the external
API.

* 
[VkExternalComputeQueueNV](#undefined.adoc#VkExternalComputeQueueNV)

* 
[vkCreateExternalComputeQueueNV](#undefined.adoc#vkCreateExternalComputeQueueNV)

* 
[vkDestroyExternalComputeQueueNV](#undefined.adoc#vkDestroyExternalComputeQueueNV)

* 
[vkGetExternalComputeQueueDataNV](#undefined.adoc#vkGetExternalComputeQueueDataNV)

* 
[VkExternalComputeQueueCreateInfoNV](#undefined.adoc#VkExternalComputeQueueCreateInfoNV)

* 
[VkExternalComputeQueueDataParamsNV](#undefined.adoc#VkExternalComputeQueueDataParamsNV)

* 
Extending [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkExternalComputeQueueDeviceCreateInfoNV](#undefined.adoc#VkExternalComputeQueueDeviceCreateInfoNV)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceExternalComputeQueuePropertiesNV](#undefined.adoc#VkPhysicalDeviceExternalComputeQueuePropertiesNV)

* 
`VK_NV_EXTERNAL_COMPUTE_QUEUE_EXTENSION_NAME`

* 
`VK_NV_EXTERNAL_COMPUTE_QUEUE_SPEC_VERSION`

* 
Extending [VkObjectType](../chapters/debugging.html#VkObjectType):

`VK_OBJECT_TYPE_EXTERNAL_COMPUTE_QUEUE_NV`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_CREATE_INFO_NV`

* 
`VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_DATA_PARAMS_NV`

* 
`VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_DEVICE_CREATE_INFO_NV`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_COMPUTE_QUEUE_PROPERTIES_NV`

|  | While the external queue is now a part of a `VkDevice`, idling the
| --- | --- |
device through [vkDeviceWaitIdle](../chapters/synchronization.html#vkDeviceWaitIdle) does not wait for the external queue.
Draining the work on an external queue **must** be done through its own
external API.
External queues **must** be idled before destroying the associated
`VkDevice`. |

|  | In general, synchronization and resource sharing between the external API
| --- | --- |
and Vulkan must still be accomplished via existing cross-API interop
mechanisms. |

* 
Revision 1, 2024-05-20 (Chris Lentini)

Internal revisions

**Name String**

`VK_NV_external_memory_rdma`

**Extension Type**

Device extension

**Registered Extension Number**

372

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_external_memory](#VK_KHR_external_memory)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Contact**

* 
Carsten Rohde [crohde](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NV_external_memory_rdma] @crohde%0A*Here describe the issue or question you have about the VK_NV_external_memory_rdma extension*)

**Last Modified Date**

2021-04-19

**IP Status**

No known IP claims.

**Contributors**

* 
Carsten Rohde, NVIDIA

This extension adds support for allocating memory which can be used for
remote direct memory access (RDMA) from other devices.

* 
`VkRemoteAddressNV`

* 
[vkGetMemoryRemoteAddressNV](../chapters/memory.html#vkGetMemoryRemoteAddressNV)

* 
[VkMemoryGetRemoteAddressInfoNV](../chapters/memory.html#VkMemoryGetRemoteAddressInfoNV)

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceExternalMemoryRDMAFeaturesNV](../chapters/features.html#VkPhysicalDeviceExternalMemoryRDMAFeaturesNV)

* 
`VK_NV_EXTERNAL_MEMORY_RDMA_EXTENSION_NAME`

* 
`VK_NV_EXTERNAL_MEMORY_RDMA_SPEC_VERSION`

* 
Extending [VkExternalMemoryHandleTypeFlagBits](../chapters/capabilities.html#VkExternalMemoryHandleTypeFlagBits):

`VK_EXTERNAL_MEMORY_HANDLE_TYPE_RDMA_ADDRESS_BIT_NV`

Extending [VkMemoryPropertyFlagBits](../chapters/memory.html#VkMemoryPropertyFlagBits):

* 
`VK_MEMORY_PROPERTY_RDMA_CAPABLE_BIT_NV`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV`

VkPhysicalDeviceMemoryBudgetPropertiesEXT memoryBudgetProperties = { VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT };
VkPhysicalDeviceMemoryProperties2 memoryProperties2 = { VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2, &memoryBudgetProperties };
vkGetPhysicalDeviceMemoryProperties2(physicalDevice, &memoryProperties2);
uint32_t heapIndex = (uint32_t)-1;
for (uint32_t memoryType = 0; memoryType 

* 
Revision 1, 2020-12-15 (Carsten Rohde)

Internal revisions

**Name String**

`VK_NV_fill_rectangle`

**Extension Type**

Device extension

**Registered Extension Number**

154

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

None

**Contact**

* 
Jeff Bolz [jeffbolznv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NV_fill_rectangle] @jeffbolznv%0A*Here describe the issue or question you have about the VK_NV_fill_rectangle extension*)

**Last Modified Date**

2017-05-22

**Contributors**

* 
Jeff Bolz, NVIDIA

This extension adds a new [VkPolygonMode](../chapters/primsrast.html#VkPolygonMode) `enum` where a triangle is
rasterized by computing and filling its axis-aligned screen-space bounding
box, disregarding the actual triangle edges.
This can be useful for drawing a rectangle without being split into two
triangles with an internal edge.
It is also useful to minimize the number of primitives that need to be
drawn, particularly for a user interface.

* 
`VK_NV_FILL_RECTANGLE_EXTENSION_NAME`

* 
`VK_NV_FILL_RECTANGLE_SPEC_VERSION`

* 
Extending [VkPolygonMode](../chapters/primsrast.html#VkPolygonMode):

`VK_POLYGON_MODE_FILL_RECTANGLE_NV`

* 
Revision 1, 2017-05-22 (Jeff Bolz)

Internal revisions

**Name String**

`VK_NV_fragment_coverage_to_color`

**Extension Type**

Device extension

**Registered Extension Number**

150

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

None

**Contact**

* 
Jeff Bolz [jeffbolznv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NV_fragment_coverage_to_color] @jeffbolznv%0A*Here describe the issue or question you have about the VK_NV_fragment_coverage_to_color extension*)

**Last Modified Date**

2017-05-21

**Contributors**

* 
Jeff Bolz, NVIDIA

This extension allows the fragment coverage value, represented as an integer
bitmask, to be substituted for a color output being written to a
single-component color attachment with integer components (e.g.
`VK_FORMAT_R8_UINT`).
The functionality provided by this extension is different from simply
writing the `SampleMask` fragment shader output, in that the coverage
value written to the framebuffer is taken after stencil test and depth test,
as well as after fragment operations such as alpha-to-coverage.

This functionality may be useful for deferred rendering algorithms, where
the second pass needs to know which samples belong to which original
fragments.

* 
Extending [VkPipelineMultisampleStateCreateInfo](../chapters/primsrast.html#VkPipelineMultisampleStateCreateInfo):

[VkPipelineCoverageToColorStateCreateInfoNV](../chapters/fragops.html#VkPipelineCoverageToColorStateCreateInfoNV)

* 
[VkPipelineCoverageToColorStateCreateFlagsNV](../chapters/fragops.html#VkPipelineCoverageToColorStateCreateFlagsNV)

* 
`VK_NV_FRAGMENT_COVERAGE_TO_COLOR_EXTENSION_NAME`

* 
`VK_NV_FRAGMENT_COVERAGE_TO_COLOR_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV`

* 
Revision 1, 2017-05-21 (Jeff Bolz)

Internal revisions

**Name String**

`VK_NV_fragment_shading_rate_enums`

**Extension Type**

Device extension

**Registered Extension Number**

327

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_fragment_shading_rate](#VK_KHR_fragment_shading_rate)

**Contact**

* 
Pat Brown [nvpbrown](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NV_fragment_shading_rate_enums] @nvpbrown%0A*Here describe the issue or question you have about the VK_NV_fragment_shading_rate_enums extension*)

**Last Modified Date**

2020-09-02

**Contributors**

* 
Pat Brown, NVIDIA

* 
Jeff Bolz, NVIDIA

This extension builds on the fragment shading rate functionality provided by
the VK_KHR_fragment_shading_rate extension, adding support for
supersample fragment shading rates that trigger multiple fragment shader
invocations per pixel as well as a no invocations shading rate that
discards any portions of a primitive that would use that shading rate.

* 
[vkCmdSetFragmentShadingRateEnumNV](../chapters/primsrast.html#vkCmdSetFragmentShadingRateEnumNV)

* 
Extending [VkGraphicsPipelineCreateInfo](../chapters/pipelines.html#VkGraphicsPipelineCreateInfo):

[VkPipelineFragmentShadingRateEnumStateCreateInfoNV](../chapters/primsrast.html#VkPipelineFragmentShadingRateEnumStateCreateInfoNV)

Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

* 
[VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV](../chapters/features.html#VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV](../chapters/limits.html#VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV)

* 
[VkFragmentShadingRateNV](../chapters/primsrast.html#VkFragmentShadingRateNV)

* 
[VkFragmentShadingRateTypeNV](../chapters/primsrast.html#VkFragmentShadingRateTypeNV)

* 
`VK_NV_FRAGMENT_SHADING_RATE_ENUMS_EXTENSION_NAME`

* 
`VK_NV_FRAGMENT_SHADING_RATE_ENUMS_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV`

* 
`VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV`

Why was this extension created?   How should it be named?

**RESOLVED**: The primary goal of this extension was to expose support for
supersample and no invocations shading rates, which are supported by the
VK_NV_shading_rate_image extension but not by VK_KHR_fragment_shading_rate.
Because VK_KHR_fragment_shading_rate specifies the primitive shading rate
using a fragment size in pixels, it lacks a good way to specify supersample
rates.
To deal with this, we defined enums covering shading rates supported by the
KHR extension as well as the new shading rates and added structures and APIs
accepting shading rate enums instead of fragment sizes.

Since this extension adds two different types of shading rates, both
expressed using enums, we chose the extension name
VK_NV_fragment_shading_rate_enums.

Is this a standalone extension?

**RESOLVED**: No, this extension requires VK_KHR_fragment_shading_rate.
In order to use the features of this extension, applications must enable the
relevant features of KHR extension.

How are the shading rate enums used, and how were the enum values assigned?

**RESOLVED**: The shading rates supported by the enums in this extension are
accepted as pipeline, primitive, and attachment shading rates and behave
identically.
For the shading rates also supported by the KHR extension, the values
assigned to the corresponding enums are identical to the values already used
for the primitive and attachment shading rates in the KHR extension.
For those enums, bits 0 and 1 specify the base two logarithm of the fragment
height and bits 2 and 3 specify the base two logarithm of the fragment
width.
For the new shading rates added by this extension, we chose to use 11
through 14 (10 plus the base two logarithm of the invocation count) for the
supersample rates and 15 for the no invocations rate.
None of those values are supported as primitive or attachment shading rates
by the KHR extension.

Between this extension, VK_KHR_fragment_shading_rate, and
VK_NV_shading_rate_image, there are three different ways to specify shading
rate state in a pipeline.
How should we handle this?

**RESOLVED**: We do not allow the concurrent use of VK_NV_shading_rate_image
and VK_KHR_fragment_shading_rate; it is an error to enable shading rate
features from both extensions.
But we do allow applications to enable this extension together with
VK_KHR_fragment_shading_rate together.
While we expect that applications will never attach pipeline CreateInfo
structures for both this extension and the KHR extension concurrently,
Vulkan does not have any precedent forbidding such behavior and instead
typically treats a pipeline created without an extension-specific CreateInfo
structure as equivalent to one containing default values specified by the
extension.
Rather than adding such a rule considering the presence or absence of our
new CreateInfo structure, we instead included a `shadingRateType` member
to [VkPipelineFragmentShadingRateEnumStateCreateInfoNV](../chapters/primsrast.html#VkPipelineFragmentShadingRateEnumStateCreateInfoNV) that selects
between using state specified by that structure and state specified by
[VkPipelineFragmentShadingRateStateCreateInfoKHR](../chapters/primsrast.html#VkPipelineFragmentShadingRateStateCreateInfoKHR).

* 
Revision 1, 2020-09-02 (pbrown)

Internal revisions

**Name String**

`VK_NV_framebuffer_mixed_samples`

**Extension Type**

Device extension

**Registered Extension Number**

153

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

None

**API Interactions**

* 
Interacts with VK_VERSION_1_3

* 
Interacts with VK_KHR_dynamic_rendering

**Contact**

* 
Jeff Bolz [jeffbolznv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NV_framebuffer_mixed_samples] @jeffbolznv%0A*Here describe the issue or question you have about the VK_NV_framebuffer_mixed_samples extension*)

**Last Modified Date**

2017-06-04

**Contributors**

* 
Jeff Bolz, NVIDIA

This extension allows multisample rendering with a raster and depth/stencil
sample count that is larger than the color sample count.
Rasterization and the results of the depth and stencil tests together
determine the portion of a pixel that is covered.
It can be useful to evaluate coverage at a higher frequency than color
samples are stored.
This coverage is then reduced to a collection of covered color samples,
each having an opacity value corresponding to the fraction of the color
sample covered.
The opacity can optionally be blended into individual color samples.

Rendering with fewer color samples than depth/stencil samples greatly
reduces the amount of memory and bandwidth consumed by the color buffer.
However, converting the coverage values into opacity introduces artifacts
where triangles share edges and **may** not be suitable for normal triangle
mesh rendering.

One expected use case for this functionality is Stencil-then-Cover path
rendering (similar to the OpenGL GL_NV_path_rendering extension).
The stencil step determines the coverage (in the stencil buffer) for an
entire path at the higher sample frequency, and then the cover step draws
the path into the lower frequency color buffer using the coverage
information to antialias path edges.
With this two-step process, internal edges are fully covered when
antialiasing is applied and there is no corruption on these edges.

The key features of this extension are:

* 
It allows render pass and framebuffer objects to be created where the
number of samples in the depth/stencil attachment in a subpass is a
multiple of the number of samples in the color attachments in the
subpass.

* 
A coverage reduction step is added to Fragment Operations which converts
a set of covered raster/depth/stencil samples to a set of color samples
that perform blending and color writes.
The coverage reduction step also includes an optional coverage
modulation step, multiplying color values by a fractional opacity
corresponding to the number of associated raster/depth/stencil samples
covered.

* 
Extending [VkPipelineMultisampleStateCreateInfo](../chapters/primsrast.html#VkPipelineMultisampleStateCreateInfo):

[VkPipelineCoverageModulationStateCreateInfoNV](../chapters/fragops.html#VkPipelineCoverageModulationStateCreateInfoNV)

If [Vulkan Version 1.3](versions.html#versions-1.3) or [VK_KHR_dynamic_rendering](#VK_KHR_dynamic_rendering) is supported:

* 
Extending [VkCommandBufferInheritanceInfo](../chapters/cmdbuffers.html#VkCommandBufferInheritanceInfo), [VkGraphicsPipelineCreateInfo](../chapters/pipelines.html#VkGraphicsPipelineCreateInfo):

[VkAttachmentSampleCountInfoNV](../chapters/cmdbuffers.html#VkAttachmentSampleCountInfoNV)

* 
[VkCoverageModulationModeNV](../chapters/fragops.html#VkCoverageModulationModeNV)

* 
[VkPipelineCoverageModulationStateCreateFlagsNV](../chapters/fragops.html#VkPipelineCoverageModulationStateCreateFlagsNV)

* 
`VK_NV_FRAMEBUFFER_MIXED_SAMPLES_EXTENSION_NAME`

* 
`VK_NV_FRAMEBUFFER_MIXED_SAMPLES_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV`

If [Vulkan Version 1.3](versions.html#versions-1.3) or [VK_KHR_dynamic_rendering](#VK_KHR_dynamic_rendering) is supported:

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_NV`

* 
Revision 1, 2017-06-04 (Jeff Bolz)

Internal revisions

**Name String**

`VK_NV_geometry_shader_passthrough`

**Extension Type**

Device extension

**Registered Extension Number**

96

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

None

**SPIR-V Dependencies**

* 
[SPV_NV_geometry_shader_passthrough](https://github.khronos.org/SPIRV-Registry/extensions/NV/SPV_NV_geometry_shader_passthrough.html)

**Contact**

* 
Daniel Koch [dgkoch](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NV_geometry_shader_passthrough] @dgkoch%0A*Here describe the issue or question you have about the VK_NV_geometry_shader_passthrough extension*)

**Last Modified Date**

2017-02-15

**Interactions and External Dependencies**

* 
This extension provides API support for
[`GL_NV_geometry_shader_passthrough`](https://registry.khronos.org/OpenGL/extensions/NV/NV_geometry_shader_passthrough.txt)

* 
This extension requires the [    `geometryShader`](../chapters/features.html#features-geometryShader) feature.

**Contributors**

* 
Piers Daniell, NVIDIA

* 
Jeff Bolz, NVIDIA

This extension adds support for the following SPIR-V extension in Vulkan:

* 
`SPV_NV_geometry_shader_passthrough`

Geometry shaders provide the ability for applications to process each
primitive sent through the graphics pipeline using a programmable shader.
However, one common use case treats them largely as a passthrough.
In this use case, the bulk of the geometry shader code simply copies inputs
from each vertex of the input primitive to corresponding outputs in the
vertices of the output primitive.
Such shaders might also compute values for additional built-in or
user-defined per-primitive attributes (e.g., `Layer`) to be assigned to
all the vertices of the output primitive.

This extension provides access to the `PassthroughNV` decoration under
the `GeometryShaderPassthroughNV` capability.
Adding this to a geometry shader input variable specifies that the values of
this input are copied to the corresponding vertex of the output primitive.

When using GLSL source-based shading languages, the `passthrough` layout
qualifier from `GL_NV_geometry_shader_passthrough` maps to the
`PassthroughNV` decoration.
To use the `passthrough` layout, in GLSL the
`GL_NV_geometry_shader_passthrough` extension must be enabled.
Behavior is described in the `GL_NV_geometry_shader_passthrough` extension
specification.

* 
`VK_NV_GEOMETRY_SHADER_PASSTHROUGH_EXTENSION_NAME`

* 
`VK_NV_GEOMETRY_SHADER_PASSTHROUGH_SPEC_VERSION`

* 
[`PassthroughNV`](../chapters/geometry.html#geometry-passthrough-passthrough) in
[Geometry Shader Passthrough](../chapters/geometry.html#geometry-passthrough)

* 
[    `GeometryShaderPassthroughNV`](spirvenv.html#spirvenv-capabilities-table-GeometryShaderPassthroughNV)

1) Should we require or allow a passthrough geometry shader to specify the
output layout qualifiers for the output primitive type and maximum vertex
count in the SPIR-V?

**RESOLVED**: Yes they should be required in the SPIR-V.
Per GL_NV_geometry_shader_passthrough they are not permitted in the GLSL
source shader, but SPIR-V is lower-level.
It is straightforward for the GLSL compiler to infer them from the input
primitive type and to explicitly emit them in the SPIR-V according to the
following table.

| Input Layout | Implied Output Layout |
| --- | --- |
| points | `layout(points, max_vertices=1)` |
| lines | `layout(line_strip, max_vertices=2)` |
| triangles | `layout(triangle_strip, max_vertices=3)` |

2) How does interface matching work with passthrough geometry shaders?

**RESOLVED**: This is described in [Passthrough Interface Matching](../chapters/geometry.html#geometry-passthrough-interface).
In GL when using passthrough geometry shaders in separable mode, all inputs
must also be explicitly assigned location layout qualifiers.
In Vulkan all SPIR-V shader inputs (except built-ins) must also have
location decorations specified.
Redeclarations of built-in variables that add the passthrough layout
qualifier are exempted from the rule requiring location assignment because
built-in variables do not have locations and are matched by `BuiltIn`
decoration.

Consider the following simple geometry shader in unextended GLSL:

layout(triangles) in;
layout(triangle_strip) out;
layout(max_vertices=3) out;

in Inputs {
    vec2 texcoord;
    vec4 baseColor;
} v_in[];
out Outputs {
    vec2 texcoord;
    vec4 baseColor;
};

void main()
{
    int layer = compute_layer();
    for (int i = 0; i 

In this shader, the inputs `gl_Position`, `Inputs.texcoord`, and
`Inputs.baseColor` are simply copied from the input vertex to the
corresponding output vertex.
The only interesting work done by the geometry shader is computing and
emitting a `gl_Layer` value for the primitive.

The following geometry shader, using this extension, is equivalent:

#extension GL_NV_geometry_shader_passthrough : require

layout(triangles) in;
// No output primitive layout qualifiers required.

// Redeclare gl_PerVertex to pass through "gl_Position".
layout(passthrough) in gl_PerVertex {
    vec4 gl_Position;
} gl_in[];

// Declare "Inputs" with "passthrough" to automatically copy members.
layout(passthrough) in Inputs {
    vec2 texcoord;
    vec4 baseColor;
} v_in[];

// No output block declaration required.

void main()
{
    // The shader simply computes and writes gl_Layer.  We do not
    // loop over three vertices or call EmitVertex().
    gl_Layer = compute_layer();
}

* 
Revision 1, 2017-02-15 (Daniel Koch)

Internal revisions

**Name String**

`VK_NV_inherited_viewport_scissor`

**Extension Type**

Device extension

**Registered Extension Number**

279

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Contact**

* 
David Zhao Akeley [akeley98](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NV_inherited_viewport_scissor] @akeley98%0A*Here describe the issue or question you have about the VK_NV_inherited_viewport_scissor extension*)

**Last Modified Date**

2021-02-04

**Contributors**

* 
David Zhao Akeley, NVIDIA

* 
Jeff Bolz, NVIDIA

* 
Piers Daniell, NVIDIA

* 
Christoph Kubisch, NVIDIA

This extension adds the ability for a secondary command buffer to inherit
the dynamic viewport and scissor state from a primary command buffer, or a
previous secondary command buffer executed within the same
[vkCmdExecuteCommands](../chapters/cmdbuffers.html#vkCmdExecuteCommands) call.
It addresses a frequent scenario in applications that deal with window
resizing and want to improve utilization of reusable secondary command
buffers.
The functionality is provided through
[VkCommandBufferInheritanceViewportScissorInfoNV](../chapters/cmdbuffers.html#VkCommandBufferInheritanceViewportScissorInfoNV).
Viewport inheritance is effectively limited to the 2D rectangle; secondary
command buffers must re-specify the inherited depth range values.

* 
Extending [VkCommandBufferInheritanceInfo](../chapters/cmdbuffers.html#VkCommandBufferInheritanceInfo):

[VkCommandBufferInheritanceViewportScissorInfoNV](../chapters/cmdbuffers.html#VkCommandBufferInheritanceViewportScissorInfoNV)

Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

* 
[VkPhysicalDeviceInheritedViewportScissorFeaturesNV](../chapters/features.html#VkPhysicalDeviceInheritedViewportScissorFeaturesNV)

* 
`VK_NV_INHERITED_VIEWPORT_SCISSOR_EXTENSION_NAME`

* 
`VK_NV_INHERITED_VIEWPORT_SCISSOR_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV`

(1) Why are viewport depth values configured in the
[VkCommandBufferInheritanceViewportScissorInfoNV](../chapters/cmdbuffers.html#VkCommandBufferInheritanceViewportScissorInfoNV) struct, rather than by
a `vkCmd` function?

**DISCUSSION**:

We considered both adding a new `vkCmdSetViewportDepthNV` function, and
modifying [vkCmdSetViewport](../chapters/vertexpostproc.html#vkCmdSetViewport) to ignore the `x`, `y`,
`width`, and `height` values when called with a secondary command
buffer that activates this extension.

The primary design considerations for this extension are debuggability and
easy integration into existing applications.
The main issue with adding a new `vkCmdSetViewportDepthNV` function is
reducing ease-of-integration.
A new function pointer will have to be loaded, but more importantly, a new
function would require changes to be supported in graphics debuggers; this
would delay widespread adoption of the extension.

The proposal to modify [vkCmdSetViewport](../chapters/vertexpostproc.html#vkCmdSetViewport) would avoid these issues.
However, we expect that the intent of applications using this extension is
to have the viewport values used for drawing exactly match the inherited
values; thus, it would be better for debuggability if no function for
modifying the viewport depth alone is provided.
By specifying viewport depth values when starting secondary command buffer
recording, and requiring the specified depth values to match the inherited
depth values, we allow for validation layers that flag depth changes as
errors.

This design also better matches the hardware model.
In fact, there is no need to re-execute a depth-setting command.
The graphics device retains the viewport depth state; it is the CPU-side
state of [VkCommandBuffer](../chapters/cmdbuffers.html#VkCommandBuffer) that must be re-initialized.

(2) Why are viewport depth values specified as a partial [VkViewport](../chapters/vertexpostproc.html#VkViewport)
struct, rather than a leaner depth-only struct?

**DISCUSSION**:

We considered adding a new `VkViewportDepthNV` struct containing only
`minDepth` and `maxDepth`.
However, as application developers would need to maintain both a
`VK_NV_inherited_viewport_scissor` code path and a fallback code path (at
least in the short term), we ultimately chose to continue using the existing
[VkViewport](../chapters/vertexpostproc.html#VkViewport) structure.
Doing so would allow application developers to reuse the same
[VkViewport](../chapters/vertexpostproc.html#VkViewport) array for both code paths, rather than constructing
separate `VkViewportDepthNV` and [VkViewport](../chapters/vertexpostproc.html#VkViewport) arrays for each code
path.

* 
Revision 1, 2020-02-04 (David Zhao Akeley)

Internal revisions

**Name String**

`VK_NV_linear_color_attachment`

**Extension Type**

Device extension

**Registered Extension Number**

431

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**API Interactions**

* 
Interacts with VK_VERSION_1_3

* 
Interacts with VK_KHR_format_feature_flags2

**Contact**

* 
sourav parmar [souravpNV](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NV_linear_color_attachment] @souravpNV%0A*Here describe the issue or question you have about the VK_NV_linear_color_attachment extension*)

**Last Modified Date**

2021-12-02

**Interactions and External Dependencies**

* 
This extension requires `[VK_KHR_format_feature_flags2](#VK_KHR_format_feature_flags2)`

**Contributors**

* 
Pat Brown, NVIDIA

* 
Piers Daniell, NVIDIA

* 
Sourav Parmar, NVIDIA

This extension expands support for using `VK_IMAGE_TILING_LINEAR` images
as color attachments when all the color attachments in the render pass
instance have `VK_IMAGE_TILING_LINEAR` tiling.
This extension adds a new flag bit
`VK_FORMAT_FEATURE_2_LINEAR_COLOR_ATTACHMENT_BIT_NV` that extends the
existing [VkFormatFeatureFlagBits2KHR](../chapters/formats.html#VkFormatFeatureFlagBits2KHR) bits.
This flag **can** be set for renderable color formats in the
[VkFormatProperties3KHR](../chapters/formats.html#VkFormatProperties3KHR)::`linearTilingFeatures` format properties
structure member.
Formats with the `VK_FORMAT_FEATURE_2_LINEAR_COLOR_ATTACHMENT_BIT_NV`
flag **may** be used as color attachments as long as all the color attachments
in the render pass instance have `VK_IMAGE_TILING_LINEAR` tiling, and
the formats their images views are created with have
[VkFormatProperties3KHR](../chapters/formats.html#VkFormatProperties3KHR)::`linearTilingFeatures` which include
`VK_FORMAT_FEATURE_2_LINEAR_COLOR_ATTACHMENT_BIT_NV`.
This extension supports both dynamic rendering and traditional render
passes.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceLinearColorAttachmentFeaturesNV](../chapters/features.html#VkPhysicalDeviceLinearColorAttachmentFeaturesNV)

* 
`VK_NV_LINEAR_COLOR_ATTACHMENT_EXTENSION_NAME`

* 
`VK_NV_LINEAR_COLOR_ATTACHMENT_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV`

If [VK_KHR_format_feature_flags2](#VK_KHR_format_feature_flags2) or [Vulkan Version 1.3](versions.html#versions-1.3) is supported:

* 
Extending [VkFormatFeatureFlagBits2](../chapters/formats.html#VkFormatFeatureFlagBits2):

`VK_FORMAT_FEATURE_2_LINEAR_COLOR_ATTACHMENT_BIT_NV`

* 
Revision 1, 2021-11-29 (sourav parmar)

Initial draft

**Name String**

`VK_NV_low_latency`

**Extension Type**

Device extension

**Registered Extension Number**

311

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

None

**Contact**

* 
Charles Hansen [cshansen](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NV_low_latency] @cshansen%0A*Here describe the issue or question you have about the VK_NV_low_latency extension*)

**Last Modified Date**

2023-02-10

**Contributors**

* 
Charles Hansen, NVIDIA

This extension adds the [VkQueryLowLatencySupportNV](../chapters/synchronization.html#VkQueryLowLatencySupportNV) structure, a
structure used to query support for NVIDIA Reflex.

* 
Extending [VkSemaphoreCreateInfo](../chapters/synchronization.html#VkSemaphoreCreateInfo):

[VkQueryLowLatencySupportNV](../chapters/synchronization.html#VkQueryLowLatencySupportNV)

* 
`VK_NV_LOW_LATENCY_EXTENSION_NAME`

* 
`VK_NV_LOW_LATENCY_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV`

1) Why does `VkQueryLowLatencySupportNV` have output parameters in an
input chain?

**RESOLVED**: We are stuck with this for legacy reasons - we are aware this is
bad behavior and this should not be used as a precedent for future
extensions.

* 
Revision 1, 2023-02-10 (Charles Hansen)

Internal revisions

**Name String**

`VK_NV_low_latency2`

**Extension Type**

Device extension

**Registered Extension Number**

506

**Revision**

2

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[Vulkan Version 1.2](versions.html#versions-1.2)

or

[VK_KHR_timeline_semaphore](#VK_KHR_timeline_semaphore)

**Contact**

* 
Charles Hansen [cshansen](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NV_low_latency2] @cshansen%0A*Here describe the issue or question you have about the VK_NV_low_latency2 extension*)

**Last Modified Date**

2023-09-25

**Contributors**

* 
Charles Hansen, NVIDIA

* 
Liam Middlebrook, NVIDIA

* 
Lionel Duc, NVIDIA

* 
James Jones, NVIDIA

* 
Eric Sullivan, NVIDIA

* 
[vkGetLatencyTimingsNV](../chapters/VK_KHR_surface/wsi.html#vkGetLatencyTimingsNV)

* 
[vkLatencySleepNV](../chapters/VK_KHR_surface/wsi.html#vkLatencySleepNV)

* 
[vkQueueNotifyOutOfBandNV](../chapters/VK_KHR_surface/wsi.html#vkQueueNotifyOutOfBandNV)

* 
[vkSetLatencyMarkerNV](../chapters/VK_KHR_surface/wsi.html#vkSetLatencyMarkerNV)

* 
[vkSetLatencySleepModeNV](../chapters/VK_KHR_surface/wsi.html#vkSetLatencySleepModeNV)

* 
[VkGetLatencyMarkerInfoNV](../chapters/VK_KHR_surface/wsi.html#VkGetLatencyMarkerInfoNV)

* 
[VkLatencySleepInfoNV](../chapters/VK_KHR_surface/wsi.html#VkLatencySleepInfoNV)

* 
[VkLatencySleepModeInfoNV](../chapters/VK_KHR_surface/wsi.html#VkLatencySleepModeInfoNV)

* 
[VkLatencyTimingsFrameReportNV](../chapters/VK_KHR_surface/wsi.html#VkLatencyTimingsFrameReportNV)

* 
[VkOutOfBandQueueTypeInfoNV](../chapters/VK_KHR_surface/wsi.html#VkOutOfBandQueueTypeInfoNV)

* 
[VkSetLatencyMarkerInfoNV](../chapters/VK_KHR_surface/wsi.html#VkSetLatencyMarkerInfoNV)

* 
Extending [VkSubmitInfo](../chapters/cmdbuffers.html#VkSubmitInfo), [VkSubmitInfo2](../chapters/cmdbuffers.html#VkSubmitInfo2):

[VkLatencySubmissionPresentIdNV](../chapters/VK_KHR_surface/wsi.html#VkLatencySubmissionPresentIdNV)

Extending [VkSurfaceCapabilities2KHR](../chapters/VK_KHR_surface/wsi.html#VkSurfaceCapabilities2KHR):

* 
[VkLatencySurfaceCapabilitiesNV](../chapters/VK_KHR_surface/wsi.html#VkLatencySurfaceCapabilitiesNV)

Extending [VkSwapchainCreateInfoKHR](../chapters/VK_KHR_surface/wsi.html#VkSwapchainCreateInfoKHR):

* 
[VkSwapchainLatencyCreateInfoNV](../chapters/VK_KHR_surface/wsi.html#VkSwapchainLatencyCreateInfoNV)

* 
[VkLatencyMarkerNV](../chapters/VK_KHR_surface/wsi.html#VkLatencyMarkerNV)

* 
[VkOutOfBandQueueTypeNV](../chapters/VK_KHR_surface/wsi.html#VkOutOfBandQueueTypeNV)

* 
`VK_NV_LOW_LATENCY_2_EXTENSION_NAME`

* 
`VK_NV_LOW_LATENCY_2_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_GET_LATENCY_MARKER_INFO_NV`

* 
`VK_STRUCTURE_TYPE_LATENCY_SLEEP_INFO_NV`

* 
`VK_STRUCTURE_TYPE_LATENCY_SLEEP_MODE_INFO_NV`

* 
`VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV`

* 
`VK_STRUCTURE_TYPE_LATENCY_SURFACE_CAPABILITIES_NV`

* 
`VK_STRUCTURE_TYPE_LATENCY_TIMINGS_FRAME_REPORT_NV`

* 
`VK_STRUCTURE_TYPE_OUT_OF_BAND_QUEUE_TYPE_INFO_NV`

* 
`VK_STRUCTURE_TYPE_SET_LATENCY_MARKER_INFO_NV`

* 
`VK_STRUCTURE_TYPE_SWAPCHAIN_LATENCY_CREATE_INFO_NV`

This extension gives applications timing suggestions on when to start the
recording of new frames to reduce the latency between input sampling and
frame presentation.
Applications can accomplish this through the extension by calling
[vkSetLatencySleepModeNV](../chapters/VK_KHR_surface/wsi.html#vkSetLatencySleepModeNV) to allow the driver to pace a given swapchain,
then calling [vkLatencySleepNV](../chapters/VK_KHR_surface/wsi.html#vkLatencySleepNV) before input sampling to delay the start
of the CPU side work.
Additional methods and structures are provided to give insight into the
latency pipeline of an application through the latency markers.
`[VK_NV_low_latency](#VK_NV_low_latency)` provides legacy support for applications that
make use of the NVIDIA Reflex SDK whereas new implementations should use the
`[VK_NV_low_latency2](#VK_NV_low_latency2)` extension.

1) How does Low Latency 2 work with applications that utilize device groups?

Low Latency 2 does not support device groups.

* 
Revision 2, 2023-11-15 (Charles Hansen)

Update vkGetLatencyTimingsNV.
This is a breaking API change which brings behavior in line with other
array querying commands.
More background can be found in
[https://github.com/KhronosGroup/Vulkan-Docs/issues/2269](https://github.com/KhronosGroup/Vulkan-Docs/issues/2269)

Revision 1, 2023-09-25 (Charles Hansen)

* 
Internal revisions

**Name String**

`VK_NV_memory_decompression`

**Extension Type**

Device extension

**Registered Extension Number**

428

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

 [VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

 or

 [Vulkan Version 1.1](versions.html#versions-1.1)

 and

 [VK_KHR_buffer_device_address](#VK_KHR_buffer_device_address)

or

[Vulkan Version 1.2](versions.html#versions-1.2)

**Contact**

* 
Vikram Kushwaha [vkushwaha-nv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NV_memory_decompression] @vkushwaha-nv%0A*Here describe the issue or question you have about the VK_NV_memory_decompression extension*)

**Last Modified Date**

2022-01-31

**Contributors**

* 
Vikram Kushwaha, NVIDIA

* 
Jeff Bolz, NVIDIA

* 
Christoph Kubisch, NVIDIA

* 
Piers Daniell, NVIDIA

This extension adds support for performing memory to memory decompression.

* 
[vkCmdDecompressMemoryIndirectCountNV](../chapters/VK_NV_memory_decompression.html#vkCmdDecompressMemoryIndirectCountNV)

* 
[vkCmdDecompressMemoryNV](../chapters/VK_NV_memory_decompression.html#vkCmdDecompressMemoryNV)

* 
[VkDecompressMemoryRegionNV](../chapters/VK_NV_memory_decompression.html#VkDecompressMemoryRegionNV)

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceMemoryDecompressionFeaturesNV](../chapters/features.html#VkPhysicalDeviceMemoryDecompressionFeaturesNV)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceMemoryDecompressionPropertiesNV](../chapters/limits.html#VkPhysicalDeviceMemoryDecompressionPropertiesNV)

* 
[VkMemoryDecompressionMethodFlagBitsNV](../chapters/VK_NV_memory_decompression.html#VkMemoryDecompressionMethodFlagBitsNV)

* 
[VkMemoryDecompressionMethodFlagsNV](../chapters/VK_NV_memory_decompression.html#VkMemoryDecompressionMethodFlagsNV)

* 
`VK_NV_MEMORY_DECOMPRESSION_EXTENSION_NAME`

* 
`VK_NV_MEMORY_DECOMPRESSION_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV`

* 
Revision 1, 2022-01-31 (Vikram Kushwaha)

Initial draft

**Name String**

`VK_NV_mesh_shader`

**Extension Type**

Device extension

**Registered Extension Number**

203

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**API Interactions**

* 
Interacts with VK_VERSION_1_2

* 
Interacts with VK_EXT_device_generated_commands

* 
Interacts with VK_KHR_draw_indirect_count

**SPIR-V Dependencies**

* 
[SPV_NV_mesh_shader](https://github.khronos.org/SPIRV-Registry/extensions/NV/SPV_NV_mesh_shader.html)

**Contact**

* 
Christoph Kubisch [pixeljetstream](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NV_mesh_shader] @pixeljetstream%0A*Here describe the issue or question you have about the VK_NV_mesh_shader extension*)

**Last Modified Date**

2018-07-19

**Interactions and External Dependencies**

* 
This extension provides API support for
[`GLSL_NV_mesh_shader`](https://github.com/KhronosGroup/GLSL/blob/main/extensions/nv/GLSL_NV_mesh_shader.txt)

**Contributors**

* 
Pat Brown, NVIDIA

* 
Jeff Bolz, NVIDIA

* 
Daniel Koch, NVIDIA

* 
Piers Daniell, NVIDIA

* 
Pierre Boudier, NVIDIA

This extension provides a new mechanism allowing applications to generate
collections of geometric primitives via programmable mesh shading.
It is an alternative to the existing programmable primitive shading
pipeline, which relied on generating input primitives by a fixed function
assembler as well as fixed function vertex fetch.

There are new programmable shader typesthe task and mesh shaderto
generate these collections to be processed by fixed-function primitive
assembly and rasterization logic.
When task and mesh shaders are dispatched, they replace the core
[pre-rasterization stages](../chapters/pipelines.html#pipelines-graphics-subsets-pre-rasterization),
including vertex array attribute fetching, vertex shader processing,
tessellation, and geometry shader processing.

This extension also adds support for the following SPIR-V extension in
Vulkan:

* 
[`SPV_NV_mesh_shader`](https://github.khronos.org/SPIRV-Registry/extensions/NV/SPV_NV_mesh_shader.html)

* 
[vkCmdDrawMeshTasksIndirectNV](../chapters/drawing.html#vkCmdDrawMeshTasksIndirectNV)

* 
[vkCmdDrawMeshTasksNV](../chapters/drawing.html#vkCmdDrawMeshTasksNV)

If [VK_KHR_draw_indirect_count](#VK_KHR_draw_indirect_count) or [Vulkan Version 1.2](versions.html#versions-1.2) is supported:

* 
[vkCmdDrawMeshTasksIndirectCountNV](../chapters/drawing.html#vkCmdDrawMeshTasksIndirectCountNV)

* 
[VkDrawMeshTasksIndirectCommandNV](../chapters/drawing.html#VkDrawMeshTasksIndirectCommandNV)

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceMeshShaderFeaturesNV](../chapters/features.html#VkPhysicalDeviceMeshShaderFeaturesNV)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceMeshShaderPropertiesNV](../chapters/limits.html#VkPhysicalDeviceMeshShaderPropertiesNV)

* 
`VK_NV_MESH_SHADER_EXTENSION_NAME`

* 
`VK_NV_MESH_SHADER_SPEC_VERSION`

* 
Extending [VkPipelineStageFlagBits](../chapters/synchronization.html#VkPipelineStageFlagBits):

`VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV`

* 
`VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV`

Extending [VkShaderStageFlagBits](../chapters/pipelines.html#VkShaderStageFlagBits):

* 
`VK_SHADER_STAGE_MESH_BIT_NV`

* 
`VK_SHADER_STAGE_TASK_BIT_NV`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV`

If [VK_EXT_device_generated_commands](#VK_EXT_device_generated_commands) is supported:

* 
Extending [VkIndirectCommandsTokenTypeEXT](../chapters/device_generated_commands/generatedcommands.html#VkIndirectCommandsTokenTypeEXT):

`VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_COUNT_NV_EXT`

* 
`VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV_EXT`

* 
[TaskCountNV](../chapters/interfaces.html#interfaces-builtin-variables-taskcount)

* 
[PrimitiveCountNV](../chapters/interfaces.html#interfaces-builtin-variables-primitivecount)

* 
[PrimitiveIndicesNV](../chapters/interfaces.html#interfaces-builtin-variables-primitiveindices)

* 
[ClipDistancePerViewNV](../chapters/interfaces.html#interfaces-builtin-variables-clipdistancepv)

* 
[CullDistancePerViewNV](../chapters/interfaces.html#interfaces-builtin-variables-culldistancepv)

* 
[LayerPerViewNV](../chapters/interfaces.html#interfaces-builtin-variables-layerpv)

* 
[MeshViewCountNV](../chapters/interfaces.html#interfaces-builtin-variables-meshviewcount)

* 
[MeshViewIndicesNV](../chapters/interfaces.html#interfaces-builtin-variables-meshviewindices)

* 
(modified)`Position`

* 
(modified)`PointSize`

* 
(modified)`ClipDistance`

* 
(modified)`CullDistance`

* 
(modified)`PrimitiveId`

* 
(modified)`Layer`

* 
(modified)`ViewportIndex`

* 
(modified)`WorkgroupSize`

* 
(modified)`WorkgroupId`

* 
(modified)`LocalInvocationId`

* 
(modified)`GlobalInvocationId`

* 
(modified)`LocalInvocationIndex`

* 
(modified)`DrawIndex`

* 
(modified)`ViewportMaskNV`

* 
(modified)`PositionPerViewNV`

* 
(modified)`ViewportMaskPerViewNV`

* 
[`MeshShadingNV`](spirvenv.html#spirvenv-capabilities-table-MeshShadingNV)

How to name this extension?

**RESOLVED**: VK_NV_mesh_shader

Other options considered:

* 
VK_NV_mesh_shading

* 
VK_NV_programmable_mesh_shading

* 
VK_NV_primitive_group_shading

* 
VK_NV_grouped_drawing

Do we need a new VkPrimitiveTopology?

**RESOLVED**: No.
We skip the InputAssembler stage.

Should we allow Instancing?

**RESOLVED**: No.
There is no fixed function input, other than the IDs.
However, allow offsetting with a first value.

Should we use existing vkCmdDraw or introduce new functions?

**RESOLVED**: Introduce new functions.

New functions make it easier to separate from programmable primitive
shading chapter, less dual use language about existing functions
having alternative behavior.
The text around the existing draws is heavily based around emitting
vertices.

If new functions, how to name?

**RESOLVED**: CmdDrawMeshTasks*

Other options considered:

* 
CmdDrawMeshed

* 
CmdDrawTasked

* 
CmdDrawGrouped

Should VK_SHADER_STAGE_ALL_GRAPHICS be updated to include the new stages?

**RESOLVED**: No.
If an application were to be recompiled with headers that include additional
shader stage bits in VK_SHADER_STAGE_ALL_GRAPHICS, then the previously valid
application would no longer be valid on implementations that do not support
mesh or task shaders.
This means the change would not be backwards compatible.
It is too bad VkShaderStageFlagBits does not have a dedicated all
supported graphics stages bit like VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT,
which would have avoided this problem.

* 
Revision 1, 2018-07-19 (Christoph Kubisch, Daniel Koch)

Internal revisions

**Name String**

`VK_NV_optical_flow`

**Extension Type**

Device extension

**Registered Extension Number**

465

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

 [VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

 or

 [Vulkan Version 1.1](versions.html#versions-1.1)

 and

 [VK_KHR_format_feature_flags2](#VK_KHR_format_feature_flags2)

 and

 [VK_KHR_synchronization2](#VK_KHR_synchronization2)

or

[Vulkan Version 1.3](versions.html#versions-1.3)

**Contact**

* 
Carsten Rohde [crohde](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NV_optical_flow] @crohde%0A*Here describe the issue or question you have about the VK_NV_optical_flow extension*)

**Last Modified Date**

2022-09-26

**Contributors**

* 
Carsten Rohde, NVIDIA

* 
Vipul Parashar, NVIDIA

* 
Jeff Bolz, NVIDIA

* 
Eric Werness, NVIDIA

Optical flow are fundamental algorithms in computer vision (CV) area.
This extension allows applications to estimate 2D displacement of pixels
between two frames.

|  | This extension is designed to be used with upcoming NVIDIA Optical Flow SDK
| --- | --- |
Version 5 which will be available on NVIDIA Developer webpage. |

* 
[VkOpticalFlowSessionNV](../chapters/VK_NV_optical_flow/optical_flow.html#VkOpticalFlowSessionNV)

* 
[vkBindOpticalFlowSessionImageNV](../chapters/VK_NV_optical_flow/optical_flow.html#vkBindOpticalFlowSessionImageNV)

* 
[vkCmdOpticalFlowExecuteNV](../chapters/VK_NV_optical_flow/optical_flow.html#vkCmdOpticalFlowExecuteNV)

* 
[vkCreateOpticalFlowSessionNV](../chapters/VK_NV_optical_flow/optical_flow.html#vkCreateOpticalFlowSessionNV)

* 
[vkDestroyOpticalFlowSessionNV](../chapters/VK_NV_optical_flow/optical_flow.html#vkDestroyOpticalFlowSessionNV)

* 
[vkGetPhysicalDeviceOpticalFlowImageFormatsNV](../chapters/VK_NV_optical_flow/optical_flow.html#vkGetPhysicalDeviceOpticalFlowImageFormatsNV)

* 
[VkOpticalFlowExecuteInfoNV](../chapters/VK_NV_optical_flow/optical_flow.html#VkOpticalFlowExecuteInfoNV)

* 
[VkOpticalFlowImageFormatPropertiesNV](../chapters/VK_NV_optical_flow/optical_flow.html#VkOpticalFlowImageFormatPropertiesNV)

* 
[VkOpticalFlowSessionCreateInfoNV](../chapters/VK_NV_optical_flow/optical_flow.html#VkOpticalFlowSessionCreateInfoNV)

* 
Extending [VkOpticalFlowSessionCreateInfoNV](../chapters/VK_NV_optical_flow/optical_flow.html#VkOpticalFlowSessionCreateInfoNV):

[VkOpticalFlowSessionCreatePrivateDataInfoNV](../chapters/VK_NV_optical_flow/optical_flow.html#VkOpticalFlowSessionCreatePrivateDataInfoNV)

Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

* 
[VkPhysicalDeviceOpticalFlowFeaturesNV](../chapters/features.html#VkPhysicalDeviceOpticalFlowFeaturesNV)

Extending [VkPhysicalDeviceImageFormatInfo2](../chapters/capabilities.html#VkPhysicalDeviceImageFormatInfo2), [VkImageCreateInfo](../chapters/resources.html#VkImageCreateInfo):

* 
[VkOpticalFlowImageFormatInfoNV](../chapters/VK_NV_optical_flow/optical_flow.html#VkOpticalFlowImageFormatInfoNV)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceOpticalFlowPropertiesNV](../chapters/limits.html#VkPhysicalDeviceOpticalFlowPropertiesNV)

* 
[VkOpticalFlowExecuteFlagBitsNV](../chapters/VK_NV_optical_flow/optical_flow.html#VkOpticalFlowExecuteFlagBitsNV)

* 
[VkOpticalFlowGridSizeFlagBitsNV](../chapters/VK_NV_optical_flow/optical_flow.html#VkOpticalFlowGridSizeFlagBitsNV)

* 
[VkOpticalFlowPerformanceLevelNV](../chapters/VK_NV_optical_flow/optical_flow.html#VkOpticalFlowPerformanceLevelNV)

* 
[VkOpticalFlowSessionBindingPointNV](../chapters/VK_NV_optical_flow/optical_flow.html#VkOpticalFlowSessionBindingPointNV)

* 
[VkOpticalFlowSessionCreateFlagBitsNV](../chapters/VK_NV_optical_flow/optical_flow.html#VkOpticalFlowSessionCreateFlagBitsNV)

* 
[VkOpticalFlowUsageFlagBitsNV](../chapters/VK_NV_optical_flow/optical_flow.html#VkOpticalFlowUsageFlagBitsNV)

* 
[VkOpticalFlowExecuteFlagsNV](../chapters/VK_NV_optical_flow/optical_flow.html#VkOpticalFlowExecuteFlagsNV)

* 
[VkOpticalFlowGridSizeFlagsNV](../chapters/VK_NV_optical_flow/optical_flow.html#VkOpticalFlowGridSizeFlagsNV)

* 
[VkOpticalFlowSessionCreateFlagsNV](../chapters/VK_NV_optical_flow/optical_flow.html#VkOpticalFlowSessionCreateFlagsNV)

* 
[VkOpticalFlowUsageFlagsNV](../chapters/VK_NV_optical_flow/optical_flow.html#VkOpticalFlowUsageFlagsNV)

* 
`VK_NV_OPTICAL_FLOW_EXTENSION_NAME`

* 
`VK_NV_OPTICAL_FLOW_SPEC_VERSION`

* 
Extending [VkAccessFlagBits2](../chapters/synchronization.html#VkAccessFlagBits2):

`VK_ACCESS_2_OPTICAL_FLOW_READ_BIT_NV`

* 
`VK_ACCESS_2_OPTICAL_FLOW_WRITE_BIT_NV`

Extending [VkFormat](../chapters/formats.html#VkFormat):

* 
`VK_FORMAT_R16G16_S10_5_NV`

* 
`VK_FORMAT_R16G16_SFIXED5_NV`

Extending [VkFormatFeatureFlagBits2](../chapters/formats.html#VkFormatFeatureFlagBits2):

* 
`VK_FORMAT_FEATURE_2_OPTICAL_FLOW_COST_BIT_NV`

* 
`VK_FORMAT_FEATURE_2_OPTICAL_FLOW_IMAGE_BIT_NV`

* 
`VK_FORMAT_FEATURE_2_OPTICAL_FLOW_VECTOR_BIT_NV`

Extending [VkObjectType](../chapters/debugging.html#VkObjectType):

* 
`VK_OBJECT_TYPE_OPTICAL_FLOW_SESSION_NV`

Extending [VkPipelineStageFlagBits2](../chapters/synchronization.html#VkPipelineStageFlagBits2):

* 
`VK_PIPELINE_STAGE_2_OPTICAL_FLOW_BIT_NV`

Extending [VkQueueFlagBits](../chapters/devsandqueues.html#VkQueueFlagBits):

* 
`VK_QUEUE_OPTICAL_FLOW_BIT_NV`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV`

* 
`VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV`

* 
`VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV`

* 
`VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV`

* 
`VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV`

// Example querying available input formats
VkOpticalFlowImageFormatInfoNV ofFormatInfo = { VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV };
ofFormatInfo.usage = VK_OPTICAL_FLOW_USAGE_INPUT_BIT_NV;

uint32_t count = 0;
vkGetPhysicalDeviceOpticalFlowImageFormatsNV(physicalDevice, &ofFormatInfo, &count, NULL);
VkOpticalFlowImageFormatPropertiesNV* fmt = new VkOpticalFlowImageFormatPropertiesNV[count];
memset(fmt, 0, count  * sizeof(VkOpticalFlowImageFormatPropertiesNV));
for (uint32_t i = 0; i 

* 
Revision 1, 2022-09-26 (Carsten Rohde)

Internal revisions

**Name String**

`VK_NV_partitioned_acceleration_structure`

**Extension Type**

Device extension

**Registered Extension Number**

571

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_acceleration_structure](#VK_KHR_acceleration_structure)

**Contact**

* 
Vikram Kushwaha [vkushwaha](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NV_partitioned_acceleration_structure] @vkushwaha%0A*Here describe the issue or question you have about the VK_NV_partitioned_acceleration_structure extension*)

**Extension Proposal**

[VK_NV_partitioned_acceleration_structure](../../../features/latest/features/proposals/VK_NV_partitioned_acceleration_structure.html)

**Last Modified Date**

2025-01-09

**Contributors**

* 
Vikram Kushwaha, NVIDIA

* 
Eric Werness, NVIDIA

* 
Christoph Kubisch, NVIDIA

* 
Jan Schmid, NVIDIA

* 
Pyarelal Knowles, NVIDIA

With an increase in scene complexity and expansive game worlds, the number
of instances has surged in ray tracing over the last few years.
The current Top Level Acceleration Structure (TLAS) API necessitates a full
rebuild of the entire data structure even when only a few instances are
modified.

This extension introduces Partitioned Top Level Acceleration Structures
(PTLAS) as an alternative to the existing TLAS.
PTLAS enables the efficient reuse of previously constructed parts of the
acceleration structure, resulting in much faster build times and supporting
a higher number of instances.

* 
[vkCmdBuildPartitionedAccelerationStructuresNV](../chapters/accelstructures.html#vkCmdBuildPartitionedAccelerationStructuresNV)

* 
[vkGetPartitionedAccelerationStructuresBuildSizesNV](../chapters/accelstructures.html#vkGetPartitionedAccelerationStructuresBuildSizesNV)

* 
[VkBuildPartitionedAccelerationStructureIndirectCommandNV](../chapters/accelstructures.html#VkBuildPartitionedAccelerationStructureIndirectCommandNV)

* 
[VkBuildPartitionedAccelerationStructureInfoNV](../chapters/accelstructures.html#VkBuildPartitionedAccelerationStructureInfoNV)

* 
[VkPartitionedAccelerationStructureInstancesInputNV](../chapters/accelstructures.html#VkPartitionedAccelerationStructureInstancesInputNV)

* 
[VkPartitionedAccelerationStructureUpdateInstanceDataNV](../chapters/accelstructures.html#VkPartitionedAccelerationStructureUpdateInstanceDataNV)

* 
[VkPartitionedAccelerationStructureWriteInstanceDataNV](../chapters/accelstructures.html#VkPartitionedAccelerationStructureWriteInstanceDataNV)

* 
[VkPartitionedAccelerationStructureWritePartitionTranslationDataNV](../chapters/accelstructures.html#VkPartitionedAccelerationStructureWritePartitionTranslationDataNV)

* 
Extending [VkPartitionedAccelerationStructureInstancesInputNV](../chapters/accelstructures.html#VkPartitionedAccelerationStructureInstancesInputNV):

[VkPartitionedAccelerationStructureFlagsNV](../chapters/accelstructures.html#VkPartitionedAccelerationStructureFlagsNV)

Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

* 
[VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV](../chapters/features.html#VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV](../chapters/limits.html#VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV)

Extending [VkWriteDescriptorSet](../chapters/descriptorsets.html#VkWriteDescriptorSet):

* 
[VkWriteDescriptorSetPartitionedAccelerationStructureNV](../chapters/descriptorsets.html#VkWriteDescriptorSetPartitionedAccelerationStructureNV)

* 
[VkPartitionedAccelerationStructureInstanceFlagBitsNV](../chapters/accelstructures.html#VkPartitionedAccelerationStructureInstanceFlagBitsNV)

* 
[VkPartitionedAccelerationStructureOpTypeNV](../chapters/accelstructures.html#VkPartitionedAccelerationStructureOpTypeNV)

* 
[VkPartitionedAccelerationStructureInstanceFlagsNV](../chapters/accelstructures.html#VkPartitionedAccelerationStructureInstanceFlagsNV)

* 
`VK_NV_PARTITIONED_ACCELERATION_STRUCTURE_EXTENSION_NAME`

* 
`VK_NV_PARTITIONED_ACCELERATION_STRUCTURE_SPEC_VERSION`

* 
`VK_PARTITIONED_ACCELERATION_STRUCTURE_PARTITION_INDEX_GLOBAL_NV`

* 
Extending [VkDescriptorType](../chapters/descriptorsets.html#VkDescriptorType):

`VK_DESCRIPTOR_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_NV`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_BUILD_PARTITIONED_ACCELERATION_STRUCTURE_INFO_NV`

* 
`VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_FLAGS_NV`

* 
`VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCES_INPUT_NV`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_FEATURES_NV`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_PROPERTIES_NV`

* 
`VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_PARTITIONED_ACCELERATION_STRUCTURE_NV`

* 
Revision 1, 2025-01-09 (Vikram Kushwaha)

Initial draft

**Name String**

`VK_NV_per_stage_descriptor_set`

**Extension Type**

Device extension

**Registered Extension Number**

517

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_maintenance6](#VK_KHR_maintenance6)

or

[Vulkan Version 1.4](versions.html#versions-1.4)

**Contact**

* 
Piers Daniell [pdaniell-nv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NV_per_stage_descriptor_set] @pdaniell-nv%0A*Here describe the issue or question you have about the VK_NV_per_stage_descriptor_set extension*)

**Last Modified Date**

2023-10-16

**IP Status**

No known IP claims.

**Contributors**

* 
Daniel Story, Nintendo

This extension introduces a new descriptor set layout creation flag that
allows bindings in a descriptor set to be scoped to each shader stage.
This means that shaders bound at the same time **may** use completely different
descriptor set layouts without any restrictions on compatibility, and that
the descriptor limits that would otherwise apply to the union of all stages
together instead apply to each stage individually.
It also means that descriptors shared by multiple stages **must** be bound to
each stage or set of stages that use a unique descriptor set layout using
their specific per stage descriptor set layout(s).

This extension also allows each of the new descriptor binding functions from
VK_KHR_maintenance6 to have their [VkPipelineLayout](../chapters/descriptorsets.html#VkPipelineLayout) member be
optionally set to [VK_NULL_HANDLE](boilerplate.html#VK_NULL_HANDLE), in which case the pipeline layout
information is taken from a [VkPipelineLayoutCreateInfo](../chapters/descriptorsets.html#VkPipelineLayoutCreateInfo) structure in
the `pNext` chain.
This enables descriptors to be directly bound using descriptor set layouts
without applications needing to create and manage [VkPipelineLayout](../chapters/descriptorsets.html#VkPipelineLayout)
objects at command recording time.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDevicePerStageDescriptorSetFeaturesNV](../chapters/features.html#VkPhysicalDevicePerStageDescriptorSetFeaturesNV)

* 
`VK_NV_PER_STAGE_DESCRIPTOR_SET_EXTENSION_NAME`

* 
`VK_NV_PER_STAGE_DESCRIPTOR_SET_SPEC_VERSION`

* 
Extending [VkDescriptorSetLayoutCreateFlagBits](../chapters/descriptorsets.html#VkDescriptorSetLayoutCreateFlagBits):

`VK_DESCRIPTOR_SET_LAYOUT_CREATE_PER_STAGE_BIT_NV`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PER_STAGE_DESCRIPTOR_SET_FEATURES_NV`

None

* 
Revision 1, 2023-10-16 (Piers Daniell)

Initial draft

**Name String**

`VK_NV_present_barrier`

**Extension Type**

Device extension

**Registered Extension Number**

293

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

 [VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

 or

 [Vulkan Version 1.1](versions.html#versions-1.1)

and

[VK_KHR_surface](#VK_KHR_surface)

and

[VK_KHR_get_surface_capabilities2](#VK_KHR_get_surface_capabilities2)

and

[VK_KHR_swapchain](#VK_KHR_swapchain)

**Contact**

* 
Liya Li [liyli](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NV_present_barrier] @liyli%0A*Here describe the issue or question you have about the VK_NV_present_barrier extension*)

**Last Modified Date**

2022-05-16

**Contributors**

* 
Liya Li, Nvidia

* 
Martin Schwarzer, Nvidia

* 
Andy Wolf, Nvidia

* 
Ian Williams, Nvidia

* 
Ben Morris, Nvidia

* 
James Jones, Nvidia

* 
Jeff Juliano, Nvidia

This extension adds support for synchronizing corresponding presentation
requests across multiple swapchains using the *present barrier*.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDevicePresentBarrierFeaturesNV](../chapters/features.html#VkPhysicalDevicePresentBarrierFeaturesNV)

Extending [VkSurfaceCapabilities2KHR](../chapters/VK_KHR_surface/wsi.html#VkSurfaceCapabilities2KHR):

* 
[VkSurfaceCapabilitiesPresentBarrierNV](../chapters/VK_KHR_surface/wsi.html#VkSurfaceCapabilitiesPresentBarrierNV)

Extending [VkSwapchainCreateInfoKHR](../chapters/VK_KHR_surface/wsi.html#VkSwapchainCreateInfoKHR):

* 
[VkSwapchainPresentBarrierCreateInfoNV](../chapters/VK_KHR_surface/wsi.html#VkSwapchainPresentBarrierCreateInfoNV)

* 
`VK_NV_PRESENT_BARRIER_EXTENSION_NAME`

* 
`VK_NV_PRESENT_BARRIER_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV`

* 
`VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV`

* 
`VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV`

1) Is there a query interface to check if a swapchain is using the present
barrier?

**RESOLVED**.
There is no such query interface.
When creating a swapchain, an application can specify to use the *present
barrier*, and if the swapchain is created successfully, this swapchain will
be using the present barrier.

2) Do we need an extra interface to set up the present barrier across
distributed systems?

**RESOLVED**.
If the required hardware is presented in the system, and all settings for
the physical synchronization with other systems are set up, an
implementation manages the configuration automatically when creating a
swapchain, without any extra calls from the application.

* 
Revision 1, 2022-07-20

Initial version

**Name String**

`VK_NV_raw_access_chains`

**Extension Type**

Device extension

**Registered Extension Number**

556

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

None

**SPIR-V Dependencies**

* 
[SPV_NV_raw_access_chains](https://github.khronos.org/SPIRV-Registry/extensions/NV/SPV_NV_raw_access_chains.html)

**Contact**

* 
Rodrigo Locatti [rlocatti](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NV_raw_access_chains] @rlocatti%0A*Here describe the issue or question you have about the VK_NV_raw_access_chains extension*)

**Last Modified Date**

2023-12-04

**Interactions and External Dependencies**

* 
This extension requires
[`SPV_NV_raw_access_chains`](https://github.khronos.org/SPIRV-Registry/extensions/NV/SPV_NV_raw_access_chains.html)

**Contributors**

* 
Hans-Kristian Arntzen, Valve

* 
Rodrigo Locatti, NVIDIA

This extension allows the use of the `SPV_NV_raw_access_chains` extension in
SPIR-V shader modules.
This enables SPIR-V producers to efficiently implement interfaces similar to
Direct3D structured buffers and byte address buffers, allowing shaders
compiled from an HLSL source to generate more efficient code.

* 
[RawAccessChainsNV](spirvenv.html#spirvenv-capabilities-table-RawAccessChainsNV)

* 
Revision 1, 2023-12-04 (Rodrigo Locatti)

Initial revision

**Name String**

`VK_NV_ray_tracing_invocation_reorder`

**Extension Type**

Device extension

**Registered Extension Number**

491

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_ray_tracing_pipeline](#VK_KHR_ray_tracing_pipeline)

**SPIR-V Dependencies**

* 
[SPV_NV_shader_invocation_reorder](https://github.khronos.org/SPIRV-Registry/extensions/NV/SPV_NV_shader_invocation_reorder.html)

**Contact**

* 
Eric Werness [ewerness-nv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NV_ray_tracing_invocation_reorder] @ewerness-nv%0A*Here describe the issue or question you have about the VK_NV_ray_tracing_invocation_reorder extension*)

**Last Modified Date**

2022-11-02

**Interactions and External Dependencies**

* 
This extension provides API support for
[`GL_NV_shader_invocation_reorder`](https://github.com/KhronosGroup/GLSL/blob/main/extensions/nv/GLSL_NV_shader_invocation_reorder.txt)

**Contributors**

* 
Eric Werness, NVIDIA

* 
Ashwin Lele, NVIDIA

The ray tracing pipeline API provides some ability to reorder for locality,
but it is useful to have more control over how the reordering happens and
what information is included in the reordering.
The shader API provides a hit object to contain result information from the
hit which can be used as part of the explicit sorting plus options that
contain an integer for hint bits to use to add more locality.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV](../chapters/features.html#VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV](../chapters/limits.html#VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV)

* 
[VkRayTracingInvocationReorderModeNV](../chapters/limits.html#VkRayTracingInvocationReorderModeNV)

* 
`VK_NV_RAY_TRACING_INVOCATION_REORDER_EXTENSION_NAME`

* 
`VK_NV_RAY_TRACING_INVOCATION_REORDER_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV`

HLSL does not provide this functionality natively yet.

However, it is possible to use this functionality via
[SPIR-V
Intrinsics](https://github.com/microsoft/DirectXShaderCompiler/wiki/GL_EXT_spirv_intrinsics-for-SPIR-V-code-gen).

The codes for shader invocation reorder are obtained from
[this
page](https://htmlpreview.github.io/?https://github.com/KhronosGroup/SPIRV-Registry/blob/main/extensions/NV/SPV_NV_shader_invocation_reorder.html):

#define ShaderInvocationReorderNV 5383
#define HitObjectAttributeNV 5385

#define OpHitObjectRecordHitMotionNV 5249
#define OpHitObjectRecordHitWithIndexMotionNV 5250
#define OpHitObjectRecordMissMotionNV 5251
#define OpHitObjectGetWorldToObjectNV 5252
#define OpHitObjectGetObjectToWorldNV 5253
#define OpHitObjectGetObjectRayDirectionNV 5254
#define OpHitObjectGetObjectRayOriginNV 5255
#define OpHitObjectTraceRayMotionNV 5256
#define OpHitObjectGetShaderRecordBufferHandleNV 5257
#define OpHitObjectGetShaderBindingTableRecordIndexNV 5258
#define OpHitObjectRecordEmptyNV 5259
#define OpHitObjectTraceRayNV 5260
#define OpHitObjectRecordHitNV 5261
#define OpHitObjectRecordHitWithIndexNV 5262
#define OpHitObjectRecordMissNV 5263
#define OpHitObjectExecuteShaderNV 5264
#define OpHitObjectGetCurrentTimeNV 5265
#define OpHitObjectGetAttributesNV 5266
#define OpHitObjectGetHitKindNV 5267
#define OpHitObjectGetPrimitiveIndexNV 5268
#define OpHitObjectGetGeometryIndexNV 5269
#define OpHitObjectGetInstanceIdNV 5270
#define OpHitObjectGetInstanceCustomIndexNV 5271
#define OpHitObjectGetWorldRayDirectionNV 5272
#define OpHitObjectGetWorldRayOriginNV 5273
#define OpHitObjectGetRayTMaxNV 5274
#define OpHitObjectGetRayTMinNV 5275
#define OpHitObjectIsEmptyNV 5276
#define OpHitObjectIsHitNV 5277
#define OpHitObjectIsMissNV 5278
#define OpReorderThreadWithHitObjectNV 5279
#define OpReorderThreadWithHintNV 5280
#define OpTypeHitObjectNV 5281

The capability and extension need to be added:

[[vk::ext_capability(ShaderInvocationReorderNV)]]
[[vk::ext_extension("SPV_NV_shader_invocation_reorder")]]

The creation of the `HitObject` type can be done like this:

[[vk::ext_type_def(HitObjectAttributeNV, OpTypeHitObjectNV)]]
void createHitObjectNV();
#define HitObjectNV vk::ext_type

The payload:

* 
must be global

* 
needs the `RayPayloadKHR` attribute as an extra storage class

struct [raypayload] HitPayload
{
  float hitT : write(closesthit, miss) : read(caller);
  int instanceIndex : write(closesthit) : read(caller);
  float3 pos : write(closesthit) : read(caller);
  float3 nrm : write(closesthit) : read(caller);
};

#define RayPayloadKHR 5338
[[vk::ext_storage_class(RayPayloadKHR)]] static HitPayload payload;

Here is the declaration of a few invocation reordering functions:

[[vk::ext_instruction(OpHitObjectRecordEmptyNV)]]
void hitObjectRecordEmptyNV([[vk::ext_reference]] HitObjectNV hitObject);

[[vk::ext_instruction(OpHitObjectTraceRayNV)]]
void hitObjectTraceRayNV(
    [[vk::ext_reference]] HitObjectNV hitObject,
    RaytracingAccelerationStructure as,
    uint RayFlags,
    uint CullMask,
    uint SBTOffset,
    uint SBTStride,
    uint MissIndex,
    float3 RayOrigin,
    float RayTmin,
    float3 RayDirection,
    float RayTMax,
    [[vk::ext_reference]] [[vk::ext_storage_class(RayPayloadKHR)]] HitPayload payload
  );

[[vk::ext_instruction(OpReorderThreadWithHintNV)]]
void reorderThreadWithHintNV(int Hint, int Bits);

[[vk::ext_instruction(OpReorderThreadWithHitObjectNV)]]
void reorderThreadWithHitObjectNV([[vk::ext_reference]] HitObjectNV hitObject);

[[vk::ext_instruction(OpHitObjectExecuteShaderNV)]]
void hitObjectExecuteShaderNV([[vk::ext_reference]] HitObjectNV hitObject, [[vk::ext_reference]] [[vk::ext_storage_class(RayPayloadKHR)]] HitPayload payload);

[[vk::ext_instruction(OpHitObjectIsHitNV)]]
bool hitObjectIsHitNV([[vk::ext_reference]] HitObjectNV hitObject);

Using the function in the code, can be done like this

  if (USE_SER == 1)
  {
    createHitObjectNV();
    HitObjectNV hObj; //  hitObjectNV hObj;
    hitObjectRecordEmptyNV(hObj); //Initialize to an empty hit object
    hitObjectTraceRayNV(hObj, topLevelAS, rayFlags, 0xFF, 0, 0, 0, r.Origin, 0.0, r.Direction, INFINITE, payload);
    reorderThreadWithHitObjectNV(hObj);
    hitObjectExecuteShaderNV(hObj, payload);
  }

Note:

* 
createHitObjectNV() needs to be call at least once.
This can be also done in the main entry of the shader.

* 
Function with a payload parameter, needs to have the payload struct
defined before.
There are no templated declaration of the function.

* 
Revision 1, 2020-09-12 (Eric Werness, Ashwin Lele)

Initial external release

**Name String**

`VK_NV_ray_tracing_linear_swept_spheres`

**Extension Type**

Device extension

**Registered Extension Number**

430

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_ray_tracing_pipeline](#VK_KHR_ray_tracing_pipeline)

**SPIR-V Dependencies**

* 
[SPV_NV_linear_swept_spheres](https://github.khronos.org/SPIRV-Registry/extensions/NV/SPV_NV_linear_swept_spheres.html)

**Contact**

* 
Vikram Kushwaha [vkushwaha](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NV_ray_tracing_linear_swept_spheres] @vkushwaha%0A*Here describe the issue or question you have about the VK_NV_ray_tracing_linear_swept_spheres extension*)

**Extension Proposal**

[VK_NV_ray_tracing_linear_swept_spheres](../../../features/latest/features/proposals/VK_NV_ray_tracing_linear_swept_spheres.html)

**Last Modified Date**

2025-01-03

**Interactions and External Dependencies**

* 
This extension requires
[`SPV_NV_linear_swept_spheres`](https://github.khronos.org/SPIRV-Registry/extensions/NV/SPV_NV_linear_swept_spheres.html)

* 
This extension provides API support for
[`GL_NV_linear_swept_spheres`](https://github.com/KhronosGroup/GLSL/blob/main/extensions/nv/GLSL_NV_linear_swept_spheres.txt)

**Contributors**

* 
Vikram Kushwaha, NVIDIA

* 
Eric Werness, NVIDIA

* 
Daniel Koch, NVIDIA

* 
Ashwin Lele, NVIDIA

* 
Nathan Morrical, NVIDIA

This extension adds two new primitives for ray tracing: a sphere primitive
and a linear swept sphere (LSS) primitive.
The purpose of the LSS primitive is to enable rendering of high quality hair
and fur using a compact primitive representation encoded in the acceleration
structure.
Sphere primitives are defined by a position and a radius and are a subset of
LSS, but are useful in their own right, for example for particle systems.

This extension adds support for the following SPIR-V extension in Vulkan:

* 
`SPV_NV_linear_swept_spheres`

* 
Extending [VkAccelerationStructureGeometryKHR](../chapters/accelstructures.html#VkAccelerationStructureGeometryKHR):

[VkAccelerationStructureGeometryLinearSweptSpheresDataNV](../chapters/accelstructures.html#VkAccelerationStructureGeometryLinearSweptSpheresDataNV)

* 
[VkAccelerationStructureGeometrySpheresDataNV](../chapters/accelstructures.html#VkAccelerationStructureGeometrySpheresDataNV)

Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

* 
[VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV](../chapters/features.html#VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV)

* 
[VkRayTracingLssIndexingModeNV](../chapters/accelstructures.html#VkRayTracingLssIndexingModeNV)

* 
[VkRayTracingLssPrimitiveEndCapsModeNV](../chapters/accelstructures.html#VkRayTracingLssPrimitiveEndCapsModeNV)

* 
`VK_NV_RAY_TRACING_LINEAR_SWEPT_SPHERES_EXTENSION_NAME`

* 
`VK_NV_RAY_TRACING_LINEAR_SWEPT_SPHERES_SPEC_VERSION`

* 
Extending [VkFormatFeatureFlagBits2](../chapters/formats.html#VkFormatFeatureFlagBits2):

`VK_FORMAT_FEATURE_2_ACCELERATION_STRUCTURE_RADIUS_BUFFER_BIT_NV`

Extending [VkGeometryTypeKHR](../chapters/resources.html#VkGeometryTypeKHR):

* 
`VK_GEOMETRY_TYPE_LINEAR_SWEPT_SPHERES_NV`

* 
`VK_GEOMETRY_TYPE_SPHERES_NV`

Extending [VkPipelineCreateFlagBits2](../chapters/pipelines.html#VkPipelineCreateFlagBits2):

* 
`VK_PIPELINE_CREATE_2_RAY_TRACING_ALLOW_SPHERES_AND_LINEAR_SWEPT_SPHERES_BIT_NV`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_LINEAR_SWEPT_SPHERES_DATA_NV`

* 
`VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_SPHERES_DATA_NV`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_LINEAR_SWEPT_SPHERES_FEATURES_NV`

* 
[`HitIsSphereNV`](../chapters/interfaces.html#interfaces-builtin-variables-hitissphere)

* 
[`HitIsLSSNV`](../chapters/interfaces.html#interfaces-builtin-variables-hitislss)

* 
[`HitSpherePositionNV`](../chapters/interfaces.html#interfaces-builtin-variables-hitsphereposition)

* 
[`HitSphereRadiusNV`](../chapters/interfaces.html#interfaces-builtin-variables-hitsphereradius)

* 
[`HitLSSPositionsNV`](../chapters/interfaces.html#interfaces-builtin-variables-hitlsspositions)

* 
[`HitLSSRadiiNV`](../chapters/interfaces.html#interfaces-builtin-variables-hitlssradii)

* 
[    `RayTracingSpheresGeometryNV`](spirvenv.html#spirvenv-capabilities-table-RayTracingSpheresGeometryNV)

* 
[    `RayTracingLinearSweptSpheresGeometryNV`](spirvenv.html#spirvenv-capabilities-table-RayTracingLinearSweptSpheresGeometryNV)

* 
Revision 1, 2025-01-03 (Vikram Kushwaha)

Initial draft

**Name String**

`VK_NV_ray_tracing_motion_blur`

**Extension Type**

Device extension

**Registered Extension Number**

328

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_ray_tracing_pipeline](#VK_KHR_ray_tracing_pipeline)

**SPIR-V Dependencies**

* 
[SPV_NV_ray_tracing_motion_blur](https://github.khronos.org/SPIRV-Registry/extensions/NV/SPV_NV_ray_tracing_motion_blur.html)

**Contact**

* 
Eric Werness

**Last Modified Date**

2021-06-16

**Interactions and External Dependencies**

* 
This extension provides API support for
[`GL_NV_ray_tracing_motion_blur`](https://github.com/KhronosGroup/GLSL/blob/main/extensions/nv/GLSL_NV_ray_tracing_motion_blur.txt)

**Contributors**

* 
Eric Werness, NVIDIA

* 
Ashwin Lele, NVIDIA

Ray tracing support in the API provides an efficient mechanism to intersect
rays against static geometry, but rendering algorithms often want to support
motion, which is more efficiently supported with motion-specific algorithms.
This extension adds a set of mechanisms to support fast tracing of moving
geometry:

* 
A ray pipeline trace call which takes a time parameter

* 
Flags to enable motion support in an acceleration structure

* 
Support for time-varying vertex positions in a geometry

* 
Motion instances to move existing instances over time

The motion represented here is parameterized across a normalized timestep
between 0.0 and 1.0.
A motion trace using `OpTraceRayMotionNV` provides a time within that
normalized range to be used when intersecting that ray with geometry.
The geometry can be provided with motion by a combination of adding a second
vertex position for time of 1.0 using
`VkAccelerationStructureGeometryMotionTrianglesDataNV` and providing
multiple transforms in the instance using
`VkAccelerationStructureMotionInstanceNV`.

* 
[VkAccelerationStructureMatrixMotionInstanceNV](../chapters/accelstructures.html#VkAccelerationStructureMatrixMotionInstanceNV)

* 
[VkAccelerationStructureMotionInstanceNV](../chapters/accelstructures.html#VkAccelerationStructureMotionInstanceNV)

* 
[VkAccelerationStructureSRTMotionInstanceNV](../chapters/accelstructures.html#VkAccelerationStructureSRTMotionInstanceNV)

* 
[VkSRTDataNV](../chapters/accelstructures.html#VkSRTDataNV)

* 
Extending [VkAccelerationStructureCreateInfoKHR](../chapters/resources.html#VkAccelerationStructureCreateInfoKHR):

[VkAccelerationStructureMotionInfoNV](../chapters/resources.html#VkAccelerationStructureMotionInfoNV)

Extending [VkAccelerationStructureGeometryTrianglesDataKHR](../chapters/accelstructures.html#VkAccelerationStructureGeometryTrianglesDataKHR):

* 
[VkAccelerationStructureGeometryMotionTrianglesDataNV](../chapters/accelstructures.html#VkAccelerationStructureGeometryMotionTrianglesDataNV)

Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

* 
[VkPhysicalDeviceRayTracingMotionBlurFeaturesNV](../chapters/features.html#VkPhysicalDeviceRayTracingMotionBlurFeaturesNV)

* 
[VkAccelerationStructureMotionInstanceDataNV](../chapters/accelstructures.html#VkAccelerationStructureMotionInstanceDataNV)

* 
[VkAccelerationStructureMotionInstanceTypeNV](../chapters/accelstructures.html#VkAccelerationStructureMotionInstanceTypeNV)

* 
[VkAccelerationStructureMotionInfoFlagsNV](../chapters/resources.html#VkAccelerationStructureMotionInfoFlagsNV)

* 
[VkAccelerationStructureMotionInstanceFlagsNV](../chapters/accelstructures.html#VkAccelerationStructureMotionInstanceFlagsNV)

* 
`VK_NV_RAY_TRACING_MOTION_BLUR_EXTENSION_NAME`

* 
`VK_NV_RAY_TRACING_MOTION_BLUR_SPEC_VERSION`

* 
Extending [VkAccelerationStructureCreateFlagBitsKHR](../chapters/resources.html#VkAccelerationStructureCreateFlagBitsKHR):

`VK_ACCELERATION_STRUCTURE_CREATE_MOTION_BIT_NV`

Extending [VkBuildAccelerationStructureFlagBitsKHR](../chapters/resources.html#VkBuildAccelerationStructureFlagBitsKHR):

* 
`VK_BUILD_ACCELERATION_STRUCTURE_MOTION_BIT_NV`

Extending [VkPipelineCreateFlagBits](../chapters/pipelines.html#VkPipelineCreateFlagBits):

* 
`VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV`

* 
`VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV`

(1) What size is VkAccelerationStructureMotionInstanceNV?

* 
Added a note on the structure size and made the stride explicit in the
language.

(2) Allow arrayOfPointers for motion TLAS?

* 
Yes, with a packed encoding to minimize the amount of data sent for
metadata.

* 
Revision 1, 2020-06-16 (Eric Werness, Ashwin Lele)

Initial external release

**Name String**

`VK_NV_ray_tracing_validation`

**Extension Type**

Device extension

**Registered Extension Number**

569

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

None

**Contact**

* 
Vikram Kushwaha [vkushwaha-nv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NV_ray_tracing_validation] @vkushwaha-nv%0A*Here describe the issue or question you have about the VK_NV_ray_tracing_validation extension*)

**Extension Proposal**

[VK_NV_ray_tracing_validation](../../../features/latest/features/proposals/VK_NV_ray_tracing_validation.html)

**Last Modified Date**

2024-03-04

**Contributors**

* 
Vikram Kushwaha, NVIDIA

* 
Eric Werness, NVIDIA

* 
Piers Daniell, NVIDIA

This extension adds support for performing ray tracing validation at an
implementation level.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceRayTracingValidationFeaturesNV](../chapters/features.html#VkPhysicalDeviceRayTracingValidationFeaturesNV)

* 
`VK_NV_RAY_TRACING_VALIDATION_EXTENSION_NAME`

* 
`VK_NV_RAY_TRACING_VALIDATION_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_VALIDATION_FEATURES_NV`

* 
Revision 1, 2024-03-04 (Vikram Kushwaha)

Initial draft

**Name String**

`VK_NV_representative_fragment_test`

**Extension Type**

Device extension

**Registered Extension Number**

167

**Revision**

2

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Contact**

* 
Kedarnath Thangudu [kthangudu](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NV_representative_fragment_test] @kthangudu%0A*Here describe the issue or question you have about the VK_NV_representative_fragment_test extension*)

**Last Modified Date**

2018-09-13

**Contributors**

* 
Kedarnath Thangudu, NVIDIA

* 
Christoph Kubisch, NVIDIA

* 
Pierre Boudier, NVIDIA

* 
Pat Brown, NVIDIA

* 
Jeff Bolz, NVIDIA

* 
Eric Werness, NVIDIA

This extension provides a new representative fragment test that allows
implementations to reduce the amount of rasterization and fragment
processing work performed for each point, line, or triangle primitive.
For any primitive that produces one or more fragments that pass all other
early fragment tests, the implementation is permitted to choose one or more
representative fragments for processing and discard all other fragments.
For draw calls rendering multiple points, lines, or triangles arranged in
lists, strips, or fans, the representative fragment test is performed
independently for each of those primitives.

This extension is useful for applications that use an early render pass to
determine the full set of primitives that would be visible in the final
scene.
In this render pass, such applications would set up a fragment shader that
enables early fragment tests and writes to an image or shader storage buffer
to record the ID of the primitive that generated the fragment.
Without this extension, the shader would record the ID separately for each
visible fragment of each primitive.
With this extension, fewer stores will be performed, particularly for large
primitives.

The representative fragment test has no effect if early fragment tests are
not enabled via the fragment shader.
The set of fragments discarded by the representative fragment test is
implementation-dependent and may vary from frame to frame.
In some cases, the representative fragment test may not discard any
fragments for a given primitive.

* 
Extending [VkGraphicsPipelineCreateInfo](../chapters/pipelines.html#VkGraphicsPipelineCreateInfo):

[VkPipelineRepresentativeFragmentTestStateCreateInfoNV](../chapters/fragops.html#VkPipelineRepresentativeFragmentTestStateCreateInfoNV)

Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

* 
[VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV](../chapters/features.html#VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV)

* 
`VK_NV_REPRESENTATIVE_FRAGMENT_TEST_EXTENSION_NAME`

* 
`VK_NV_REPRESENTATIVE_FRAGMENT_TEST_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV`

* 
`VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV`

(1) Is the representative fragment test guaranteed to have any effect?

**RESOLVED**: No.
As specified, we only guarantee that each primitive with at least one
fragment that passes prior tests will have one fragment passing the
representative fragment tests.
We do not guarantee that any particular fragment will fail the test.

In the initial implementation of this extension, the representative fragment
test is treated as an optimization that may be completely disabled for some
pipeline states.
This feature was designed for a use case where the fragment shader records
information on individual primitives using shader storage buffers or storage
images, with no writes to color or depth buffers.

(2) Will the set of fragments that pass the representative fragment test be
repeatable if you draw the same scene over and over again?

**RESOLVED**: No.
The set of fragments that pass the representative fragment test is
implementation-dependent and may vary due to the timing of operations
performed by the GPU.

(3) What happens if you enable the representative fragment test with writes
to color and/or depth render targets enabled?

**RESOLVED**: If writes to the color or depth buffer are enabled, they will be
performed for any fragments that survive the relevant tests.
Any fragments that fail the representative fragment test will not update
color buffers.
For the use cases intended for this feature, we do not expect color or depth
writes to be enabled.

(4) How do derivatives and automatic texture LOD computations work with the
representative fragment test enabled?

**RESOLVED**: If a fragment shader uses derivative functions or texture
lookups using automatic LOD computation, derivatives will be computed
identically whether or not the representative fragment test is enabled.
For the use cases intended for this feature, we do not expect the use of
derivatives in the fragment shader.

* 
Revision 2, 2018-09-13 (pbrown)

Add issues.

Revision 1, 2018-08-22 (Kedarnath Thangudu)

* 
Internal Revisions

**Name String**

`VK_NV_sample_mask_override_coverage`

**Extension Type**

Device extension

**Registered Extension Number**

95

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

None

**SPIR-V Dependencies**

* 
[SPV_NV_sample_mask_override_coverage](https://github.khronos.org/SPIRV-Registry/extensions/NV/SPV_NV_sample_mask_override_coverage.html)

**Contact**

* 
Piers Daniell [pdaniell-nv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NV_sample_mask_override_coverage] @pdaniell-nv%0A*Here describe the issue or question you have about the VK_NV_sample_mask_override_coverage extension*)

**Last Modified Date**

2016-12-08

**IP Status**

No known IP claims.

**Interactions and External Dependencies**

* 
This extension provides API support for
[`GL_NV_sample_mask_override_coverage`](https://registry.khronos.org/OpenGL/extensions/NV/NV_sample_mask_override_coverage.txt)

**Contributors**

* 
Daniel Koch, NVIDIA

* 
Jeff Bolz, NVIDIA

This extension adds support for the following SPIR-V extension in Vulkan:

* 
`SPV_NV_sample_mask_override_coverage`

The extension provides access to the `OverrideCoverageNV` decoration
under the `SampleMaskOverrideCoverageNV` capability.
Adding this decoration to a variable with the `SampleMask` builtin
decoration allows the shader to modify the coverage mask and affect which
samples are used to process the fragment.

When using GLSL source-based shader languages, the `override_coverage`
layout qualifier from `GL_NV_sample_mask_override_coverage` maps to the
`OverrideCoverageNV` decoration.
To use the `override_coverage` layout qualifier in GLSL the
`GL_NV_sample_mask_override_coverage` extension must be enabled.
Behavior is described in the `GL_NV_sample_mask_override_coverage` extension
spec.

* 
`VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_EXTENSION_NAME`

* 
`VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_SPEC_VERSION`

* 
[OverrideCoverageNV in    SampleMask](../chapters/interfaces.html#interfaces-builtin-variables-samplemask)

* 
[    `SampleMaskOverrideCoverageNV`](spirvenv.html#spirvenv-capabilities-table-SampleMaskOverrideCoverageNV)

* 
Revision 1, 2016-12-08 (Piers Daniell)

Internal revisions

**Name String**

`VK_NV_scissor_exclusive`

**Extension Type**

Device extension

**Registered Extension Number**

206

**Revision**

2

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Contact**

* 
Pat Brown [nvpbrown](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NV_scissor_exclusive] @nvpbrown%0A*Here describe the issue or question you have about the VK_NV_scissor_exclusive extension*)

**Last Modified Date**

2023-01-18

**IP Status**

No known IP claims.

**Interactions and External Dependencies**

None

**Contributors**

* 
Pat Brown, NVIDIA

* 
Jeff Bolz, NVIDIA

* 
Piers Daniell, NVIDIA

* 
Daniel Koch, NVIDIA

This extension adds support for an exclusive scissor test to Vulkan.
The exclusive scissor test behaves like the scissor test, except that the
exclusive scissor test fails for pixels inside the corresponding rectangle
and passes for pixels outside the rectangle.
If the same rectangle is used for both the scissor and exclusive scissor
tests, the exclusive scissor test will pass if and only if the scissor test
fails.

Version 2 of this extension introduces
`VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_ENABLE_NV` and
[vkCmdSetExclusiveScissorEnableNV](../chapters/fragops.html#vkCmdSetExclusiveScissorEnableNV).
Applications that use this dynamic state must ensure the implementation
advertises at least `specVersion` `2` of this extension.

* 
[vkCmdSetExclusiveScissorEnableNV](../chapters/fragops.html#vkCmdSetExclusiveScissorEnableNV)

* 
[vkCmdSetExclusiveScissorNV](../chapters/fragops.html#vkCmdSetExclusiveScissorNV)

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceExclusiveScissorFeaturesNV](../chapters/features.html#VkPhysicalDeviceExclusiveScissorFeaturesNV)

Extending [VkPipelineViewportStateCreateInfo](../chapters/vertexpostproc.html#VkPipelineViewportStateCreateInfo):

* 
[VkPipelineViewportExclusiveScissorStateCreateInfoNV](../chapters/fragops.html#VkPipelineViewportExclusiveScissorStateCreateInfoNV)

* 
`VK_NV_SCISSOR_EXCLUSIVE_EXTENSION_NAME`

* 
`VK_NV_SCISSOR_EXCLUSIVE_SPEC_VERSION`

* 
Extending [VkDynamicState](../chapters/pipelines.html#VkDynamicState):

`VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_ENABLE_NV`

* 
`VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV`

* 
`VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV`

1) For the scissor test, the viewport state must be created with a matching
number of scissor and viewport rectangles.
Should we have the same requirement for exclusive scissors?

**RESOLVED**: For exclusive scissors, we relax this requirement and allow an
exclusive scissor rectangle count that is either zero or equal to the number
of viewport rectangles.
If you pass in an exclusive scissor count of zero, the exclusive scissor
test is treated as disabled.

* 
Revision 2, 2023-01-18 (Piers Daniell)

Add dynamic state for explicit exclusive scissor enables

Revision 1, 2018-07-31 (Pat Brown)

* 
Internal revisions

**Name String**

`VK_NV_shader_atomic_float16_vector`

**Extension Type**

Device extension

**Registered Extension Number**

564

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

None

**SPIR-V Dependencies**

* 
[SPV_NV_shader_atomic_fp16_vector](https://github.khronos.org/SPIRV-Registry/extensions/NV/SPV_NV_shader_atomic_fp16_vector.html)

**Contact**

* 
Jeff Bolz [jeffbolznv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NV_shader_atomic_float16_vector] @jeffbolznv%0A*Here describe the issue or question you have about the VK_NV_shader_atomic_float16_vector extension*)

**Last Modified Date**

2024-02-03

**IP Status**

No known IP claims.

**Interactions and External Dependencies**

* 
This extension provides API support for
[`GL_NV_shader_atomic_fp16_vector`](https://registry.khronos.org/OpenGL/extensions/NV/NV_shader_atomic_fp16_vector.txt)

**Contributors**

* 
Jeff Bolz, NVIDIA

This extension allows a shader to perform atomic add, min, max, and exchange
operations on 2- and 4-component vectors of float16.
Buffer, workgroup, and image storage classes are all supported.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV](../chapters/features.html#VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV)

* 
`VK_NV_SHADER_ATOMIC_FLOAT16_VECTOR_EXTENSION_NAME`

* 
`VK_NV_SHADER_ATOMIC_FLOAT16_VECTOR_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT16_VECTOR_FEATURES_NV`

None.

* 
[    `AtomicFloat16VectorNV`](spirvenv.html#spirvenv-capabilities-table-AtomicFloat16VectorNV)

* 
Revision 1, 2024-02-03 (Jeff Bolz)

Internal revisions

**Name String**

`VK_NV_shader_image_footprint`

**Extension Type**

Device extension

**Registered Extension Number**

205

**Revision**

2

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**SPIR-V Dependencies**

* 
[SPV_NV_shader_image_footprint](https://github.khronos.org/SPIRV-Registry/extensions/NV/SPV_NV_shader_image_footprint.html)

**Contact**

* 
Pat Brown [nvpbrown](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NV_shader_image_footprint] @nvpbrown%0A*Here describe the issue or question you have about the VK_NV_shader_image_footprint extension*)

**Last Modified Date**

2018-09-13

**IP Status**

No known IP claims.

**Interactions and External Dependencies**

* 
This extension provides API support for
[`GL_NV_shader_texture_footprint`](https://github.com/KhronosGroup/GLSL/blob/main/extensions/nv/GLSL_NV_shader_texture_footprint.txt)

**Contributors**

* 
Pat Brown, NVIDIA

* 
Chris Lentini, NVIDIA

* 
Daniel Koch, NVIDIA

* 
Jeff Bolz, NVIDIA

This extension adds Vulkan support for the
[`SPV_NV_shader_image_footprint`](https://github.khronos.org/SPIRV-Registry/extensions/NV/SPV_NV_shader_image_footprint.html)
SPIR-V extension.
That SPIR-V extension provides a new instruction
`OpImageSampleFootprintNV` allowing shaders to determine the set of
texels that would be accessed by an equivalent filtered texture lookup.

Instead of returning a filtered texture value, the instruction returns a
structure that can be interpreted by shader code to determine the footprint
of a filtered texture lookup.
This structure includes integer values that identify a small neighborhood of
texels in the image being accessed and a bitfield that indicates which
texels in that neighborhood would be used.
The structure also includes a bitfield where each bit identifies whether any
texel in a small aligned block of texels would be fetched by the texture
lookup.
The size of each block is specified by an access *granularity* provided by
the shader.
The minimum granularity supported by this extension is 2x2 (for 2D textures)
and 2x2x2 (for 3D textures); the maximum granularity is 256x256 (for 2D
textures) or 64x32x32 (for 3D textures).
Each footprint query returns the footprint from a single texture level.
When using minification filters that combine accesses from multiple mipmap
levels, shaders must perform separate queries for the two levels accessed
(fine and coarse).
The footprint query also returns a flag indicating if the texture lookup
would access texels from only one mipmap level or from two neighboring
levels.

This extension should be useful for multi-pass rendering operations that do
an initial expensive rendering pass to produce a first image that is then
used as a texture for a second pass.
If the second pass ends up accessing only portions of the first image (e.g.,
due to visibility), the work spent rendering the non-accessed portion of the
first image was wasted.
With this feature, an application can limit this waste using an initial pass
over the geometry in the second image that performs a footprint query for
each visible pixel to determine the set of pixels that it needs from the
first image.
This pass would accumulate an aggregate footprint of all visible pixels into
a separate footprint image using shader atomics.
Then, when rendering the first image, the application can kill all shading
work for pixels not in this aggregate footprint.

This extension has a number of limitations.
The `OpImageSampleFootprintNV` instruction only supports for two- and
three-dimensional textures.
Footprint evaluation only supports the CLAMP_TO_EDGE wrap mode; results are
**undefined** for all other wrap modes.
Only a limited set of granularity values and that set does not support
separate coverage information for each texel in the original image.

When using SPIR-V generated from the OpenGL Shading Language, the new
instruction will be generated from code using the new
`textureFootprint*NV` built-in functions from the
`GL_NV_shader_texture_footprint` shading language extension.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceShaderImageFootprintFeaturesNV](../chapters/features.html#VkPhysicalDeviceShaderImageFootprintFeaturesNV)

* 
`VK_NV_SHADER_IMAGE_FOOTPRINT_EXTENSION_NAME`

* 
`VK_NV_SHADER_IMAGE_FOOTPRINT_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV`

* 
[`ImageFootprintNV`](spirvenv.html#spirvenv-capabilities-table-ImageFootprintNV)

(1) The footprint returned by the SPIR-V instruction is a structure that
    includes an anchor, an offset, and a mask that represents a 8x8 or 4x4x4
    neighborhood of texel groups.
    But the bits of the mask are not stored in simple pitch order.
    Why is the footprint built this way?

**RESOLVED**: We expect that applications using this feature will want to use
a fixed granularity and accumulate coverage information from the returned
footprints into an aggregate footprint image that tracks the portions of
an image that would be needed by regular texture filtering.
If an application is using a two-dimensional image with 4x4 pixel
granularity, we expect that the footprint image will use 64-bit texels where
each bit in an 8x8 array of bits corresponds to coverage for a 4x4 block in
the original image.
Texel (0,0) in the footprint image would correspond to texels (0,0) through
(31,31) in the original image.

In the usual case, the footprint for a single access will fully contained in
a 32x32 aligned region of the original texture, which corresponds to a
single 64-bit texel in the footprint image.
In that case, the implementation will return an anchor coordinate pointing
at the single footprint image texel, an offset vector of (0,0), and a mask
whose bits are aligned with the bits in the footprint texel.
For this case, the shader can simply atomically OR the mask bits into the
contents of the footprint texel to accumulate footprint coverage.

In the worst case, the footprint for a single access spans multiple 32x32
aligned regions and may require updates to four separate footprint image
texels.
In this case, the implementation will return an anchor coordinate pointing
at the lower right footprint image texel and an offset will identify how
many columns and rows of the returned 8x8 mask correspond to
footprint texels to the left and above the anchor texel.
If the anchor is (2,3), the 64 bits of the returned mask are arranged
spatially as follows, where each 4x4 block is assigned a bit number that
matches its bit number in the footprint image texels:

    +-------------------------+-------------------------+
    | -- -- -- -- -- -- -- -- | -- -- -- -- -- -- -- -- |
    | -- -- -- -- -- -- -- -- | -- -- -- -- -- -- -- -- |
    | -- -- -- -- -- -- -- -- | -- -- -- -- -- -- -- -- |
    | -- -- -- -- -- -- -- -- | -- -- -- -- -- -- -- -- |
    | -- -- -- -- -- -- -- -- | -- -- -- -- -- -- -- -- |
    | -- -- -- -- -- -- 46 47 | 40 41 42 43 44 45 -- -- |
    | -- -- -- -- -- -- 54 55 | 48 49 50 51 52 53 -- -- |
    | -- -- -- -- -- -- 62 63 | 56 57 58 59 60 61 -- -- |
    +-------------------------+-------------------------+
    | -- -- -- -- -- -- 06 07 | 00 01 02 03 04 05 -- -- |
    | -- -- -- -- -- -- 14 15 | 08 09 10 11 12 13 -- -- |
    | -- -- -- -- -- -- 22 23 | 16 17 18 19 20 21 -- -- |
    | -- -- -- -- -- -- 30 31 | 24 25 26 27 28 29 -- -- |
    | -- -- -- -- -- -- 38 39 | 32 33 34 35 36 37 -- -- |
    | -- -- -- -- -- -- -- -- | -- -- -- -- -- -- -- -- |
    | -- -- -- -- -- -- -- -- | -- -- -- -- -- -- -- -- |
    | -- -- -- -- -- -- -- -- | -- -- -- -- -- -- -- -- |
    +-------------------------+-------------------------+

To accumulate coverage for each of the four footprint image texels, a shader
can AND the returned mask with simple masks derived from the x and y offset
values and then atomically OR the updated mask bits into the contents of the
corresponding footprint texel.

    uint64_t returnedMask = (uint64_t(footprint.mask.x) | (uint64_t(footprint.mask.y) > footprint.offset.x) * 0x0101010101010101UL);
    uint64_t bottomMask   = 0xFFFFFFFFFFFFFFFFUL >> (8 * footprint.offset.y);
    uint64_t bottomRight  = returnedMask & bottomMask & rightMask;
    uint64_t bottomLeft   = returnedMask & bottomMask & (~rightMask);
    uint64_t topRight     = returnedMask & (~bottomMask) & rightMask;
    uint64_t topLeft      = returnedMask & (~bottomMask) & (~rightMask);

(2) What should an application do to ensure maximum performance when
accumulating footprints into an aggregate footprint image?

**RESOLVED**: We expect that the most common usage of this feature will be to
accumulate aggregate footprint coverage, as described in the previous issue.
Even if you ignore the anisotropic filtering case where the implementation
may return a granularity larger than that requested by the caller, each
shader invocation will need to use atomic functions to update up to four
footprint image texels for each LOD accessed.
Having each active shader invocation perform multiple atomic operations can
be expensive, particularly when neighboring invocations will want to update
the same footprint image texels.

Techniques can be used to reduce the number of atomic operations performed
when accumulating coverage include:

* 
Have logic that detects returned footprints where all components of the
returned offset vector are zero.
In that case, the mask returned by the footprint function is guaranteed
to be aligned with the footprint image texels and affects only a single
footprint image texel.

* 
Have fragment shaders communicate using built-in functions from the
`VK_NV_shader_subgroup_partitioned` extension or other shader subgroup
extensions.
If you have multiple invocations in a subgroup that need to update the
same texel (x,y) in the footprint image, compute an aggregate footprint
mask across all invocations in the subgroup updating that texel and have
a single invocation perform an atomic operation using that aggregate
mask.

* 
When the returned footprint spans multiple texels in the footprint
image, each invocation need to perform four atomic operations.
In the previous issue, we had an example that computed separate masks
for topLeft, topRight, bottomLeft, and bottomRight.
When the invocations in a subgroup have good locality, it might be the
case the top left for some invocations might refer to footprint
image texel (10,10), while neighbors might have their top left
texels at (11,10), (10,11), and (11,11).
If you compute separate masks for even/odd x and y values instead of
left/right or top/bottom, the odd/odd mask for all invocations in
the subgroup hold coverage for footprint image texel (11,11), which can
be updated by a single atomic operation for the entire subgroup.

TBD

* 
Revision 2, 2018-09-13 (Pat Brown)

Add issue (2) with performance tips.

Revision 1, 2018-08-12 (Pat Brown)

* 
Initial draft

**Name String**

`VK_NV_shader_sm_builtins`

**Extension Type**

Device extension

**Registered Extension Number**

155

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[Vulkan Version 1.1](versions.html#versions-1.1)

**SPIR-V Dependencies**

* 
[SPV_NV_shader_sm_builtins](https://github.khronos.org/SPIRV-Registry/extensions/NV/SPV_NV_shader_sm_builtins.html)

**Contact**

* 
Daniel Koch [dgkoch](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NV_shader_sm_builtins] @dgkoch%0A*Here describe the issue or question you have about the VK_NV_shader_sm_builtins extension*)

**Last Modified Date**

2019-05-28

**Interactions and External Dependencies**

* 
This extension provides API support for
[`GL_NV_shader_sm_builtins`](https://github.com/KhronosGroup/GLSL/blob/main/extensions/nv/GLSL_NV_shader_sm_builtins.txt)

**Contributors**

* 
Jeff Bolz, NVIDIA

* 
Eric Werness, NVIDIA

This extension provides the ability to determine device-specific properties
on NVIDIA GPUs.
It provides the number of streaming multiprocessors (SMs), the maximum
number of warps (subgroups) that can run on an SM, and shader builtins to
enable invocations to identify which SM and warp a shader invocation is
executing on.

This extension enables support for the SPIR-V `ShaderSMBuiltinsNV`
capability.

These properties and built-ins **should** typically only be used for debugging
purposes.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceShaderSMBuiltinsFeaturesNV](../chapters/features.html#VkPhysicalDeviceShaderSMBuiltinsFeaturesNV)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceShaderSMBuiltinsPropertiesNV](../chapters/limits.html#VkPhysicalDeviceShaderSMBuiltinsPropertiesNV)

* 
`VK_NV_SHADER_SM_BUILTINS_EXTENSION_NAME`

* 
`VK_NV_SHADER_SM_BUILTINS_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV`

* 
[`WarpsPerSMNV`](../chapters/interfaces.html#interfaces-builtin-variables-warpspersmnv)

* 
[`SMCountNV`](../chapters/interfaces.html#interfaces-builtin-variables-smcountnv)

* 
[`WarpIDNV`](../chapters/interfaces.html#interfaces-builtin-variables-warpidnv)

* 
[`SMIDNV`](../chapters/interfaces.html#interfaces-builtin-variables-smidnv)

* 
[    `ShaderSMBuiltinsNV`](spirvenv.html#spirvenv-capabilities-table-ShaderSMBuiltinsNV)

What should we call this extension?

**RESOLVED**: `NV_shader_sm_builtins`.
Other options considered included:

* 
`NV_shader_smid` - but SMID is really easy to typo/confuse as SIMD.

* 
`NV_shader_sm_info` - but **Info** is typically reserved for input
structures

* 
Revision 1, 2019-05-28 (Daniel Koch)

Internal revisions

**Name String**

`VK_NV_shader_subgroup_partitioned`

**Extension Type**

Device extension

**Registered Extension Number**

199

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[Vulkan Version 1.1](versions.html#versions-1.1)

**SPIR-V Dependencies**

* 
[SPV_NV_shader_subgroup_partitioned](https://github.khronos.org/SPIRV-Registry/extensions/NV/SPV_NV_shader_subgroup_partitioned.html)

**Contact**

* 
Jeff Bolz [jeffbolznv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NV_shader_subgroup_partitioned] @jeffbolznv%0A*Here describe the issue or question you have about the VK_NV_shader_subgroup_partitioned extension*)

**Last Modified Date**

2018-03-17

**Interactions and External Dependencies**

* 
This extension provides API support for
[`GL_NV_shader_subgroup_partitioned`](https://github.com/KhronosGroup/GLSL/blob/main/extensions/nv/GL_NV_shader_subgroup_partitioned.txt)

**Contributors**

* 
Jeff Bolz, NVIDIA

This extension enables support for a new class of
[group operations](../chapters/shaders.html#shaders-group-operations) on [subgroups](../chapters/shaders.html#shaders-scope-subgroup) via the
[`GL_NV_shader_subgroup_partitioned`](https://github.com/KhronosGroup/GLSL/blob/main/extensions/nv/GL_NV_shader_subgroup_partitioned.txt)
GLSL extension and
[`SPV_NV_shader_subgroup_partitioned`](https://github.khronos.org/SPIRV-Registry/extensions/NV/SPV_NV_shader_subgroup_partitioned.html)
SPIR-V extension.
Support for these new operations is advertised via the
`VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV` bit.

This extension requires Vulkan 1.1, for general subgroup support.

* 
`VK_NV_SHADER_SUBGROUP_PARTITIONED_EXTENSION_NAME`

* 
`VK_NV_SHADER_SUBGROUP_PARTITIONED_SPEC_VERSION`

* 
Extending [VkSubgroupFeatureFlagBits](../chapters/limits.html#VkSubgroupFeatureFlagBits):

`VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV`

* 
Revision 1, 2018-03-17 (Jeff Bolz)

Internal revisions

**Name String**

`VK_NV_shading_rate_image`

**Extension Type**

Device extension

**Registered Extension Number**

165

**Revision**

3

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**SPIR-V Dependencies**

* 
[SPV_NV_shading_rate](https://github.khronos.org/SPIRV-Registry/extensions/NV/SPV_NV_shading_rate.html)

**Contact**

* 
Pat Brown [nvpbrown](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NV_shading_rate_image] @nvpbrown%0A*Here describe the issue or question you have about the VK_NV_shading_rate_image extension*)

**Last Modified Date**

2019-07-18

**Interactions and External Dependencies**

* 
This extension provides API support for
[`GL_NV_shading_rate_image`](https://github.com/KhronosGroup/GLSL/blob/main/extensions/nv/GLSL_NV_shading_rate_image.txt)

**Contributors**

* 
Pat Brown, NVIDIA

* 
Carsten Rohde, NVIDIA

* 
Jeff Bolz, NVIDIA

* 
Daniel Koch, NVIDIA

* 
Mathias Schott, NVIDIA

* 
Matthew Netsch, Qualcomm Technologies, Inc.

This extension allows applications to use a variable shading rate when
processing fragments of rasterized primitives.
By default, Vulkan will spawn one fragment shader for each pixel covered by
a primitive.
In this extension, applications can bind a *shading rate image* that can be
used to vary the number of fragment shader invocations across the
framebuffer.
Some portions of the screen may be configured to spawn up to 16 fragment
shaders for each pixel, while other portions may use a single fragment
shader invocation for a 4x4 block of pixels.
This can be useful for use cases like eye tracking, where the portion of the
framebuffer that the user is looking at directly can be processed at high
frequency, while distant corners of the image can be processed at lower
frequency.
Each texel in the shading rate image represents a fixed-size rectangle in
the framebuffer, covering 16x16 pixels in the initial implementation of this
extension.
When rasterizing a primitive covering one of these rectangles, the Vulkan
implementation reads a texel in the bound shading rate image and looks up
the fetched value in a palette to determine a base shading rate.

In addition to the API support controlling rasterization, this extension
also adds Vulkan support for the
[`SPV_NV_shading_rate`](https://github.khronos.org/SPIRV-Registry/extensions/NV/SPV_NV_shading_rate.html) extension to
SPIR-V.
That extension provides two fragment shader variable decorations that allow
fragment shaders to determine the shading rate used for processing the
fragment:

* 
`FragmentSizeNV`, which indicates the width and height of the set of
pixels processed by the fragment shader.

* 
`InvocationsPerPixel`, which indicates the maximum number of fragment
shader invocations that could be spawned for the pixel(s) covered by the
fragment.

When using SPIR-V in conjunction with the OpenGL Shading Language (GLSL),
the fragment shader capabilities are provided by the
`GL_NV_shading_rate_image` language extension and correspond to the built-in
variables `gl_FragmentSizeNV` and `gl_InvocationsPerPixelNV`,
respectively.

* 
[vkCmdBindShadingRateImageNV](../chapters/primsrast.html#vkCmdBindShadingRateImageNV)

* 
[vkCmdSetCoarseSampleOrderNV](../chapters/primsrast.html#vkCmdSetCoarseSampleOrderNV)

* 
[vkCmdSetViewportShadingRatePaletteNV](../chapters/primsrast.html#vkCmdSetViewportShadingRatePaletteNV)

* 
[VkCoarseSampleLocationNV](../chapters/primsrast.html#VkCoarseSampleLocationNV)

* 
[VkCoarseSampleOrderCustomNV](../chapters/primsrast.html#VkCoarseSampleOrderCustomNV)

* 
[VkShadingRatePaletteNV](../chapters/primsrast.html#VkShadingRatePaletteNV)

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceShadingRateImageFeaturesNV](../chapters/features.html#VkPhysicalDeviceShadingRateImageFeaturesNV)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceShadingRateImagePropertiesNV](../chapters/limits.html#VkPhysicalDeviceShadingRateImagePropertiesNV)

Extending [VkPipelineViewportStateCreateInfo](../chapters/vertexpostproc.html#VkPipelineViewportStateCreateInfo):

* 
[VkPipelineViewportCoarseSampleOrderStateCreateInfoNV](../chapters/primsrast.html#VkPipelineViewportCoarseSampleOrderStateCreateInfoNV)

* 
[VkPipelineViewportShadingRateImageStateCreateInfoNV](../chapters/primsrast.html#VkPipelineViewportShadingRateImageStateCreateInfoNV)

* 
[VkCoarseSampleOrderTypeNV](../chapters/primsrast.html#VkCoarseSampleOrderTypeNV)

* 
[VkShadingRatePaletteEntryNV](../chapters/primsrast.html#VkShadingRatePaletteEntryNV)

* 
`VK_NV_SHADING_RATE_IMAGE_EXTENSION_NAME`

* 
`VK_NV_SHADING_RATE_IMAGE_SPEC_VERSION`

* 
Extending [VkAccessFlagBits](../chapters/synchronization.html#VkAccessFlagBits):

`VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV`

Extending [VkDynamicState](../chapters/pipelines.html#VkDynamicState):

* 
`VK_DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV`

* 
`VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV`

Extending [VkImageLayout](../chapters/resources.html#VkImageLayout):

* 
`VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV`

Extending [VkImageUsageFlagBits](../chapters/resources.html#VkImageUsageFlagBits):

* 
`VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV`

Extending [VkPipelineStageFlagBits](../chapters/synchronization.html#VkPipelineStageFlagBits):

* 
`VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV`

* 
`VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV`

* 
`VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV`

(1) When using shading rates specifying coarse fragments covering
    multiple pixels, we will generate a combined coverage mask that combines
    the coverage masks of all pixels covered by the fragment.
    By default, these masks are combined in an implementation-dependent
    order.
    Should we provide a mechanism allowing applications to query or specify
    an exact order?

**RESOLVED**: Yes, this feature is useful for cases where most of the fragment
shader can be evaluated once for an entire coarse fragment, but where some
per-pixel computations are also required.
For example, a per-pixel alpha test may want to kill all the samples for
some pixels in a coarse fragment.
This sort of test can be implemented using an output sample mask, but such a
shader would need to know which bit in the mask corresponds to each sample
in the coarse fragment.
We are including a mechanism to allow applications to specify the orders of
coverage samples for each shading rate and sample count, either as static
pipeline state or dynamically via a command buffer.
This portion of the extension has its own feature bit.

We will not be providing a query to determine the implementation-dependent
default ordering.
The thinking here is that if an application cares enough about the coarse
fragment sample ordering to perform such a query, it could instead just set
its own order, also using custom per-pixel sample locations if required.

(2) For the pipeline stage
`VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV`, should we specify a
precise location in the pipeline the shading rate image is accessed (after
geometry shading, but before the early fragment tests) or leave it
under-specified in case there are other implementations that access the
image in a different pipeline location?

**RESOLVED** We are specifying the pipeline stage to be between the final
[pre-rasterization shader stage](../chapters/pipelines.html#pipelines-graphics-subsets-pre-rasterization) (`VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT`) and before the first
stage used for fragment processing
(`VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT`), which seems to be the
natural place to access the shading rate image.

(3) How do centroid-sampled variables work with fragments larger than one
pixel?

**RESOLVED** For single-pixel fragments, fragment shader inputs decorated with
`Centroid` are sampled at an implementation-dependent location in the
intersection of the area of the primitive being rasterized and the area of
the pixel that corresponds to the fragment.
With multi-pixel fragments, we follow a similar pattern, using the
intersection of the primitive and the **set** of pixels corresponding to the
fragment.

One important thing to keep in mind when using such coarse shading rates
is that fragment attributes are sampled at the center of the fragment by
default, regardless of the set of pixels/samples covered by the fragment.
For fragments with a size of 4x4 pixels, this center location will be more
than two pixels (1.5 * sqrt(2)) away from the center of the pixels at the
corners of the fragment.
When rendering a primitive that covers only a small part of a coarse
fragment, sampling a color outside the primitive can produce overly bright
or dark color values if the color values have a large gradient.
To deal with this, an application can use centroid sampling on attributes
where extrapolation artifacts can lead to overly bright or dark pixels.
Note that this same problem also exists for multisampling with single-pixel
fragments, but is less severe because it only affects certain samples of a
pixel and such bright/dark samples may be averaged with other samples that
do not have a similar problem.

* 
Revision 3, 2019-07-18 (Mathias Schott)

Fully list extension interfaces in this appendix.

Revision 2, 2018-09-13 (Pat Brown)

* 
Miscellaneous edits preparing the specification for publication.

Revision 1, 2018-08-08 (Pat Brown)

* 
Internal revisions

**Name String**

`VK_NV_viewport_array2`

**Extension Type**

Device extension

**Registered Extension Number**

97

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

None

**SPIR-V Dependencies**

* 
[SPV_NV_viewport_array2](https://github.khronos.org/SPIRV-Registry/extensions/NV/SPV_NV_viewport_array2.html)

**Contact**

* 
Daniel Koch [dgkoch](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NV_viewport_array2] @dgkoch%0A*Here describe the issue or question you have about the VK_NV_viewport_array2 extension*)

**Last Modified Date**

2017-02-15

**Interactions and External Dependencies**

* 
This extension provides API support for
[`GL_NV_viewport_array2`](https://registry.khronos.org/OpenGL/extensions/NV/NV_viewport_array2.txt)

* 
This extension requires the [    `geometryShader`](../chapters/features.html#features-geometryShader) and [    `multiViewport`](../chapters/features.html#features-multiViewport) features.

* 
This extension interacts with the [    `tessellationShader`](../chapters/features.html#features-tessellationShader) feature.

**Contributors**

* 
Piers Daniell, NVIDIA

* 
Jeff Bolz, NVIDIA

This extension adds support for the following SPIR-V extension in Vulkan:

* 
`SPV_NV_viewport_array2`

which allows a single primitive to be broadcast to multiple viewports and/or
multiple layers.
A new shader built-in output `ViewportMaskNV` is provided, which allows a
single primitive to be output to multiple viewports simultaneously.
Also, a new SPIR-V decoration is added to control whether the effective
viewport index is added into the variable decorated with the `Layer`
built-in decoration.
These capabilities allow a single primitive to be output to multiple layers
simultaneously.

This extension allows variables decorated with the `Layer` and
`ViewportIndex` built-ins to be exported from vertex or tessellation
shaders, using the `ShaderViewportIndexLayerNV` capability.

This extension adds a new `ViewportMaskNV` built-in decoration that is
available for output variables in vertex, tessellation evaluation, and
geometry shaders, and a new `ViewportRelativeNV` decoration that can be
added on variables decorated with `Layer` when using the
`ShaderViewportMaskNV` capability.

When using GLSL source-based shading languages, the `gl_ViewportMask`[]
built-in output variable and `viewport_relative` layout qualifier from
`GL_NV_viewport_array2` map to the `ViewportMaskNV` and
`ViewportRelativeNV` decorations, respectively.
Behavior is described in the `GL_NV_viewport_array2` extension
specification.

|  | The `ShaderViewportIndexLayerNV` capability is equivalent to the
| --- | --- |
`ShaderViewportIndexLayerEXT` capability added by
`[VK_EXT_shader_viewport_index_layer](#VK_EXT_shader_viewport_index_layer)`. |

* 
`VK_NV_VIEWPORT_ARRAY2_EXTENSION_NAME`

* 
`VK_NV_VIEWPORT_ARRAY2_SPEC_VERSION`

* 
`VK_NV_VIEWPORT_ARRAY_2_EXTENSION_NAME`

* 
`VK_NV_VIEWPORT_ARRAY_2_SPEC_VERSION`

* 
(modified) [`Layer`](../chapters/interfaces.html#interfaces-builtin-variables-layer)

* 
(modified)
[`ViewportIndex`](../chapters/interfaces.html#interfaces-builtin-variables-viewportindex)

* 
[`ViewportMaskNV`](../chapters/interfaces.html#interfaces-builtin-variables-viewportmask)

* 
[`ViewportRelativeNV` in    `Layer`](../chapters/interfaces.html#interfaces-builtin-variables-layer)

* 
[    `ShaderViewportIndexLayerNV`](spirvenv.html#spirvenv-capabilities-table-ShaderViewportIndexLayerEXT)

* 
[    `ShaderViewportMaskNV`](spirvenv.html#spirvenv-capabilities-table-ShaderViewportMaskNV)

* 
Revision 1, 2017-02-15 (Daniel Koch)

Internal revisions

**Name String**

`VK_NV_viewport_swizzle`

**Extension Type**

Device extension

**Registered Extension Number**

99

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

None

**Contact**

* 
Piers Daniell [pdaniell-nv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NV_viewport_swizzle] @pdaniell-nv%0A*Here describe the issue or question you have about the VK_NV_viewport_swizzle extension*)

**Last Modified Date**

2016-12-22

**Interactions and External Dependencies**

* 
This extension requires `multiViewport` and `geometryShader`
features to be useful.

**Contributors**

* 
Daniel Koch, NVIDIA

* 
Jeff Bolz, NVIDIA

This extension provides a new per-viewport swizzle that can modify the
position of primitives sent to each viewport.
New viewport swizzle state is added for each viewport, and a new position
vector is computed for each vertex by selecting from and optionally negating
any of the four components of the original position vector.

This new viewport swizzle is useful for a number of algorithms, including
single-pass cube map rendering (broadcasting a primitive to multiple faces
and reorienting the vertex position for each face) and voxel rasterization.
The per-viewport component remapping and negation provided by the swizzle
allows application code to re-orient three-dimensional geometry with a view
along any of the **X**, **Y**, or **Z** axes.
If a perspective projection and depth buffering is required, 1/W
buffering should be used, as described in the single-pass cube map rendering
example in the Issues section below.

* 
[VkViewportSwizzleNV](../chapters/vertexpostproc.html#VkViewportSwizzleNV)

* 
Extending [VkPipelineViewportStateCreateInfo](../chapters/vertexpostproc.html#VkPipelineViewportStateCreateInfo):

[VkPipelineViewportSwizzleStateCreateInfoNV](../chapters/vertexpostproc.html#VkPipelineViewportSwizzleStateCreateInfoNV)

* 
[VkViewportCoordinateSwizzleNV](../chapters/vertexpostproc.html#VkViewportCoordinateSwizzleNV)

* 
[VkPipelineViewportSwizzleStateCreateFlagsNV](../chapters/vertexpostproc.html#VkPipelineViewportSwizzleStateCreateFlagsNV)

* 
`VK_NV_VIEWPORT_SWIZZLE_EXTENSION_NAME`

* 
`VK_NV_VIEWPORT_SWIZZLE_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV`

1) Where does viewport swizzling occur in the pipeline?

**RESOLVED**: Despite being associated with the viewport, viewport swizzling
must happen prior to the viewport transform.
In particular, it needs to be performed before clipping and perspective
division.

The viewport mask expansion (`[VK_NV_viewport_array2](#VK_NV_viewport_array2)`) and the
viewport swizzle could potentially be performed before or after transform
feedback, but feeding back several viewports worth of primitives with
different swizzles does not seem particularly useful.
This specification applies the viewport mask and swizzle after transform
feedback, and makes primitive queries only count each primitive once.

2) Any interesting examples of how this extension,
`[VK_NV_viewport_array2](#VK_NV_viewport_array2)`, and
`[VK_NV_geometry_shader_passthrough](#VK_NV_geometry_shader_passthrough)` can be used together in practice?

**RESOLVED**: One interesting use case for this extension is for single-pass
rendering to a cube map.
In this example, the application would attach a cube map texture to a
layered FBO where the six cube faces are treated as layers.
Vertices are sent through the vertex shader without applying a projection
matrix, where the `gl_Position` output is (x,y,z,1) and the center
of the cube map is at (0,0,0).
With unextended Vulkan, one could have a conventional instanced geometry
shader that looks something like the following:

layout(invocations = 6) in;     // separate invocation per face
layout(triangles) in;
layout(triangle_strip) out;
layout(max_vertices = 3) out;

in Inputs {
vec2 texcoord;
vec3 normal;
vec4 baseColor;
} v[];

    out Outputs {
    vec2 texcoord;
    vec3 normal;
    vec4 baseColor;
    };

    void main()
    {
    int face = gl_InvocationID;  // which face am I?

    // Project gl_Position for each vertex onto the cube map face.
    vec4 positions[3];
    for (int i = 0; i 

With passthrough geometry shaders, this can be done using a much simpler
shader:

layout(triangles) in;
layout(passthrough) in Inputs {
    vec2 texcoord;
    vec3 normal;
    vec4 baseColor;
}
layout(passthrough) in gl_PerVertex {
    vec4 gl_Position;
} gl_in[];
layout(viewport_relative) out int gl_Layer;

void main()
{
    // Figure out which faces the primitive projects onto and
    // generate a corresponding viewport mask.
    uint mask = 0;
    for (int i = 0; i 

The application code is set up so that each of the six cube faces has a
separate viewport (numbered 0 to 5).
Each face also has a separate swizzle, programmed via the
[VkPipelineViewportSwizzleStateCreateInfoNV](../chapters/vertexpostproc.html#VkPipelineViewportSwizzleStateCreateInfoNV) pipeline state.
The viewport swizzle feature performs the coordinate transformation handled
by the `rotate`() function in the original shader.
The `viewport_relative` layout qualifier says that the viewport number (0
to 5) is added to the base `gl_Layer` value of 0 to determine which layer
(cube face) the primitive should be sent to.

Note that the use of the passed through input `normal` in this example
suggests that the fragment shader in this example would perform an operation
like per-fragment lighting.
The viewport swizzle would transform the position to be face-relative, but
`normal` would remain in the original coordinate system.
It seems likely that the fragment shader in either version of the example
would want to perform lighting in the original coordinate system.
It would likely do this by reconstructing the position of the fragment in
the original coordinate system using `gl_FragCoord`, a constant or
uniform holding the size of the cube face, and the input
`gl_ViewportIndex` (or `gl_Layer`), which identifies the cube face.
Since the value of `normal` is in the original coordinate system, it
would not need to be modified as part of this coordinate transformation.

Note that while the `rotate`() operation in the regular geometry shader
above could include an arbitrary post-rotation projection matrix, the
viewport swizzle does not support arbitrary math.
To get proper projection, 1/W buffering should be used.
To do this:

Program the viewport swizzles to move the pre-projection W eye
coordinate (typically 1.0) into the Z coordinate of the swizzle
output and the eye coordinate component used for depth into the W
coordinate.
For example, the viewport corresponding to the +Z face might use a
swizzle of (+X, -Y, +W, +Z).
The Z normalized device coordinate computed after swizzling would
then be z'/w' = 1/Zeye.

On NVIDIA implementations supporting floating-point depth buffers with
values outside [0,1], prevent unwanted near plane clipping by
enabling `depthClampEnable`.
Ensure that the depth clamp does not mess up depth testing by
programming the depth range to very large values, such as
`minDepthBounds`=-z, `maxDepthBounds`=+z, where
z = 2127.
It should be possible to use IEEE infinity encodings also (`0xFF800000`
for `-INF`, `0x7F800000` for `+INF`).
Even when near/far clipping is disabled, primitives extending behind the
eye will still be clipped because one or more vertices will have a
negative W coordinate and fail X/Y clipping tests.

On other implementations, scale X, Y, and Z eye
coordinates so that vertices on the near plane have a post-swizzle W
coordinate of 1.0.
For example, if the near plane is at Zeye = 1/256, scale X,
Y, and Z by 256.

Adjust depth testing to reflect the fact that 1/W values are large
near the eye and small away from the eye.
Clear the depth buffer to zero (infinitely far away) and use a depth
test of `VK_COMPARE_OP_GREATER` instead of `VK_COMPARE_OP_LESS`.

* 
Revision 1, 2016-12-22 (Piers Daniell)

Internal revisions

**Name String**

`VK_NVX_binary_import`

**Extension Type**

Device extension

**Registered Extension Number**

30

**Revision**

2

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

None

**API Interactions**

* 
Interacts with VK_EXT_debug_report

**Contact**

* 
Eric Werness [ewerness-nv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NVX_binary_import] @ewerness-nv%0A*Here describe the issue or question you have about the VK_NVX_binary_import extension*)

* 
Liam Middlebrook [liam-middlebrook](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NVX_binary_import] @liam-middlebrook%0A*Here describe the issue or question you have about the VK_NVX_binary_import extension*)

**Last Modified Date**

2024-11-04

**Contributors**

* 
Eric Werness, NVIDIA

* 
Liam Middlebrook, NVIDIA

This extension allows applications to import CuBIN binaries and execute
them.

|  | There is currently no specification language written for this extension.
| --- | --- |
The links to APIs defined by the extension are to stubs that only include
generated content such as API declarations and implicit valid usage
statements. |

* 
[VkCuFunctionNVX](#VkCuFunctionNVX)

* 
[VkCuModuleNVX](#VkCuModuleNVX)

* 
[vkCmdCuLaunchKernelNVX](#vkCmdCuLaunchKernelNVX)

* 
[vkCreateCuFunctionNVX](#vkCreateCuFunctionNVX)

* 
[vkCreateCuModuleNVX](#vkCreateCuModuleNVX)

* 
[vkDestroyCuFunctionNVX](#vkDestroyCuFunctionNVX)

* 
[vkDestroyCuModuleNVX](#vkDestroyCuModuleNVX)

* 
[VkCuFunctionCreateInfoNVX](#VkCuFunctionCreateInfoNVX)

* 
[VkCuLaunchInfoNVX](#VkCuLaunchInfoNVX)

* 
[VkCuModuleCreateInfoNVX](#VkCuModuleCreateInfoNVX)

* 
Extending [VkCuModuleCreateInfoNVX](#VkCuModuleCreateInfoNVX):

[VkCuModuleTexturingModeCreateInfoNVX](#VkCuModuleTexturingModeCreateInfoNVX)

* 
`VK_NVX_BINARY_IMPORT_EXTENSION_NAME`

* 
`VK_NVX_BINARY_IMPORT_SPEC_VERSION`

* 
Extending [VkObjectType](../chapters/debugging.html#VkObjectType):

`VK_OBJECT_TYPE_CU_FUNCTION_NVX`

* 
`VK_OBJECT_TYPE_CU_MODULE_NVX`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX`

* 
`VK_STRUCTURE_TYPE_CU_LAUNCH_INFO_NVX`

* 
`VK_STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX`

* 
`VK_STRUCTURE_TYPE_CU_MODULE_TEXTURING_MODE_CREATE_INFO_NVX`

If [VK_EXT_debug_report](#VK_EXT_debug_report) is supported:

* 
Extending [VkDebugReportObjectTypeEXT](../chapters/debugging.html#VkDebugReportObjectTypeEXT):

`VK_DEBUG_REPORT_OBJECT_TYPE_CU_FUNCTION_NVX_EXT`

* 
`VK_DEBUG_REPORT_OBJECT_TYPE_CU_MODULE_NVX_EXT`

There is currently no specification language written for this type.
This section acts only as placeholder and to avoid dead links in the
specification and reference pages.

// Provided by VK_NVX_binary_import
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkCuFunctionNVX)

There is currently no specification language written for this type.
This section acts only as placeholder and to avoid dead links in the
specification and reference pages.

// Provided by VK_NVX_binary_import
VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkCuModuleNVX)

There is currently no specification language written for this command.
This section acts only as placeholder and to avoid dead links in the
specification and reference pages.

// Provided by VK_NVX_binary_import
VkResult vkCreateCuFunctionNVX(
    VkDevice                                    device,
    const VkCuFunctionCreateInfoNVX*            pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkCuFunctionNVX*                            pFunction);

Valid Usage (Implicit)

* 
[](#VUID-vkCreateCuFunctionNVX-device-parameter) VUID-vkCreateCuFunctionNVX-device-parameter

 `device` **must** be a valid [VkDevice](../chapters/devsandqueues.html#VkDevice) handle

* 
[](#VUID-vkCreateCuFunctionNVX-pCreateInfo-parameter) VUID-vkCreateCuFunctionNVX-pCreateInfo-parameter

 `pCreateInfo` **must** be a valid pointer to a valid [VkCuFunctionCreateInfoNVX](#VkCuFunctionCreateInfoNVX) structure

* 
[](#VUID-vkCreateCuFunctionNVX-pAllocator-parameter) VUID-vkCreateCuFunctionNVX-pAllocator-parameter

 If `pAllocator` is not `NULL`, `pAllocator` **must** be a valid pointer to a valid [VkAllocationCallbacks](../chapters/memory.html#VkAllocationCallbacks) structure

* 
[](#VUID-vkCreateCuFunctionNVX-pFunction-parameter) VUID-vkCreateCuFunctionNVX-pFunction-parameter

 `pFunction` **must** be a valid pointer to a [VkCuFunctionNVX](#VkCuFunctionNVX) handle

Return Codes

[Success](../chapters/fundamentals.html#fundamentals-successcodes)

* 
`VK_SUCCESS`

[Failure](../chapters/fundamentals.html#fundamentals-errorcodes)

* 
`VK_ERROR_OUT_OF_HOST_MEMORY`

* 
`VK_ERROR_INITIALIZATION_FAILED`

There is currently no specification language written for this type.
This section acts only as placeholder and to avoid dead links in the
specification and reference pages.

// Provided by VK_NVX_binary_import
typedef struct VkCuFunctionCreateInfoNVX {
    VkStructureType    sType;
    const void*        pNext;
    VkCuModuleNVX      module;
    const char*        pName;
} VkCuFunctionCreateInfoNVX;

Valid Usage (Implicit)

* 
[](#VUID-VkCuFunctionCreateInfoNVX-sType-sType) VUID-VkCuFunctionCreateInfoNVX-sType-sType

 `sType` **must** be `VK_STRUCTURE_TYPE_CU_FUNCTION_CREATE_INFO_NVX`

* 
[](#VUID-VkCuFunctionCreateInfoNVX-pNext-pNext) VUID-VkCuFunctionCreateInfoNVX-pNext-pNext

 `pNext` **must** be `NULL`

* 
[](#VUID-VkCuFunctionCreateInfoNVX-module-parameter) VUID-VkCuFunctionCreateInfoNVX-module-parameter

 `module` **must** be a valid [VkCuModuleNVX](#VkCuModuleNVX) handle

* 
[](#VUID-VkCuFunctionCreateInfoNVX-pName-parameter) VUID-VkCuFunctionCreateInfoNVX-pName-parameter

 `pName` **must** be a null-terminated UTF-8 string

There is currently no specification language written for this command.
This section acts only as placeholder and to avoid dead links in the
specification and reference pages.

// Provided by VK_NVX_binary_import
void vkDestroyCuFunctionNVX(
    VkDevice                                    device,
    VkCuFunctionNVX                             function,
    const VkAllocationCallbacks*                pAllocator);

Valid Usage (Implicit)

* 
[](#VUID-vkDestroyCuFunctionNVX-device-parameter) VUID-vkDestroyCuFunctionNVX-device-parameter

 `device` **must** be a valid [VkDevice](../chapters/devsandqueues.html#VkDevice) handle

* 
[](#VUID-vkDestroyCuFunctionNVX-function-parameter) VUID-vkDestroyCuFunctionNVX-function-parameter

 `function` **must** be a valid [VkCuFunctionNVX](#VkCuFunctionNVX) handle

* 
[](#VUID-vkDestroyCuFunctionNVX-pAllocator-parameter) VUID-vkDestroyCuFunctionNVX-pAllocator-parameter

 If `pAllocator` is not `NULL`, `pAllocator` **must** be a valid pointer to a valid [VkAllocationCallbacks](../chapters/memory.html#VkAllocationCallbacks) structure

* 
[](#VUID-vkDestroyCuFunctionNVX-function-parent) VUID-vkDestroyCuFunctionNVX-function-parent

 `function` **must** have been created, allocated, or retrieved from `device`

There is currently no specification language written for this command.
This section acts only as placeholder and to avoid dead links in the
specification and reference pages.

// Provided by VK_NVX_binary_import
VkResult vkCreateCuModuleNVX(
    VkDevice                                    device,
    const VkCuModuleCreateInfoNVX*              pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkCuModuleNVX*                              pModule);

Valid Usage (Implicit)

* 
[](#VUID-vkCreateCuModuleNVX-device-parameter) VUID-vkCreateCuModuleNVX-device-parameter

 `device` **must** be a valid [VkDevice](../chapters/devsandqueues.html#VkDevice) handle

* 
[](#VUID-vkCreateCuModuleNVX-pCreateInfo-parameter) VUID-vkCreateCuModuleNVX-pCreateInfo-parameter

 `pCreateInfo` **must** be a valid pointer to a valid [VkCuModuleCreateInfoNVX](#VkCuModuleCreateInfoNVX) structure

* 
[](#VUID-vkCreateCuModuleNVX-pAllocator-parameter) VUID-vkCreateCuModuleNVX-pAllocator-parameter

 If `pAllocator` is not `NULL`, `pAllocator` **must** be a valid pointer to a valid [VkAllocationCallbacks](../chapters/memory.html#VkAllocationCallbacks) structure

* 
[](#VUID-vkCreateCuModuleNVX-pModule-parameter) VUID-vkCreateCuModuleNVX-pModule-parameter

 `pModule` **must** be a valid pointer to a [VkCuModuleNVX](#VkCuModuleNVX) handle

Return Codes

[Success](../chapters/fundamentals.html#fundamentals-successcodes)

* 
`VK_SUCCESS`

[Failure](../chapters/fundamentals.html#fundamentals-errorcodes)

* 
`VK_ERROR_OUT_OF_HOST_MEMORY`

* 
`VK_ERROR_INITIALIZATION_FAILED`

There is currently no specification language written for this type.
This section acts only as placeholder and to avoid dead links in the
specification and reference pages.

// Provided by VK_NVX_binary_import
typedef struct VkCuModuleCreateInfoNVX {
    VkStructureType    sType;
    const void*        pNext;
    size_t             dataSize;
    const void*        pData;
} VkCuModuleCreateInfoNVX;

Valid Usage (Implicit)

* 
[](#VUID-VkCuModuleCreateInfoNVX-sType-sType) VUID-VkCuModuleCreateInfoNVX-sType-sType

 `sType` **must** be `VK_STRUCTURE_TYPE_CU_MODULE_CREATE_INFO_NVX`

* 
[](#VUID-VkCuModuleCreateInfoNVX-pNext-pNext) VUID-VkCuModuleCreateInfoNVX-pNext-pNext

 `pNext` **must** be `NULL` or a pointer to a valid instance of [VkCuModuleTexturingModeCreateInfoNVX](#VkCuModuleTexturingModeCreateInfoNVX)

* 
[](#VUID-VkCuModuleCreateInfoNVX-sType-unique) VUID-VkCuModuleCreateInfoNVX-sType-unique

 The `sType` value of each structure in the `pNext` chain **must** be unique

* 
[](#VUID-VkCuModuleCreateInfoNVX-pData-parameter) VUID-VkCuModuleCreateInfoNVX-pData-parameter

 If `dataSize` is not `0`, `pData` **must** be a valid pointer to an array of `dataSize` bytes

There is currently no specification language written for this type.
This section acts only as placeholder and to avoid dead links in the
specification and reference pages.

// Provided by VK_NVX_binary_import
typedef struct VkCuModuleTexturingModeCreateInfoNVX {
    VkStructureType    sType;
    const void*        pNext;
    VkBool32           use64bitTexturing;
} VkCuModuleTexturingModeCreateInfoNVX;

Valid Usage (Implicit)

* 
[](#VUID-VkCuModuleTexturingModeCreateInfoNVX-sType-sType) VUID-VkCuModuleTexturingModeCreateInfoNVX-sType-sType

 `sType` **must** be `VK_STRUCTURE_TYPE_CU_MODULE_TEXTURING_MODE_CREATE_INFO_NVX`

There is currently no specification language written for this command.
This section acts only as placeholder and to avoid dead links in the
specification and reference pages.

// Provided by VK_NVX_binary_import
void vkDestroyCuModuleNVX(
    VkDevice                                    device,
    VkCuModuleNVX                               module,
    const VkAllocationCallbacks*                pAllocator);

Valid Usage (Implicit)

* 
[](#VUID-vkDestroyCuModuleNVX-device-parameter) VUID-vkDestroyCuModuleNVX-device-parameter

 `device` **must** be a valid [VkDevice](../chapters/devsandqueues.html#VkDevice) handle

* 
[](#VUID-vkDestroyCuModuleNVX-module-parameter) VUID-vkDestroyCuModuleNVX-module-parameter

 `module` **must** be a valid [VkCuModuleNVX](#VkCuModuleNVX) handle

* 
[](#VUID-vkDestroyCuModuleNVX-pAllocator-parameter) VUID-vkDestroyCuModuleNVX-pAllocator-parameter

 If `pAllocator` is not `NULL`, `pAllocator` **must** be a valid pointer to a valid [VkAllocationCallbacks](../chapters/memory.html#VkAllocationCallbacks) structure

* 
[](#VUID-vkDestroyCuModuleNVX-module-parent) VUID-vkDestroyCuModuleNVX-module-parent

 `module` **must** have been created, allocated, or retrieved from `device`

There is currently no specification language written for this command.
This section acts only as placeholder and to avoid dead links in the
specification and reference pages.

// Provided by VK_NVX_binary_import
void vkCmdCuLaunchKernelNVX(
    VkCommandBuffer                             commandBuffer,
    const VkCuLaunchInfoNVX*                    pLaunchInfo);

Valid Usage (Implicit)

* 
[](#VUID-vkCmdCuLaunchKernelNVX-commandBuffer-parameter) VUID-vkCmdCuLaunchKernelNVX-commandBuffer-parameter

 `commandBuffer` **must** be a valid [VkCommandBuffer](../chapters/cmdbuffers.html#VkCommandBuffer) handle

* 
[](#VUID-vkCmdCuLaunchKernelNVX-pLaunchInfo-parameter) VUID-vkCmdCuLaunchKernelNVX-pLaunchInfo-parameter

 `pLaunchInfo` **must** be a valid pointer to a valid [VkCuLaunchInfoNVX](#VkCuLaunchInfoNVX) structure

* 
[](#VUID-vkCmdCuLaunchKernelNVX-commandBuffer-recording) VUID-vkCmdCuLaunchKernelNVX-commandBuffer-recording

 `commandBuffer` **must** be in the [recording state](../chapters/cmdbuffers.html#commandbuffers-lifecycle)

* 
[](#VUID-vkCmdCuLaunchKernelNVX-commandBuffer-cmdpool) VUID-vkCmdCuLaunchKernelNVX-commandBuffer-cmdpool

 The `VkCommandPool` that `commandBuffer` was allocated from **must** support graphics, or compute operations

* 
[](#VUID-vkCmdCuLaunchKernelNVX-videocoding) VUID-vkCmdCuLaunchKernelNVX-videocoding

 This command **must** only be called outside of a video coding scope

Host Synchronization

* 
Host access to the `VkCommandPool` that `commandBuffer` was allocated from **must** be externally synchronized

Command Properties
| [Command Buffer Levels](../chapters/cmdbuffers.html#VkCommandBufferLevel) | [Render Pass Scope](../chapters/renderpass.html#vkCmdBeginRenderPass) | [Video Coding Scope](../chapters/videocoding.html#vkCmdBeginVideoCodingKHR) | [Supported Queue Types](../chapters/devsandqueues.html#VkQueueFlagBits) | [Command Type](../chapters/fundamentals.html#fundamentals-queueoperation-command-types) |
| --- | --- | --- | --- | --- |
| Primary

Secondary | Both | Outside | Graphics

Compute | Action |

There is currently no specification language written for this type.
This section acts only as placeholder and to avoid dead links in the
specification and reference pages.

// Provided by VK_NVX_binary_import
typedef struct VkCuLaunchInfoNVX {
    VkStructureType        sType;
    const void*            pNext;
    VkCuFunctionNVX        function;
    uint32_t               gridDimX;
    uint32_t               gridDimY;
    uint32_t               gridDimZ;
    uint32_t               blockDimX;
    uint32_t               blockDimY;
    uint32_t               blockDimZ;
    uint32_t               sharedMemBytes;
    size_t                 paramCount;
    const void* const *    pParams;
    size_t                 extraCount;
    const void* const *    pExtras;
} VkCuLaunchInfoNVX;

Valid Usage (Implicit)

* 
[](#VUID-VkCuLaunchInfoNVX-sType-sType) VUID-VkCuLaunchInfoNVX-sType-sType

 `sType` **must** be `VK_STRUCTURE_TYPE_CU_LAUNCH_INFO_NVX`

* 
[](#VUID-VkCuLaunchInfoNVX-pNext-pNext) VUID-VkCuLaunchInfoNVX-pNext-pNext

 `pNext` **must** be `NULL`

* 
[](#VUID-VkCuLaunchInfoNVX-function-parameter) VUID-VkCuLaunchInfoNVX-function-parameter

 `function` **must** be a valid [VkCuFunctionNVX](#VkCuFunctionNVX) handle

* 
[](#VUID-VkCuLaunchInfoNVX-pParams-parameter) VUID-VkCuLaunchInfoNVX-pParams-parameter

 If `paramCount` is not `0`, `pParams` **must** be a valid pointer to an array of `paramCount` bytes

* 
[](#VUID-VkCuLaunchInfoNVX-pExtras-parameter) VUID-VkCuLaunchInfoNVX-pExtras-parameter

 If `extraCount` is not `0`, `pExtras` **must** be a valid pointer to an array of `extraCount` bytes

* 
Revision 2, 2024-11-04 (Liam Middlebrook)

Add [VkCuModuleTexturingModeCreateInfoNVX](#VkCuModuleTexturingModeCreateInfoNVX)

Revision 1, 2021-04-09 (Eric Werness)

* 
Internal revisions

**Name String**

`VK_NVX_image_view_handle`

**Extension Type**

Device extension

**Registered Extension Number**

31

**Revision**

3

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

None

**Contact**

* 
Eric Werness [ewerness-nv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NVX_image_view_handle] @ewerness-nv%0A*Here describe the issue or question you have about the VK_NVX_image_view_handle extension*)

**Last Modified Date**

2024-11-04

**Contributors**

* 
Eric Werness, NVIDIA

* 
Jeff Bolz, NVIDIA

* 
Daniel Koch, NVIDIA

* 
Liam Middlebrook, NVIDIA

This extension allows applications to query an opaque handle from an image
view for use as a sampled image or storage image.
This provides no direct functionality itself.

* 
[vkGetImageViewAddressNVX](../chapters/resources.html#vkGetImageViewAddressNVX)

* 
[vkGetImageViewHandle64NVX](../chapters/resources.html#vkGetImageViewHandle64NVX)

* 
[vkGetImageViewHandleNVX](../chapters/resources.html#vkGetImageViewHandleNVX)

* 
[VkImageViewAddressPropertiesNVX](../chapters/resources.html#VkImageViewAddressPropertiesNVX)

* 
[VkImageViewHandleInfoNVX](../chapters/resources.html#VkImageViewHandleInfoNVX)

* 
`VK_NVX_IMAGE_VIEW_HANDLE_EXTENSION_NAME`

* 
`VK_NVX_IMAGE_VIEW_HANDLE_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX`

* 
`VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX`

* 
Revision 3, 2024-11-04 (Liam Middlebrook)

Add [vkGetImageViewHandle64NVX](../chapters/resources.html#vkGetImageViewHandle64NVX)

Revision 2, 2020-04-03 (Piers Daniell)

* 
Add [vkGetImageViewAddressNVX](../chapters/resources.html#vkGetImageViewAddressNVX)

Revision 1, 2018-12-07 (Eric Werness)

* 
Internal revisions

**Name String**

`VK_NVX_multiview_per_view_attributes`

**Extension Type**

Device extension

**Registered Extension Number**

98

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_multiview](#VK_KHR_multiview)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**API Interactions**

* 
Interacts with VK_VERSION_1_3

* 
Interacts with VK_KHR_dynamic_rendering

**SPIR-V Dependencies**

* 
[SPV_NVX_multiview_per_view_attributes](https://github.khronos.org/SPIRV-Registry/extensions/NVX/SPV_NVX_multiview_per_view_attributes.html)

**Contact**

* 
Jeff Bolz [jeffbolznv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NVX_multiview_per_view_attributes] @jeffbolznv%0A*Here describe the issue or question you have about the VK_NVX_multiview_per_view_attributes extension*)

**Last Modified Date**

2017-01-13

**IP Status**

No known IP claims.

**Interactions and External Dependencies**

* 
This extension provides API support for
[`GL_NVX_multiview_per_view_attributes`](https://github.com/KhronosGroup/GLSL/blob/main/extensions/nvx/GL_NVX_multiview_per_view_attributes.txt)

* 
This extension interacts with `[VK_NV_viewport_array2](#VK_NV_viewport_array2)`.

**Contributors**

* 
Jeff Bolz, NVIDIA

* 
Daniel Koch, NVIDIA

This extension adds a new way to write shaders to be used with multiview
subpasses, where the attributes for all views are written out by a single
invocation of the
[pre-rasterization shader stages](../chapters/pipelines.html#pipelines-graphics-subsets-pre-rasterization).
Related SPIR-V and GLSL extensions `SPV_NVX_multiview_per_view_attributes`
and `GL_NVX_multiview_per_view_attributes` introduce per-view position and
viewport mask attributes arrays, and this extension defines how those
per-view attribute arrays are interpreted by Vulkan.
Pipelines using per-view attributes **may** only execute the
[pre-rasterization shader stages](../chapters/pipelines.html#pipelines-graphics-subsets-pre-rasterization) once for all views rather than once per-view, which reduces
redundant shading work.

A subpass creation flag controls whether the subpass uses this extension.
A subpass **must** either exclusively use this extension or not use it at all.

Some Vulkan implementations only support the position attribute varying
between views in the X component.
A subpass can declare via a second creation flag whether all pipelines
compiled for this subpass will obey this restriction.

Shaders that use the new per-view outputs (e.g. `gl_PositionPerViewNV`)
**must** also write the non-per-view output (`gl_Position`), and the values
written **must** be such that `gl_Position =
gl_PositionPerViewNV[gl_ViewIndex]` for all views in the subpass.
Implementations are free to either use the per-view outputs or the
non-per-view outputs, whichever would be more efficient.

If the `[VK_NV_viewport_array2](#VK_NV_viewport_array2)` extension is not also supported and
enabled, the per-view viewport mask **must** not be used.

* 
Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

[VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX](../chapters/limits.html#VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX)

If [Vulkan Version 1.3](versions.html#versions-1.3) or [VK_KHR_dynamic_rendering](#VK_KHR_dynamic_rendering) is supported:

* 
Extending [VkCommandBufferInheritanceInfo](../chapters/cmdbuffers.html#VkCommandBufferInheritanceInfo), [VkGraphicsPipelineCreateInfo](../chapters/pipelines.html#VkGraphicsPipelineCreateInfo), [VkRenderingInfo](../chapters/renderpass.html#VkRenderingInfo):

[VkMultiviewPerViewAttributesInfoNVX](../chapters/renderpass.html#VkMultiviewPerViewAttributesInfoNVX)

* 
`VK_NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_EXTENSION_NAME`

* 
`VK_NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX`

Extending [VkSubpassDescriptionFlagBits](../chapters/renderpass.html#VkSubpassDescriptionFlagBits):

* 
`VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX`

* 
`VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX`

If [Vulkan Version 1.3](versions.html#versions-1.3) or [VK_KHR_dynamic_rendering](#VK_KHR_dynamic_rendering) is supported:

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX`

* 
[`PositionPerViewNV`](../chapters/interfaces.html#interfaces-builtin-variables-positionperview)

* 
[`ViewportMaskPerViewNV`](../chapters/interfaces.html#interfaces-builtin-variables-viewportmaskperview)

* 
[    `PerViewAttributesNV`](spirvenv.html#spirvenv-capabilities-table-PerViewAttributesNV)

#version 450 core

#extension GL_KHX_multiview : enable
#extension GL_NVX_multiview_per_view_attributes : enable

layout(location = 0) in vec4 position;
layout(set = 0, binding = 0) uniform Block { mat4 mvpPerView[2]; } buf;

void main()
{
    // Output both per-view positions and gl_Position as a function
    // of gl_ViewIndex
    gl_PositionPerViewNV[0] = buf.mvpPerView[0] * position;
    gl_PositionPerViewNV[1] = buf.mvpPerView[1] * position;
    gl_Position = buf.mvpPerView[gl_ViewIndex] * position;
}

* 
Revision 1, 2017-01-13 (Jeff Bolz)

Internal revisions

**Name String**

`VK_QCOM_filter_cubic_clamp`

**Extension Type**

Device extension

**Registered Extension Number**

522

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_EXT_filter_cubic](#VK_EXT_filter_cubic)

and

 [Vulkan Version 1.2](versions.html#versions-1.2)

 or

 [VK_EXT_sampler_filter_minmax](#VK_EXT_sampler_filter_minmax)

**Contact**

* 
Matthew Netsch [mnetsch](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_QCOM_filter_cubic_clamp] @mnetsch%0A*Here describe the issue or question you have about the VK_QCOM_filter_cubic_clamp extension*)

**Last Modified Date**

2023-08-02

**Contributors**

* 
Jeff Leger, Qualcomm Technologies, Inc.

This extension extends cubic filtering by adding the ability to enable an
anti-ringing clamp.
Cubic filtering samples from a 4x4 region of texels and computes a cubic
weighted average of the region.
In some cases, the resulting value is outside the range of any of the texels
in the 4x4 region.
This is sometimes referred to as filter overshoot or filter ringing
and can occur when there is a sharp discontinuity in the 4x4 region being
filtered.
For some use cases this ringing can produces unacceptable artifacts.

The solution to the ringing problem is to clamp the post-cubic-filtered
value to be within the max and min of texel values in the 4x4 region.
While such range clamping can be performed in shader code, the
additional texture fetches and clamping ALU operations can be costly.

Certain Adreno GPUs are able to perform the range clamp in the texture unit
during cubic filtering at significant performance/power savings versus a
shader-based clamping approach.
This extension exposes such hardware functionality.

This extension extends [VkSamplerReductionMode](../chapters/samplers.html#VkSamplerReductionMode), adding
`VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM` which
enables the range clamp operation.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceCubicClampFeaturesQCOM](../chapters/features.html#VkPhysicalDeviceCubicClampFeaturesQCOM)

* 
`VK_QCOM_FILTER_CUBIC_CLAMP_EXTENSION_NAME`

* 
`VK_QCOM_FILTER_CUBIC_CLAMP_SPEC_VERSION`

* 
Extending [VkSamplerReductionMode](../chapters/samplers.html#VkSamplerReductionMode):

`VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM`

* 
Revision 1, 2023-08-02 (jleger)

Initial version

**Name String**

`VK_QCOM_filter_cubic_weights`

**Extension Type**

Device extension

**Registered Extension Number**

520

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_EXT_filter_cubic](#VK_EXT_filter_cubic)

**Contact**

* 
Matthew Netsch [mnetsch](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_QCOM_filter_cubic_weights] @mnetsch%0A*Here describe the issue or question you have about the VK_QCOM_filter_cubic_weights extension*)

**Last Modified Date**

2023-06-23

**Contributors**

* 
Jeff Leger, Qualcomm Technologies, Inc.

* 
Jonathan Wicks, Qualcomm Technologies, Inc.

This extension extends cubic filtering by adding the ability to select a set
of weights.
Without this extension, the weights used in cubic filtering are limited to
those corresponding to a Catmull-Rom spline.
This extension adds support for 3 additional spline weights.

This extension adds a new structure that **can** be added to the `pNext`
chain of [VkSamplerCreateInfo](../chapters/samplers.html#VkSamplerCreateInfo) that **can** be used to specify which set of
cubic weights are used in cubic filtering.
A similar structure can be added to the `pNext` chain of
[VkBlitImageInfo2](../chapters/copies.html#VkBlitImageInfo2) to specify cubic weights used in a blit operation.

With this extension weights corresponding to the following additional
splines can be selected for cubic filtered sampling and blits:

* 
Zero Tangent Cardinal

* 
B-Spline

* 
Mitchell-Netravali

* 
Extending [VkBlitImageInfo2](../chapters/copies.html#VkBlitImageInfo2):

[VkBlitImageCubicWeightsInfoQCOM](../chapters/copies.html#VkBlitImageCubicWeightsInfoQCOM)

Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

* 
[VkPhysicalDeviceCubicWeightsFeaturesQCOM](../chapters/features.html#VkPhysicalDeviceCubicWeightsFeaturesQCOM)

Extending [VkSamplerCreateInfo](../chapters/samplers.html#VkSamplerCreateInfo):

* 
[VkSamplerCubicWeightsCreateInfoQCOM](../chapters/samplers.html#VkSamplerCubicWeightsCreateInfoQCOM)

* 
[VkCubicFilterWeightsQCOM](../chapters/samplers.html#VkCubicFilterWeightsQCOM)

* 
`VK_QCOM_FILTER_CUBIC_WEIGHTS_EXTENSION_NAME`

* 
`VK_QCOM_FILTER_CUBIC_WEIGHTS_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM`

* 
`VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM`

* 
Revision 1, 2023-06-23 (jleger)

Initial version

**Name String**

`VK_QCOM_image_processing`

**Extension Type**

Device extension

**Registered Extension Number**

441

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_format_feature_flags2](#VK_KHR_format_feature_flags2)

or

[Vulkan Version 1.3](versions.html#versions-1.3)

**API Interactions**

* 
Interacts with VK_VERSION_1_3

* 
Interacts with VK_KHR_format_feature_flags2

**SPIR-V Dependencies**

* 
[SPV_QCOM_image_processing](https://github.khronos.org/SPIRV-Registry/extensions/QCOM/SPV_QCOM_image_processing.html)

**Contact**

* 
Matthew Netsch [mnetsch](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_QCOM_image_processing] @mnetsch%0A*Here describe the issue or question you have about the VK_QCOM_image_processing extension*)

**Extension Proposal**

[VK_QCOM_image_processing](../../../features/latest/features/proposals/VK_QCOM_image_processing.html)

**Last Modified Date**

2022-07-08

**Interactions and External Dependencies**

* 
This extension provides API support for
[`GL_QCOM_image_processing`](https://github.com/KhronosGroup/GLSL/blob/main/extensions/qcom/GLSL_QCOM_image_processing.txt)

**Contributors**

* 
Jeff Leger, Qualcomm Technologies, Inc.

* 
Ruihao Zhang, Qualcomm Technologies, Inc.

GPUs are commonly used to process images for various applications from 3D
graphics to UI and from composition to compute applications.
Simple scaling and filtering can be done with bilinear filtering, which
comes for free during texture sampling.
However, as screen sizes get larger and more use cases rely on GPU such as
camera and video post-processing needs, there is increasing demand for GPU
to support higher order filtering and other advanced image processing.

This extension introduces a new set of SPIR-V built-in functions for image
processing.
It exposes the following new imaging operations

* 
The `OpImageSampleWeightedQCOM` instruction takes 3 operands: *sampled
  image*, *weight image*, and texture coordinates.
  The instruction computes a weighted average of an MxN region of texels
in the *sampled image*, using a set of MxN weights in the *weight image*.

* 
The `OpImageBoxFilterQCOM` instruction takes 3 operands: *sampled
image*, *box size*, and texture coordinates.
Note that *box size* specifies a floating-point width and height in
texels.
The instruction computes a weighted average of all texels in the
*sampled image* that are covered (either partially or fully) by a box
with the specified size and centered at the specified texture
coordinates.

* 
The `OpImageBlockMatchSADQCOM` and `OpImageBlockMatchSSDQCOM`
instructions each takes 5 operands: *target image*, *target
coordinates*, *reference image*, *reference coordinates*, and *block
size*.
Each instruction computes an error metric, that describes whether a
block of texels in the *target image* matches a corresponding block of
texels in the *reference image*.
The error metric is computed per-component.
`OpImageBlockMatchSADQCOM` computes "Sum Of Absolute Difference" and
`OpImageBlockMatchSSDQCOM` computes "Sum of Squared Difference".

Each of the image processing instructions operate only on 2D images.
The instructions do not-support sampling of mipmap, multi-plane,
multi-layer, multi-sampled, or depth/stencil images.
The instructions can be used in any shader stage.

Implementations of this extension should support these operations natively
at the HW instruction level, offering potential performance gains as well as
ease of development.

* 
Extending [VkImageViewCreateInfo](../chapters/resources.html#VkImageViewCreateInfo):

[VkImageViewSampleWeightCreateInfoQCOM](../chapters/resources.html#VkImageViewSampleWeightCreateInfoQCOM)

Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

* 
[VkPhysicalDeviceImageProcessingFeaturesQCOM](../chapters/features.html#VkPhysicalDeviceImageProcessingFeaturesQCOM)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceImageProcessingPropertiesQCOM](../chapters/devsandqueues.html#VkPhysicalDeviceImageProcessingPropertiesQCOM)

* 
`VK_QCOM_IMAGE_PROCESSING_EXTENSION_NAME`

* 
`VK_QCOM_IMAGE_PROCESSING_SPEC_VERSION`

* 
Extending [VkDescriptorType](../chapters/descriptorsets.html#VkDescriptorType):

`VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM`

* 
`VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM`

Extending [VkImageUsageFlagBits](../chapters/resources.html#VkImageUsageFlagBits):

* 
`VK_IMAGE_USAGE_SAMPLE_BLOCK_MATCH_BIT_QCOM`

* 
`VK_IMAGE_USAGE_SAMPLE_WEIGHT_BIT_QCOM`

Extending [VkSamplerCreateFlagBits](../chapters/samplers.html#VkSamplerCreateFlagBits):

* 
`VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM`

If [VK_KHR_format_feature_flags2](#VK_KHR_format_feature_flags2) or [Vulkan Version 1.3](versions.html#versions-1.3) is supported:

* 
Extending [VkFormatFeatureFlagBits2](../chapters/formats.html#VkFormatFeatureFlagBits2):

`VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM`

* 
`VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM`

* 
`VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM`

* 
`VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM`

* 
Revision 1, 2022-07-08 (Jeff Leger)

**Name String**

`VK_QCOM_image_processing2`

**Extension Type**

Device extension

**Registered Extension Number**

519

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_QCOM_image_processing](#VK_QCOM_image_processing)

**SPIR-V Dependencies**

* 
[SPV_QCOM_image_processing2](https://github.khronos.org/SPIRV-Registry/extensions/QCOM/SPV_QCOM_image_processing2.html)

**Contact**

* 
Matthew Netsch [mnetsch](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_QCOM_image_processing2] @mnetsch%0A*Here describe the issue or question you have about the VK_QCOM_image_processing2 extension*)

**Last Modified Date**

2023-03-10

**Interactions and External Dependencies**

* 
This extension provides API support for
[`GL_QCOM_image_processing2`](https://github.com/KhronosGroup/GLSL/blob/main/extensions/qcom/GLSL_QCOM_image_processing2.txt)

**Contributors**

* 
Jeff Leger, Qualcomm Technologies, Inc.

This extension enables support for the SPIR-V `TextureBlockMatch2QCOM`
capability.
It builds on the functionality of QCOM_image_processing with the addition of
4 new image processing operations.

* 
The `opImageBlockMatchWindowSADQCOM`` SPIR-V instruction builds upon
the functionality of `opImageBlockMatchSADQCOM`` by repeatedly
performing block match operations across a 2D window.
The 2D windowExtent and compareMode are specified by
[VkSamplerBlockMatchWindowCreateInfoQCOM](../chapters/samplers.html#VkSamplerBlockMatchWindowCreateInfoQCOM) in the sampler used to
create the *target image*.
Like `OpImageBlockMatchSADQCOM`, `opImageBlockMatchWindowSADQCOM`
computes an error metric, that describes whether a block of texels in
the *target image* matches a corresponding block of texels in the
*reference image*.
Unlike `OpImageBlockMatchSADQCOM`, this instruction computes an error
metric at each (X,Y) location within the 2D window and returns either
the minimum or maximum error.
The instruction only supports single-component formats.
Refer to the pseudocode below for details.

* 
The `opImageBlockMatchWindowSSDQCOM` follows the same pattern,
computing the SSD error metric at each location within the 2D window.

* 
The `opImageBlockMatchGatherSADQCOM` builds upon
`OpImageBlockMatchSADQCOM`.
This instruction computes an error metric, that describes whether a
block of texels in the *target image* matches a corresponding block of
texels in the *reference image*.
The instruction computes the SAD error metric at 4 texel offsets and
returns the error metric for each offset in the X,Y,Z,and W components.
The instruction only supports single-component texture formats.
Refer to the pseudocode below for details.

* 
The `opImageBlockMatchGatherSSDQCOM` follows the same pattern,
computing the SSD error metric for 4 offsets.

Each of the above 4 image processing instructions are limited to
single-component formats.

Below is the pseudocode for GLSL built-in function
`textureWindowBlockMatchSADQCOM`.
The pseudocode for `textureWindowBlockMatchSSD` is identical other than
replacing all instances of `"SAD"` with `"SSD"`.

vec4 textureBlockMatchWindowSAD( sampler2D target,
                                 uvec2 targetCoord,
                                 samler2D reference,
                                 uvec2 refCoord,
                                 uvec2 blocksize) {
    // compareMode (MIN or MAX) comes from the vkSampler associated with `target`
    // uvec2 window  comes from the vkSampler associated with `target`
    minSAD = INF;
    maxSAD = -INF;
    uvec2 minCoord;
    uvec2 maxCoord;

    for (uint x=0, x  maxSAD) {
                maxSAD = SAD;
                maxCoord = uvec2(x,y);
            }
        }
    }
    if (compareMode=MIN) {
        return vec4(minSAD, minCoord.x, minCoord.y, 0.0);
    } else {
        return vec4(maxSAD, maxCoord.x, maxCoord.y, 0.0);
    }
}

Below is the pseudocode for `textureBlockMatchGatherSADQCOM`.
The pseudocode for `textureBlockMatchGatherSSD` follows an identical
pattern.

vec4 textureBlockMatchGatherSAD( sampler2D target,
                                 uvec2 targetCoord,
                                 samler2D reference,
                                 uvec2 refCoord,
                                 uvec2 blocksize) {
    vec4 out;
    for (uint x=0, x

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceImageProcessing2FeaturesQCOM](../chapters/features.html#VkPhysicalDeviceImageProcessing2FeaturesQCOM)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceImageProcessing2PropertiesQCOM](../chapters/devsandqueues.html#VkPhysicalDeviceImageProcessing2PropertiesQCOM)

Extending [VkSamplerCreateInfo](../chapters/samplers.html#VkSamplerCreateInfo):

* 
[VkSamplerBlockMatchWindowCreateInfoQCOM](../chapters/samplers.html#VkSamplerBlockMatchWindowCreateInfoQCOM)

* 
[VkBlockMatchWindowCompareModeQCOM](../chapters/samplers.html#VkBlockMatchWindowCompareModeQCOM)

* 
`VK_QCOM_IMAGE_PROCESSING_2_EXTENSION_NAME`

* 
`VK_QCOM_IMAGE_PROCESSING_2_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM`

* 
`VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM`

1) What is the precision of the min/max comparison checks?

**RESOLVED**: Intermediate computations for the new operations are performed
at 16-bit floating-point precision.
If the value of `"float SAD"` in the above code sample is a 16-bit denorm
value, then behavior of the MIN/MAX comparison is undefined.

* 
Revision 1, 2023-03-10 (Jeff Leger)

**Name String**

`VK_QCOM_multiview_per_view_render_areas`

**Extension Type**

Device extension

**Registered Extension Number**

511

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

None

**Contact**

* 
Matthew Netsch [mnetsch](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_QCOM_multiview_per_view_render_areas] @mnetsch%0A*Here describe the issue or question you have about the VK_QCOM_multiview_per_view_render_areas extension*)

**Last Modified Date**

2023-01-10

**IP Status**

No known IP claims.

**Interactions and External Dependencies**

* 
This extension interacts with `[VK_KHR_dynamic_rendering](#VK_KHR_dynamic_rendering)`

* 
This extension interacts with `[VK_QCOM_render_pass_transform](#VK_QCOM_render_pass_transform)`

**Contributors**

* 
Jeff Leger, Qualcomm

* 
Jonathan Tinkham, Qualcomm

* 
Jonathan Wicks, Qualcomm

Certain use cases (e.g., side-by-side VR rendering) use multiview and render
to distinct regions of the framebuffer for each view.
On some implementations, there may be a performance benefit for providing
per-view render areas to the implementation.
Such per-view render areas can be used by the implementation to reduce the
pixels that are affected by attachment load, store, and multisample resolve
operations.

The extension enables a multiview render pass instance to define per-view
render areas.
For each view of a multiview render pass instance, only those pixels in the
per-view render area are affected by load, store and resolve operations.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM](../chapters/features.html#VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM)

Extending [VkRenderPassBeginInfo](../chapters/renderpass.html#VkRenderPassBeginInfo), [VkRenderingInfo](../chapters/renderpass.html#VkRenderingInfo):

* 
[VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM](../chapters/renderpass.html#VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM)

* 
`VK_QCOM_MULTIVIEW_PER_VIEW_RENDER_AREAS_EXTENSION_NAME`

* 
`VK_QCOM_MULTIVIEW_PER_VIEW_RENDER_AREAS_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM`

1) Do the per-view `renderAreas` interact with
[vkGetRenderAreaGranularity](../chapters/renderpass.html#vkGetRenderAreaGranularity) ?

**RESOLVED**: There is no change.
The granularity returned by [vkGetRenderAreaGranularity](../chapters/renderpass.html#vkGetRenderAreaGranularity) also applies to
the per-view `renderAreas`.

2) How does this extension interact with
`[VK_QCOM_render_pass_transform](#VK_QCOM_render_pass_transform)`?

**RESOLVED**: When `[VK_QCOM_render_pass_transform](#VK_QCOM_render_pass_transform)` is enabled, the
application provides render area in non-rotated coordinates which is rotated
by the implementation to the rotated coordinate system.
When this extension is used in combination with
`[VK_QCOM_render_pass_transform](#VK_QCOM_render_pass_transform)`, then the `renderArea` provided
in [VkRenderingInfo](../chapters/renderpass.html#VkRenderingInfo)::`renderArea`,
[VkRenderPassBeginInfo](../chapters/renderpass.html#VkRenderPassBeginInfo)::`renderArea`, or
[VkCommandBufferInheritanceRenderPassTransformInfoQCOM](../chapters/cmdbuffers.html#VkCommandBufferInheritanceRenderPassTransformInfoQCOM)::`renderArea`
is rotated by the implementation.
The per-view render areas are not rotated.

3) How does this extension interact with
`[VK_QCOM_multiview_per_view_viewports](#VK_QCOM_multiview_per_view_viewports)`

**RESOLVED**: There is no direct interaction.
The per-view viewports and the per-view renderAreas are orthogonal features.

4) When a per-view `renderArea` is specified, must multiview rendering
for each view of a multiview render pass be contained within the per-view
`renderArea`?

**RESOLVED**: Yes, and the `[VK_QCOM_multiview_per_view_viewports](#VK_QCOM_multiview_per_view_viewports)` may
help here since it provides per-view scissors.

5) When per-view render areas are specified, what purpose if any do
[VkRenderPassBeginInfo](../chapters/renderpass.html#VkRenderPassBeginInfo)::`renderArea` and
[VkRenderingInfo](../chapters/renderpass.html#VkRenderingInfo)::`renderArea` serve?

**RESOLVED**: The per-view `renderArea` effectively overrides the
per-renderpass `renderArea`.
The per-view `renderArea` defines the regions of the attachments that
are effected by load, store, and multisample resolve operations.
A valid implementation could ignore the per-renderpass `renderArea`.
However, as an aid to the implementation, the application must set the
per-renderpass `renderArea` to an area that is at least as large as the
union of all the per-view render areas.
Pixels that are within the per-renderpass `renderArea` but not within
any per-view render area must not be affected by load, store, or multisample
resolve operations.

* 
Revision 1, 2023-01-10 (Jeff Leger)

**Name String**

`VK_QCOM_multiview_per_view_viewports`

**Extension Type**

Device extension

**Registered Extension Number**

489

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Contact**

* 
Matthew Netsch [mnetsch](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_QCOM_multiview_per_view_viewports] @mnetsch%0A*Here describe the issue or question you have about the VK_QCOM_multiview_per_view_viewports extension*)

**Last Modified Date**

2022-11-22

**IP Status**

No known IP claims.

**Interactions and External Dependencies**

* 
This extension interacts with `[VK_KHR_dynamic_rendering](#VK_KHR_dynamic_rendering)`

* 
This extension interacts with `[VK_EXT_extended_dynamic_state](#VK_EXT_extended_dynamic_state)`

**Contributors**

* 
Jeff Leger, Qualcomm

* 
Jonathan Tinkham, Qualcomm

* 
Jonathan Wicks, Qualcomm

Certain use cases for multiview have a need for specifying a separate
viewport and scissor for each view, without using shader-based viewport
indexing as introduced with `[VK_EXT_shader_viewport_index_layer](#VK_EXT_shader_viewport_index_layer)`.

This extension adds a new way to control ViewportIndex with multiview.
When the [`multiviewPerViewViewports`](../chapters/features.html#features-multiviewPerViewViewports) feature is enabled and if the last
pre-rasterization shader entry points interface does not use the
`ViewportIndex` built-in decoration, then each view of a multiview render
pass instance will use a viewport and scissor index equal to the
`ViewIndex`.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM](../chapters/features.html#VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM)

* 
`VK_QCOM_MULTIVIEW_PER_VIEW_VIEWPORTS_EXTENSION_NAME`

* 
`VK_QCOM_MULTIVIEW_PER_VIEW_VIEWPORTS_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM`

1) Is it possible to enable/disable the
[`multiviewPerViewViewports`](../chapters/features.html#features-multiviewPerViewViewports)
feature for individual render pass instances?

**RESOLVED**: No, when the multiviewPerViewViewports feature is enabled during
vkCreateDevice, then all created render pass instances (including dynamic
render passes from `[VK_KHR_dynamic_rendering](#VK_KHR_dynamic_rendering)`) and all created
VkPipelines will have the feature enabled.
This approach was chosen because it simplifies application code and there is
no known use case to enable/disable the feature for individual render passes
or pipelines.

2) When this extension is used, is the value of `ViewportIndex`
implicitly written by the last pre-rasterization shader stage and can the
value of `ViewportIndex` be read in the fragment shader?

**RESOLVED**: No, use of the extension does not add an implicit write to
`ViewportIndex` in any shader stage, and additionally, the value of
`ViewportIndex` in the fragment shader is undefined.

* 
Revision 1, 2022-11-22 (Jeff Leger)

**Name String**

`VK_QCOM_render_pass_shader_resolve`

**Extension Type**

Device extension

**Registered Extension Number**

172

**Revision**

4

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

None

**Contact**

* 
Matthew Netsch [mnetsch](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_QCOM_render_pass_shader_resolve] @mnetsch%0A*Here describe the issue or question you have about the VK_QCOM_render_pass_shader_resolve extension*)

**Last Modified Date**

2019-11-07

**IP Status**

No known IP claims.

**Interactions and External Dependencies**

None.

**Contributors**

* 
Srihari Babu Alla, Qualcomm

* 
Bill Licea-Kane, Qualcomm

* 
Jeff Leger, Qualcomm

This extension allows a shader resolve to replace fixed-function resolve.

Fixed-function resolve is limited in function to simple filters of
multisample buffers to a single sample buffer.

Fixed-function resolve is more performance efficient and/or power efficient
than shader resolve for such simple filters.

Shader resolve allows a shader writer to create complex, non-linear
filtering of a multisample buffer in the last subpass of a subpass
dependency chain.

This extension also provides a bit which **can** be used to enlarge a sample
region dependency to a fragment region dependency, so that a
framebuffer-region dependency **can** replace a framebuffer-global dependency
in some cases.

* 
`VK_QCOM_RENDER_PASS_SHADER_RESOLVE_EXTENSION_NAME`

* 
`VK_QCOM_RENDER_PASS_SHADER_RESOLVE_SPEC_VERSION`

* 
Extending [VkSubpassDescriptionFlagBits](../chapters/renderpass.html#VkSubpassDescriptionFlagBits):

`VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_QCOM`

* 
`VK_SUBPASS_DESCRIPTION_SHADER_RESOLVE_BIT_QCOM`

1) Should this extension be named render_pass_shader_resolve?

**RESOLVED** Yes.

This is part of suite of small extensions to render pass.

Following the style guide, instead of following VK_KHR_create_renderpass2.

2) Should the VK_SAMPLE_COUNT_1_BIT be required for each pColorAttachment
and the DepthStencilAttachent?

**RESOLVED** No.

While this may not be a common use case, and while most fixed-function
resolve hardware has this limitation, there is little reason to require a
shader resolve to resolve to a single sample buffer.

3) Should a shader resolve subpass be the last subpass in a render pass?

**RESOLVED** Yes.

To be more specific, it should be the last subpass in a subpass dependency
chain.

4) Do we need the `VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_QCOM` bit?

**RESOLVED** Yes.

This applies when an input attachments sample count is equal to
`rasterizationSamples`.
Further, if `sampleShading` is enabled (explicitly or implicitly) then
`minSampleShading` **must** equal 0.0.

However, this bit may be set on any subpass, it is not restricted to a
shader resolve subpass.

* 
Revision 1, 2019-06-28 (wwlk)

Initial draft

Revision 2, 2019-11-06 (wwlk)

* 
General clean-up/spec updates

* 
Added issues

Revision 3, 2019-11-07 (wwlk)

* 
Typos

* 
Additional issues

* 
Clarified that a shader resolve subpass is the last subpass in a
subpass dependency chain

Revision 4, 2020-01-06 (wwlk)

* 
Change resolution of Issue 1 (*render_pass*, not *renderpass*)

**Name String**

`VK_QCOM_render_pass_store_ops`

**Extension Type**

Device extension

**Registered Extension Number**

302

**Revision**

2

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

None

**Contact**

* 
Matthew Netsch [mnetsch](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_QCOM_render_pass_store_ops] @mnetsch%0A*Here describe the issue or question you have about the VK_QCOM_render_pass_store_ops extension*)

**Last Modified Date**

2020-03-25

**Contributors**

* 
Bill Licea-Kane, Qualcomm Technologies, Inc.

Render pass attachments **can** be read-only for the duration of a render pass.

Examples include input attachments and depth attachments where depth tests
are enabled but depth writes are not enabled.

In such cases, there **can** be no contents generated for an attachment within
the render area.

This extension adds a new [VkAttachmentStoreOp](../chapters/renderpass.html#VkAttachmentStoreOp)
`VK_ATTACHMENT_STORE_OP_NONE_QCOM` specifying that the contents within
the render area **may** not be written to memory, but that the prior contents
of the attachment in memory are preserved.
However, if any contents were generated within the render area during
rendering, the contents of the attachment will be **undefined** inside the
render area.

|  | The [VkAttachmentStoreOp](../chapters/renderpass.html#VkAttachmentStoreOp) `VK_ATTACHMENT_STORE_OP_STORE` **may** force
| --- | --- |
an implementation to assume that the attachment was written and force an
implementation to flush data to memory or to a higher level cache.
The [VkAttachmentStoreOp](../chapters/renderpass.html#VkAttachmentStoreOp) `VK_ATTACHMENT_STORE_OP_NONE_QCOM` **may**
allow an implementation to assume that the attachment was not written and
allow an implementation to avoid such a flush. |

* 
`VK_QCOM_RENDER_PASS_STORE_OPS_EXTENSION_NAME`

* 
`VK_QCOM_RENDER_PASS_STORE_OPS_SPEC_VERSION`

* 
Extending [VkAttachmentStoreOp](../chapters/renderpass.html#VkAttachmentStoreOp):

`VK_ATTACHMENT_STORE_OP_NONE_QCOM`

* 
Revision 1, 2019-12-20 (wwlk)

Initial version

Revision 2, 2020-03-25 (wwlk)

* 
Minor renaming

**Name String**

`VK_QCOM_render_pass_transform`

**Extension Type**

Device extension

**Registered Extension Number**

283

**Revision**

4

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

None

**Contact**

* 
Matthew Netsch [mnetsch](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_QCOM_render_pass_transform] @mnetsch%0A*Here describe the issue or question you have about the VK_QCOM_render_pass_transform extension*)

**Last Modified Date**

2023-12-13

**Interactions and External Dependencies**

* 
This extension interacts with `[VK_KHR_swapchain](#VK_KHR_swapchain)`

* 
This extension interacts with `[VK_KHR_surface](#VK_KHR_surface)`

* 
This extension interacts with `[VK_EXT_fragment_density_map](#VK_EXT_fragment_density_map)`

* 
This extension interacts with `[VK_KHR_fragment_shading_rate](#VK_KHR_fragment_shading_rate)`

* 
This extension interacts with `[VK_QCOM_tile_properties](#VK_QCOM_tile_properties)`

**Contributors**

* 
Jeff Leger, Qualcomm Technologies, Inc.

* 
Brandon Light, Qualcomm Technologies, Inc.

* 
Matthew Netsch, Qualcomm Technologies, Inc.

* 
Arpit Agarwal, Qualcomm Technologies, Inc.

This extension provides a mechanism for applications to enable driver
support for [render pass transform](../chapters/vertexpostproc.html#vertexpostproc-renderpass-transform).

Mobile devices can be rotated and mobile applications need to render
properly when a device is held in a landscape or portrait orientation.
When the current orientation differs from the devices native orientation, a
rotation is required so that the up direction of the rendered scene
matches the current orientation.

If the Display Processing Unit (DPU) does not natively support rotation, the
Vulkan presentation engine can handle this rotation in a separate
composition pass.
Alternatively, the application can render frames pre-rotated to avoid
this extra pass.
The latter is preferred to reduce power consumption and achieve the best
performance because it avoids tasking the GPU with extra work to perform the
copy/rotate operation.

Unlike OpenGL ES, the burden of pre-rotation in Vulkan falls on the
application.
To implement pre-rotation, applications render into swapchain images
matching the device native aspect ratio of the display and pre-rotate
the rendering content to match the devices current orientation.
The burden is more than adjusting the Model View Projection (MVP) matrix in
the vertex shader to account for rotation and aspect ratio.
The coordinate systems of scissors, viewports, derivatives and several
shader built-ins may need to be adapted to produce the correct result.

It is difficult for some game engines to manage this burden; many chose to
simply accept the performance/power overhead of performing rotation in the
presentation engine.

This extension allows applications to achieve the performance benefits of
pre-rotated rendering by moving much of the above-mentioned burden to the
graphics driver.
The following is unchanged with this extension:

* 
Applications create a swapchain matching the native orientation of the
display.
Applications must also set the
[VkSwapchainCreateInfoKHR](../chapters/VK_KHR_surface/wsi.html#VkSwapchainCreateInfoKHR)::`preTransform` equal to the
`currentTransform` as returned by
[vkGetPhysicalDeviceSurfaceCapabilitiesKHR](../chapters/VK_KHR_surface/wsi.html#vkGetPhysicalDeviceSurfaceCapabilitiesKHR).

The following is changed with this extension:

* 
At [vkCmdBeginRenderPass](../chapters/renderpass.html#vkCmdBeginRenderPass), the application provides extension struct
[VkRenderPassTransformBeginInfoQCOM](../chapters/renderpass.html#VkRenderPassTransformBeginInfoQCOM) specifying the render pass
transform parameters.

* 
At [vkBeginCommandBuffer](../chapters/cmdbuffers.html#vkBeginCommandBuffer) for secondary command buffers, the
application provides extension struct
[VkCommandBufferInheritanceRenderPassTransformInfoQCOM](../chapters/cmdbuffers.html#VkCommandBufferInheritanceRenderPassTransformInfoQCOM) specifying
the render pass transform parameters.

* 
The `renderArea`, viewports, scissors, and `fragmentSize` are
all provided in the current (non-rotated) coordinate system.
The implementation will transform those into the native (rotated)
coordinate system.

* 
The implementation is responsible for transforming shader built-ins
(`FragCoord`, `PointCoord`, `SamplePosition`,
`PrimitiveShadingRateKHR`, interpolateAt(), dFdx, dFdy, fWidth) into
the rotated coordinate system.

* 
The implementation is responsible for transforming `position` to the
rotated coordinate system.

* 
If this extension is used with `[VK_QCOM_tile_properties](#VK_QCOM_tile_properties)`, then
[vkGetFramebufferTilePropertiesQCOM](../chapters/framebuffer.html#vkGetFramebufferTilePropertiesQCOM) and
[vkGetDynamicRenderingTilePropertiesQCOM](../chapters/renderpass.html#vkGetDynamicRenderingTilePropertiesQCOM) return tile properties in
the rotated coordinate space.

* 
Extending [VkCommandBufferInheritanceInfo](../chapters/cmdbuffers.html#VkCommandBufferInheritanceInfo):

[VkCommandBufferInheritanceRenderPassTransformInfoQCOM](../chapters/cmdbuffers.html#VkCommandBufferInheritanceRenderPassTransformInfoQCOM)

Extending [VkRenderPassBeginInfo](../chapters/renderpass.html#VkRenderPassBeginInfo):

* 
[VkRenderPassTransformBeginInfoQCOM](../chapters/renderpass.html#VkRenderPassTransformBeginInfoQCOM)

* 
`VK_QCOM_RENDER_PASS_TRANSFORM_EXTENSION_NAME`

* 
`VK_QCOM_RENDER_PASS_TRANSFORM_SPEC_VERSION`

* 
Extending [VkRenderPassCreateFlagBits](../chapters/renderpass.html#VkRenderPassCreateFlagBits):

`VK_RENDER_PASS_CREATE_TRANSFORM_BIT_QCOM`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM`

* 
`VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM`

1) Some early Adreno drivers (October 2019 through March 2020) advertised
support for this extension but expected VK_STRUCTURE_TYPE values different
from those in the vukan headers.
To cover all Adreno devices on the market, applications need to detect the
driver version and use the appropriate VK_STRUCTURE_TYPE values from the
table below.

The driver version reported in VkPhysicalDeviceProperties.driverVersion is a
`uint32_t` type.
You can decode the `uint32_t` value into a major.minor.patch version as
shown below:

uint32_t  major = ((driverVersion) >> 22);
uint32_t  minor = ((driverVersion) >> 12) & 0x3ff);
uint32_t  patch = ((driverVersion) & 0xfff);

If the Adreno major.minor.patch version is greater than or equal to
512.469.0, then simply use the VK_STRUCTURE_TYPE values as defined in
vulkan_core.h.
If the version is less than or equal to 512.468.0, then use the alternate
values for the two VK_STRUCTURE_TYPEs in the table below.

|  | Adreno Driver Version |
| --- | --- |
|  | 512.468.0 and earlier | 512.469.0 and later |
| VK_STRUCTURE_TYPE_ RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM | 1000282000 | 1000282001 |
| VK_STRUCTURE_TYPE_ COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM | 1000282001 | 1000282000 |

2) Should the extension support only rotations (e.g. 90, 180, 270-degrees),
or also mirror transforms (e.g. vertical flips)? Mobile use cases only
require rotation.
Other display systems such as projectors might require a flipped transform.

**RESOLVED**: In this version of the extension, the functionality is
restricted to 90, 180, and 270-degree rotations to address mobile use cases.

3) How does this extension interact with VK_EXT_fragment_density_map?

**RESOLVED** Some implementations may not be able to support a render pass
that enables both render pass transform and fragment density maps.
For simplicity, this extension disallows enabling both features within a
single render pass.

4) What should this extension be named?

We considered names such as rotated_rendering, pre_rotation and
others.
Since the functionality is limited to a render pass, it seemed the name
should include render_pass.
While the current extension is limited to rotations, it could be extended to
other transforms (like mirror) in the future.

**RESOLVED** The name render_pass_transform seems like the most accurate
description of the introduced functionality.

5) How does this extension interact with VK_KHR_fragment_shading_rate?

**RESOLVED**: For the same reasons as issue 3, this extension disallows
enabling both `pFragmentShadingRateAttachment` and render pass transform
within a single render pass.

However, pipeline shading rate and primitive shading rate are supported, and
their respective `fragmentSize` and `PrimitiveShadingRateKHR` are
provided in the current (non-rotated) coordinate system.
The implementation is responsible for transforming them to the rotated
coordinate system.

The [set of supported shading rates](../chapters/primsrast.html#primsrast-fragment-shading-rate) **may**
be different per transform.
Supported rates queried from
[vkGetPhysicalDeviceFragmentShadingRatesKHR](../chapters/primsrast.html#vkGetPhysicalDeviceFragmentShadingRatesKHR) are in the native (rotated)
coordinate system.
This means that the application **must** swap the x/y of the reported rates to
get the set of rates supported for 90 and 270 degree rotation.

* 
Revision 1, 2020-02-05 (Jeff Leger)

* 
Revision 2, 2021-03-09 (Matthew Netsch)

Adds interactions with VK_KHR_fragment_shading_rate

Revision 3, 2022-07-11 (Arpit Agarwal)

* 
Adds interactions with VK_QCOM_tile_properties

Revision 4, 2023-12-13 (Matthew Netsch)

* 
Relax dependencies on VK_KHR_surface and VK_KHR_swapchain

**Name String**

`VK_QCOM_rotated_copy_commands`

**Extension Type**

Device extension

**Registered Extension Number**

334

**Revision**

2

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_copy_commands2](#VK_KHR_copy_commands2)

or

[Vulkan Version 1.3](versions.html#versions-1.3)

**Contact**

* 
Matthew Netsch [mnetsch](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_QCOM_rotated_copy_commands] @mnetsch%0A*Here describe the issue or question you have about the VK_QCOM_rotated_copy_commands extension*)

**Last Modified Date**

2023-12-13

**Interactions and External Dependencies**

* 
This extension interacts with `[VK_KHR_swapchain](#VK_KHR_swapchain)`

* 
This extension interacts with `[VK_KHR_surface](#VK_KHR_surface)`

**Contributors**

* 
Jeff Leger, Qualcomm Technologies, Inc.

* 
Matthew Netsch, Qualcomm Technologies, Inc.

This extension extends adds an optional rotation transform to copy commands
[vkCmdBlitImage2KHR](../chapters/copies.html#vkCmdBlitImage2KHR), [vkCmdCopyImageToBuffer2KHR](../chapters/copies.html#vkCmdCopyImageToBuffer2KHR) and
[vkCmdCopyBufferToImage2KHR](../chapters/copies.html#vkCmdCopyBufferToImage2KHR).
When copying between two resources, where one resource contains rotated
content and the other does not, a rotated copy may be desired.
This extension may be used in combination with VK_QCOM_render_pass_transform
which adds rotated render passes.

This extension adds an extension structure to the following commands:
vkCmdBlitImage2KHR, vkCmdCopyImageToBuffer2KHR and
vkCmdCopyBufferToImage2KHR

1) What is an appropriate name for the added extension structure? The style
guide says Structures which extend other structures through the
`pNext` chain should reflect the name of the base structure they
extend., but in this case a single extension structure is used to extend
three base structures (vkCmdBlitImage2KHR, vkCmdCopyImageToBuffer2KHR and
vkCmdCopyBufferToImage2KHR).
Creating three identical structures with unique names seemed undesirable.

**RESOLVED**: Deviate from the style guide for extension structure naming.

2) Should this extension add a rotation capability to vkCmdCopyImage2KHR?

**RESOLVED**: No.
Use of rotated vkCmdBlitImage2KHR can fully address this use case.

3) Should this extension add a rotation capability to vkCmdResolveImage2KHR?

**RESOLVED** No.
Use of vkCmdResolveImage2KHR is very slow and extremely bandwidth intensive
on Qualcomms GPU architecture and use of pResolveAttachments in
vkRenderPass is the strongly preferred approach.
Therefore, we choose not to introduce a rotation capability to
vkCmdResolveImage2KHR.

* 
Extending [VkBufferImageCopy2](../chapters/copies.html#VkBufferImageCopy2), [VkImageBlit2](../chapters/copies.html#VkImageBlit2):

[VkCopyCommandTransformInfoQCOM](../chapters/copies.html#VkCopyCommandTransformInfoQCOM)

* 
`VK_QCOM_ROTATED_COPY_COMMANDS_EXTENSION_NAME`

* 
`VK_QCOM_ROTATED_COPY_COMMANDS_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM`

* 
Revision 1, 2020-09-19 (Jeff Leger)

* 
Revision 2, 2023-12-13 (Matthew Netsch)

Relax dependency on VK_KHR_swapchain

**Name String**

`VK_QCOM_tile_memory_heap`

**Extension Type**

Device extension

**Registered Extension Number**

548

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

 [VK_KHR_get_memory_requirements2](#VK_KHR_get_memory_requirements2)

 and

 [VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**API Interactions**

* 
Interacts with VK_QCOM_tile_properties

**Contact**

* 
Patrick Boyle [pboyleQCOM](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_QCOM_tile_memory_heap] @pboyleQCOM%0A*Here describe the issue or question you have about the VK_QCOM_tile_memory_heap extension*)

**Extension Proposal**

[VK_QCOM_tile_memory_heap](../../../features/latest/features/proposals/VK_QCOM_tile_memory_heap.html)

**Last Modified Date**

2025-05-05

**Interactions and External Dependencies**

* 
Interacts with `[VK_QCOM_tile_properties](#VK_QCOM_tile_properties)`

* 
Interacts with `[VK_QCOM_tile_shading](#VK_QCOM_tile_shading)`

**Contributors**

* 
Patrick Boyle, Qualcomm Technologies, Inc.

* 
Matthew Netsch, Qualcomm Technologies, Inc.

* 
Srihari Babu Alla, Qualcomm Technologies, Inc.

* 
Kevin Matlage, Qualcomm Technologies, Inc.

This extension adds a new memory heap which allows applications to allocate
and manage tile memory.
A tile memory heap is denoted by the new
`VK_MEMORY_HEAP_TILE_MEMORY_BIT_QCOM` property.
Memory contents within this heap behave differently than other heaps and
only persist its memory contents within a command buffer submission batch
boundary.
This boundary may be extended to a queue submit boundary by querying
`queueSubmitBoundary` in the new
`VkPhysicalDeviceTileMemoryHeapPropertiesQCOM` structure.

Tile memory from this heap can be bound to VkImages or VkBuffers.
The following new usage flags `VK_IMAGE_USAGE_TILE_MEMORY_BIT_QCOM`,
`VK_BUFFER_USAGE_TILE_MEMORY_BIT_QCOM`,
`VK_BUFFER_USAGE_2_TILE_MEMORY_BIT_QCOM` were added for this.
A new extended structure is added to get memory requirements for tile memory
`VkTileMemoryRequirementsQCOM`.

A new command is added to bind tile memory to a command buffer in order to
access and persist tile memory contents while executing commands
[vkCmdBindTileMemoryQCOM](../chapters/memory.html#vkCmdBindTileMemoryQCOM).

This extension can be used in combination with
[VK_QCOM_tile_properties](#VK_QCOM_tile_properties) with the new structure
[VkTileMemorySizeInfoQCOM](../chapters/renderpass.html#VkTileMemorySizeInfoQCOM).

None.

* 
[vkCmdBindTileMemoryQCOM](../chapters/memory.html#vkCmdBindTileMemoryQCOM)

* 
Extending [VkCommandBufferInheritanceInfo](../chapters/cmdbuffers.html#VkCommandBufferInheritanceInfo):

[VkTileMemoryBindInfoQCOM](../chapters/memory.html#VkTileMemoryBindInfoQCOM)

Extending [VkMemoryRequirements2](../chapters/resources.html#VkMemoryRequirements2):

* 
[VkTileMemoryRequirementsQCOM](../chapters/resources.html#VkTileMemoryRequirementsQCOM)

Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

* 
[VkPhysicalDeviceTileMemoryHeapFeaturesQCOM](../chapters/features.html#VkPhysicalDeviceTileMemoryHeapFeaturesQCOM)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceTileMemoryHeapPropertiesQCOM](../chapters/limits.html#VkPhysicalDeviceTileMemoryHeapPropertiesQCOM)

If [VK_QCOM_tile_properties](#VK_QCOM_tile_properties) is supported:

* 
Extending [VkRenderPassCreateInfo](../chapters/renderpass.html#VkRenderPassCreateInfo), [VkRenderPassCreateInfo2](../chapters/renderpass.html#VkRenderPassCreateInfo2), [VkRenderingInfo](../chapters/renderpass.html#VkRenderingInfo):

[VkTileMemorySizeInfoQCOM](../chapters/renderpass.html#VkTileMemorySizeInfoQCOM)

* 
`VK_QCOM_TILE_MEMORY_HEAP_EXTENSION_NAME`

* 
`VK_QCOM_TILE_MEMORY_HEAP_SPEC_VERSION`

* 
Extending [VkBufferUsageFlagBits](../chapters/resources.html#VkBufferUsageFlagBits):

`VK_BUFFER_USAGE_TILE_MEMORY_BIT_QCOM`

Extending [VkBufferUsageFlagBits2](../chapters/resources.html#VkBufferUsageFlagBits2):

* 
`VK_BUFFER_USAGE_2_TILE_MEMORY_BIT_QCOM`

Extending [VkImageUsageFlagBits](../chapters/resources.html#VkImageUsageFlagBits):

* 
`VK_IMAGE_USAGE_TILE_MEMORY_BIT_QCOM`

Extending [VkMemoryHeapFlagBits](../chapters/memory.html#VkMemoryHeapFlagBits):

* 
`VK_MEMORY_HEAP_TILE_MEMORY_BIT_QCOM`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_FEATURES_QCOM`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_PROPERTIES_QCOM`

* 
`VK_STRUCTURE_TYPE_TILE_MEMORY_BIND_INFO_QCOM`

* 
`VK_STRUCTURE_TYPE_TILE_MEMORY_REQUIREMENTS_QCOM`

If [VK_QCOM_tile_properties](#VK_QCOM_tile_properties) is supported:

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_TILE_MEMORY_SIZE_INFO_QCOM`

* 
Revision 1, 2025-03-26 (Patrick Boyle)

Initial version

**Name String**

`VK_QCOM_tile_properties`

**Extension Type**

Device extension

**Registered Extension Number**

485

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**API Interactions**

* 
Interacts with VK_VERSION_1_3

* 
Interacts with VK_KHR_dynamic_rendering

**Contact**

* 
Matthew Netsch [mnetsch](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_QCOM_tile_properties] @mnetsch%0A*Here describe the issue or question you have about the VK_QCOM_tile_properties extension*)

**Extension Proposal**

[VK_QCOM_tile_properties](../../../features/latest/features/proposals/VK_QCOM_tile_properties.html)

**Last Modified Date**

2022-07-11

**Interactions and External Dependencies**

* 
This extension interacts with `[VK_EXT_subpass_merge_feedback](#VK_EXT_subpass_merge_feedback)`

**Contributors**

* 
Jonathan Wicks, Qualcomm Technologies, Inc.

* 
Jonathan Tinkham, Qualcomm Technologies, Inc.

* 
Arpit Agarwal, Qualcomm Technologies, Inc.

* 
Jeff Leger, Qualcomm Technologies, Inc.

This extension allows an application to query the tile properties.
This extension supports both renderpasses and dynamic rendering.

* 
[vkGetDynamicRenderingTilePropertiesQCOM](../chapters/renderpass.html#vkGetDynamicRenderingTilePropertiesQCOM)

* 
[vkGetFramebufferTilePropertiesQCOM](../chapters/framebuffer.html#vkGetFramebufferTilePropertiesQCOM)

* 
[VkTilePropertiesQCOM](../chapters/renderpass.html#VkTilePropertiesQCOM)

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceTilePropertiesFeaturesQCOM](../chapters/features.html#VkPhysicalDeviceTilePropertiesFeaturesQCOM)

If [VK_KHR_dynamic_rendering](#VK_KHR_dynamic_rendering) or [Vulkan Version 1.3](versions.html#versions-1.3) is supported:

* 
[VkRenderingInfoKHR](../chapters/renderpass.html#VkRenderingInfoKHR)

* 
`VK_QCOM_TILE_PROPERTIES_EXTENSION_NAME`

* 
`VK_QCOM_TILE_PROPERTIES_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM`

* 
`VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM`

* 
Revision 1, 2022-07-11 (Arpit Agarwal)

Initial version

**Name String**

`VK_QCOM_tile_shading`

**Extension Type**

Device extension

**Registered Extension Number**

310

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_QCOM_tile_properties](#VK_QCOM_tile_properties)

or

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

**SPIR-V Dependencies**

* 
[SPV_QCOM_tile_shading](https://github.khronos.org/SPIRV-Registry/extensions/QCOM/SPV_QCOM_tile_shading.html)

**Contact**

* 
Matthew Netsch [mnetsch](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_QCOM_tile_shading] @mnetsch%0A*Here describe the issue or question you have about the VK_QCOM_tile_shading extension*)

**Extension Proposal**

[VK_QCOM_tile_shading](../../../features/latest/features/proposals/VK_QCOM_tile_shading.html)

**Last Modified Date**

2025-5-12

**IP Status**

No known IP claims.

**Interactions and External Dependencies**

* 
This extension interacts with `[VK_KHR_dynamic_rendering](#VK_KHR_dynamic_rendering)`

* 
This extension interacts with `[VK_EXT_transform_feedback](#VK_EXT_transform_feedback)`

* 
This extension interacts with `[VK_EXT_debug_marker](#VK_EXT_debug_marker)`

* 
This extension interacts with
`[VK_EXT_attachment_feedback_loop_layout](#VK_EXT_attachment_feedback_loop_layout)`

* 
This extension interacts with
`[VK_KHR_dynamic_rendering_local_read](#VK_KHR_dynamic_rendering_local_read)`

* 
This extension interacts with `[VK_QCOM_image_processing](#VK_QCOM_image_processing)`

**Contributors**

* 
Jeff Leger, Qualcomm

* 
Matt Netsch, Qualcomm

* 
Srihari Babu Alla, Qualcomm

* 
Matthew Smith, Qualcomm

* 
Kevin Matlage, Qualcomm

* 
Alex Bourd, Qualcomm

This extension exposes tile shading in Vulkan.
Many mobile GPUs utilize Tile-Based Deferred Rendering (TBDR) to optimize
for power and performance.
Conversely, most desktop GPUs use immediate-mode rendering (IM).
Adreno  GPUs uniquely have the ability to operate in either mode, and
when this extension is not enabled, the Adreno driver will select the most
optimal mode (TBDR or IM) based on the workload; this feature is called
FlexRender .
When this extension is in use, FlexRender is disabled and the GPU operates
exclusively in TBDR wherever possible.

The TBDR mode divides the color and depth/stencil buffer attachments into a
regular grid of smaller regions called "tiles".
When a render pass instance is submitted for execution on an Adreno GPU, the
rendering is split into two phases: a single "visibility pass" followed by
multiple "rendering passes" where a separate render pass is issued for each
tile in the framebuffer.

The "visibility pass" processes the geometry: identifies which tiles are
covered by each primitive, eliminates occluded primitives and unneeded state
changes, and performs other tile-specific optimizations.
The primitive coverage information collected during the visibility pass is
used in the subsequent "rendering pass" for each tile.
During the rendering pass for each tile, any primitives that were determined
not to cover the current tile are skipped.

This deferred rasterization additionally utilizes a specialized
high-bandwidth on-die memory, "tile memory".
Tile memory is dramatically more efficient than other device memory.
The tile memory temporarily stores the color and other attachments for each
tile during rasterization.
After each tile is fully rasterized, the resulting tile is typically copied
to device memory backing the attachment as specified by the render pass
STORE_OP.
The per-tile rendering passes occur independently for each tile, with
multiple tiles potentially being processed in parallel.

This extension enables applications to leverage the power and performance of
tile memory in new ways:

* 
Adds a mechanism for recording dispatches or draws that are guaranteed
to be executed per-tile.

* 
Such draws bypass the above-mentioned visibility-based skipping and are
guaranteed to be executed for every tile in the rendering pass.

* 
Shaders can declare "tile attachments" variables, providing shader
access to color, depth/stencil, and input attachment pixels.

* 
Fragment and compute shaders can read these render pass attachments at
any location within the tile.
Compute shaders can also write to color attachments at any location
within the tile.

* 
Shaders can use new built-in variables that provide the location, size,
and apron region of the tile.

* 
A new tile dispatch command automatically scales workgroup sizes and
counts to the tile size, given a desired shading rate.

* 
Framebuffer-local dependencies are expanded to tile-sized regions,
rather than a single pixel or sample.

* 
A tile shading render pass can also enable tiling "aprons".
This is a specialized rendering mode where the GPU renders overlapping
tiles that enable specific use-cases.

* 
[vkCmdBeginPerTileExecutionQCOM](../chapters/renderpass.html#vkCmdBeginPerTileExecutionQCOM)

* 
[vkCmdDispatchTileQCOM](../chapters/dispatch.html#vkCmdDispatchTileQCOM)

* 
[vkCmdEndPerTileExecutionQCOM](../chapters/renderpass.html#vkCmdEndPerTileExecutionQCOM)

* 
[VkDispatchTileInfoQCOM](../chapters/dispatch.html#VkDispatchTileInfoQCOM)

* 
[VkPerTileBeginInfoQCOM](../chapters/renderpass.html#VkPerTileBeginInfoQCOM)

* 
[VkPerTileEndInfoQCOM](../chapters/renderpass.html#VkPerTileEndInfoQCOM)

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceTileShadingFeaturesQCOM](../chapters/features.html#VkPhysicalDeviceTileShadingFeaturesQCOM)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceTileShadingPropertiesQCOM](../chapters/limits.html#VkPhysicalDeviceTileShadingPropertiesQCOM)

Extending [VkRenderPassCreateInfo](../chapters/renderpass.html#VkRenderPassCreateInfo), [VkRenderPassCreateInfo2](../chapters/renderpass.html#VkRenderPassCreateInfo2), [VkRenderingInfo](../chapters/renderpass.html#VkRenderingInfo), [VkCommandBufferInheritanceInfo](../chapters/cmdbuffers.html#VkCommandBufferInheritanceInfo):

* 
[VkRenderPassTileShadingCreateInfoQCOM](../chapters/renderpass.html#VkRenderPassTileShadingCreateInfoQCOM)

* 
[VkTileShadingRenderPassFlagBitsQCOM](../chapters/renderpass.html#VkTileShadingRenderPassFlagBitsQCOM)

* 
[VkTileShadingRenderPassFlagsQCOM](../chapters/renderpass.html#VkTileShadingRenderPassFlagsQCOM)

* 
`VK_QCOM_TILE_SHADING_EXTENSION_NAME`

* 
`VK_QCOM_TILE_SHADING_SPEC_VERSION`

* 
Extending [VkAccessFlagBits2](../chapters/synchronization.html#VkAccessFlagBits2):

`VK_ACCESS_2_SHADER_TILE_ATTACHMENT_READ_BIT_QCOM`

* 
`VK_ACCESS_2_SHADER_TILE_ATTACHMENT_WRITE_BIT_QCOM`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_DISPATCH_TILE_INFO_QCOM`

* 
`VK_STRUCTURE_TYPE_PER_TILE_BEGIN_INFO_QCOM`

* 
`VK_STRUCTURE_TYPE_PER_TILE_END_INFO_QCOM`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_FEATURES_QCOM`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_PROPERTIES_QCOM`

* 
`VK_STRUCTURE_TYPE_RENDER_PASS_TILE_SHADING_CREATE_INFO_QCOM`

Extending [VkSubpassDescriptionFlagBits](../chapters/renderpass.html#VkSubpassDescriptionFlagBits):

* 
`VK_SUBPASS_DESCRIPTION_TILE_SHADING_APRON_BIT_QCOM`

* 
[`TileOffsetQCOM`](../chapters/interfaces.html#interfaces-builtin-variables-tileoffset)

* 
[`TileDimensionQCOM`](../chapters/interfaces.html#interfaces-builtin-variables-tilesize)

* 
[`TileApronSizeQCOM`](../chapters/interfaces.html#interfaces-builtin-variables-tileapronsize)

* 
[`TileShadingQCOM`](spirvenv.html#spirvenv-capabilities-table-TileShadingQCOM)

* 
none

* 
Revision 1, 2023-10-12 (Jeff Leger)

**Name String**

`VK_QCOM_ycbcr_degamma`

**Extension Type**

Device extension

**Registered Extension Number**

521

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

None

**Contact**

* 
Matthew Netsch [mnetsch](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_QCOM_ycbcr_degamma] @mnetsch%0A*Here describe the issue or question you have about the VK_QCOM_ycbcr_degamma extension*)

**Last Modified Date**

2023-07-31

**IP Status**

No known IP claims.

**Interactions and External Dependencies**

None

**Contributors**

* 
Jeff Leger, Qualcomm

* 
Jonathan Wicks, Qualcomm

This extension allows implementations to expose support for sRGB EOTF
also known as sRGB degamma, used in combination with images using 8-bit
YCBCR formats.
In addition, the degamma can be selectively applied to the Y (luma) or CrCb
(chroma).

`[VK_KHR_sampler_ycbcr_conversion](#VK_KHR_sampler_ycbcr_conversion)` adds support for YCBCR
conversion, but allows texture sampling in a non-linear space which can
cause artifacts.
This extension allows implementations to expose sRGB degamma for YCBCR
formats, which is performed during texture filtering, allowing texture
filtering to operate in a linear space.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceYcbcrDegammaFeaturesQCOM](../chapters/features.html#VkPhysicalDeviceYcbcrDegammaFeaturesQCOM)

Extending [VkSamplerYcbcrConversionCreateInfo](../chapters/samplers.html#VkSamplerYcbcrConversionCreateInfo):

* 
[VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM](../chapters/samplers.html#VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM)

* 
`VK_QCOM_YCBCR_DEGAMMA_EXTENSION_NAME`

* 
`VK_QCOM_YCBCR_DEGAMMA_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM`

* 
`VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM`

1) Which YCBCR formats support the degamma feature?

**RESOLVED**: For implementations that support the extension, each format that
contains 8-bit R, G, and B components and supports either
`VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT` or
`VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT` must support degamma.

Since non-compressed Vulkan sRGB formats are already limited to 8-bit
components, and since Adreno supports degamma for all 8bit YCBCR formats,
this extension does not introduce a new VK_FORMAT_FEATURE* bit for the
degamma feature.

2) On which YCBCR components is the degamma applied?

**RESOLVED**: While degamma is expected to be applied to only the Y (luma)
component, the extension provides the ability to selectively enable degamma
for both the Y (luma) and/or CbCr (chroma) components.

3) Should degamma be enabled for the sampler object or for the image view
object?

**RESOLVED**: Both.
This extension extends [VkSamplerYcbcrConversionCreateInfo](../chapters/samplers.html#VkSamplerYcbcrConversionCreateInfo) and the
specification already requires that both sampler and view objects must be
created with an *identical* [VkSamplerYcbcrConversionCreateInfo](../chapters/samplers.html#VkSamplerYcbcrConversionCreateInfo) in
their pNext chains.

4) Why apply the sRGB transfer function directly to YCBCR data when it
would be more correct to use the ITU transfer function, and do so only
after the values have been converted into non-linear RGB'?

**RESOLVED**: YCBCR is frequently stored according to standards (e.g. BT.601
and BT.709) that specify that the conversion between linear and non-linear
should use the ITU Transfer function.
The ITU transfer function is mathematically different from the sRGB transfer
function and while sRGB and ITU define similar curves, the difference is
significant.
Performing the sRGB degamma prior to range expansion can introduce
artifacts if the content uses `VK_SAMPLER_YCBCR_RANGE_ITU_NARROW`
encoding.
Nevertheless, using sRGB can make sense for certain use cases where camera
YCbCr images are known to be encoded with sRGB (or a pure gamma 2.2)
transfer function and are known to use full-range encoding.

For those use cases, this extension leverages the GPU ability to enable sRGB
degamma at little cost, and can improve quality because texture filtering is
able to occur in linear space.

* 
Revision 1, 2023-07-31 (Jeff Leger)

**Name String**

`VK_QNX_external_memory_screen_buffer`

**Extension Type**

Device extension

**Registered Extension Number**

530

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

 [VK_KHR_sampler_ycbcr_conversion](#VK_KHR_sampler_ycbcr_conversion)

 and

 [VK_KHR_external_memory](#VK_KHR_external_memory)

 and

 [VK_KHR_dedicated_allocation](#VK_KHR_dedicated_allocation)

 or

 [Vulkan Version 1.1](versions.html#versions-1.1)

and

[VK_EXT_queue_family_foreign](#VK_EXT_queue_family_foreign)

**Contact**

* 
Mike Gorchak [mgorchak-blackberry](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_QNX_external_memory_screen_buffer] @mgorchak-blackberry%0A*Here describe the issue or question you have about the VK_QNX_external_memory_screen_buffer extension*)

* 
Aaron Ruby [aruby-blackberry](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_QNX_external_memory_screen_buffer] @aruby-blackberry%0A*Here describe the issue or question you have about the VK_QNX_external_memory_screen_buffer extension*)

**Last Modified Date**

2023-05-17

**IP Status**

No known IP claims.

**Contributors**

* 
Mike Gorchak, QNX / Blackberry Limited

* 
Aaron Ruby, QNX / Blackberry Limited

This extension enables an application to import QNX Screen
`_screen_buffer` objects created outside of the Vulkan device into Vulkan
memory objects, where they can be bound to images and buffers.

Some `_screen_buffer` images have implementation-defined *external
formats* that **may** not correspond to Vulkan formats.
Sampler YCBCR conversion **can** be used to sample from these images and
convert them to a known color space.

`_screen_buffer` is strongly typed, so naming the handle type is
redundant.
The internal layout and therefore size of a `_screen_buffer` image may
depend on native usage flags that do not have corresponding Vulkan
counterparts.

* 
[vkGetScreenBufferPropertiesQNX](../chapters/memory.html#vkGetScreenBufferPropertiesQNX)

* 
[VkScreenBufferPropertiesQNX](../chapters/memory.html#VkScreenBufferPropertiesQNX)

* 
Extending [VkImageCreateInfo](../chapters/resources.html#VkImageCreateInfo), [VkSamplerYcbcrConversionCreateInfo](../chapters/samplers.html#VkSamplerYcbcrConversionCreateInfo):

[VkExternalFormatQNX](../chapters/resources.html#VkExternalFormatQNX)

Extending [VkMemoryAllocateInfo](../chapters/memory.html#VkMemoryAllocateInfo):

* 
[VkImportScreenBufferInfoQNX](../chapters/memory.html#VkImportScreenBufferInfoQNX)

Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

* 
[VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX](../chapters/features.html#VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX)

Extending [VkScreenBufferPropertiesQNX](../chapters/memory.html#VkScreenBufferPropertiesQNX):

* 
[VkScreenBufferFormatPropertiesQNX](../chapters/memory.html#VkScreenBufferFormatPropertiesQNX)

* 
`VK_QNX_EXTERNAL_MEMORY_SCREEN_BUFFER_EXTENSION_NAME`

* 
`VK_QNX_EXTERNAL_MEMORY_SCREEN_BUFFER_SPEC_VERSION`

* 
Extending [VkExternalMemoryHandleTypeFlagBits](../chapters/capabilities.html#VkExternalMemoryHandleTypeFlagBits):

`VK_EXTERNAL_MEMORY_HANDLE_TYPE_SCREEN_BUFFER_BIT_QNX`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX`

* 
`VK_STRUCTURE_TYPE_IMPORT_SCREEN_BUFFER_INFO_QNX`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCREEN_BUFFER_FEATURES_QNX`

* 
`VK_STRUCTURE_TYPE_SCREEN_BUFFER_FORMAT_PROPERTIES_QNX`

* 
`VK_STRUCTURE_TYPE_SCREEN_BUFFER_PROPERTIES_QNX`

* 
Revision 1, 2023-05-17 (Mike Gorchak)

Initial version

**Name String**

`VK_QNX_screen_surface`

**Extension Type**

Instance extension

**Registered Extension Number**

379

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_surface](#VK_KHR_surface)

**Contact**

* 
Mike Gorchak [mgorchak-blackberry](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_QNX_screen_surface] @mgorchak-blackberry%0A*Here describe the issue or question you have about the VK_QNX_screen_surface extension*)

**Last Modified Date**

2021-01-11

**IP Status**

No known IP claims.

**Contributors**

* 
Mike Gorchak, BlackBerry Limited

The `VK_QNX_screen_surface` extension is an instance extension.
It provides a mechanism to create a [VkSurfaceKHR](../chapters/VK_KHR_surface/wsi.html#VkSurfaceKHR) object (defined by
the `[VK_KHR_surface](#VK_KHR_surface)` extension) that refers to a QNX Screen
`window`, as well as a query to determine support for rendering to a QNX
Screen compositor.

* 
[vkCreateScreenSurfaceQNX](../chapters/VK_KHR_surface/wsi.html#vkCreateScreenSurfaceQNX)

* 
[vkGetPhysicalDeviceScreenPresentationSupportQNX](../chapters/VK_KHR_surface/wsi.html#vkGetPhysicalDeviceScreenPresentationSupportQNX)

* 
[VkScreenSurfaceCreateInfoQNX](../chapters/VK_KHR_surface/wsi.html#VkScreenSurfaceCreateInfoQNX)

* 
[VkScreenSurfaceCreateFlagsQNX](../chapters/VK_KHR_surface/wsi.html#VkScreenSurfaceCreateFlagsQNX)

* 
`VK_QNX_SCREEN_SURFACE_EXTENSION_NAME`

* 
`VK_QNX_SCREEN_SURFACE_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_SCREEN_SURFACE_CREATE_INFO_QNX`

* 
Revision 1, 2021-01-11 (Mike Gorchak)

Initial draft.

**Name String**

`VK_SEC_amigo_profiling`

**Extension Type**

Device extension

**Registered Extension Number**

486

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Contact**

* 
Ralph Potter r_potter

**Last Modified Date**

2022-07-29

**IP Status**

No known IP claims.

**Contributors**

* 
Ralph Potter, Samsung

* 
Sangrak Oh, Samsung

* 
Jinku Kang, Samsung

This extension is intended to communicate information from layered API
implementations such as ANGLE to internal proprietary system schedulers.
It has no behavioral implications beyond enabling more intelligent behavior
from the system scheduler.

Application developers should avoid using this extension.
It is documented solely for the benefit of tools and layer developers, who
may need to manipulate `pNext` chains that include these structures.

|  | There is currently no specification language written for this extension.
| --- | --- |
The links to APIs defined by the extension are to stubs that only include
generated content such as API declarations and implicit valid usage
statements. |

|  | This extension is only intended for use in specific embedded environments
| --- | --- |
with known implementation details, and is therefore undocumented. |

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceAmigoProfilingFeaturesSEC](#VkPhysicalDeviceAmigoProfilingFeaturesSEC)

Extending [VkSubmitInfo](../chapters/cmdbuffers.html#VkSubmitInfo):

* 
[VkAmigoProfilingSubmitInfoSEC](#VkAmigoProfilingSubmitInfoSEC)

* 
`VK_SEC_AMIGO_PROFILING_EXTENSION_NAME`

* 
`VK_SEC_AMIGO_PROFILING_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC`

There is currently no specification language written for this type.
This section acts only as placeholder and to avoid dead links in the
specification and reference pages.

// Provided by VK_SEC_amigo_profiling
typedef struct VkPhysicalDeviceAmigoProfilingFeaturesSEC {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           amigoProfiling;
} VkPhysicalDeviceAmigoProfilingFeaturesSEC;

Valid Usage (Implicit)

* 
[](#VUID-VkPhysicalDeviceAmigoProfilingFeaturesSEC-sType-sType) VUID-VkPhysicalDeviceAmigoProfilingFeaturesSEC-sType-sType

 `sType` **must** be `VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC`

There is currently no specification language written for this type.
This section acts only as placeholder and to avoid dead links in the
specification and reference pages.

// Provided by VK_SEC_amigo_profiling
typedef struct VkAmigoProfilingSubmitInfoSEC {
    VkStructureType    sType;
    const void*        pNext;
    uint64_t           firstDrawTimestamp;
    uint64_t           swapBufferTimestamp;
} VkAmigoProfilingSubmitInfoSEC;

Valid Usage (Implicit)

* 
[](#VUID-VkAmigoProfilingSubmitInfoSEC-sType-sType) VUID-VkAmigoProfilingSubmitInfoSEC-sType-sType

 `sType` **must** be `VK_STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC`

* 
Revision 1, 2022-07-29 (Ralph Potter)

Initial specification

**Name String**

`VK_VALVE_descriptor_set_host_mapping`

**Extension Type**

Device extension

**Registered Extension Number**

421

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Special Use**

* 
[D3D support](../chapters/extensions.html#extendingvulkan-compatibility-specialuse)

**Contact**

* 
Hans-Kristian Arntzen [HansKristian-Work](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_VALVE_descriptor_set_host_mapping] @HansKristian-Work%0A*Here describe the issue or question you have about the VK_VALVE_descriptor_set_host_mapping extension*)

**Last Modified Date**

2022-02-22

**IP Status**

No known IP claims.

**Contributors**

* 
Hans-Kristian Arntzen, Valve

This extension allows applications to directly query a host pointer for a
[VkDescriptorSet](../chapters/descriptorsets.html#VkDescriptorSet) which **can** be used to copy descriptors between
descriptor sets without the use of an API command.
Memory offsets and sizes for descriptors **can** be queried from a
[VkDescriptorSetLayout](../chapters/descriptorsets.html#VkDescriptorSetLayout) as well.

|  | There is currently no specification language written for this extension.
| --- | --- |
The links to APIs defined by the extension are to stubs that only include
generated content such as API declarations and implicit valid usage
statements. |

|  | This extension is only intended for use in specific embedded environments
| --- | --- |
with known implementation details, and is therefore undocumented. |

* 
[vkGetDescriptorSetHostMappingVALVE](#vkGetDescriptorSetHostMappingVALVE)

* 
[vkGetDescriptorSetLayoutHostMappingInfoVALVE](#vkGetDescriptorSetLayoutHostMappingInfoVALVE)

* 
[VkDescriptorSetBindingReferenceVALVE](#VkDescriptorSetBindingReferenceVALVE)

* 
[VkDescriptorSetLayoutHostMappingInfoVALVE](#VkDescriptorSetLayoutHostMappingInfoVALVE)

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE](#VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE)

* 
`VK_VALVE_DESCRIPTOR_SET_HOST_MAPPING_EXTENSION_NAME`

* 
`VK_VALVE_DESCRIPTOR_SET_HOST_MAPPING_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE`

* 
`VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE`

There is currently no specification language written for this command.
This section acts only as placeholder and to avoid dead links in the
specification and reference pages.

// Provided by VK_VALVE_descriptor_set_host_mapping
void vkGetDescriptorSetLayoutHostMappingInfoVALVE(
    VkDevice                                    device,
    const VkDescriptorSetBindingReferenceVALVE* pBindingReference,
    VkDescriptorSetLayoutHostMappingInfoVALVE*  pHostMapping);

Valid Usage (Implicit)

* 
[](#VUID-vkGetDescriptorSetLayoutHostMappingInfoVALVE-device-parameter) VUID-vkGetDescriptorSetLayoutHostMappingInfoVALVE-device-parameter

 `device` **must** be a valid [VkDevice](../chapters/devsandqueues.html#VkDevice) handle

* 
[](#VUID-vkGetDescriptorSetLayoutHostMappingInfoVALVE-pBindingReference-parameter) VUID-vkGetDescriptorSetLayoutHostMappingInfoVALVE-pBindingReference-parameter

 `pBindingReference` **must** be a valid pointer to a valid [VkDescriptorSetBindingReferenceVALVE](#VkDescriptorSetBindingReferenceVALVE) structure

* 
[](#VUID-vkGetDescriptorSetLayoutHostMappingInfoVALVE-pHostMapping-parameter) VUID-vkGetDescriptorSetLayoutHostMappingInfoVALVE-pHostMapping-parameter

 `pHostMapping` **must** be a valid pointer to a [VkDescriptorSetLayoutHostMappingInfoVALVE](#VkDescriptorSetLayoutHostMappingInfoVALVE) structure

There is currently no specification language written for this command.
This section acts only as placeholder and to avoid dead links in the
specification and reference pages.

// Provided by VK_VALVE_descriptor_set_host_mapping
void vkGetDescriptorSetHostMappingVALVE(
    VkDevice                                    device,
    VkDescriptorSet                             descriptorSet,
    void**                                      ppData);

Valid Usage (Implicit)

* 
[](#VUID-vkGetDescriptorSetHostMappingVALVE-device-parameter) VUID-vkGetDescriptorSetHostMappingVALVE-device-parameter

 `device` **must** be a valid [VkDevice](../chapters/devsandqueues.html#VkDevice) handle

* 
[](#VUID-vkGetDescriptorSetHostMappingVALVE-descriptorSet-parameter) VUID-vkGetDescriptorSetHostMappingVALVE-descriptorSet-parameter

 `descriptorSet` **must** be a valid [VkDescriptorSet](../chapters/descriptorsets.html#VkDescriptorSet) handle

* 
[](#VUID-vkGetDescriptorSetHostMappingVALVE-ppData-parameter) VUID-vkGetDescriptorSetHostMappingVALVE-ppData-parameter

 `ppData` **must** be a valid pointer to a pointer value

* 
[](#VUID-vkGetDescriptorSetHostMappingVALVE-descriptorSet-parent) VUID-vkGetDescriptorSetHostMappingVALVE-descriptorSet-parent

 `descriptorSet` **must** have been created, allocated, or retrieved from `device`

There is currently no specification language written for this type.
This section acts only as placeholder and to avoid dead links in the
specification and reference pages.

// Provided by VK_VALVE_descriptor_set_host_mapping
typedef struct VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           descriptorSetHostMapping;
} VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE;

Valid Usage (Implicit)

* 
[](#VUID-VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE-sType-sType) VUID-VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE-sType-sType

 `sType` **must** be `VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE`

There is currently no specification language written for this type.
This section acts only as placeholder and to avoid dead links in the
specification and reference pages.

// Provided by VK_VALVE_descriptor_set_host_mapping
typedef struct VkDescriptorSetBindingReferenceVALVE {
    VkStructureType          sType;
    const void*              pNext;
    VkDescriptorSetLayout    descriptorSetLayout;
    uint32_t                 binding;
} VkDescriptorSetBindingReferenceVALVE;

Valid Usage (Implicit)

* 
[](#VUID-VkDescriptorSetBindingReferenceVALVE-sType-sType) VUID-VkDescriptorSetBindingReferenceVALVE-sType-sType

 `sType` **must** be `VK_STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE`

* 
[](#VUID-VkDescriptorSetBindingReferenceVALVE-pNext-pNext) VUID-VkDescriptorSetBindingReferenceVALVE-pNext-pNext

 `pNext` **must** be `NULL`

* 
[](#VUID-VkDescriptorSetBindingReferenceVALVE-descriptorSetLayout-parameter) VUID-VkDescriptorSetBindingReferenceVALVE-descriptorSetLayout-parameter

 `descriptorSetLayout` **must** be a valid [VkDescriptorSetLayout](../chapters/descriptorsets.html#VkDescriptorSetLayout) handle

There is currently no specification language written for this type.
This section acts only as placeholder and to avoid dead links in the
specification and reference pages.

// Provided by VK_VALVE_descriptor_set_host_mapping
typedef struct VkDescriptorSetLayoutHostMappingInfoVALVE {
    VkStructureType    sType;
    void*              pNext;
    size_t             descriptorOffset;
    uint32_t           descriptorSize;
} VkDescriptorSetLayoutHostMappingInfoVALVE;

Valid Usage (Implicit)

* 
[](#VUID-VkDescriptorSetLayoutHostMappingInfoVALVE-sType-sType) VUID-VkDescriptorSetLayoutHostMappingInfoVALVE-sType-sType

 `sType` **must** be `VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE`

* 
[](#VUID-VkDescriptorSetLayoutHostMappingInfoVALVE-pNext-pNext) VUID-VkDescriptorSetLayoutHostMappingInfoVALVE-pNext-pNext

 `pNext` **must** be `NULL`

* 
Revision 1, 2022-02-22 (Hans-Kristian Arntzen)

Initial specification

**Name String**

`VK_KHR_portability_subset`

**Extension Type**

Device extension

**Registered Extension Number**

164

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

* 
**This is a *provisional* extension and must** be used with caution.
See the [description](boilerplate.html#boilerplate-provisional-header) of provisional header files for enablement and stability details.

**Contact**

* 
Bill Hollings [billhollings](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_portability_subset] @billhollings%0A*Here describe the issue or question you have about the VK_KHR_portability_subset extension*)

**Last Modified Date**

2020-07-21

**IP Status**

No known IP claims.

**Contributors**

* 
Bill Hollings, The Brenwill Workshop Ltd.

* 
Daniel Koch, NVIDIA

* 
Dzmitry Malyshau, Mozilla

* 
Chip Davis, CodeWeavers

* 
Dan Ginsburg, Valve

* 
Mike Weiblen, LunarG

* 
Neil Trevett, NVIDIA

* 
Alexey Knyazev, Independent

The `[VK_KHR_portability_subset](#VK_KHR_portability_subset)` extension allows a non-conformant
Vulkan implementation to be built on top of another non-Vulkan graphics API,
and identifies differences between that implementation and a
fully-conformant native Vulkan implementation.

This extension provides Vulkan implementations with the ability to mark
otherwise-required capabilities as unsupported, or to establish additional
properties and limits that the application should adhere to in order to
guarantee portable behavior and operation across platforms, including
platforms where Vulkan is not natively supported.

The goal of this specification is to document, and make queryable,
capabilities which are required to be supported by a fully-conformant Vulkan
1.0 implementation, but may be optional for an implementation of the Vulkan
1.0 Portability Subset.

The intent is that this extension will be advertised only on implementations
of the Vulkan 1.0 Portability Subset, and not on conformant implementations
of Vulkan 1.0.
Fully-conformant Vulkan implementations provide all the required
capabilities, and so will not provide this extension.
Therefore, the existence of this extension can be used to determine that an
implementation is likely not fully conformant with the Vulkan spec.

If this extension is supported by the Vulkan implementation, the application
must enable this extension.

This extension defines several new structures that can be chained to the
existing structures used by certain standard Vulkan calls, in order to query
for non-conformant portable behavior.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDevicePortabilitySubsetFeaturesKHR](../chapters/features.html#VkPhysicalDevicePortabilitySubsetFeaturesKHR)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDevicePortabilitySubsetPropertiesKHR](../chapters/limits.html#VkPhysicalDevicePortabilitySubsetPropertiesKHR)

* 
`VK_KHR_PORTABILITY_SUBSET_EXTENSION_NAME`

* 
`VK_KHR_PORTABILITY_SUBSET_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR`

None.

* 
Revision 1, 2020-07-21 (Bill Hollings)

Initial draft.

**Name String**

`VK_AMDX_shader_enqueue`

**Extension Type**

Device extension

**Registered Extension Number**

135

**Revision**

2

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

 [VK_KHR_synchronization2](#VK_KHR_synchronization2)

 and

 [VK_KHR_spirv_1_4](#VK_KHR_spirv_1_4)

 and

 [VK_EXT_extended_dynamic_state](#VK_EXT_extended_dynamic_state)

 or

 [Vulkan Version 1.3](versions.html#versions-1.3)

and

[VK_KHR_maintenance5](#VK_KHR_maintenance5)

and

[VK_KHR_pipeline_library](#VK_KHR_pipeline_library)

* 
**This is a *provisional* extension and must** be used with caution.
See the [description](boilerplate.html#boilerplate-provisional-header) of provisional header files for enablement and stability details.

**API Interactions**

* 
Interacts with VK_VERSION_1_4

* 
Interacts with VK_EXT_mesh_shader

* 
Interacts with VK_KHR_maintenance5

**SPIR-V Dependencies**

* 
[SPV_AMDX_shader_enqueue](https://github.khronos.org/SPIRV-Registry/extensions/AMDX/SPV_AMDX_shader_enqueue.html)

**Contact**

* 
Tobias Hector [tobski](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_AMDX_shader_enqueue] @tobski%0A*Here describe the issue or question you have about the VK_AMDX_shader_enqueue extension*)

**Extension Proposal**

[VK_AMDX_shader_enqueue](../../../features/latest/features/proposals/VK_AMDX_shader_enqueue.html)

**Last Modified Date**

2024-07-17

**Provisional**

**This extension is *provisional* and should** not be used in production
applications.
The functionality **may** change in ways that break backwards compatibility
between revisions, and before final release.

**Contributors**

* 
Tobias Hector, AMD

* 
Matthaeus Chajdas, AMD

* 
Maciej Jesionowski, AMD

* 
Robert Martin, AMD

* 
Qun Lin, AMD

* 
Rex Xu, AMD

* 
Dominik Witczak, AMD

* 
Karthik Srinivasan, AMD

* 
Nicolai Haehnle, AMD

* 
Stuart Smith, AMD

This extension adds the ability for developers to enqueue mesh and compute
shader workgroups from other compute shaders.

* 
[vkCmdDispatchGraphAMDX](../chapters/executiongraphs.html#vkCmdDispatchGraphAMDX)

* 
[vkCmdDispatchGraphIndirectAMDX](../chapters/executiongraphs.html#vkCmdDispatchGraphIndirectAMDX)

* 
[vkCmdDispatchGraphIndirectCountAMDX](../chapters/executiongraphs.html#vkCmdDispatchGraphIndirectCountAMDX)

* 
[vkCmdInitializeGraphScratchMemoryAMDX](../chapters/executiongraphs.html#vkCmdInitializeGraphScratchMemoryAMDX)

* 
[vkCreateExecutionGraphPipelinesAMDX](../chapters/executiongraphs.html#vkCreateExecutionGraphPipelinesAMDX)

* 
[vkGetExecutionGraphPipelineNodeIndexAMDX](../chapters/executiongraphs.html#vkGetExecutionGraphPipelineNodeIndexAMDX)

* 
[vkGetExecutionGraphPipelineScratchSizeAMDX](../chapters/executiongraphs.html#vkGetExecutionGraphPipelineScratchSizeAMDX)

* 
[VkDispatchGraphCountInfoAMDX](../chapters/executiongraphs.html#VkDispatchGraphCountInfoAMDX)

* 
[VkDispatchGraphInfoAMDX](../chapters/executiongraphs.html#VkDispatchGraphInfoAMDX)

* 
[VkExecutionGraphPipelineCreateInfoAMDX](../chapters/executiongraphs.html#VkExecutionGraphPipelineCreateInfoAMDX)

* 
[VkExecutionGraphPipelineScratchSizeAMDX](../chapters/executiongraphs.html#VkExecutionGraphPipelineScratchSizeAMDX)

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceShaderEnqueueFeaturesAMDX](../chapters/features.html#VkPhysicalDeviceShaderEnqueueFeaturesAMDX)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceShaderEnqueuePropertiesAMDX](../chapters/limits.html#VkPhysicalDeviceShaderEnqueuePropertiesAMDX)

Extending [VkPipelineShaderStageCreateInfo](../chapters/pipelines.html#VkPipelineShaderStageCreateInfo):

* 
[VkPipelineShaderStageNodeCreateInfoAMDX](../chapters/executiongraphs.html#VkPipelineShaderStageNodeCreateInfoAMDX)

* 
[VkDeviceOrHostAddressConstAMDX](../chapters/executiongraphs.html#VkDeviceOrHostAddressConstAMDX)

* 
`VK_AMDX_SHADER_ENQUEUE_EXTENSION_NAME`

* 
`VK_AMDX_SHADER_ENQUEUE_SPEC_VERSION`

* 
`VK_SHADER_INDEX_UNUSED_AMDX`

* 
Extending [VkBufferUsageFlagBits](../chapters/resources.html#VkBufferUsageFlagBits):

`VK_BUFFER_USAGE_EXECUTION_GRAPH_SCRATCH_BIT_AMDX`

Extending [VkPipelineBindPoint](../chapters/pipelines.html#VkPipelineBindPoint):

* 
`VK_PIPELINE_BIND_POINT_EXECUTION_GRAPH_AMDX`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_CREATE_INFO_AMDX`

* 
`VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_SCRATCH_SIZE_AMDX`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_FEATURES_AMDX`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_PROPERTIES_AMDX`

* 
`VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_NODE_CREATE_INFO_AMDX`

If [VK_KHR_maintenance5](#VK_KHR_maintenance5) or [Vulkan Version 1.4](versions.html#versions-1.4) is supported:

* 
Extending [VkBufferUsageFlagBits2](../chapters/resources.html#VkBufferUsageFlagBits2):

`VK_BUFFER_USAGE_2_EXECUTION_GRAPH_SCRATCH_BIT_AMDX`

Extending [VkPipelineCreateFlagBits2](../chapters/pipelines.html#VkPipelineCreateFlagBits2):

* 
`VK_PIPELINE_CREATE_2_EXECUTION_GRAPH_BIT_AMDX`

* 
Revision 2, 2024-07-17 (Tobias Hector)

Add mesh nodes

Revision 1, 2021-07-22 (Tobias Hector)

* 
Initial revision

**Name String**

`VK_NV_cuda_kernel_launch`

**Extension Type**

Device extension

**Registered Extension Number**

308

**Revision**

2

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

None

* 
**This is a *provisional* extension and must** be used with caution.
See the [description](boilerplate.html#boilerplate-provisional-header) of provisional header files for enablement and stability details.

**API Interactions**

* 
Interacts with VK_EXT_debug_report

**Contact**

* 
Tristan Lorach [tlorach](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NV_cuda_kernel_launch] @tlorach%0A*Here describe the issue or question you have about the VK_NV_cuda_kernel_launch extension*)

**Last Modified Date**

2020-09-30

**Contributors**

* 
Eric Werness, NVIDIA

Interoperability between APIs can sometimes create additional overhead
depending on the platform used.
This extension targets deployment of existing CUDA kernels via Vulkan, with
a way to directly upload PTX kernels and dispatch the kernels from Vulkans
command buffer without the need to use interoperability between the Vulkan
and CUDA contexts.
However, we do encourage actual development using the native CUDA runtime
for the purpose of debugging and profiling.

The application will first have to create a CUDA module using
[vkCreateCudaModuleNV](../chapters/shaders.html#vkCreateCudaModuleNV) then create the CUDA function entry point with
[vkCreateCudaFunctionNV](../chapters/shaders.html#vkCreateCudaFunctionNV).

Then in order to dispatch this function, the application will create a
command buffer where it will launch the kernel with
[vkCmdCudaLaunchKernelNV](../chapters/dispatch.html#vkCmdCudaLaunchKernelNV).

When done, the application will then destroy the function handle, as well as
the CUDA module handle with [vkDestroyCudaFunctionNV](../chapters/shaders.html#vkDestroyCudaFunctionNV) and
[vkDestroyCudaModuleNV](../chapters/shaders.html#vkDestroyCudaModuleNV).

To reduce the impact of compilation time, this extension offers the
capability to return a binary cache from the PTX that was provided.
For this, a first query for the required cache size is made with
[vkGetCudaModuleCacheNV](../chapters/shaders.html#vkGetCudaModuleCacheNV) with a `NULL` pointer to a buffer and with a
valid pointer receiving the size; then another call of the same function
with a valid pointer to a buffer to retrieve the data.
The resulting cache could then be used later for further runs of this
application by sending this cache instead of the PTX code (using the same
[vkCreateCudaModuleNV](../chapters/shaders.html#vkCreateCudaModuleNV)), thus significantly speeding up the
initialization of the CUDA module.

As with [VkPipelineCache](../chapters/pipelines.html#VkPipelineCache), the binary cache depends on the hardware
architecture.
The application must assume the cache might fail, and need to handle falling
back to the original PTX code as necessary.
Most often, the cache will succeed if the same GPU driver and architecture
is used between the cache generation from PTX and the use of this cache.
In the event of a new driver version, or if using a different GPU
architecture, the cache is likely to become invalid.

* 
[VkCudaFunctionNV](../chapters/shaders.html#VkCudaFunctionNV)

* 
[VkCudaModuleNV](../chapters/shaders.html#VkCudaModuleNV)

* 
[vkCmdCudaLaunchKernelNV](../chapters/dispatch.html#vkCmdCudaLaunchKernelNV)

* 
[vkCreateCudaFunctionNV](../chapters/shaders.html#vkCreateCudaFunctionNV)

* 
[vkCreateCudaModuleNV](../chapters/shaders.html#vkCreateCudaModuleNV)

* 
[vkDestroyCudaFunctionNV](../chapters/shaders.html#vkDestroyCudaFunctionNV)

* 
[vkDestroyCudaModuleNV](../chapters/shaders.html#vkDestroyCudaModuleNV)

* 
[vkGetCudaModuleCacheNV](../chapters/shaders.html#vkGetCudaModuleCacheNV)

* 
[VkCudaFunctionCreateInfoNV](../chapters/shaders.html#VkCudaFunctionCreateInfoNV)

* 
[VkCudaLaunchInfoNV](../chapters/dispatch.html#VkCudaLaunchInfoNV)

* 
[VkCudaModuleCreateInfoNV](../chapters/shaders.html#VkCudaModuleCreateInfoNV)

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceCudaKernelLaunchFeaturesNV](../chapters/features.html#VkPhysicalDeviceCudaKernelLaunchFeaturesNV)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceCudaKernelLaunchPropertiesNV](../chapters/limits.html#VkPhysicalDeviceCudaKernelLaunchPropertiesNV)

* 
`VK_NV_CUDA_KERNEL_LAUNCH_EXTENSION_NAME`

* 
`VK_NV_CUDA_KERNEL_LAUNCH_SPEC_VERSION`

* 
Extending [VkObjectType](../chapters/debugging.html#VkObjectType):

`VK_OBJECT_TYPE_CUDA_FUNCTION_NV`

* 
`VK_OBJECT_TYPE_CUDA_MODULE_NV`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_CUDA_FUNCTION_CREATE_INFO_NV`

* 
`VK_STRUCTURE_TYPE_CUDA_LAUNCH_INFO_NV`

* 
`VK_STRUCTURE_TYPE_CUDA_MODULE_CREATE_INFO_NV`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_FEATURES_NV`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_PROPERTIES_NV`

If [VK_EXT_debug_report](#VK_EXT_debug_report) is supported:

* 
Extending [VkDebugReportObjectTypeEXT](../chapters/debugging.html#VkDebugReportObjectTypeEXT):

`VK_DEBUG_REPORT_OBJECT_TYPE_CUDA_FUNCTION_NV_EXT`

* 
`VK_DEBUG_REPORT_OBJECT_TYPE_CUDA_MODULE_NV_EXT`

None.

* 
Revision 1, 2020-03-01 (Tristan Lorach)

* 
Revision 2, 2020-09-30 (Tristan Lorach)

**Name String**

`VK_NV_present_metering`

**Extension Type**

Device extension

**Registered Extension Number**

614

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

None

* 
**This is a *provisional* extension and must** be used with caution.
See the [description](boilerplate.html#boilerplate-provisional-header) of provisional header files for enablement and stability details.

**Contact**

* 
Charles Hansen [chansen](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NV_present_metering] @chansen%0A*Here describe the issue or question you have about the VK_NV_present_metering extension*)

**Last Modified Date**

2025-01-08

**Provisional**

*This extension is *provisional* and **should** not be used in production
applications.
The functionality defined by this extension **may** change in ways that break
backwards compatibility between revisions, and before the final release of
the non-provisional version of this extension.

**Contributors**

* 
Charles Hansen, NVIDIA

* 
Lionel Duc, NVIDIA

This extension is used to evenly meter presents.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDevicePresentMeteringFeaturesNV](../chapters/features.html#VkPhysicalDevicePresentMeteringFeaturesNV)

Extending [VkPresentInfoKHR](../chapters/VK_KHR_surface/wsi.html#VkPresentInfoKHR):

* 
[VkSetPresentConfigNV](../chapters/VK_KHR_surface/wsi.html#VkSetPresentConfigNV)

* 
`VK_NV_PRESENT_METERING_EXTENSION_NAME`

* 
`VK_NV_PRESENT_METERING_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_METERING_FEATURES_NV`

* 
`VK_STRUCTURE_TYPE_SET_PRESENT_CONFIG_NV`

* 
Revision 1, 2025-01-08 (Charles Hansen)

Internal revisions

**Name String**

`VK_KHR_16bit_storage`

**Extension Type**

Device extension

**Registered Extension Number**

84

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

 [VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

 and

 [VK_KHR_storage_buffer_storage_class](#VK_KHR_storage_buffer_storage_class)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**SPIR-V Dependencies**

* 
[SPV_KHR_16bit_storage](https://github.khronos.org/SPIRV-Registry/extensions/KHR/SPV_KHR_16bit_storage.html)

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.1](versions.html#versions-1.1-promotions)

**Contact**

* 
Jan-Harald Fredriksen [janharaldfredriksen-arm](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_16bit_storage] @janharaldfredriksen-arm%0A*Here describe the issue or question you have about the VK_KHR_16bit_storage extension*)

**Last Modified Date**

2017-09-05

**IP Status**

No known IP claims.

**Interactions and External Dependencies**

* 
This extension provides API support for
[`GL_EXT_shader_16bit_storage`](https://github.com/KhronosGroup/GLSL/blob/main/extensions/ext/GL_EXT_shader_16bit_storage.txt)

**Contributors**

* 
Alexander Galazin, ARM

* 
Jan-Harald Fredriksen, ARM

* 
Joerg Wagner, ARM

* 
Neil Henning, Codeplay

* 
Jeff Bolz, Nvidia

* 
Daniel Koch, Nvidia

* 
David Neto, Google

* 
John Kessenich, Google

The `VK_KHR_16bit_storage` extension allows use of 16-bit types in shader
input and output interfaces, and push constant blocks.
This extension introduces several new optional features which map to SPIR-V
capabilities and allow access to 16-bit data in `Block`-decorated objects
in the `Uniform` and the `StorageBuffer` storage classes, and objects
in the `PushConstant` storage class.
This extension allows 16-bit variables to be declared and used as
user-defined shader inputs and outputs but does not change location
assignment and component assignment rules.

All functionality in this extension is included in core Vulkan 1.1, with the
KHR suffix omitted.
However, if Vulkan 1.1 is supported and this extension is not, the
`storageBuffer16BitAccess` capability is optional.
The original type, enum, and command names are still available as aliases of
the core functionality.

If Vulkan 1.4 is supported, support for the `storageBuffer16BitAccess`
capability is required.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDevice16BitStorageFeaturesKHR](../chapters/features.html#VkPhysicalDevice16BitStorageFeaturesKHR)

* 
`VK_KHR_16BIT_STORAGE_EXTENSION_NAME`

* 
`VK_KHR_16BIT_STORAGE_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR`

* 
[    `StorageBuffer16BitAccess`](spirvenv.html#spirvenv-capabilities-table-StorageBuffer16BitAccess)

* 
[    `UniformAndStorageBuffer16BitAccess`](spirvenv.html#spirvenv-capabilities-table-UniformAndStorageBuffer16BitAccess)

* 
[    `StoragePushConstant16`](spirvenv.html#spirvenv-capabilities-table-StoragePushConstant16)

* 
[    `StorageInputOutput16`](spirvenv.html#spirvenv-capabilities-table-StorageInputOutput16)

* 
Revision 1, 2017-03-23 (Alexander Galazin)

Initial draft

**Name String**

`VK_KHR_8bit_storage`

**Extension Type**

Device extension

**Registered Extension Number**

178

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

 [VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

 and

 [VK_KHR_storage_buffer_storage_class](#VK_KHR_storage_buffer_storage_class)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**SPIR-V Dependencies**

* 
[SPV_KHR_8bit_storage](https://github.khronos.org/SPIRV-Registry/extensions/KHR/SPV_KHR_8bit_storage.html)

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.2](versions.html#versions-1.2-promotions)

**Contact**

* 
Alexander Galazin [alegal-arm](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_8bit_storage] @alegal-arm%0A*Here describe the issue or question you have about the VK_KHR_8bit_storage extension*)

**Last Modified Date**

2018-02-05

**Interactions and External Dependencies**

* 
This extension provides API support for
[`GL_EXT_shader_16bit_storage`](https://github.com/KhronosGroup/GLSL/blob/main/extensions/ext/GL_EXT_shader_16bit_storage.txt)

**IP Status**

No known IP claims.

**Contributors**

* 
Alexander Galazin, Arm

The `VK_KHR_8bit_storage` extension allows use of 8-bit types in uniform and
storage buffers, and push constant blocks.
This extension introduces several new optional features which map to SPIR-V
capabilities and allow access to 8-bit data in `Block`-decorated objects
in the `Uniform` and the `StorageBuffer` storage classes, and objects
in the `PushConstant` storage class.

The `StorageBuffer8BitAccess` capability **must** be supported by all
implementations of this extension.
The other capabilities are optional.

Vulkan APIs in this extension are included in core Vulkan 1.2, with the KHR
suffix omitted.
However, if Vulkan 1.2 is supported and this extension is not, the
`StorageBuffer8BitAccess` capability is optional.
External interactions defined by this extension, such as SPIR-V token names,
retain their original names.
The original Vulkan API names are still available as aliases of the core
functionality.

If Vulkan 1.4 is supported, support for the `storageBuffer8BitAccess`
capability is required.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDevice8BitStorageFeaturesKHR](../chapters/features.html#VkPhysicalDevice8BitStorageFeaturesKHR)

* 
`VK_KHR_8BIT_STORAGE_EXTENSION_NAME`

* 
`VK_KHR_8BIT_STORAGE_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR`

* 
[    `StorageBuffer8BitAccess`](spirvenv.html#spirvenv-capabilities-table-StorageBuffer8BitAccess)

* 
[    `UniformAndStorageBuffer8BitAccess`](spirvenv.html#spirvenv-capabilities-table-UniformAndStorageBuffer8BitAccess)

* 
[    `StoragePushConstant8`](spirvenv.html#spirvenv-capabilities-table-StoragePushConstant8)

* 
Revision 1, 2018-02-05 (Alexander Galazin)

Initial draft

**Name String**

`VK_KHR_bind_memory2`

**Extension Type**

Device extension

**Registered Extension Number**

158

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

None

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.1](versions.html#versions-1.1-promotions)

**Contact**

* 
Tobias Hector [tobski](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_bind_memory2] @tobski%0A*Here describe the issue or question you have about the VK_KHR_bind_memory2 extension*)

**Last Modified Date**

2017-09-05

**IP Status**

No known IP claims.

**Contributors**

* 
Jeff Bolz, NVIDIA

* 
Tobias Hector, Imagination Technologies

This extension provides versions of [vkBindBufferMemory](../chapters/resources.html#vkBindBufferMemory) and
[vkBindImageMemory](../chapters/resources.html#vkBindImageMemory) that allow multiple bindings to be performed at
once, and are extensible.

This extension also introduces `VK_IMAGE_CREATE_ALIAS_BIT_KHR`, which
allows identical images that alias the same memory to interpret the
contents consistently, even across image layout changes.

All functionality in this extension is included in core Vulkan 1.1, with the
KHR suffix omitted.
The original type, enum, and command names are still available as aliases of
the core functionality.

* 
[vkBindBufferMemory2KHR](../chapters/resources.html#vkBindBufferMemory2KHR)

* 
[vkBindImageMemory2KHR](../chapters/resources.html#vkBindImageMemory2KHR)

* 
[VkBindBufferMemoryInfoKHR](../chapters/resources.html#VkBindBufferMemoryInfoKHR)

* 
[VkBindImageMemoryInfoKHR](../chapters/resources.html#VkBindImageMemoryInfoKHR)

* 
`VK_KHR_BIND_MEMORY_2_EXTENSION_NAME`

* 
`VK_KHR_BIND_MEMORY_2_SPEC_VERSION`

* 
Extending [VkImageCreateFlagBits](../chapters/resources.html#VkImageCreateFlagBits):

`VK_IMAGE_CREATE_ALIAS_BIT_KHR`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR`

* 
Revision 1, 2017-05-19 (Tobias Hector)

Pulled bind memory functions into their own extension

**Name String**

`VK_KHR_buffer_device_address`

**Extension Type**

Device extension

**Registered Extension Number**

258

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

 [VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

 and

 [VK_KHR_device_group](#VK_KHR_device_group)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**SPIR-V Dependencies**

* 
[SPV_KHR_physical_storage_buffer](https://github.khronos.org/SPIRV-Registry/extensions/KHR/SPV_KHR_physical_storage_buffer.html)

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.2](versions.html#versions-1.2-promotions)

**Contact**

* 
Jeff Bolz [jeffbolznv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_buffer_device_address] @jeffbolznv%0A*Here describe the issue or question you have about the VK_KHR_buffer_device_address extension*)

**Last Modified Date**

2019-06-24

**IP Status**

No known IP claims.

**Interactions and External Dependencies**

* 
This extension provides API support for
[`GL_EXT_buffer_reference`](https://github.com/KhronosGroup/GLSL/blob/main/extensions/ext/GLSL_EXT_buffer_reference.txt)
and
[`GL_EXT_buffer_reference2`](https://github.com/KhronosGroup/GLSL/blob/main/extensions/ext/GLSL_EXT_buffer_reference2.txt)
and
[`GL_EXT_buffer_reference_uvec2`](https://github.com/KhronosGroup/GLSL/blob/main/extensions/ext/GLSL_EXT_buffer_reference_uvec2.txt)

**Contributors**

* 
Jeff Bolz, NVIDIA

* 
Neil Henning, AMD

* 
Tobias Hector, AMD

* 
Faith Ekstrand, Intel

* 
Baldur Karlsson, Valve

* 
Jan-Harald Fredriksen, Arm

This extension allows the application to query a 64-bit buffer device
address value for a buffer, which can be used to access the buffer memory
via the `PhysicalStorageBuffer` storage class in the
[`GL_EXT_buffer_reference`](https://github.com/KhronosGroup/GLSL/blob/main/extensions/ext/GLSL_EXT_buffer_reference.txt)
GLSL extension and
[`SPV_KHR_physical_storage_buffer`](https://github.khronos.org/SPIRV-Registry/extensions/KHR/SPV_KHR_physical_storage_buffer.html)
SPIR-V extension.

Another way to describe this extension is that it adds pointers to buffer
memory in shaders.
By calling [vkGetBufferDeviceAddress](../chapters/descriptorsets.html#vkGetBufferDeviceAddress) with a `VkBuffer`, it will
return a `VkDeviceAddress` value which represents the address of the
start of the buffer.

[vkGetBufferOpaqueCaptureAddress](../chapters/descriptorsets.html#vkGetBufferOpaqueCaptureAddress) and
[vkGetDeviceMemoryOpaqueCaptureAddress](../chapters/memory.html#vkGetDeviceMemoryOpaqueCaptureAddress) allow opaque addresses for
buffers and memory objects to be queried for the current process.
A trace capture and replay tool can then supply these addresses to be used
at replay time to match the addresses used when the trace was captured.
To enable tools to insert these queries, new memory allocation flags must be
specified for memory objects that will be bound to buffers accessed via the
`PhysicalStorageBuffer` storage class.
**Note that this mechanism is intended only to support capture/replay tools,
and is not recommended for use in other applications.**

All functionality in this extension is included in core Vulkan 1.2, with the
KHR suffix omitted.
However, if Vulkan 1.2 is supported and this extension is not, the
`bufferDeviceAddress` feature is optional.
The original type, enum, and command names are still available as aliases of
the core functionality.

If Vulkan 1.3 is supported, support for the `bufferDeviceAddress`
capability is required.

* 
[vkGetBufferDeviceAddressKHR](../chapters/descriptorsets.html#vkGetBufferDeviceAddressKHR)

* 
[vkGetBufferOpaqueCaptureAddressKHR](../chapters/descriptorsets.html#vkGetBufferOpaqueCaptureAddressKHR)

* 
[vkGetDeviceMemoryOpaqueCaptureAddressKHR](../chapters/memory.html#vkGetDeviceMemoryOpaqueCaptureAddressKHR)

* 
[VkBufferDeviceAddressInfoKHR](../chapters/descriptorsets.html#VkBufferDeviceAddressInfoKHR)

* 
[VkDeviceMemoryOpaqueCaptureAddressInfoKHR](../chapters/memory.html#VkDeviceMemoryOpaqueCaptureAddressInfoKHR)

* 
Extending [VkBufferCreateInfo](../chapters/resources.html#VkBufferCreateInfo):

[VkBufferOpaqueCaptureAddressCreateInfoKHR](../chapters/resources.html#VkBufferOpaqueCaptureAddressCreateInfoKHR)

Extending [VkMemoryAllocateInfo](../chapters/memory.html#VkMemoryAllocateInfo):

* 
[VkMemoryOpaqueCaptureAddressAllocateInfoKHR](../chapters/memory.html#VkMemoryOpaqueCaptureAddressAllocateInfoKHR)

Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

* 
[VkPhysicalDeviceBufferDeviceAddressFeaturesKHR](../chapters/features.html#VkPhysicalDeviceBufferDeviceAddressFeaturesKHR)

* 
`VK_KHR_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME`

* 
`VK_KHR_BUFFER_DEVICE_ADDRESS_SPEC_VERSION`

* 
Extending [VkBufferCreateFlagBits](../chapters/resources.html#VkBufferCreateFlagBits):

`VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR`

Extending [VkBufferUsageFlagBits](../chapters/resources.html#VkBufferUsageFlagBits):

* 
`VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_KHR`

Extending [VkMemoryAllocateFlagBits](../chapters/memory.html#VkMemoryAllocateFlagBits):

* 
`VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT_KHR`

* 
`VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR`

Extending [VkResult](../chapters/fundamentals.html#VkResult):

* 
`VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_KHR`

* 
[    `PhysicalStorageBufferAddresses`](spirvenv.html#spirvenv-capabilities-table-PhysicalStorageBufferAddresses)

* 
Revision 1, 2019-06-24 (Jan-Harald Fredriksen)

Internal revisions based on VK_EXT_buffer_device_address

**Name String**

`VK_KHR_copy_commands2`

**Extension Type**

Device extension

**Registered Extension Number**

338

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.3](versions.html#versions-1.3-promotions)

**Contact**

* 
Matthew Netsch [mnetsch](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_copy_commands2] @mnetsch%0A*Here describe the issue or question you have about the VK_KHR_copy_commands2 extension*)

**Last Modified Date**

2020-07-06

**Contributors**

* 
Jeff Leger, Qualcomm

* 
Tobias Hector, AMD

* 
Jan-Harald Fredriksen, ARM

* 
Tom Olson, ARM

This extension provides extensible versions of the Vulkan buffer and image
copy commands.
The new commands are functionally identical to the core commands, except
that their copy parameters are specified using extensible structures that
can be used to pass extension-specific information.

The following extensible copy commands are introduced with this extension:
[vkCmdCopyBuffer2KHR](../chapters/copies.html#vkCmdCopyBuffer2KHR), [vkCmdCopyImage2KHR](../chapters/copies.html#vkCmdCopyImage2KHR),
[vkCmdCopyBufferToImage2KHR](../chapters/copies.html#vkCmdCopyBufferToImage2KHR), [vkCmdCopyImageToBuffer2KHR](../chapters/copies.html#vkCmdCopyImageToBuffer2KHR),
[vkCmdBlitImage2KHR](../chapters/copies.html#vkCmdBlitImage2KHR), and [vkCmdResolveImage2KHR](../chapters/copies.html#vkCmdResolveImage2KHR).
Each command contains an `*Info2KHR` structure parameter that includes
`sType`/`pNext` members.
Lower level structures describing each region to be copied are also extended
with `sType`/`pNext` members.

* 
[vkCmdBlitImage2KHR](../chapters/copies.html#vkCmdBlitImage2KHR)

* 
[vkCmdCopyBuffer2KHR](../chapters/copies.html#vkCmdCopyBuffer2KHR)

* 
[vkCmdCopyBufferToImage2KHR](../chapters/copies.html#vkCmdCopyBufferToImage2KHR)

* 
[vkCmdCopyImage2KHR](../chapters/copies.html#vkCmdCopyImage2KHR)

* 
[vkCmdCopyImageToBuffer2KHR](../chapters/copies.html#vkCmdCopyImageToBuffer2KHR)

* 
[vkCmdResolveImage2KHR](../chapters/copies.html#vkCmdResolveImage2KHR)

* 
[VkBlitImageInfo2KHR](../chapters/copies.html#VkBlitImageInfo2KHR)

* 
[VkBufferCopy2KHR](../chapters/copies.html#VkBufferCopy2KHR)

* 
[VkBufferImageCopy2KHR](../chapters/copies.html#VkBufferImageCopy2KHR)

* 
[VkCopyBufferInfo2KHR](../chapters/copies.html#VkCopyBufferInfo2KHR)

* 
[VkCopyBufferToImageInfo2KHR](../chapters/copies.html#VkCopyBufferToImageInfo2KHR)

* 
[VkCopyImageInfo2KHR](../chapters/copies.html#VkCopyImageInfo2KHR)

* 
[VkCopyImageToBufferInfo2KHR](../chapters/copies.html#VkCopyImageToBufferInfo2KHR)

* 
[VkImageBlit2KHR](../chapters/copies.html#VkImageBlit2KHR)

* 
[VkImageCopy2KHR](../chapters/copies.html#VkImageCopy2KHR)

* 
[VkImageResolve2KHR](../chapters/copies.html#VkImageResolve2KHR)

* 
[VkResolveImageInfo2KHR](../chapters/copies.html#VkResolveImageInfo2KHR)

* 
`VK_KHR_COPY_COMMANDS_2_EXTENSION_NAME`

* 
`VK_KHR_COPY_COMMANDS_2_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2_KHR`

* 
`VK_STRUCTURE_TYPE_BUFFER_COPY_2_KHR`

* 
`VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2_KHR`

* 
`VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2_KHR`

* 
`VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2_KHR`

* 
`VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2_KHR`

* 
`VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2_KHR`

* 
`VK_STRUCTURE_TYPE_IMAGE_BLIT_2_KHR`

* 
`VK_STRUCTURE_TYPE_IMAGE_COPY_2_KHR`

* 
`VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2_KHR`

* 
`VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2_KHR`

Vulkan APIs in this extension are included in core Vulkan 1.3, with the KHR
suffix omitted.
External interactions defined by this extension, such as SPIR-V token names,
retain their original names.
The original Vulkan API names are still available as aliases of the core
functionality.

* 
Revision 1, 2020-07-06 (Jeff Leger)

Internal revisions

**Name String**

`VK_KHR_create_renderpass2`

**Extension Type**

Device extension

**Registered Extension Number**

110

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

 [VK_KHR_multiview](#VK_KHR_multiview)

 and

 [VK_KHR_maintenance2](#VK_KHR_maintenance2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.2](versions.html#versions-1.2-promotions)

**Contact**

* 
Tobias Hector [tobias](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_create_renderpass2] @tobias%0A*Here describe the issue or question you have about the VK_KHR_create_renderpass2 extension*)

**Last Modified Date**

2018-02-07

**Contributors**

* 
Tobias Hector

* 
Jeff Bolz

This extension provides a new command to create render passes in a way that
can be easily extended by other extensions through the substructures of
render pass creation.
The Vulkan 1.0 render pass creation sub-structures do not include
`sType`/`pNext` members.
Additionally, the render pass begin/next/end commands have been augmented
with new extensible structures for passing additional subpass information.

The [VkRenderPassMultiviewCreateInfo](../chapters/renderpass.html#VkRenderPassMultiviewCreateInfo) and
[VkInputAttachmentAspectReference](../chapters/renderpass.html#VkInputAttachmentAspectReference) structures that extended the original
[VkRenderPassCreateInfo](../chapters/renderpass.html#VkRenderPassCreateInfo) are not accepted into the new creation
functions, and instead their parameters are folded into this extension as
follows:

* 
Elements of [VkRenderPassMultiviewCreateInfo](../chapters/renderpass.html#VkRenderPassMultiviewCreateInfo)::`pViewMasks` are
now specified in [VkSubpassDescription2KHR](../chapters/renderpass.html#VkSubpassDescription2KHR)::`viewMask`.

* 
Elements of [VkRenderPassMultiviewCreateInfo](../chapters/renderpass.html#VkRenderPassMultiviewCreateInfo)::`pViewOffsets`
are now specified in [VkSubpassDependency2KHR](../chapters/renderpass.html#VkSubpassDependency2KHR)::`viewOffset`.

* 
[VkRenderPassMultiviewCreateInfo](../chapters/renderpass.html#VkRenderPassMultiviewCreateInfo)::`correlationMaskCount` and
[VkRenderPassMultiviewCreateInfo](../chapters/renderpass.html#VkRenderPassMultiviewCreateInfo)::`pCorrelationMasks` are
directly specified in [VkRenderPassCreateInfo2KHR](../chapters/renderpass.html#VkRenderPassCreateInfo2KHR).

* 
[VkInputAttachmentAspectReference](../chapters/renderpass.html#VkInputAttachmentAspectReference)::`aspectMask` is now
specified in the relevant input attachment reference in
[VkAttachmentReference2KHR](../chapters/renderpass.html#VkAttachmentReference2KHR)::`aspectMask`

The details of these mappings are explained fully in the new structures.

All functionality in this extension is included in core Vulkan 1.2, with the
KHR suffix omitted.
The original type, enum, and command names are still available as aliases of
the core functionality.

* 
[vkCmdBeginRenderPass2KHR](../chapters/renderpass.html#vkCmdBeginRenderPass2KHR)

* 
[vkCmdEndRenderPass2KHR](../chapters/renderpass.html#vkCmdEndRenderPass2KHR)

* 
[vkCmdNextSubpass2KHR](../chapters/renderpass.html#vkCmdNextSubpass2KHR)

* 
[vkCreateRenderPass2KHR](../chapters/renderpass.html#vkCreateRenderPass2KHR)

* 
[VkAttachmentDescription2KHR](../chapters/renderpass.html#VkAttachmentDescription2KHR)

* 
[VkAttachmentReference2KHR](../chapters/renderpass.html#VkAttachmentReference2KHR)

* 
[VkRenderPassCreateInfo2KHR](../chapters/renderpass.html#VkRenderPassCreateInfo2KHR)

* 
[VkSubpassBeginInfoKHR](../chapters/renderpass.html#VkSubpassBeginInfoKHR)

* 
[VkSubpassDependency2KHR](../chapters/renderpass.html#VkSubpassDependency2KHR)

* 
[VkSubpassDescription2KHR](../chapters/renderpass.html#VkSubpassDescription2KHR)

* 
[VkSubpassEndInfoKHR](../chapters/renderpass.html#VkSubpassEndInfoKHR)

* 
`VK_KHR_CREATE_RENDERPASS_2_EXTENSION_NAME`

* 
`VK_KHR_CREATE_RENDERPASS_2_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR`

* 
`VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR`

* 
`VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR`

* 
`VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR`

* 
`VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR`

* 
`VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR`

* 
Revision 1, 2018-02-07 (Tobias Hector)

Internal revisions

**Name String**

`VK_KHR_dedicated_allocation`

**Extension Type**

Device extension

**Registered Extension Number**

128

**Revision**

3

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_memory_requirements2](#VK_KHR_get_memory_requirements2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.1](versions.html#versions-1.1-promotions)

**Contact**

* 
James Jones [cubanismo](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_dedicated_allocation] @cubanismo%0A*Here describe the issue or question you have about the VK_KHR_dedicated_allocation extension*)

**Last Modified Date**

2017-09-05

**IP Status**

No known IP claims.

**Contributors**

* 
Jeff Bolz, NVIDIA

* 
Faith Ekstrand, Intel

This extension enables resources to be bound to a dedicated allocation,
rather than suballocated.
For any particular resource, applications **can** query whether a dedicated
allocation is recommended, in which case using a dedicated allocation **may**
improve the performance of access to that resource.
Normal device memory allocations must support multiple resources per
allocation, memory aliasing and sparse binding, which could interfere with
some optimizations.
Applications should query the implementation for when a dedicated allocation
**may** be beneficial by adding a `VkMemoryDedicatedRequirementsKHR`
structure to the `pNext` chain of the `VkMemoryRequirements2`
structure passed as the `pMemoryRequirements` parameter of a call to
`vkGetBufferMemoryRequirements2` or `vkGetImageMemoryRequirements2`.
Certain external handle types and external images or buffers **may** also
depend on dedicated allocations on implementations that associate image or
buffer metadata with OS-level memory objects.

This extension adds a two small structures to memory requirements querying
and memory allocation: a new structure that flags whether an image/buffer
should have a dedicated allocation, and a structure indicating the image or
buffer that an allocation will be bound to.

All functionality in this extension is included in core Vulkan 1.1, with the
KHR suffix omitted.
The original type, enum, and command names are still available as aliases of
the core functionality.

* 
Extending [VkMemoryAllocateInfo](../chapters/memory.html#VkMemoryAllocateInfo):

[VkMemoryDedicatedAllocateInfoKHR](../chapters/memory.html#VkMemoryDedicatedAllocateInfoKHR)

Extending [VkMemoryRequirements2](../chapters/resources.html#VkMemoryRequirements2):

* 
[VkMemoryDedicatedRequirementsKHR](../chapters/resources.html#VkMemoryDedicatedRequirementsKHR)

* 
`VK_KHR_DEDICATED_ALLOCATION_EXTENSION_NAME`

* 
`VK_KHR_DEDICATED_ALLOCATION_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR`

    // Create an image with a dedicated allocation based on the
    // implementation's preference

    VkImageCreateInfo imageCreateInfo =
    {
        // Image creation parameters
    };

    VkImage image;
    VkResult result = vkCreateImage(
        device,
        &imageCreateInfo,
        NULL,               // pAllocator
        &image);

    VkMemoryDedicatedRequirementsKHR dedicatedRequirements =
    {
        .sType = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR,
        .pNext = NULL,
    };

    VkMemoryRequirements2 memoryRequirements =
    {
        .sType = VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2,
        .pNext = &dedicatedRequirements,
    };

    const VkImageMemoryRequirementsInfo2 imageRequirementsInfo =
    {
        .sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2,
        .pNext = NULL,
        .image = image
    };

    vkGetImageMemoryRequirements2(
        device,
        &imageRequirementsInfo,
        &memoryRequirements);

    if (dedicatedRequirements.prefersDedicatedAllocation) {
        // Allocate memory with VkMemoryDedicatedAllocateInfoKHR::image
        // pointing to the image we are allocating the memory for

        VkMemoryDedicatedAllocateInfoKHR dedicatedInfo =
        {
            .sType = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR,
            .pNext = NULL,
            .image = image,
            .buffer = VK_NULL_HANDLE,
        };

        VkMemoryAllocateInfo memoryAllocateInfo =
        {
            .sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
            .pNext = &dedicatedInfo,
            .allocationSize = memoryRequirements.size,
            .memoryTypeIndex = FindMemoryTypeIndex(memoryRequirements.memoryTypeBits),
        };

        VkDeviceMemory memory;
        vkAllocateMemory(
            device,
            &memoryAllocateInfo,
            NULL,               // pAllocator
            &memory);

        // Bind the image to the memory

        vkBindImageMemory(
            device,
            image,
            memory,
            0);
    } else {
        // Take the normal memory sub-allocation path
    }

* 
Revision 1, 2017-02-27 (James Jones)

Copy content from VK_NV_dedicated_allocation

* 
Add some references to external object interactions to the overview.

Revision 2, 2017-03-27 (Faith Ekstrand)

* 
Rework the extension to be query-based

Revision 3, 2017-07-31 (Faith Ekstrand)

* 
Clarify that memory objects allocated with
VkMemoryDedicatedAllocateInfoKHR can only have the specified resource
bound and no others.

**Name String**

`VK_KHR_depth_stencil_resolve`

**Extension Type**

Device extension

**Registered Extension Number**

200

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_create_renderpass2](#VK_KHR_create_renderpass2)

or

[Vulkan Version 1.2](versions.html#versions-1.2)

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.2](versions.html#versions-1.2-promotions)

**Contact**

* 
Jan-Harald Fredriksen [janharald](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_depth_stencil_resolve] @janharald%0A*Here describe the issue or question you have about the VK_KHR_depth_stencil_resolve extension*)

**Last Modified Date**

2018-04-09

**Contributors**

* 
Jan-Harald Fredriksen, Arm

* 
Andrew Garrard, Samsung Electronics

* 
Soowan Park, Samsung Electronics

* 
Jeff Bolz, NVIDIA

* 
Daniel Rakos, AMD

This extension adds support for automatically resolving multisampled
depth/stencil attachments in a subpass in a similar manner as for color
attachments.

Multisampled color attachments can be resolved at the end of a subpass by
specifying `pResolveAttachments` entries corresponding to the
`pColorAttachments` array entries.
This does not allow for a way to map the resolve attachments to the
depth/stencil attachment.
The [vkCmdResolveImage](../chapters/copies.html#vkCmdResolveImage) command does not allow for depth/stencil images.
While there are other ways to resolve the depth/stencil attachment, they can
give sub-optimal performance.
Extending the `VkSubpassDescription2` in this extension allows an
application to add a `pDepthStencilResolveAttachment`, that is similar
to the color `pResolveAttachments`, that the
`pDepthStencilAttachment` can be resolved into.

Depth and stencil samples are resolved to a single value based on the
resolve mode.
The set of possible resolve modes is defined in the
[VkResolveModeFlagBits](../chapters/renderpass.html#VkResolveModeFlagBits) enum.
The `VK_RESOLVE_MODE_SAMPLE_ZERO_BIT` mode is the only mode that is
required of all implementations (that support the extension or support
Vulkan 1.2 or higher).
Some implementations may also support averaging (the same as color sample
resolve) or taking the minimum or maximum sample, which may be more suitable
for depth/stencil resolve.

All functionality in this extension is included in core Vulkan 1.2, with the
KHR suffix omitted.
The original type, enum, and command names are still available as aliases of
the core functionality.

* 
Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

[VkPhysicalDeviceDepthStencilResolvePropertiesKHR](../chapters/limits.html#VkPhysicalDeviceDepthStencilResolvePropertiesKHR)

Extending [VkSubpassDescription2](../chapters/renderpass.html#VkSubpassDescription2):

* 
[VkSubpassDescriptionDepthStencilResolveKHR](../chapters/renderpass.html#VkSubpassDescriptionDepthStencilResolveKHR)

* 
[VkResolveModeFlagBitsKHR](../chapters/renderpass.html#VkResolveModeFlagBitsKHR)

* 
[VkResolveModeFlagsKHR](../chapters/renderpass.html#VkResolveModeFlagsKHR)

* 
`VK_KHR_DEPTH_STENCIL_RESOLVE_EXTENSION_NAME`

* 
`VK_KHR_DEPTH_STENCIL_RESOLVE_SPEC_VERSION`

* 
Extending [VkResolveModeFlagBits](../chapters/renderpass.html#VkResolveModeFlagBits):

`VK_RESOLVE_MODE_AVERAGE_BIT_KHR`

* 
`VK_RESOLVE_MODE_MAX_BIT_KHR`

* 
`VK_RESOLVE_MODE_MIN_BIT_KHR`

* 
`VK_RESOLVE_MODE_NONE_KHR`

* 
`VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR`

* 
`VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR`

* 
Revision 1, 2018-04-09 (Jan-Harald Fredriksen)

Initial revision

**Name String**

`VK_KHR_descriptor_update_template`

**Extension Type**

Device extension

**Registered Extension Number**

86

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

None

**API Interactions**

* 
Interacts with VK_EXT_debug_report

* 
Interacts with VK_KHR_push_descriptor

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.1](versions.html#versions-1.1-promotions)

**Contact**

* 
Markus Tavenrath [mtavenrath](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_descriptor_update_template] @mtavenrath%0A*Here describe the issue or question you have about the VK_KHR_descriptor_update_template extension*)

**Last Modified Date**

2017-09-05

**IP Status**

No known IP claims.

**Interactions and External Dependencies**

* 
Interacts with `[VK_KHR_push_descriptor](#VK_KHR_push_descriptor)`

**Contributors**

* 
Jeff Bolz, NVIDIA

* 
Michael Worcester, Imagination Technologies

Applications may wish to update a fixed set of descriptors in a large number
of descriptor sets very frequently, i.e. during initialization phase or if
it is required to rebuild descriptor sets for each frame.
For those cases it is also not unlikely that all information required to
update a single descriptor set is stored in a single struct.
This extension provides a way to update a fixed set of descriptors in a
single [VkDescriptorSet](../chapters/descriptorsets.html#VkDescriptorSet) with a pointer to an application-defined data
structure describing the new descriptors.

[vkCmdPushDescriptorSetWithTemplateKHR](../chapters/descriptorsets.html#vkCmdPushDescriptorSetWithTemplateKHR) is included as an interaction
with `[VK_KHR_push_descriptor](#VK_KHR_push_descriptor)`.
If Vulkan 1.1 and `VK_KHR_push_descriptor` are supported, this is included
by `[VK_KHR_push_descriptor](#VK_KHR_push_descriptor)`.

The base functionality in this extension is included in core Vulkan 1.1,
with the KHR suffix omitted.
The original type, enum, and command names are still available as aliases of
the core functionality.

* 
[VkDescriptorUpdateTemplateKHR](../chapters/descriptorsets.html#VkDescriptorUpdateTemplateKHR)

* 
[vkCreateDescriptorUpdateTemplateKHR](../chapters/descriptorsets.html#vkCreateDescriptorUpdateTemplateKHR)

* 
[vkDestroyDescriptorUpdateTemplateKHR](../chapters/descriptorsets.html#vkDestroyDescriptorUpdateTemplateKHR)

* 
[vkUpdateDescriptorSetWithTemplateKHR](../chapters/descriptorsets.html#vkUpdateDescriptorSetWithTemplateKHR)

If [VK_KHR_push_descriptor](#VK_KHR_push_descriptor) is supported:

* 
[vkCmdPushDescriptorSetWithTemplateKHR](../chapters/descriptorsets.html#vkCmdPushDescriptorSetWithTemplateKHR)

* 
[VkDescriptorUpdateTemplateCreateInfoKHR](../chapters/descriptorsets.html#VkDescriptorUpdateTemplateCreateInfoKHR)

* 
[VkDescriptorUpdateTemplateEntryKHR](../chapters/descriptorsets.html#VkDescriptorUpdateTemplateEntryKHR)

* 
[VkDescriptorUpdateTemplateTypeKHR](../chapters/descriptorsets.html#VkDescriptorUpdateTemplateTypeKHR)

* 
[VkDescriptorUpdateTemplateCreateFlagsKHR](../chapters/descriptorsets.html#VkDescriptorUpdateTemplateCreateFlagsKHR)

* 
`VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_EXTENSION_NAME`

* 
`VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_SPEC_VERSION`

* 
Extending [VkDescriptorUpdateTemplateType](../chapters/descriptorsets.html#VkDescriptorUpdateTemplateType):

`VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR`

Extending [VkObjectType](../chapters/debugging.html#VkObjectType):

* 
`VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR`

If [VK_EXT_debug_report](#VK_EXT_debug_report) is supported:

* 
Extending [VkDebugReportObjectTypeEXT](../chapters/debugging.html#VkDebugReportObjectTypeEXT):

`VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT`

If [VK_KHR_push_descriptor](#VK_KHR_push_descriptor) is supported:

* 
Extending [VkDescriptorUpdateTemplateType](../chapters/descriptorsets.html#VkDescriptorUpdateTemplateType):

`VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR`

* 
Revision 1, 2016-01-11 (Markus Tavenrath)

Initial draft

**Name String**

`VK_KHR_device_group`

**Extension Type**

Device extension

**Registered Extension Number**

61

**Revision**

4

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_device_group_creation](#VK_KHR_device_group_creation)

**API Interactions**

* 
Interacts with VK_KHR_bind_memory2

* 
Interacts with VK_KHR_surface

* 
Interacts with VK_KHR_swapchain

**SPIR-V Dependencies**

* 
[SPV_KHR_device_group](https://github.khronos.org/SPIRV-Registry/extensions/KHR/SPV_KHR_device_group.html)

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.1](versions.html#versions-1.1-promotions)

**Contact**

* 
Jeff Bolz [jeffbolznv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_device_group] @jeffbolznv%0A*Here describe the issue or question you have about the VK_KHR_device_group extension*)

**Last Modified Date**

2017-10-10

**IP Status**

No known IP claims.

**Contributors**

* 
Jeff Bolz, NVIDIA

* 
Tobias Hector, Imagination Technologies

This extension provides functionality to use a logical device that consists
of multiple physical devices, as created with the
`[VK_KHR_device_group_creation](#VK_KHR_device_group_creation)` extension.
A device group can allocate memory across the subdevices, bind memory from
one subdevice to a resource on another subdevice, record command buffers
where some work executes on an arbitrary subset of the subdevices, and
potentially present a swapchain image from one or more subdevices.

The following enums, types and commands are included as interactions with
`[VK_KHR_swapchain](#VK_KHR_swapchain)`:

* 
`VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR`

* 
`VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR`

* 
`VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR`

* 
[VkDeviceGroupPresentModeFlagBitsKHR](../chapters/VK_KHR_surface/wsi.html#VkDeviceGroupPresentModeFlagBitsKHR)

* 
[VkDeviceGroupPresentCapabilitiesKHR](../chapters/VK_KHR_surface/wsi.html#VkDeviceGroupPresentCapabilitiesKHR)

* 
[VkImageSwapchainCreateInfoKHR](../chapters/resources.html#VkImageSwapchainCreateInfoKHR)

* 
[VkBindImageMemorySwapchainInfoKHR](../chapters/resources.html#VkBindImageMemorySwapchainInfoKHR)

* 
[VkAcquireNextImageInfoKHR](../chapters/VK_KHR_surface/wsi.html#VkAcquireNextImageInfoKHR)

* 
[VkDeviceGroupPresentInfoKHR](../chapters/VK_KHR_surface/wsi.html#VkDeviceGroupPresentInfoKHR)

* 
[VkDeviceGroupSwapchainCreateInfoKHR](../chapters/VK_KHR_surface/wsi.html#VkDeviceGroupSwapchainCreateInfoKHR)

* 
[vkGetDeviceGroupPresentCapabilitiesKHR](../chapters/VK_KHR_surface/wsi.html#vkGetDeviceGroupPresentCapabilitiesKHR)

* 
[vkGetDeviceGroupSurfacePresentModesKHR](../chapters/VK_KHR_surface/wsi.html#vkGetDeviceGroupSurfacePresentModesKHR)

* 
[vkGetPhysicalDevicePresentRectanglesKHR](../chapters/VK_KHR_surface/wsi.html#vkGetPhysicalDevicePresentRectanglesKHR)

* 
[vkAcquireNextImage2KHR](../chapters/VK_KHR_surface/wsi.html#vkAcquireNextImage2KHR)

If Vulkan 1.1 and `[VK_KHR_swapchain](#VK_KHR_swapchain)` are supported, these are
included by `VK_KHR_swapchain`.

The base functionality in this extension is included in core Vulkan 1.1,
with the KHR suffix omitted.
The original type, enum, and command names are still available as aliases of
the core functionality.

* 
[vkCmdDispatchBaseKHR](../chapters/dispatch.html#vkCmdDispatchBaseKHR)

* 
[vkCmdSetDeviceMaskKHR](../chapters/cmdbuffers.html#vkCmdSetDeviceMaskKHR)

* 
[vkGetDeviceGroupPeerMemoryFeaturesKHR](../chapters/memory.html#vkGetDeviceGroupPeerMemoryFeaturesKHR)

If [VK_KHR_surface](#VK_KHR_surface) is supported:

* 
[vkGetDeviceGroupPresentCapabilitiesKHR](../chapters/VK_KHR_surface/wsi.html#vkGetDeviceGroupPresentCapabilitiesKHR)

* 
[vkGetDeviceGroupSurfacePresentModesKHR](../chapters/VK_KHR_surface/wsi.html#vkGetDeviceGroupSurfacePresentModesKHR)

* 
[vkGetPhysicalDevicePresentRectanglesKHR](../chapters/VK_KHR_surface/wsi.html#vkGetPhysicalDevicePresentRectanglesKHR)

If [VK_KHR_swapchain](#VK_KHR_swapchain) is supported:

* 
[vkAcquireNextImage2KHR](../chapters/VK_KHR_surface/wsi.html#vkAcquireNextImage2KHR)

* 
Extending [VkBindSparseInfo](../chapters/sparsemem.html#VkBindSparseInfo):

[VkDeviceGroupBindSparseInfoKHR](../chapters/sparsemem.html#VkDeviceGroupBindSparseInfoKHR)

Extending [VkCommandBufferBeginInfo](../chapters/cmdbuffers.html#VkCommandBufferBeginInfo):

* 
[VkDeviceGroupCommandBufferBeginInfoKHR](../chapters/cmdbuffers.html#VkDeviceGroupCommandBufferBeginInfoKHR)

Extending [VkMemoryAllocateInfo](../chapters/memory.html#VkMemoryAllocateInfo):

* 
[VkMemoryAllocateFlagsInfoKHR](../chapters/memory.html#VkMemoryAllocateFlagsInfoKHR)

Extending [VkRenderPassBeginInfo](../chapters/renderpass.html#VkRenderPassBeginInfo), [VkRenderingInfo](../chapters/renderpass.html#VkRenderingInfo):

* 
[VkDeviceGroupRenderPassBeginInfoKHR](../chapters/renderpass.html#VkDeviceGroupRenderPassBeginInfoKHR)

Extending [VkSubmitInfo](../chapters/cmdbuffers.html#VkSubmitInfo):

* 
[VkDeviceGroupSubmitInfoKHR](../chapters/cmdbuffers.html#VkDeviceGroupSubmitInfoKHR)

If [VK_KHR_bind_memory2](#VK_KHR_bind_memory2) is supported:

* 
Extending [VkBindBufferMemoryInfo](../chapters/resources.html#VkBindBufferMemoryInfo):

[VkBindBufferMemoryDeviceGroupInfoKHR](../chapters/resources.html#VkBindBufferMemoryDeviceGroupInfoKHR)

Extending [VkBindImageMemoryInfo](../chapters/resources.html#VkBindImageMemoryInfo):

* 
[VkBindImageMemoryDeviceGroupInfoKHR](../chapters/resources.html#VkBindImageMemoryDeviceGroupInfoKHR)

If [VK_KHR_surface](#VK_KHR_surface) is supported:

* 
[VkDeviceGroupPresentCapabilitiesKHR](../chapters/VK_KHR_surface/wsi.html#VkDeviceGroupPresentCapabilitiesKHR)

If [VK_KHR_swapchain](#VK_KHR_swapchain) is supported:

* 
[VkAcquireNextImageInfoKHR](../chapters/VK_KHR_surface/wsi.html#VkAcquireNextImageInfoKHR)

* 
Extending [VkBindImageMemoryInfo](../chapters/resources.html#VkBindImageMemoryInfo):

[VkBindImageMemorySwapchainInfoKHR](../chapters/resources.html#VkBindImageMemorySwapchainInfoKHR)

Extending [VkImageCreateInfo](../chapters/resources.html#VkImageCreateInfo):

* 
[VkImageSwapchainCreateInfoKHR](../chapters/resources.html#VkImageSwapchainCreateInfoKHR)

Extending [VkPresentInfoKHR](../chapters/VK_KHR_surface/wsi.html#VkPresentInfoKHR):

* 
[VkDeviceGroupPresentInfoKHR](../chapters/VK_KHR_surface/wsi.html#VkDeviceGroupPresentInfoKHR)

Extending [VkSwapchainCreateInfoKHR](../chapters/VK_KHR_surface/wsi.html#VkSwapchainCreateInfoKHR):

* 
[VkDeviceGroupSwapchainCreateInfoKHR](../chapters/VK_KHR_surface/wsi.html#VkDeviceGroupSwapchainCreateInfoKHR)

* 
[VkMemoryAllocateFlagBitsKHR](../chapters/memory.html#VkMemoryAllocateFlagBitsKHR)

* 
[VkPeerMemoryFeatureFlagBitsKHR](../chapters/memory.html#VkPeerMemoryFeatureFlagBitsKHR)

If [VK_KHR_surface](#VK_KHR_surface) is supported:

* 
[VkDeviceGroupPresentModeFlagBitsKHR](../chapters/VK_KHR_surface/wsi.html#VkDeviceGroupPresentModeFlagBitsKHR)

* 
[VkMemoryAllocateFlagsKHR](../chapters/memory.html#VkMemoryAllocateFlagsKHR)

* 
[VkPeerMemoryFeatureFlagsKHR](../chapters/memory.html#VkPeerMemoryFeatureFlagsKHR)

If [VK_KHR_surface](#VK_KHR_surface) is supported:

* 
[VkDeviceGroupPresentModeFlagsKHR](../chapters/VK_KHR_surface/wsi.html#VkDeviceGroupPresentModeFlagsKHR)

* 
`VK_KHR_DEVICE_GROUP_EXTENSION_NAME`

* 
`VK_KHR_DEVICE_GROUP_SPEC_VERSION`

* 
Extending [VkDependencyFlagBits](../chapters/synchronization.html#VkDependencyFlagBits):

`VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR`

Extending [VkMemoryAllocateFlagBits](../chapters/memory.html#VkMemoryAllocateFlagBits):

* 
`VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR`

Extending [VkPeerMemoryFeatureFlagBits](../chapters/memory.html#VkPeerMemoryFeatureFlagBits):

* 
`VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR`

* 
`VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR`

* 
`VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR`

* 
`VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR`

Extending [VkPipelineCreateFlagBits](../chapters/pipelines.html#VkPipelineCreateFlagBits):

* 
`VK_PIPELINE_CREATE_DISPATCH_BASE_KHR`

* 
`VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR`

If [VK_KHR_bind_memory2](#VK_KHR_bind_memory2) is supported:

* 
Extending [VkImageCreateFlagBits](../chapters/resources.html#VkImageCreateFlagBits):

`VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR`

If [VK_KHR_surface](#VK_KHR_surface) is supported:

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR`

If [VK_KHR_swapchain](#VK_KHR_swapchain) is supported:

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR`

Extending [VkSwapchainCreateFlagBitsKHR](../chapters/VK_KHR_surface/wsi.html#VkSwapchainCreateFlagBitsKHR):

* 
`VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR`

* 
[`DeviceIndex`](../chapters/interfaces.html#interfaces-builtin-variables-deviceindex)

* 
[`DeviceGroup`](spirvenv.html#spirvenv-capabilities-table-DeviceGroup)

* 
Revision 1, 2016-10-19 (Jeff Bolz)

Internal revisions

Revision 2, 2017-05-19 (Tobias Hector)

* 
Removed extended memory bind functions to VK_KHR_bind_memory2, added
dependency on that extension, and device-group-specific structs for
those functions.

Revision 3, 2017-10-06 (Ian Elliott)

* 
Corrected Vulkan 1.1 interactions with the WSI extensions.
All Vulkan 1.1 WSI interactions are with the VK_KHR_swapchain
extension.

Revision 4, 2017-10-10 (Jeff Bolz)

* 
Rename SFR bits and structure members to use the phrase split
instance bind regions.

**Name String**

`VK_KHR_device_group_creation`

**Extension Type**

Instance extension

**Registered Extension Number**

71

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

None

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.1](versions.html#versions-1.1-promotions)

**Contact**

* 
Jeff Bolz [jeffbolznv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_device_group_creation] @jeffbolznv%0A*Here describe the issue or question you have about the VK_KHR_device_group_creation extension*)

**Last Modified Date**

2016-10-19

**IP Status**

No known IP claims.

**Contributors**

* 
Jeff Bolz, NVIDIA

This extension provides instance-level commands to enumerate groups of
physical devices, and to create a logical device from a subset of one of
those groups.
Such a logical device can then be used with new features in the
`[VK_KHR_device_group](#VK_KHR_device_group)` extension.

All functionality in this extension is included in core Vulkan 1.1, with the
KHR suffix omitted.
The original type, enum, and command names are still available as aliases of
the core functionality.

* 
[vkEnumeratePhysicalDeviceGroupsKHR](../chapters/devsandqueues.html#vkEnumeratePhysicalDeviceGroupsKHR)

* 
[VkPhysicalDeviceGroupPropertiesKHR](../chapters/devsandqueues.html#VkPhysicalDeviceGroupPropertiesKHR)

* 
Extending [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkDeviceGroupDeviceCreateInfoKHR](../chapters/devsandqueues.html#VkDeviceGroupDeviceCreateInfoKHR)

* 
`VK_KHR_DEVICE_GROUP_CREATION_EXTENSION_NAME`

* 
`VK_KHR_DEVICE_GROUP_CREATION_SPEC_VERSION`

* 
`VK_MAX_DEVICE_GROUP_SIZE_KHR`

* 
Extending [VkMemoryHeapFlagBits](../chapters/memory.html#VkMemoryHeapFlagBits):

`VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHR`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR`

    VkDeviceCreateInfo devCreateInfo = { VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO };
    // (not shown) fill out devCreateInfo as usual.
    uint32_t deviceGroupCount = 0;
    VkPhysicalDeviceGroupPropertiesKHR *props = NULL;

    // Query the number of device groups
    vkEnumeratePhysicalDeviceGroupsKHR(g_vkInstance, &deviceGroupCount, NULL);

    // Allocate and initialize structures to query the device groups
    props = (VkPhysicalDeviceGroupPropertiesKHR *)malloc(deviceGroupCount*sizeof(VkPhysicalDeviceGroupPropertiesKHR));
    for (i = 0; i  1) {
        deviceGroupInfo.physicalDeviceCount = props[0].physicalDeviceCount;
        deviceGroupInfo.pPhysicalDevices = props[0].physicalDevices;
        devCreateInfo.pNext = &deviceGroupInfo;
    }

    vkCreateDevice(props[0].physicalDevices[0], &devCreateInfo, NULL, &g_vkDevice);
    free(props);

* 
Revision 1, 2016-10-19 (Jeff Bolz)

Internal revisions

**Name String**

`VK_KHR_draw_indirect_count`

**Extension Type**

Device extension

**Registered Extension Number**

170

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

None

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.2](versions.html#versions-1.2-promotions)

**Contact**

* 
Piers Daniell [pdaniell-nv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_draw_indirect_count] @pdaniell-nv%0A*Here describe the issue or question you have about the VK_KHR_draw_indirect_count extension*)

**Last Modified Date**

2017-08-25

**IP Status**

No known IP claims.

**Contributors**

* 
Matthaeus G. Chajdas, AMD

* 
Derrick Owens, AMD

* 
Graham Sellers, AMD

* 
Daniel Rakos, AMD

* 
Dominik Witczak, AMD

* 
Piers Daniell, NVIDIA

This extension is based on the `[VK_AMD_draw_indirect_count](#VK_AMD_draw_indirect_count)`
extension.
This extension allows an application to source the number of draws for
indirect drawing calls from a buffer.

Applications might want to do culling on the GPU via a compute shader prior
to drawing.
This enables the application to generate an arbitrary number of drawing
commands and execute them without host intervention.

All functionality in this extension is included in core Vulkan 1.2, with the
KHR suffix omitted.
However, if Vulkan 1.2 is supported and this extension is not, the commands
[vkCmdDrawIndirectCount](../chapters/drawing.html#vkCmdDrawIndirectCount) and [vkCmdDrawIndexedIndirectCount](../chapters/drawing.html#vkCmdDrawIndexedIndirectCount) are
optional.
The original type, enum, and command names are still available as aliases of
the core functionality.

* 
[vkCmdDrawIndexedIndirectCountKHR](../chapters/drawing.html#vkCmdDrawIndexedIndirectCountKHR)

* 
[vkCmdDrawIndirectCountKHR](../chapters/drawing.html#vkCmdDrawIndirectCountKHR)

* 
`VK_KHR_DRAW_INDIRECT_COUNT_EXTENSION_NAME`

* 
`VK_KHR_DRAW_INDIRECT_COUNT_SPEC_VERSION`

* 
Revision 1, 2017-08-25 (Piers Daniell)

Initial draft based on VK_AMD_draw_indirect_count

**Name String**

`VK_KHR_driver_properties`

**Extension Type**

Device extension

**Registered Extension Number**

197

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.2](versions.html#versions-1.2-promotions)

**Contact**

* 
Daniel Rakos [drakos-amd](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_driver_properties] @drakos-amd%0A*Here describe the issue or question you have about the VK_KHR_driver_properties extension*)

**Last Modified Date**

2018-04-11

**IP Status**

No known IP claims.

**Contributors**

* 
Baldur Karlsson

* 
Matthaeus G. Chajdas, AMD

* 
Piers Daniell, NVIDIA

* 
Alexander Galazin, Arm

* 
Jesse Hall, Google

* 
Daniel Rakos, AMD

This extension provides a new physical device query which allows retrieving
information about the driver implementation, allowing applications to
determine which physical device corresponds to which particular vendors
driver, and which conformance test suite version the driver implementation
is compliant with.

All functionality in this extension is included in core Vulkan 1.2, with the
KHR suffix omitted.
The original type, enum, and command names are still available as aliases of
the core functionality.

* 
[VkConformanceVersionKHR](../chapters/devsandqueues.html#VkConformanceVersionKHR)

* 
Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

[VkPhysicalDeviceDriverPropertiesKHR](../chapters/devsandqueues.html#VkPhysicalDeviceDriverPropertiesKHR)

* 
[VkDriverIdKHR](../chapters/devsandqueues.html#VkDriverIdKHR)

* 
`VK_KHR_DRIVER_PROPERTIES_EXTENSION_NAME`

* 
`VK_KHR_DRIVER_PROPERTIES_SPEC_VERSION`

* 
`VK_MAX_DRIVER_INFO_SIZE_KHR`

* 
`VK_MAX_DRIVER_NAME_SIZE_KHR`

* 
Extending [VkDriverId](../chapters/devsandqueues.html#VkDriverId):

`VK_DRIVER_ID_AMD_OPEN_SOURCE_KHR`

* 
`VK_DRIVER_ID_AMD_PROPRIETARY_KHR`

* 
`VK_DRIVER_ID_ARM_PROPRIETARY_KHR`

* 
`VK_DRIVER_ID_BROADCOM_PROPRIETARY_KHR`

* 
`VK_DRIVER_ID_GGP_PROPRIETARY_KHR`

* 
`VK_DRIVER_ID_GOOGLE_SWIFTSHADER_KHR`

* 
`VK_DRIVER_ID_IMAGINATION_PROPRIETARY_KHR`

* 
`VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA_KHR`

* 
`VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS_KHR`

* 
`VK_DRIVER_ID_MESA_RADV_KHR`

* 
`VK_DRIVER_ID_NVIDIA_PROPRIETARY_KHR`

* 
`VK_DRIVER_ID_QUALCOMM_PROPRIETARY_KHR`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR`

* 
Revision 1, 2018-04-11 (Daniel Rakos)

Internal revisions

**Name String**

`VK_KHR_dynamic_rendering`

**Extension Type**

Device extension

**Registered Extension Number**

45

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

 [VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

 or

 [Vulkan Version 1.1](versions.html#versions-1.1)

 and

 [VK_KHR_depth_stencil_resolve](#VK_KHR_depth_stencil_resolve)

or

[Vulkan Version 1.2](versions.html#versions-1.2)

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.3](versions.html#versions-1.3-promotions)

**Contact**

* 
Tobias Hector [tobski](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_dynamic_rendering] @tobski%0A*Here describe the issue or question you have about the VK_KHR_dynamic_rendering extension*)

**Extension Proposal**

[VK_KHR_dynamic_rendering](../../../features/latest/features/proposals/VK_KHR_dynamic_rendering.html)

**Last Modified Date**

2021-10-06

**Contributors**

* 
Tobias Hector, AMD

* 
Arseny Kapoulkine, Roblox

* 
Franois Duranleau, Gameloft

* 
Stuart Smith, AMD

* 
Hai Nguyen, Google

* 
Jean-Franois Roy, Google

* 
Jeff Leger, Qualcomm

* 
Jan-Harald Fredriksen, Arm

* 
Piers Daniell, Nvidia

* 
James Fitzpatrick, Imagination

* 
Piotr Byszewski, Mobica

* 
Jesse Hall, Google

* 
Mike Blumenkrantz, Valve

This extension allows applications to create single-pass render pass
instances without needing to create render pass objects or framebuffers.
Dynamic render passes can also span across multiple primary command buffers,
rather than relying on secondary command buffers.

This extension also incorporates `VK_ATTACHMENT_STORE_OP_NONE_KHR` from
`[VK_QCOM_render_pass_store_ops](#VK_QCOM_render_pass_store_ops)`, enabling applications to avoid
unnecessary synchronization when an attachment is not written during a
render pass.

* 
[vkCmdBeginRenderingKHR](../chapters/renderpass.html#vkCmdBeginRenderingKHR)

* 
[vkCmdEndRenderingKHR](../chapters/renderpass.html#vkCmdEndRenderingKHR)

* 
[VkRenderingAttachmentInfoKHR](../chapters/renderpass.html#VkRenderingAttachmentInfoKHR)

* 
[VkRenderingInfoKHR](../chapters/renderpass.html#VkRenderingInfoKHR)

* 
Extending [VkCommandBufferInheritanceInfo](../chapters/cmdbuffers.html#VkCommandBufferInheritanceInfo):

[VkCommandBufferInheritanceRenderingInfoKHR](../chapters/cmdbuffers.html#VkCommandBufferInheritanceRenderingInfoKHR)

Extending [VkGraphicsPipelineCreateInfo](../chapters/pipelines.html#VkGraphicsPipelineCreateInfo):

* 
[VkPipelineRenderingCreateInfoKHR](../chapters/pipelines.html#VkPipelineRenderingCreateInfoKHR)

Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

* 
[VkPhysicalDeviceDynamicRenderingFeaturesKHR](../chapters/features.html#VkPhysicalDeviceDynamicRenderingFeaturesKHR)

* 
[VkRenderingFlagBitsKHR](../chapters/renderpass.html#VkRenderingFlagBitsKHR)

* 
[VkRenderingFlagsKHR](../chapters/renderpass.html#VkRenderingFlagsKHR)

* 
`VK_KHR_DYNAMIC_RENDERING_EXTENSION_NAME`

* 
`VK_KHR_DYNAMIC_RENDERING_SPEC_VERSION`

* 
Extending [VkAttachmentStoreOp](../chapters/renderpass.html#VkAttachmentStoreOp):

`VK_ATTACHMENT_STORE_OP_NONE_KHR`

Extending [VkRenderingFlagBits](../chapters/renderpass.html#VkRenderingFlagBits):

* 
`VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT_KHR`

* 
`VK_RENDERING_RESUMING_BIT_KHR`

* 
`VK_RENDERING_SUSPENDING_BIT_KHR`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES_KHR`

* 
`VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_RENDERING_INFO_KHR`

Vulkan APIs in this extension are included in core Vulkan 1.3, with the KHR
suffix omitted.
External interactions defined by this extension, such as SPIR-V token names,
retain their original names.
The original Vulkan API names are still available as aliases of the core
functionality.

* 
Revision 1, 2021-10-06 (Tobias Hector)

Initial revision

**Name String**

`VK_KHR_dynamic_rendering_local_read`

**Extension Type**

Device extension

**Registered Extension Number**

233

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_dynamic_rendering](#VK_KHR_dynamic_rendering)

or

[Vulkan Version 1.3](versions.html#versions-1.3)

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.4](versions.html#versions-1.4-promotions)

**Contact**

* 
Tobias Hector [tobski](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_dynamic_rendering_local_read] @tobski%0A*Here describe the issue or question you have about the VK_KHR_dynamic_rendering_local_read extension*)

**Extension Proposal**

[VK_KHR_dynamic_rendering_local_read](../../../features/latest/features/proposals/VK_KHR_dynamic_rendering_local_read.html)

**Last Modified Date**

2023-11-03

**Contributors**

* 
Tobias Hector, AMD

* 
Hans-Kristian Arntzen, Valve

* 
Connor Abbott, Valve

* 
Pan Gao, Huawei

* 
Lionel Landwerlin, Intel

* 
Shahbaz Youssefi, Google

* 
Alyssa Rosenzweig, Valve

* 
Jan-Harald Fredriksen, Arm

* 
Mike Blumenkrantz, Valve

* 
Graeme Leese, Broadcom

* 
Piers Daniell, Nvidia

* 
Stuart Smith, AMD

* 
Daniel Story, Nintendo

* 
James Fitzpatrick, Imagination

* 
Piotr Byszewski, Mobica

* 
Spencer Fricke, LunarG

* 
Tom Olson, Arm

* 
Michal Pietrasiuk, Intel

* 
Matthew Netsch, Qualcomm

* 
Marty Johnson, Khronos

* 
Wyvern Wang, Huawei

* 
Jeff Bolz, Nvidia

* 
Samuel (Sheng-Wen) Huang, MediaTek

This extension enables reads from attachments and resources written by
previous fragment shaders within a dynamic render pass.

* 
[vkCmdSetRenderingAttachmentLocationsKHR](../chapters/interfaces.html#vkCmdSetRenderingAttachmentLocationsKHR)

* 
[vkCmdSetRenderingInputAttachmentIndicesKHR](../chapters/interfaces.html#vkCmdSetRenderingInputAttachmentIndicesKHR)

* 
Extending [VkGraphicsPipelineCreateInfo](../chapters/pipelines.html#VkGraphicsPipelineCreateInfo), [VkCommandBufferInheritanceInfo](../chapters/cmdbuffers.html#VkCommandBufferInheritanceInfo):

[VkRenderingAttachmentLocationInfoKHR](../chapters/interfaces.html#VkRenderingAttachmentLocationInfoKHR)

* 
[VkRenderingInputAttachmentIndexInfoKHR](../chapters/interfaces.html#VkRenderingInputAttachmentIndexInfoKHR)

Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

* 
[VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR](../chapters/features.html#VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR)

* 
`VK_KHR_DYNAMIC_RENDERING_LOCAL_READ_EXTENSION_NAME`

* 
`VK_KHR_DYNAMIC_RENDERING_LOCAL_READ_SPEC_VERSION`

* 
Extending [VkImageLayout](../chapters/resources.html#VkImageLayout):

`VK_IMAGE_LAYOUT_RENDERING_LOCAL_READ_KHR`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES_KHR`

* 
`VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO_KHR`

Functionality in this extension is included in core Vulkan 1.4, with the KHR
suffix omitted.
However, Vulkan 1.4 implementations only have to support local read for
storage resources and single sampled color attachments.

Support for reading depth/stencil attachments and multi-sampled attachments
are respectively gated behind the new boolean
`dynamicRenderingLocalReadDepthStencilAttachments` and
`dynamicRenderingLocalReadMultisampledAttachments` properties, as
described in the [Version 1.4](versions.html#versions-1.4) appendix.

The original type, enum, and command names are still available as aliases of
the core functionality.

* 
Revision 1, 2023-11-03 (Tobias Hector)

Initial revision

**Name String**

`VK_KHR_external_fence`

**Extension Type**

Device extension

**Registered Extension Number**

114

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_external_fence_capabilities](#VK_KHR_external_fence_capabilities)

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.1](versions.html#versions-1.1-promotions)

**Contact**

* 
Jesse Hall [critsec](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_external_fence] @critsec%0A*Here describe the issue or question you have about the VK_KHR_external_fence extension*)

**Last Modified Date**

2017-05-08

**IP Status**

No known IP claims.

**Contributors**

* 
Jesse Hall, Google

* 
James Jones, NVIDIA

* 
Jeff Juliano, NVIDIA

* 
Cass Everitt, Oculus

* 
Contributors to `[VK_KHR_external_semaphore](#VK_KHR_external_semaphore)`

An application using external memory may wish to synchronize access to that
memory using fences.
This extension enables an application to create fences from which non-Vulkan
handles that reference the underlying synchronization primitive can be
exported.

All functionality in this extension is included in core Vulkan 1.1, with the
KHR suffix omitted.
The original type, enum, and command names are still available as aliases of
the core functionality.

* 
Extending [VkFenceCreateInfo](../chapters/synchronization.html#VkFenceCreateInfo):

[VkExportFenceCreateInfoKHR](../chapters/synchronization.html#VkExportFenceCreateInfoKHR)

* 
[VkFenceImportFlagBitsKHR](../chapters/synchronization.html#VkFenceImportFlagBitsKHR)

* 
[VkFenceImportFlagsKHR](../chapters/synchronization.html#VkFenceImportFlagsKHR)

* 
`VK_KHR_EXTERNAL_FENCE_EXTENSION_NAME`

* 
`VK_KHR_EXTERNAL_FENCE_SPEC_VERSION`

* 
Extending [VkFenceImportFlagBits](../chapters/synchronization.html#VkFenceImportFlagBits):

`VK_FENCE_IMPORT_TEMPORARY_BIT_KHR`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR`

This extension borrows concepts, semantics, and language from
`[VK_KHR_external_semaphore](#VK_KHR_external_semaphore)`.
That extensions issues apply equally to this extension.

* 
Revision 1, 2017-05-08 (Jesse Hall)

Initial revision

**Name String**

`VK_KHR_external_fence_capabilities`

**Extension Type**

Instance extension

**Registered Extension Number**

113

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.1](versions.html#versions-1.1-promotions)

**Contact**

* 
Jesse Hall [critsec](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_external_fence_capabilities] @critsec%0A*Here describe the issue or question you have about the VK_KHR_external_fence_capabilities extension*)

**Last Modified Date**

2017-05-08

**IP Status**

No known IP claims.

**Contributors**

* 
Jesse Hall, Google

* 
James Jones, NVIDIA

* 
Jeff Juliano, NVIDIA

* 
Cass Everitt, Oculus

* 
Contributors to `[VK_KHR_external_semaphore_capabilities](#VK_KHR_external_semaphore_capabilities)`

An application may wish to reference device fences in multiple Vulkan
logical devices or instances, in multiple processes, and/or in multiple
APIs.
This extension provides a set of capability queries and handle definitions
that allow an application to determine what types of external fence
handles an implementation supports for a given set of use cases.

All functionality in this extension is included in core Vulkan 1.1, with the
KHR suffix omitted.
The original type, enum, and command names are still available as aliases of
the core functionality.

* 
[vkGetPhysicalDeviceExternalFencePropertiesKHR](../chapters/capabilities.html#vkGetPhysicalDeviceExternalFencePropertiesKHR)

* 
[VkExternalFencePropertiesKHR](../chapters/capabilities.html#VkExternalFencePropertiesKHR)

* 
[VkPhysicalDeviceExternalFenceInfoKHR](../chapters/capabilities.html#VkPhysicalDeviceExternalFenceInfoKHR)

* 
Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

[VkPhysicalDeviceIDPropertiesKHR](../chapters/devsandqueues.html#VkPhysicalDeviceIDPropertiesKHR)

* 
[VkExternalFenceFeatureFlagBitsKHR](../chapters/capabilities.html#VkExternalFenceFeatureFlagBitsKHR)

* 
[VkExternalFenceHandleTypeFlagBitsKHR](../chapters/capabilities.html#VkExternalFenceHandleTypeFlagBitsKHR)

* 
[VkExternalFenceFeatureFlagsKHR](../chapters/capabilities.html#VkExternalFenceFeatureFlagsKHR)

* 
[VkExternalFenceHandleTypeFlagsKHR](../chapters/capabilities.html#VkExternalFenceHandleTypeFlagsKHR)

* 
`VK_KHR_EXTERNAL_FENCE_CAPABILITIES_EXTENSION_NAME`

* 
`VK_KHR_EXTERNAL_FENCE_CAPABILITIES_SPEC_VERSION`

* 
`VK_LUID_SIZE_KHR`

* 
Extending [VkExternalFenceFeatureFlagBits](../chapters/capabilities.html#VkExternalFenceFeatureFlagBits):

`VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR`

* 
`VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR`

Extending [VkExternalFenceHandleTypeFlagBits](../chapters/capabilities.html#VkExternalFenceHandleTypeFlagBits):

* 
`VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR`

* 
`VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR`

* 
`VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR`

* 
`VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR`

* 
Revision 1, 2017-05-08 (Jesse Hall)

Initial version

**Name String**

`VK_KHR_external_memory`

**Extension Type**

Device extension

**Registered Extension Number**

73

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_external_memory_capabilities](#VK_KHR_external_memory_capabilities)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.1](versions.html#versions-1.1-promotions)

**Contact**

* 
James Jones [cubanismo](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_external_memory] @cubanismo%0A*Here describe the issue or question you have about the VK_KHR_external_memory extension*)

**Last Modified Date**

2016-10-20

**IP Status**

No known IP claims.

**Interactions and External Dependencies**

* 
Interacts with `[VK_KHR_dedicated_allocation](#VK_KHR_dedicated_allocation)`.

* 
Interacts with `[VK_NV_dedicated_allocation](#VK_NV_dedicated_allocation)`.

**Contributors**

* 
Faith Ekstrand, Intel

* 
Ian Elliott, Google

* 
Jesse Hall, Google

* 
Tobias Hector, Imagination Technologies

* 
James Jones, NVIDIA

* 
Jeff Juliano, NVIDIA

* 
Matthew Netsch, Qualcomm Technologies, Inc.

* 
Daniel Rakos, AMD

* 
Carsten Rohde, NVIDIA

* 
Ray Smith, ARM

* 
Lina Versace, Google

An application may wish to reference device memory in multiple Vulkan
logical devices or instances, in multiple processes, and/or in multiple
APIs.
This extension enables an application to export non-Vulkan handles from
Vulkan memory objects such that the underlying resources can be referenced
outside the scope of the Vulkan logical device that created them.

All functionality in this extension is included in core Vulkan 1.1, with the
KHR suffix omitted.
The original type, enum, and command names are still available as aliases of
the core functionality.

* 
Extending [VkBufferCreateInfo](../chapters/resources.html#VkBufferCreateInfo):

[VkExternalMemoryBufferCreateInfoKHR](../chapters/resources.html#VkExternalMemoryBufferCreateInfoKHR)

Extending [VkImageCreateInfo](../chapters/resources.html#VkImageCreateInfo):

* 
[VkExternalMemoryImageCreateInfoKHR](../chapters/resources.html#VkExternalMemoryImageCreateInfoKHR)

Extending [VkMemoryAllocateInfo](../chapters/memory.html#VkMemoryAllocateInfo):

* 
[VkExportMemoryAllocateInfoKHR](../chapters/memory.html#VkExportMemoryAllocateInfoKHR)

* 
`VK_KHR_EXTERNAL_MEMORY_EXTENSION_NAME`

* 
`VK_KHR_EXTERNAL_MEMORY_SPEC_VERSION`

* 
`VK_QUEUE_FAMILY_EXTERNAL_KHR`

* 
Extending [VkResult](../chapters/fundamentals.html#VkResult):

`VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR`

1) How do applications correlate two physical devices across process or
Vulkan instance boundaries?

**RESOLVED**: New device ID fields have been introduced by
`[VK_KHR_external_memory_capabilities](#VK_KHR_external_memory_capabilities)`.
These fields, combined with the existing
[VkPhysicalDeviceProperties](../chapters/devsandqueues.html#VkPhysicalDeviceProperties)::`driverVersion` field can be used to
identify compatible devices across processes, drivers, and APIs.
[VkPhysicalDeviceProperties](../chapters/devsandqueues.html#VkPhysicalDeviceProperties)::`pipelineCacheUUID` is not sufficient
for this purpose because despite its description in the specification, it
need only identify a unique pipeline cache format in practice.
Multiple devices may be able to use the same pipeline cache data, and hence
it would be desirable for all of them to have the same pipeline cache UUID.
However, only the same concrete physical device can be used when sharing
memory, so an actual unique device ID was introduced.
Further, the pipeline cache UUID was specific to Vulkan, but correlation
with other, non-extensible APIs is required to enable interoperation with
those APIs.

2) If memory objects are shared between processes and APIs, is this
considered aliasing according to the rules outlined in the
[Memory Aliasing](../chapters/resources.html#resources-memory-aliasing) section?

**RESOLVED**: Yes.
Applications must take care to obey all restrictions imposed on aliased
resources when using memory across multiple Vulkan instances or other APIs.

3) Are new image layouts or metadata required to specify image layouts and
layout transitions compatible with non-Vulkan APIs, or with other instances
of the same Vulkan driver?

**RESOLVED**: Separate instances of the same Vulkan driver running on the same
GPU should have identical internal layout semantics, so applications have
the tools they need to ensure views of images are consistent between the two
instances.
Other APIs will fall into two categories: Those that are Vulkan- compatible,
and those that are Vulkan-incompatible.
Vulkan-incompatible APIs will require the image to be in the GENERAL layout
whenever they are accessing them.

Note this does not attempt to address cross-device transitions, nor
transitions to engines on the same device which are not visible within the
Vulkan API.
Both of these are beyond the scope of this extension.

4) Is a new barrier flag or operation of some type needed to prepare
external memory for handoff to another Vulkan instance or API and/or receive
it from another instance or API?

**RESOLVED**: Yes.
Some implementations need to perform additional cache management when
transitioning memory between address spaces and other APIs, instances, or
processes which may operate in a separate address space.
Options for defining this transition include:

* 
A new structure that can be added to the `pNext` list in
[VkMemoryBarrier](../chapters/synchronization.html#VkMemoryBarrier), [VkBufferMemoryBarrier](../chapters/synchronization.html#VkBufferMemoryBarrier), and
[VkImageMemoryBarrier](../chapters/synchronization.html#VkImageMemoryBarrier).

* 
A new bit in [VkAccessFlags](../chapters/synchronization.html#VkAccessFlags) that can be set to indicate an
external access.

* 
A new bit in [VkDependencyFlags](../chapters/synchronization.html#VkDependencyFlags)

* 
A new special queue family that represents an external queue.

A new structure has the advantage that the type of external transition can
be described in as much detail as necessary.
However, there is not currently a known need for anything beyond
differentiating between external and internal accesses, so this is likely an
over-engineered solution.
The access flag bit has the advantage that it can be applied at buffer,
image, or global granularity, and semantically it maps pretty well to the
operation being described.
Additionally, the API already includes `VK_ACCESS_MEMORY_READ_BIT` and
`VK_ACCESS_MEMORY_WRITE_BIT` which appear to be intended for this
purpose.
However, there is no obvious pipeline stage that would correspond to an
external access, and therefore no clear way to use
`VK_ACCESS_MEMORY_READ_BIT` or `VK_ACCESS_MEMORY_WRITE_BIT`.
[VkDependencyFlags](../chapters/synchronization.html#VkDependencyFlags) and [VkPipelineStageFlags](../chapters/synchronization.html#VkPipelineStageFlags) operate at command
granularity rather than image or buffer granularity, which would make an
entire pipeline barrier an internalexternal or externalinternal barrier.
This may not be a problem in practice, but seems like the wrong scope.
Another downside of [VkDependencyFlags](../chapters/synchronization.html#VkDependencyFlags) is that it lacks inherent
directionality: there are no `src` and `dst` variants of it in the
barrier or dependency description semantics, so two bits might need to be
added to describe both internalexternal and externalinternal
transitions.
Transitioning a resource to a special queue family corresponds well with the
operation of transitioning to a separate Vulkan instance, in that both
operations ideally include scheduling a barrier on both sides of the
transition: Both the releasing and the acquiring queue or process.
Using a special queue family requires adding an additional reserved queue
family index.
Reusing `VK_QUEUE_FAMILY_IGNORED` would have left it unclear how to
transition a concurrent usage resource from one process to another, since
the semantics would have likely been equivalent to the currently-ignored
transition of
`VK_QUEUE_FAMILY_IGNORED``VK_QUEUE_FAMILY_IGNORED`.
Fortunately, creating a new reserved queue family index is not invasive.

Based on the above analysis, the approach of transitioning to a special
external queue family was chosen.

5) Do internal driver memory arrangements and/or other internal driver image
properties need to be exported and imported when sharing images across
processes or APIs.

**RESOLVED**: Some vendors claim this is necessary on their implementations,
but it was determined that the security risks of allowing opaque metadata to
be passed from applications to the driver were too high.
Therefore, implementations which require metadata will need to associate it
with the objects represented by the external handles, and rely on the
dedicated allocation mechanism to associate the exported and imported memory
objects with a single image or buffer.

6) Most prior interoperation and cross-process sharing APIs have been based
on image-level sharing.
Should Vulkan sharing be based on memory-object sharing or image sharing?

**RESOLVED**: These extensions have assumed memory-level sharing is the
correct granularity.
Vulkan is a lower-level API than most prior APIs, and as such attempts to
closely align with to the underlying primitives of the hardware and
system-level drivers it abstracts.
In general, the resource that holds the backing store for both images and
buffers of various types is memory.
Images and buffers are merely metadata containing brief descriptions of the
layout of bits within that memory.

Because memory object-based sharing is aligned with the overall Vulkan API
design, it enables the full range of Vulkan capabilities with external
objects.
External memory can be used as backing for sparse images, for example,
whereas such usage would be awkward at best with a sharing mechanism based
on higher-level primitives such as images.
Further, aligning the mechanism with the API in this way provides some hope
of trivial compatibility with future API enhancements.
If new objects backed by memory objects are added to the API, they too can
be used across processes with minimal additions to the base external memory
APIs.

Earlier APIs implemented interop at a higher level, and this necessitated
entirely separate sharing APIs for images and buffers.
To co-exist and interoperate with those APIs, the Vulkan external sharing
mechanism must accommodate their model.
However, if it can be agreed that memory-based sharing is the more desirable
and forward-looking design, legacy interoperation constraints can be
considered another reason to favor memory-based sharing: while native and
legacy driver primitives that may be used to implement sharing may not be as
low-level as the API here suggests, raw memory is still the least common
denominator among the types.
Image-based sharing can be cleanly derived from a set of base memory- object
sharing APIs with minimal effort, whereas image-based sharing does not
generalize well to buffer or raw-memory sharing.
Therefore, following the general Vulkan design principle of minimalism, it
is better to expose interopability with image-based native and external
primitives via the memory sharing API, and place sufficient limits on their
usage to ensure they can be used only as backing for equivalent Vulkan
images.
This provides a consistent API for applications regardless of which platform
or external API they are targeting, which makes development of multi-API and
multi-platform applications simpler.

7) Should Vulkan define a common external handle type and provide Vulkan
functions to facilitate cross-process sharing of such handles rather than
relying on native handles to define the external objects?

**RESOLVED**: No.
Cross-process sharing of resources is best left to native platforms.
There are myriad security and extensibility issues with such a mechanism,
and attempting to re-solve all those issues within Vulkan does not align
with Vulkans purpose as a graphics API.
If desired, such a mechanism could be built as a layer or helper library on
top of the opaque native handle defined in this family of extensions.

8) Must implementations provide additional guarantees about state implicitly
included in memory objects for those memory objects that may be exported?

**RESOLVED**: Implementations must ensure that sharing memory objects does not
transfer any information between the exporting and importing instances and
APIs other than that required to share the data contained in the memory
objects explicitly shared.
As specific examples, data from previously freed memory objects that used
the same underlying physical memory, and data from memory objects using
adjacent physical memory must not be visible to applications importing an
exported memory object.

9) Must implementations validate external handles the application provides
as inputs to memory import operations?

**RESOLVED**: Implementations must return an error to the application if the
provided memory handle cannot be used to complete the requested import
operation.
However, implementations need not validate handles are of the exact type
specified by the application.

* 
Revision 1, 2016-10-20 (James Jones)

Initial version

**Name String**

`VK_KHR_external_memory_capabilities`

**Extension Type**

Instance extension

**Registered Extension Number**

72

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.1](versions.html#versions-1.1-promotions)

**Contact**

* 
James Jones [cubanismo](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_external_memory_capabilities] @cubanismo%0A*Here describe the issue or question you have about the VK_KHR_external_memory_capabilities extension*)

**Last Modified Date**

2016-10-17

**IP Status**

No known IP claims.

**Interactions and External Dependencies**

* 
Interacts with `[VK_KHR_dedicated_allocation](#VK_KHR_dedicated_allocation)`.

* 
Interacts with `[VK_NV_dedicated_allocation](#VK_NV_dedicated_allocation)`.

**Contributors**

* 
Ian Elliott, Google

* 
Jesse Hall, Google

* 
James Jones, NVIDIA

An application may wish to reference device memory in multiple Vulkan
logical devices or instances, in multiple processes, and/or in multiple
APIs.
This extension provides a set of capability queries and handle definitions
that allow an application to determine what types of external memory
handles an implementation supports for a given set of use cases.

All functionality in this extension is included in core Vulkan 1.1, with the
KHR suffix omitted.
The original type, enum, and command names are still available as aliases of
the core functionality.

* 
[vkGetPhysicalDeviceExternalBufferPropertiesKHR](../chapters/capabilities.html#vkGetPhysicalDeviceExternalBufferPropertiesKHR)

* 
[VkExternalBufferPropertiesKHR](../chapters/capabilities.html#VkExternalBufferPropertiesKHR)

* 
[VkExternalMemoryPropertiesKHR](../chapters/capabilities.html#VkExternalMemoryPropertiesKHR)

* 
[VkPhysicalDeviceExternalBufferInfoKHR](../chapters/capabilities.html#VkPhysicalDeviceExternalBufferInfoKHR)

* 
Extending [VkImageFormatProperties2](../chapters/capabilities.html#VkImageFormatProperties2):

[VkExternalImageFormatPropertiesKHR](../chapters/capabilities.html#VkExternalImageFormatPropertiesKHR)

Extending [VkPhysicalDeviceImageFormatInfo2](../chapters/capabilities.html#VkPhysicalDeviceImageFormatInfo2):

* 
[VkPhysicalDeviceExternalImageFormatInfoKHR](../chapters/capabilities.html#VkPhysicalDeviceExternalImageFormatInfoKHR)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceIDPropertiesKHR](../chapters/devsandqueues.html#VkPhysicalDeviceIDPropertiesKHR)

* 
[VkExternalMemoryFeatureFlagBitsKHR](../chapters/capabilities.html#VkExternalMemoryFeatureFlagBitsKHR)

* 
[VkExternalMemoryHandleTypeFlagBitsKHR](../chapters/capabilities.html#VkExternalMemoryHandleTypeFlagBitsKHR)

* 
[VkExternalMemoryFeatureFlagsKHR](../chapters/capabilities.html#VkExternalMemoryFeatureFlagsKHR)

* 
[VkExternalMemoryHandleTypeFlagsKHR](../chapters/capabilities.html#VkExternalMemoryHandleTypeFlagsKHR)

* 
`VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME`

* 
`VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION`

* 
`VK_LUID_SIZE_KHR`

* 
Extending [VkExternalMemoryFeatureFlagBits](../chapters/capabilities.html#VkExternalMemoryFeatureFlagBits):

`VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR`

* 
`VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR`

* 
`VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR`

Extending [VkExternalMemoryHandleTypeFlagBits](../chapters/capabilities.html#VkExternalMemoryHandleTypeFlagBits):

* 
`VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR`

* 
`VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR`

* 
`VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR`

* 
`VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR`

* 
`VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR`

* 
`VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR`

* 
`VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR`

* 
`VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR`

1) Why do so many external memory capabilities need to be queried on a
per-memory-handle-type basis?

**PROPOSED RESOLUTION**: This is because some handle types are based on
OS-native objects that have far more limited capabilities than the very
generic Vulkan memory objects.
Not all memory handle types can name memory objects that support 3D images,
for example.
Some handle types cannot even support the deferred image and memory binding
behavior of Vulkan and require specifying the image when allocating or
importing the memory object.

2) Do the [VkExternalImageFormatPropertiesKHR](../chapters/capabilities.html#VkExternalImageFormatPropertiesKHR) and
[VkExternalBufferPropertiesKHR](../chapters/capabilities.html#VkExternalBufferPropertiesKHR) structs need to include a list of memory
type bits that support the given handle type?

**PROPOSED RESOLUTION**: No.
The memory types that do not support the handle types will simply be
filtered out of the results returned by [vkGetImageMemoryRequirements](../chapters/resources.html#vkGetImageMemoryRequirements)
and [vkGetBufferMemoryRequirements](../chapters/resources.html#vkGetBufferMemoryRequirements) when a set of handle types was
specified at image or buffer creation time.

3) Should the non-opaque handle types be moved to their own extension?

**PROPOSED RESOLUTION**: Perhaps.
However, defining the handle type bits does very little and does not require
any platform-specific types on its own, and it is easier to maintain the
bitfield values in a single extension for now.
Presumably more handle types could be added by separate extensions though,
and it would be midly weird to have some platform-specific ones defined in
the core spec and some in extensions

4) Do we need a `D3D11_TILEPOOL` type?

**PROPOSED RESOLUTION**: No.
This is technically possible, but the synchronization is awkward.
D3D11 surfaces must be synchronized using shared mutexes, and these
synchronization primitives are shared by the entire memory object, so D3D11
shared allocations divided among multiple buffer and image bindings may be
difficult to synchronize.

5) Should the Windows 7-compatible handle types be named KMT handles or
GLOBAL_SHARE handles?

**PROPOSED RESOLUTION**: KMT, simply because it is more concise.

6) How do applications identify compatible devices and drivers across
instance, process, and API boundaries when sharing memory?

**PROPOSED RESOLUTION**: New device properties are exposed that allow
applications to correctly correlate devices and drivers.
A device and driver UUID that must both match to ensure sharing
compatibility between two Vulkan instances, or a Vulkan instance and an
extensible external API are added.
To allow correlating with Direct3D devices, a device LUID is added that
corresponds to a DXGI adapter LUID.
A driver ID is not needed for Direct3D because mismatched driver component
versions are not currently supported on the Windows OS.
Should support for such configurations be introduced at the OS level,
further Vulkan extensions would be needed to correlate userspace component
builds.

* 
Revision 1, 2016-10-17 (James Jones)

Initial version

**Name String**

`VK_KHR_external_semaphore`

**Extension Type**

Device extension

**Registered Extension Number**

78

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_external_semaphore_capabilities](#VK_KHR_external_semaphore_capabilities)

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.1](versions.html#versions-1.1-promotions)

**Contact**

* 
James Jones [cubanismo](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_external_semaphore] @cubanismo%0A*Here describe the issue or question you have about the VK_KHR_external_semaphore extension*)

**Last Modified Date**

2016-10-21

**IP Status**

No known IP claims.

**Contributors**

* 
Faith Ekstrand, Intel

* 
Jesse Hall, Google

* 
Tobias Hector, Imagination Technologies

* 
James Jones, NVIDIA

* 
Jeff Juliano, NVIDIA

* 
Matthew Netsch, Qualcomm Technologies, Inc.

* 
Ray Smith, ARM

* 
Lina Versace, Google

An application using external memory may wish to synchronize access to that
memory using semaphores.
This extension enables an application to create semaphores from which
non-Vulkan handles that reference the underlying synchronization primitive
can be exported.

All functionality in this extension is included in core Vulkan 1.1, with the
KHR suffix omitted.
The original type, enum, and command names are still available as aliases of
the core functionality.

* 
Extending [VkSemaphoreCreateInfo](../chapters/synchronization.html#VkSemaphoreCreateInfo):

[VkExportSemaphoreCreateInfoKHR](../chapters/synchronization.html#VkExportSemaphoreCreateInfoKHR)

* 
[VkSemaphoreImportFlagBitsKHR](../chapters/synchronization.html#VkSemaphoreImportFlagBitsKHR)

* 
[VkSemaphoreImportFlagsKHR](../chapters/synchronization.html#VkSemaphoreImportFlagsKHR)

* 
`VK_KHR_EXTERNAL_SEMAPHORE_EXTENSION_NAME`

* 
`VK_KHR_EXTERNAL_SEMAPHORE_SPEC_VERSION`

* 
Extending [VkSemaphoreImportFlagBits](../chapters/synchronization.html#VkSemaphoreImportFlagBits):

`VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR`

1) Should there be restrictions on what side effects can occur when waiting
on imported semaphores that are in an invalid state?

**RESOLVED**: Yes.
Normally, validating such state would be the responsibility of the
application, and the implementation would be free to enter an **undefined**
state if valid usage rules were violated.
However, this could cause security concerns when using imported semaphores,
as it would require the importing application to trust the exporting
application to ensure the state is valid.
Requiring this level of trust is undesirable for many potential use cases.

2) Must implementations validate external handles the application provides
as input to semaphore state import operations?

**RESOLVED**: Implementations must return an error to the application if the
provided semaphore state handle cannot be used to complete the requested
import operation.
However, implementations need not validate handles are of the exact type
specified by the application.

* 
Revision 1, 2016-10-21 (James Jones)

Initial revision

**Name String**

`VK_KHR_external_semaphore_capabilities`

**Extension Type**

Instance extension

**Registered Extension Number**

77

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.1](versions.html#versions-1.1-promotions)

**Contact**

* 
James Jones [cubanismo](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_external_semaphore_capabilities] @cubanismo%0A*Here describe the issue or question you have about the VK_KHR_external_semaphore_capabilities extension*)

**Last Modified Date**

2016-10-20

**IP Status**

No known IP claims.

**Contributors**

* 
Jesse Hall, Google

* 
James Jones, NVIDIA

* 
Jeff Juliano, NVIDIA

An application may wish to reference device semaphores in multiple Vulkan
logical devices or instances, in multiple processes, and/or in multiple
APIs.
This extension provides a set of capability queries and handle definitions
that allow an application to determine what types of external semaphore
handles an implementation supports for a given set of use cases.

All functionality in this extension is included in core Vulkan 1.1, with the
KHR suffix omitted.
The original type, enum, and command names are still available as aliases of
the core functionality.

* 
[vkGetPhysicalDeviceExternalSemaphorePropertiesKHR](../chapters/capabilities.html#vkGetPhysicalDeviceExternalSemaphorePropertiesKHR)

* 
[VkExternalSemaphorePropertiesKHR](../chapters/capabilities.html#VkExternalSemaphorePropertiesKHR)

* 
[VkPhysicalDeviceExternalSemaphoreInfoKHR](../chapters/capabilities.html#VkPhysicalDeviceExternalSemaphoreInfoKHR)

* 
Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

[VkPhysicalDeviceIDPropertiesKHR](../chapters/devsandqueues.html#VkPhysicalDeviceIDPropertiesKHR)

* 
[VkExternalSemaphoreFeatureFlagBitsKHR](../chapters/capabilities.html#VkExternalSemaphoreFeatureFlagBitsKHR)

* 
[VkExternalSemaphoreHandleTypeFlagBitsKHR](../chapters/capabilities.html#VkExternalSemaphoreHandleTypeFlagBitsKHR)

* 
[VkExternalSemaphoreFeatureFlagsKHR](../chapters/capabilities.html#VkExternalSemaphoreFeatureFlagsKHR)

* 
[VkExternalSemaphoreHandleTypeFlagsKHR](../chapters/capabilities.html#VkExternalSemaphoreHandleTypeFlagsKHR)

* 
`VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION_NAME`

* 
`VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_SPEC_VERSION`

* 
`VK_LUID_SIZE_KHR`

* 
Extending [VkExternalSemaphoreFeatureFlagBits](../chapters/capabilities.html#VkExternalSemaphoreFeatureFlagBits):

`VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR`

* 
`VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR`

Extending [VkExternalSemaphoreHandleTypeFlagBits](../chapters/capabilities.html#VkExternalSemaphoreHandleTypeFlagBits):

* 
`VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR`

* 
`VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR`

* 
`VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR`

* 
`VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR`

* 
`VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR`

* 
Revision 1, 2016-10-20 (James Jones)

Initial revision

**Name String**

`VK_KHR_format_feature_flags2`

**Extension Type**

Device extension

**Registered Extension Number**

361

**Revision**

2

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**API Interactions**

* 
Interacts with VK_VERSION_1_2

* 
Interacts with VK_EXT_filter_cubic

* 
Interacts with VK_EXT_sampler_filter_minmax

* 
Interacts with VK_IMG_filter_cubic

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.3](versions.html#versions-1.3-promotions)

**Contact**

* 
Lionel Landwerlin [llandwerlin](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_format_feature_flags2] @llandwerlin%0A*Here describe the issue or question you have about the VK_KHR_format_feature_flags2 extension*)

**Last Modified Date**

2021-07-01

**IP Status**

No known IP claims.

**Contributors**

* 
Lionel Landwerlin, Intel

* 
Faith Ekstrand, Intel

* 
Tobias Hector, AMD

* 
Spencer Fricke, Samsung Electronics

* 
Graeme Leese, Broadcom

* 
Jan-Harald Fredriksen, ARM

This extension adds a new [VkFormatFeatureFlagBits2KHR](../chapters/formats.html#VkFormatFeatureFlagBits2KHR) 64bits format
feature flag type to extend the existing [VkFormatFeatureFlagBits](../chapters/formats.html#VkFormatFeatureFlagBits) which
is limited to 31 flags.
At the time of this writing 29 bits of [VkFormatFeatureFlagBits](../chapters/formats.html#VkFormatFeatureFlagBits) are
already used.

Because [VkFormatProperties2](../chapters/formats.html#VkFormatProperties2) is already defined to extend the Vulkan
1.0 [vkGetPhysicalDeviceFormatProperties](../chapters/formats.html#vkGetPhysicalDeviceFormatProperties) command, this extension
defines a new [VkFormatProperties3KHR](../chapters/formats.html#VkFormatProperties3KHR) to extend the
[VkFormatProperties](../chapters/formats.html#VkFormatProperties).

On top of replicating all the bits from [VkFormatFeatureFlagBits](../chapters/formats.html#VkFormatFeatureFlagBits),
[VkFormatFeatureFlagBits2KHR](../chapters/formats.html#VkFormatFeatureFlagBits2KHR) adds the following bits :

* 
`VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT_KHR` and
`VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT_KHR` specify
that an implementation supports reading and writing, respectively, a
given [VkFormat](../chapters/formats.html#VkFormat) through storage operations without specifying the
format in the shader.

* 
`VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT_KHR`
specifies that an implementation supports depth comparison performed by
`OpImage*Dref*` instructions on a given [VkFormat](../chapters/formats.html#VkFormat).
Previously the result of executing a `OpImage*Dref*` instruction on
an image view, where the `format` was not one of the depth/stencil
formats with a depth component, was undefined.
This bit clarifies on which formats such instructions can be used.

Prior to version 2 of this extension, implementations exposing the
[`shaderStorageImageReadWithoutFormat`](../chapters/features.html#features-shaderStorageImageReadWithoutFormat) and
[`shaderStorageImageWriteWithoutFormat`](../chapters/features.html#features-shaderStorageImageWriteWithoutFormat) features may not report
`VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT_KHR` and
`VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT_KHR` in
[VkFormatProperties3KHR](../chapters/formats.html#VkFormatProperties3KHR)::`bufferFeatures`.
Despite this, buffer reads/writes are supported as intended by the original
features.

* 
Extending [VkFormatProperties2](../chapters/formats.html#VkFormatProperties2):

[VkFormatProperties3KHR](../chapters/formats.html#VkFormatProperties3KHR)

* 
[VkFormatFeatureFlagBits2KHR](../chapters/formats.html#VkFormatFeatureFlagBits2KHR)

* 
[VkFormatFeatureFlags2KHR](../chapters/formats.html#VkFormatFeatureFlags2KHR)

* 
`VK_KHR_FORMAT_FEATURE_FLAGS_2_EXTENSION_NAME`

* 
`VK_KHR_FORMAT_FEATURE_FLAGS_2_SPEC_VERSION`

* 
Extending [VkFormatFeatureFlagBits2](../chapters/formats.html#VkFormatFeatureFlagBits2):

`VK_FORMAT_FEATURE_2_BLIT_DST_BIT_KHR`

* 
`VK_FORMAT_FEATURE_2_BLIT_SRC_BIT_KHR`

* 
`VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT_KHR`

* 
`VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT_KHR`

* 
`VK_FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT_KHR`

* 
`VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT_KHR`

* 
`VK_FORMAT_FEATURE_2_DISJOINT_BIT_KHR`

* 
`VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT_KHR`

* 
`VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT_KHR`

* 
`VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT_KHR`

* 
`VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT_KHR`

* 
`VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR`

* 
`VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR`

* 
`VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR`

* 
`VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR`

* 
`VK_FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT_KHR`

* 
`VK_FORMAT_FEATURE_2_STORAGE_IMAGE_BIT_KHR`

* 
`VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT_KHR`

* 
`VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT_KHR`

* 
`VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT_KHR`

* 
`VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT_KHR`

* 
`VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT_KHR`

* 
`VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT_KHR`

* 
`VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT_KHR`

* 
`VK_FORMAT_FEATURE_2_VERTEX_BUFFER_BIT_KHR`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3_KHR`

If [VK_EXT_filter_cubic](#VK_EXT_filter_cubic) or [VK_IMG_filter_cubic](#VK_IMG_filter_cubic) is supported:

* 
Extending [VkFormatFeatureFlagBits2](../chapters/formats.html#VkFormatFeatureFlagBits2):

`VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT`

If [Vulkan Version 1.2](versions.html#versions-1.2) or [VK_EXT_sampler_filter_minmax](#VK_EXT_sampler_filter_minmax) is supported:

* 
Extending [VkFormatFeatureFlagBits2](../chapters/formats.html#VkFormatFeatureFlagBits2):

`VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT_KHR`

Vulkan APIs in this extension are included in core Vulkan 1.3, with the KHR
suffix omitted.
External interactions defined by this extension, such as SPIR-V token names,
retain their original names.
The original Vulkan API names are still available as aliases of the core
functionality.

* 
Revision 2, 2022-07-20 (Lionel Landwerlin)

Clarify that
VK_FORMAT_FEATURE_2_STORAGE_(READ|WRITE)_WITHOUT_FORMAT_BIT also apply
to buffer views.

Revision 1, 2020-07-21 (Lionel Landwerlin)

* 
Initial draft

**Name String**

`VK_KHR_get_memory_requirements2`

**Extension Type**

Device extension

**Registered Extension Number**

147

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

None

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.1](versions.html#versions-1.1-promotions)

**Contact**

* 
Faith Ekstrand [gfxstrand](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_get_memory_requirements2] @gfxstrand%0A*Here describe the issue or question you have about the VK_KHR_get_memory_requirements2 extension*)

**Last Modified Date**

2017-09-05

**IP Status**

No known IP claims.

**Contributors**

* 
Faith Ekstrand, Intel

* 
Jeff Bolz, NVIDIA

* 
Jesse Hall, Google

This extension provides new queries for memory requirements of images and
buffers that can be easily extended by other extensions, without introducing
any additional commands.
The Vulkan 1.0 [VkMemoryRequirements](../chapters/resources.html#VkMemoryRequirements) and
[VkSparseImageMemoryRequirements](../chapters/sparsemem.html#VkSparseImageMemoryRequirements) structures do not include `sType`
and `pNext` members.
This extension wraps them in new structures with these members, so an
application can query a chain of memory requirements structures by
constructing the chain and letting the implementation fill them in.
A new command is added for each `vkGet*MemoryRequrements` command in
core Vulkan 1.0.

All functionality in this extension is included in core Vulkan 1.1, with the
KHR suffix omitted.
The original type, enum, and command names are still available as aliases of
the core functionality.

* 
[vkGetBufferMemoryRequirements2KHR](../chapters/resources.html#vkGetBufferMemoryRequirements2KHR)

* 
[vkGetImageMemoryRequirements2KHR](../chapters/resources.html#vkGetImageMemoryRequirements2KHR)

* 
[vkGetImageSparseMemoryRequirements2KHR](../chapters/sparsemem.html#vkGetImageSparseMemoryRequirements2KHR)

* 
[VkBufferMemoryRequirementsInfo2KHR](../chapters/resources.html#VkBufferMemoryRequirementsInfo2KHR)

* 
[VkImageMemoryRequirementsInfo2KHR](../chapters/resources.html#VkImageMemoryRequirementsInfo2KHR)

* 
[VkImageSparseMemoryRequirementsInfo2KHR](../chapters/sparsemem.html#VkImageSparseMemoryRequirementsInfo2KHR)

* 
[VkMemoryRequirements2KHR](../chapters/resources.html#VkMemoryRequirements2KHR)

* 
[VkSparseImageMemoryRequirements2KHR](../chapters/sparsemem.html#VkSparseImageMemoryRequirements2KHR)

* 
`VK_KHR_GET_MEMORY_REQUIREMENTS_2_EXTENSION_NAME`

* 
`VK_KHR_GET_MEMORY_REQUIREMENTS_2_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR`

* 
`VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR`

* 
`VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR`

* 
`VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR`

* 
`VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR`

* 
Revision 1, 2017-03-23 (Faith Ekstrand)

Internal revisions

**Name String**

`VK_KHR_get_physical_device_properties2`

**Extension Type**

Instance extension

**Registered Extension Number**

60

**Revision**

2

**Ratification Status**

Ratified

**Extension and Version Dependencies**

None

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.1](versions.html#versions-1.1-promotions)

**Contact**

* 
Jeff Bolz [jeffbolznv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_get_physical_device_properties2] @jeffbolznv%0A*Here describe the issue or question you have about the VK_KHR_get_physical_device_properties2 extension*)

**Last Modified Date**

2017-09-05

**IP Status**

No known IP claims.

**Contributors**

* 
Jeff Bolz, NVIDIA

* 
Ian Elliott, Google

This extension provides new queries for device features, device properties,
and format properties that can be easily extended by other extensions,
without introducing any further queries.
The Vulkan 1.0 feature/limit/formatproperty structures do not include
`sType`/`pNext` members.
This extension wraps them in new structures with `sType`/`pNext`
members, so an application can query a chain of feature/limit/formatproperty
structures by constructing the chain and letting the implementation fill
them in.
A new command is added for each `vkGetPhysicalDevice*` command in core
Vulkan 1.0.
The new feature structure (and a `pNext` chain of extending structures)
can also be passed in to device creation to enable features.

This extension also allows applications to use the physical-device
components of device extensions before [vkCreateDevice](../chapters/devsandqueues.html#vkCreateDevice) is called.

All functionality in this extension is included in core Vulkan 1.1, with the
KHR suffix omitted.
The original type, enum, and command names are still available as aliases of
the core functionality.

* 
[vkGetPhysicalDeviceFeatures2KHR](../chapters/features.html#vkGetPhysicalDeviceFeatures2KHR)

* 
[vkGetPhysicalDeviceFormatProperties2KHR](../chapters/formats.html#vkGetPhysicalDeviceFormatProperties2KHR)

* 
[vkGetPhysicalDeviceImageFormatProperties2KHR](../chapters/capabilities.html#vkGetPhysicalDeviceImageFormatProperties2KHR)

* 
[vkGetPhysicalDeviceMemoryProperties2KHR](../chapters/memory.html#vkGetPhysicalDeviceMemoryProperties2KHR)

* 
[vkGetPhysicalDeviceProperties2KHR](../chapters/devsandqueues.html#vkGetPhysicalDeviceProperties2KHR)

* 
[vkGetPhysicalDeviceQueueFamilyProperties2KHR](../chapters/devsandqueues.html#vkGetPhysicalDeviceQueueFamilyProperties2KHR)

* 
[vkGetPhysicalDeviceSparseImageFormatProperties2KHR](../chapters/sparsemem.html#vkGetPhysicalDeviceSparseImageFormatProperties2KHR)

* 
[VkFormatProperties2KHR](../chapters/formats.html#VkFormatProperties2KHR)

* 
[VkImageFormatProperties2KHR](../chapters/capabilities.html#VkImageFormatProperties2KHR)

* 
[VkPhysicalDeviceImageFormatInfo2KHR](../chapters/capabilities.html#VkPhysicalDeviceImageFormatInfo2KHR)

* 
[VkPhysicalDeviceMemoryProperties2KHR](../chapters/memory.html#VkPhysicalDeviceMemoryProperties2KHR)

* 
[VkPhysicalDeviceProperties2KHR](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2KHR)

* 
[VkPhysicalDeviceSparseImageFormatInfo2KHR](../chapters/sparsemem.html#VkPhysicalDeviceSparseImageFormatInfo2KHR)

* 
[VkQueueFamilyProperties2KHR](../chapters/devsandqueues.html#VkQueueFamilyProperties2KHR)

* 
[VkSparseImageFormatProperties2KHR](../chapters/sparsemem.html#VkSparseImageFormatProperties2KHR)

* 
Extending [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceFeatures2KHR](../chapters/features.html#VkPhysicalDeviceFeatures2KHR)

* 
`VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME`

* 
`VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR`

* 
`VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR`

* 
`VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR`

* 
`VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR`

    // Get features with a hypothetical future extension.
    VkHypotheticalExtensionFeaturesKHR hypotheticalFeatures =
    {
        .sType = VK_STRUCTURE_TYPE_HYPOTHETICAL_FEATURES_KHR,
        .pNext = NULL,
    };

    VkPhysicalDeviceFeatures2KHR features =
    {
        .sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR,
        .pNext = &hypotheticalFeatures,
    };

    // After this call, features and hypotheticalFeatures have been filled out.
    vkGetPhysicalDeviceFeatures2KHR(physicalDevice, &features);

    // Properties/limits can be chained and queried similarly.

    // Enable some features:
    VkHypotheticalExtensionFeaturesKHR enabledHypotheticalFeatures =
    {
        .sType = VK_STRUCTURE_TYPE_HYPOTHETICAL_FEATURES_KHR,
        .pNext = NULL,
    };

    VkPhysicalDeviceFeatures2KHR enabledFeatures =
    {
        .sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR,
        .pNext = &enabledHypotheticalFeatures,
    };

    enabledFeatures.features.xyz = VK_TRUE;
    enabledHypotheticalFeatures.abc = VK_TRUE;

    VkDeviceCreateInfo deviceCreateInfo =
    {
        .sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
        .pNext = &enabledFeatures,
        ...
        .pEnabledFeatures = NULL,
    };

    VkDevice device;
    vkCreateDevice(physicalDevice, &deviceCreateInfo, NULL, &device);

* 
Revision 1, 2016-09-12 (Jeff Bolz)

Internal revisions

Revision 2, 2016-11-02 (Ian Elliott)

* 
Added ability for applications to use the physical-device components of
device extensions before vkCreateDevice is called.

**Name String**

`VK_KHR_global_priority`

**Extension Type**

Device extension

**Registered Extension Number**

189

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.4](versions.html#versions-1.4-promotions)

**Contact**

* 
Tobias Hector [tobski](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_global_priority] @tobski%0A*Here describe the issue or question you have about the VK_KHR_global_priority extension*)

**Last Modified Date**

2021-10-22

**Contributors**

* 
Tobias Hector, AMD

* 
Contributors to `[VK_EXT_global_priority](#VK_EXT_global_priority)`

* 
Contributors to `[VK_EXT_global_priority_query](#VK_EXT_global_priority_query)`

In Vulkan, users can specify device-scope queue priorities.
In some cases it may be useful to extend this concept to a system-wide
scope.
This device extension allows applications to query the global queue
priorities supported by a queue family, and then set a priority when
creating queues.
The default queue priority is `VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT`.

Implementations can report which global priority levels are treated
differently by the implementation.
It is intended primarily for use in system integration along with certain
platform-specific priority enforcement rules.

The driver implementation will attempt to skew hardware resource allocation
in favor of the higher-priority task.
Therefore, higher-priority work may retain similar latency and throughput
characteristics even if the system is congested with lower priority work.

The global priority level of a queue shall take precedence over the
per-process queue priority
(`VkDeviceQueueCreateInfo`::`pQueuePriorities`).

Abuse of this feature may result in starving the rest of the system from
hardware resources.
Therefore, the driver implementation may deny requests to acquire a priority
above the default priority (`VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT`) if
the caller does not have sufficient privileges.
In this scenario `VK_ERROR_NOT_PERMITTED_EXT` is returned.

The driver implementation may fail the queue allocation request if resources
required to complete the operation have been exhausted (either by the same
process or a different process).
In this scenario `VK_ERROR_INITIALIZATION_FAILED` is returned.

* 
Extending [VkDeviceQueueCreateInfo](../chapters/devsandqueues.html#VkDeviceQueueCreateInfo):

[VkDeviceQueueGlobalPriorityCreateInfoKHR](../chapters/devsandqueues.html#VkDeviceQueueGlobalPriorityCreateInfoKHR)

Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

* 
[VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR](../chapters/features.html#VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR)

Extending [VkQueueFamilyProperties2](../chapters/devsandqueues.html#VkQueueFamilyProperties2):

* 
[VkQueueFamilyGlobalPriorityPropertiesKHR](../chapters/devsandqueues.html#VkQueueFamilyGlobalPriorityPropertiesKHR)

* 
[VkQueueGlobalPriorityKHR](../chapters/devsandqueues.html#VkQueueGlobalPriorityKHR)

* 
`VK_KHR_GLOBAL_PRIORITY_EXTENSION_NAME`

* 
`VK_KHR_GLOBAL_PRIORITY_SPEC_VERSION`

* 
`VK_MAX_GLOBAL_PRIORITY_SIZE_KHR`

* 
Extending [VkQueueGlobalPriority](../chapters/devsandqueues.html#VkQueueGlobalPriority):

`VK_QUEUE_GLOBAL_PRIORITY_HIGH_KHR`

* 
`VK_QUEUE_GLOBAL_PRIORITY_LOW_KHR`

* 
`VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_KHR`

* 
`VK_QUEUE_GLOBAL_PRIORITY_REALTIME_KHR`

Extending [VkResult](../chapters/fundamentals.html#VkResult):

* 
`VK_ERROR_NOT_PERMITTED_KHR`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR`

* 
`VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR`

Functionality in this extension is included in core Vulkan 1.4 with the KHR
suffix omitted.
The original type, enum and command names are still available as aliases of
the core functionality.

1) Can we additionally query whether a caller is permitted to acquire a
specific global queue priority in this extension?

**RESOLVED**: No.
Whether a caller has enough privilege goes with the OS, and the Vulkan
driver cannot really guarantee that the privilege will not change in between
this query and the actual queue creation call.

2) If more than 1 queue using global priority is requested, is there a good
way to know which queue is failing the device creation?

**RESOLVED**: No.
There is not a good way at this moment, and it is also not quite actionable
for the applications to know that because the information may not be
accurate.
Queue creation can fail because of runtime constraints like insufficient
privilege or lack of resource, and the failure is not necessarily tied to
that particular queue configuration requested.

* 
Revision 1, 2021-10-22 (Tobias Hector)

Initial draft

**Name String**

`VK_KHR_image_format_list`

**Extension Type**

Device extension

**Registered Extension Number**

148

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

None

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.2](versions.html#versions-1.2-promotions)

**Contact**

* 
Faith Ekstrand [gfxstrand](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_image_format_list] @gfxstrand%0A*Here describe the issue or question you have about the VK_KHR_image_format_list extension*)

**Last Modified Date**

2017-03-20

**IP Status**

No known IP claims.

**Contributors**

* 
Faith Ekstrand, Intel

* 
Jan-Harald Fredriksen, ARM

* 
Jeff Bolz, NVIDIA

* 
Jeff Leger, Qualcomm

* 
Neil Henning, Codeplay

On some implementations, setting the
`VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT` on image creation can cause access
to that image to perform worse than an equivalent image created without
`VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT` because the implementation does not
know what view formats will be paired with the image.

This extension allows an application to provide the list of all formats that
**can** be used with an image when it is created.
The implementation may then be able to create a more efficient image that
supports the subset of formats required by the application without having to
support all formats in the format compatibility class of the image format.

All functionality in this extension is included in core Vulkan 1.2, with the
KHR suffix omitted.
The original type, enum, and command names are still available as aliases of
the core functionality.

* 
Extending [VkImageCreateInfo](../chapters/resources.html#VkImageCreateInfo), [VkSwapchainCreateInfoKHR](../chapters/VK_KHR_surface/wsi.html#VkSwapchainCreateInfoKHR), [VkPhysicalDeviceImageFormatInfo2](../chapters/capabilities.html#VkPhysicalDeviceImageFormatInfo2):

[VkImageFormatListCreateInfoKHR](../chapters/resources.html#VkImageFormatListCreateInfoKHR)

* 
`VK_KHR_IMAGE_FORMAT_LIST_EXTENSION_NAME`

* 
`VK_KHR_IMAGE_FORMAT_LIST_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR`

* 
Revision 1, 2017-03-20 (Faith Ekstrand)

Initial revision

**Name String**

`VK_KHR_imageless_framebuffer`

**Extension Type**

Device extension

**Registered Extension Number**

109

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

 [VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

 and

 [VK_KHR_maintenance2](#VK_KHR_maintenance2)

 or

 [Vulkan Version 1.1](versions.html#versions-1.1)

 and

 [VK_KHR_image_format_list](#VK_KHR_image_format_list)

or

[Vulkan Version 1.2](versions.html#versions-1.2)

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.2](versions.html#versions-1.2-promotions)

**Contact**

* 
Tobias Hector [tobias](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_imageless_framebuffer] @tobias%0A*Here describe the issue or question you have about the VK_KHR_imageless_framebuffer extension*)

**Last Modified Date**

2018-12-14

**Contributors**

* 
Tobias Hector

* 
Graham Wihlidal

This extension allows framebuffers to be created without the need for
creating images first, allowing more flexibility in how they are used, and
avoiding the need for many of the confusing compatibility rules.

Framebuffers are now created with a small amount of additional metadata
about the image views that will be used in
[VkFramebufferAttachmentsCreateInfoKHR](../chapters/renderpass.html#VkFramebufferAttachmentsCreateInfoKHR), and the actual image views are
provided at render pass begin time via
[VkRenderPassAttachmentBeginInfoKHR](../chapters/renderpass.html#VkRenderPassAttachmentBeginInfoKHR).

All functionality in this extension is included in core Vulkan 1.2, with the
KHR suffix omitted.
The original type, enum, and command names are still available as aliases of
the core functionality.

* 
[VkFramebufferAttachmentImageInfoKHR](../chapters/renderpass.html#VkFramebufferAttachmentImageInfoKHR)

* 
Extending [VkFramebufferCreateInfo](../chapters/renderpass.html#VkFramebufferCreateInfo):

[VkFramebufferAttachmentsCreateInfoKHR](../chapters/renderpass.html#VkFramebufferAttachmentsCreateInfoKHR)

Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

* 
[VkPhysicalDeviceImagelessFramebufferFeaturesKHR](../chapters/features.html#VkPhysicalDeviceImagelessFramebufferFeaturesKHR)

Extending [VkRenderPassBeginInfo](../chapters/renderpass.html#VkRenderPassBeginInfo):

* 
[VkRenderPassAttachmentBeginInfoKHR](../chapters/renderpass.html#VkRenderPassAttachmentBeginInfoKHR)

* 
`VK_KHR_IMAGELESS_FRAMEBUFFER_EXTENSION_NAME`

* 
`VK_KHR_IMAGELESS_FRAMEBUFFER_SPEC_VERSION`

* 
Extending [VkFramebufferCreateFlagBits](../chapters/renderpass.html#VkFramebufferCreateFlagBits):

`VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT_KHR`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES_KHR`

* 
`VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO_KHR`

* 
Revision 1, 2018-12-14 (Tobias Hector)

Internal revisions

**Name String**

`VK_KHR_index_type_uint8`

**Extension Type**

Device extension

**Registered Extension Number**

534

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.4](versions.html#versions-1.4-promotions)

**Contact**

* 
Piers Daniell [pdaniell-nv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_index_type_uint8] @pdaniell-nv%0A*Here describe the issue or question you have about the VK_KHR_index_type_uint8 extension*)

**Last Modified Date**

2023-06-06

**IP Status**

No known IP claims.

**Contributors**

* 
Jeff Bolz, NVIDIA

This extension allows `uint8_t` indices to be used with
[vkCmdBindIndexBuffer](../chapters/drawing.html#vkCmdBindIndexBuffer).

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceIndexTypeUint8FeaturesKHR](../chapters/features.html#VkPhysicalDeviceIndexTypeUint8FeaturesKHR)

* 
`VK_KHR_INDEX_TYPE_UINT8_EXTENSION_NAME`

* 
`VK_KHR_INDEX_TYPE_UINT8_SPEC_VERSION`

* 
Extending [VkIndexType](../chapters/drawing.html#VkIndexType):

`VK_INDEX_TYPE_UINT8_KHR`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_KHR`

Functionality in this extension is included in core Vulkan 1.4 with the KHR
suffix omitted.
The original type, enum and command names are still available as aliases of
the core functionality.

* 
Revision 1, 2023-06-06 (Piers Daniell)

Internal revisions

**Name String**

`VK_KHR_line_rasterization`

**Extension Type**

Device extension

**Registered Extension Number**

535

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.4](versions.html#versions-1.4-promotions)

**Contact**

* 
Piers Daniell [pdaniell-nv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_line_rasterization] @pdaniell-nv%0A*Here describe the issue or question you have about the VK_KHR_line_rasterization extension*)

**Last Modified Date**

2023-06-08

**IP Status**

No known IP claims.

**Contributors**

* 
Jeff Bolz, NVIDIA

* 
Allen Jensen, NVIDIA

* 
Faith Ekstrand, Intel

This extension adds some line rasterization features that are commonly used
in CAD applications and supported in other APIs like OpenGL.
Bresenham-style line rasterization is supported, smooth rectangular lines
(coverage to alpha) are supported, and stippled lines are supported for all
three line rasterization modes.

* 
[vkCmdSetLineStippleKHR](../chapters/primsrast.html#vkCmdSetLineStippleKHR)

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceLineRasterizationFeaturesKHR](../chapters/features.html#VkPhysicalDeviceLineRasterizationFeaturesKHR)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceLineRasterizationPropertiesKHR](../chapters/limits.html#VkPhysicalDeviceLineRasterizationPropertiesKHR)

Extending [VkPipelineRasterizationStateCreateInfo](../chapters/primsrast.html#VkPipelineRasterizationStateCreateInfo):

* 
[VkPipelineRasterizationLineStateCreateInfoKHR](../chapters/primsrast.html#VkPipelineRasterizationLineStateCreateInfoKHR)

* 
[VkLineRasterizationModeKHR](../chapters/primsrast.html#VkLineRasterizationModeKHR)

* 
`VK_KHR_LINE_RASTERIZATION_EXTENSION_NAME`

* 
`VK_KHR_LINE_RASTERIZATION_SPEC_VERSION`

* 
Extending [VkDynamicState](../chapters/pipelines.html#VkDynamicState):

`VK_DYNAMIC_STATE_LINE_STIPPLE_KHR`

Extending [VkLineRasterizationMode](../chapters/primsrast.html#VkLineRasterizationMode):

* 
`VK_LINE_RASTERIZATION_MODE_BRESENHAM_KHR`

* 
`VK_LINE_RASTERIZATION_MODE_DEFAULT_KHR`

* 
`VK_LINE_RASTERIZATION_MODE_RECTANGULAR_KHR`

* 
`VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_KHR`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_KHR`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_KHR`

* 
`VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_KHR`

Functionality in this extension is included in core Vulkan 1.4 with the KHR
suffix omitted.
The original type, enum and command names are still available as aliases of
the core functionality.

When [Version 1.4](versions.html#versions-1.4) is supported, the
[`bresenhamLines`](../chapters/features.html#features-bresenhamLines) feature must be supported.

1) Do we need to support Bresenham-style and smooth lines with more than one
rasterization sample? i.e. the equivalent of glDisable(GL_MULTISAMPLE) in
OpenGL when the framebuffer has more than one sample?

**RESOLVED**: Yes.
For simplicity, Bresenham line rasterization carries forward a few
restrictions from OpenGL, such as not supporting per-sample shading, alpha
to coverage, or alpha to one.

* 
Revision 1, 2019-05-09 (Jeff Bolz)

Initial draft

**Name String**

`VK_KHR_load_store_op_none`

**Extension Type**

Device extension

**Registered Extension Number**

527

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

None

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.4](versions.html#versions-1.4-promotions)

**Contact**

* 
Shahbaz Youssefi [syoussefi](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_load_store_op_none] @syoussefi%0A*Here describe the issue or question you have about the VK_KHR_load_store_op_none extension*)

**Extension Proposal**

[VK_KHR_load_store_op_none](../../../features/latest/features/proposals/VK_KHR_load_store_op_none.html)

**Last Modified Date**

2023-05-16

**Contributors**

* 
Shahbaz Youssefi, Google

* 
Bill Licea-Kane, Qualcomm Technologies, Inc.

* 
Tobias Hector, AMD

This extension provides `VK_ATTACHMENT_LOAD_OP_NONE_KHR` and
`VK_ATTACHMENT_STORE_OP_NONE_KHR`, which are identically promoted from
the `[VK_EXT_load_store_op_none](#VK_EXT_load_store_op_none)` extension.

* 
`VK_KHR_LOAD_STORE_OP_NONE_EXTENSION_NAME`

* 
`VK_KHR_LOAD_STORE_OP_NONE_SPEC_VERSION`

* 
Extending [VkAttachmentLoadOp](../chapters/renderpass.html#VkAttachmentLoadOp):

`VK_ATTACHMENT_LOAD_OP_NONE_KHR`

Extending [VkAttachmentStoreOp](../chapters/renderpass.html#VkAttachmentStoreOp):

* 
`VK_ATTACHMENT_STORE_OP_NONE_KHR`

Functionality in this extension is included in core Vulkan 1.4 with the KHR
suffix omitted.
The original type, enum and command names are still available as aliases of
the core functionality.

|  | While `VK_ATTACHMENT_STORE_OP_NONE` is part of Vulkan 1.3, this
| --- | --- |
extension was not promoted to core Vulkan 1.3 either in whole or in part.
This functionality was promoted from `[VK_KHR_dynamic_rendering](#VK_KHR_dynamic_rendering)`. |

* 
Revision 1, 2023-05-16 (Shahbaz Youssefi)

Initial revision, based on VK_EXT_load_store_op_none.

**Name String**

`VK_KHR_maintenance1`

**Extension Type**

Device extension

**Registered Extension Number**

70

**Revision**

2

**Ratification Status**

Ratified

**Extension and Version Dependencies**

None

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.1](versions.html#versions-1.1-promotions)

**Contact**

* 
Piers Daniell [pdaniell-nv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_maintenance1] @pdaniell-nv%0A*Here describe the issue or question you have about the VK_KHR_maintenance1 extension*)

**Last Modified Date**

2018-03-13

**Contributors**

* 
Dan Ginsburg, Valve

* 
Daniel Koch, NVIDIA

* 
Daniel Rakos, AMD

* 
Jan-Harald Fredriksen, ARM

* 
Faith Ekstrand, Intel

* 
Jeff Bolz, NVIDIA

* 
Jesse Hall, Google

* 
John Kessenich, Google

* 
Michael Worcester, Imagination Technologies

* 
Neil Henning, Codeplay Software Ltd.

* 
Piers Daniell, NVIDIA

* 
Slawomir Grajewski, Intel

* 
Tobias Hector, Imagination Technologies

* 
Tom Olson, ARM

`VK_KHR_maintenance1` adds a collection of minor features that were
intentionally left out or overlooked from the original Vulkan 1.0 release.

The new features are as follows:

* 
Allow 2D and 2D array image views to be created from 3D images, which
can then be used as color framebuffer attachments.
This allows applications to render to slices of a 3D image.

* 
Support [vkCmdCopyImage](../chapters/copies.html#vkCmdCopyImage) between 2D array layers and 3D slices.
This extension allows copying from layers of a 2D array image to slices
of a 3D image and vice versa.

* 
Allow negative height to be specified in the
[VkViewport](../chapters/vertexpostproc.html#VkViewport)::`height` field to perform y-inversion of the
clip-space to framebuffer-space transform.
This allows apps to avoid having to use `gl_Position.y = -gl_Position.y`
in shaders also targeting other APIs.

* 
Allow implementations to express support for doing just transfers and
clears of image formats that they otherwise support no other format
features for.
This is done by adding new format feature flags
`VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR` and
`VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR`.

* 
Support [vkCmdFillBuffer](../chapters/clears.html#vkCmdFillBuffer) on transfer-only queues.
Previously [vkCmdFillBuffer](../chapters/clears.html#vkCmdFillBuffer) was defined to only work on command
buffers allocated from command pools which support graphics or compute
queues.
It is now allowed on queues that just support transfer operations.

* 
Fix the inconsistency of how error conditions are returned between the
[vkCreateGraphicsPipelines](../chapters/pipelines.html#vkCreateGraphicsPipelines) and [vkCreateComputePipelines](../chapters/pipelines.html#vkCreateComputePipelines)
functions and the [vkAllocateDescriptorSets](../chapters/descriptorsets.html#vkAllocateDescriptorSets) and
[vkAllocateCommandBuffers](../chapters/cmdbuffers.html#vkAllocateCommandBuffers) functions.

* 
Add new `VK_ERROR_OUT_OF_POOL_MEMORY_KHR` error so implementations
can give a more precise reason for [vkAllocateDescriptorSets](../chapters/descriptorsets.html#vkAllocateDescriptorSets)
failures.

* 
Add a new command [vkTrimCommandPoolKHR](../chapters/cmdbuffers.html#vkTrimCommandPoolKHR) which gives the
implementation an opportunity to release any unused command pool memory
back to the system.

All functionality in this extension is included in core Vulkan 1.1, with the
KHR suffix omitted.
The original type, enum, and command names are still available as aliases of
the core functionality.

* 
[vkTrimCommandPoolKHR](../chapters/cmdbuffers.html#vkTrimCommandPoolKHR)

* 
[VkCommandPoolTrimFlagsKHR](../chapters/cmdbuffers.html#VkCommandPoolTrimFlagsKHR)

* 
`VK_KHR_MAINTENANCE1_EXTENSION_NAME`

* 
`VK_KHR_MAINTENANCE1_SPEC_VERSION`

* 
`VK_KHR_MAINTENANCE_1_EXTENSION_NAME`

* 
`VK_KHR_MAINTENANCE_1_SPEC_VERSION`

* 
Extending [VkFormatFeatureFlagBits](../chapters/formats.html#VkFormatFeatureFlagBits):

`VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR`

* 
`VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR`

Extending [VkImageCreateFlagBits](../chapters/resources.html#VkImageCreateFlagBits):

* 
`VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR`

Extending [VkResult](../chapters/fundamentals.html#VkResult):

* 
`VK_ERROR_OUT_OF_POOL_MEMORY_KHR`

Are viewports with zero height allowed?

**RESOLVED**: Yes, although they have low utility.

* 
Revision 1, 2016-10-26 (Piers Daniell)

Internal revisions

Revision 2, 2018-03-13 (Jon Leech)

* 
Add issue for zero-height viewports

**Name String**

`VK_KHR_maintenance2`

**Extension Type**

Device extension

**Registered Extension Number**

118

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

None

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.1](versions.html#versions-1.1-promotions)

**Contact**

* 
Michael Worcester [michaelworcester](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_maintenance2] @michaelworcester%0A*Here describe the issue or question you have about the VK_KHR_maintenance2 extension*)

**Last Modified Date**

2017-09-05

**Contributors**

* 
Michael Worcester, Imagination Technologies

* 
Stuart Smith, Imagination Technologies

* 
Jeff Bolz, NVIDIA

* 
Daniel Koch, NVIDIA

* 
Jan-Harald Fredriksen, ARM

* 
Daniel Rakos, AMD

* 
Neil Henning, Codeplay

* 
Piers Daniell, NVIDIA

`VK_KHR_maintenance2` adds a collection of minor features that were
intentionally left out or overlooked from the original Vulkan 1.0 release.

The new features are as follows:

* 
Allow the application to specify which aspect of an input attachment
might be read for a given subpass.

* 
Allow implementations to express the clipping behavior of points.

* 
Allow creating images with usage flags that may not be supported for the
base images format, but are supported for image views of the image that
have a different but compatible format.

* 
Allow creating uncompressed image views of compressed images.

* 
Allow the application to select between an upper-left and lower-left
origin for the tessellation domain space.

* 
Adds two new image layouts for depth stencil images to allow either the
depth or stencil aspect to be read-only while the other aspect is
writable.

Input attachment specification allows an application to specify which aspect
of a multi-aspect image (e.g. a depth/stencil format) will be accessed via a
`subpassLoad` operation.

On some implementations there **may** be a performance penalty if the
implementation does not know (at [vkCreateRenderPass](../chapters/renderpass.html#vkCreateRenderPass) time) which
aspect(s) of multi-aspect images **can** be accessed as input attachments.

All functionality in this extension is included in core Vulkan 1.1, with the
KHR suffix omitted.
The original type, enum, and command names are still available as aliases of
the core functionality.

* 
[VkInputAttachmentAspectReferenceKHR](../chapters/renderpass.html#VkInputAttachmentAspectReferenceKHR)

* 
Extending [VkImageViewCreateInfo](../chapters/resources.html#VkImageViewCreateInfo):

[VkImageViewUsageCreateInfoKHR](../chapters/resources.html#VkImageViewUsageCreateInfoKHR)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDevicePointClippingPropertiesKHR](../chapters/limits.html#VkPhysicalDevicePointClippingPropertiesKHR)

Extending [VkPipelineTessellationStateCreateInfo](../chapters/tessellation.html#VkPipelineTessellationStateCreateInfo):

* 
[VkPipelineTessellationDomainOriginStateCreateInfoKHR](../chapters/tessellation.html#VkPipelineTessellationDomainOriginStateCreateInfoKHR)

Extending [VkRenderPassCreateInfo](../chapters/renderpass.html#VkRenderPassCreateInfo):

* 
[VkRenderPassInputAttachmentAspectCreateInfoKHR](../chapters/renderpass.html#VkRenderPassInputAttachmentAspectCreateInfoKHR)

* 
[VkPointClippingBehaviorKHR](../chapters/vertexpostproc.html#VkPointClippingBehaviorKHR)

* 
[VkTessellationDomainOriginKHR](../chapters/tessellation.html#VkTessellationDomainOriginKHR)

* 
`VK_KHR_MAINTENANCE2_EXTENSION_NAME`

* 
`VK_KHR_MAINTENANCE2_SPEC_VERSION`

* 
`VK_KHR_MAINTENANCE_2_EXTENSION_NAME`

* 
`VK_KHR_MAINTENANCE_2_SPEC_VERSION`

* 
Extending [VkImageCreateFlagBits](../chapters/resources.html#VkImageCreateFlagBits):

`VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR`

* 
`VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR`

Extending [VkImageLayout](../chapters/resources.html#VkImageLayout):

* 
`VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR`

* 
`VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR`

Extending [VkPointClippingBehavior](../chapters/vertexpostproc.html#VkPointClippingBehavior):

* 
`VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES_KHR`

* 
`VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY_KHR`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR`

* 
`VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR`

Extending [VkTessellationDomainOrigin](../chapters/tessellation.html#VkTessellationDomainOrigin):

* 
`VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT_KHR`

* 
`VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT_KHR`

Consider the case where a render pass has two subpasses and two attachments.

Attachment 0 has the format `VK_FORMAT_D24_UNORM_S8_UINT`, attachment 1
has some color format.

Subpass 0 writes to attachment 0, subpass 1 reads only the depth information
from attachment 0 (using inputAttachmentRead) and writes to attachment 1.

    VkInputAttachmentAspectReferenceKHR references[] = {
        {
            .subpass = 1,
            .inputAttachmentIndex = 0,
            .aspectMask = VK_IMAGE_ASPECT_DEPTH_BIT
        }
    };

    VkRenderPassInputAttachmentAspectCreateInfoKHR specifyAspects = {
        .sType = VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR,
        .pNext = NULL,
        .aspectReferenceCount = 1,
        .pAspectReferences = references
    };

    VkRenderPassCreateInfo createInfo = {
        ...
        .pNext = &specifyAspects,
        ...
    };

    vkCreateRenderPass(...);

1) What is the default tessellation domain origin?

**RESOLVED**: Vulkan 1.0 originally inadvertently documented a lower-left
origin, but the conformance tests and all implementations implemented an
upper-left origin.
This extension adds a control to select between lower-left (for
compatibility with OpenGL) and upper-left, and we retroactively fix
unextended Vulkan to have a default of an upper-left origin.

* 
Revision 1, 2017-04-28

**Name String**

`VK_KHR_maintenance3`

**Extension Type**

Device extension

**Registered Extension Number**

169

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.1](versions.html#versions-1.1-promotions)

**Contact**

* 
Jeff Bolz [jeffbolznv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_maintenance3] @jeffbolznv%0A*Here describe the issue or question you have about the VK_KHR_maintenance3 extension*)

**Last Modified Date**

2017-09-05

**Contributors**

* 
Jeff Bolz, NVIDIA

`VK_KHR_maintenance3` adds a collection of minor features that were
intentionally left out or overlooked from the original Vulkan 1.0 release.

The new features are as follows:

* 
A limit on the maximum number of descriptors that are supported in a
single descriptor set layout.
Some implementations have a limit on the total size of descriptors in a
set, which cannot be expressed in terms of the limits in Vulkan 1.0.

* 
A limit on the maximum size of a single memory allocation.
Some platforms have kernel interfaces that limit the maximum size of an
allocation.

All functionality in this extension is included in core Vulkan 1.1, with the
KHR suffix omitted.
The original type, enum, and command names are still available as aliases of
the core functionality.

* 
[vkGetDescriptorSetLayoutSupportKHR](../chapters/descriptorsets.html#vkGetDescriptorSetLayoutSupportKHR)

* 
[VkDescriptorSetLayoutSupportKHR](../chapters/descriptorsets.html#VkDescriptorSetLayoutSupportKHR)

* 
Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

[VkPhysicalDeviceMaintenance3PropertiesKHR](../chapters/limits.html#VkPhysicalDeviceMaintenance3PropertiesKHR)

* 
`VK_KHR_MAINTENANCE3_EXTENSION_NAME`

* 
`VK_KHR_MAINTENANCE3_SPEC_VERSION`

* 
`VK_KHR_MAINTENANCE_3_EXTENSION_NAME`

* 
`VK_KHR_MAINTENANCE_3_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR`

* 
Revision 1, 2017-08-22

**Name String**

`VK_KHR_maintenance4`

**Extension Type**

Device extension

**Registered Extension Number**

414

**Revision**

2

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[Vulkan Version 1.1](versions.html#versions-1.1)

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.3](versions.html#versions-1.3-promotions)

**Contact**

* 
Piers Daniell [pdaniell-nv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_maintenance4] @pdaniell-nv%0A*Here describe the issue or question you have about the VK_KHR_maintenance4 extension*)

**Last Modified Date**

2021-10-25

**Interactions and External Dependencies**

* 
Requires SPIR-V 1.2 for `LocalSizeId`

**Contributors**

* 
Lionel Duc, NVIDIA

* 
Faith Ekstrand, Intel

* 
Spencer Fricke, Samsung

* 
Tobias Hector, AMD

* 
Lionel Landwerlin, Intel

* 
Graeme Leese, Broadcom

* 
Tom Olson, Arm

* 
Stu Smith, AMD

* 
Yiwei Zhang, Google

`VK_KHR_maintenance4` adds a collection of minor features, none of which
would warrant an entire extension of their own.

The new features are as follows:

* 
Allow the application to destroy their [VkPipelineLayout](../chapters/descriptorsets.html#VkPipelineLayout) object
immediately after it was used to create another object.
It is no longer necessary to keep its handle valid while the created
object is in use.

* 
Add a new [`maxBufferSize`](../chapters/devsandqueues.html#limits-maxBufferSize)
implementation-defined limit for the maximum size `VkBuffer` that
**can** be created.

* 
Add support for the SPIR-V 1.2 `LocalSizeId` execution mode, which
can be used as an alternative to `LocalSize` to specify the local
workgroup size with specialization constants.

* 
Add a guarantee that images created with identical creation parameters
will always have the same alignment requirements.

* 
Add new [vkGetDeviceBufferMemoryRequirementsKHR](../chapters/resources.html#vkGetDeviceBufferMemoryRequirementsKHR),
[vkGetDeviceImageMemoryRequirementsKHR](../chapters/resources.html#vkGetDeviceImageMemoryRequirementsKHR), and
[vkGetDeviceImageSparseMemoryRequirementsKHR](../chapters/sparsemem.html#vkGetDeviceImageSparseMemoryRequirementsKHR) to allow the
application to query the image memory requirements without having to
create an image object and query it.

* 
Relax the requirement that push constants must be initialized before
they are dynamically accessed.

* 
Relax the interface matching rules to allow a larger output vector to
match with a smaller input vector, with additional values being
discarded.

* 
Add a guarantee for buffer memory requirement that the size memory
requirement is never greater than the result of aligning create size
with the alignment memory requirement.

* 
[vkGetDeviceBufferMemoryRequirementsKHR](../chapters/resources.html#vkGetDeviceBufferMemoryRequirementsKHR)

* 
[vkGetDeviceImageMemoryRequirementsKHR](../chapters/resources.html#vkGetDeviceImageMemoryRequirementsKHR)

* 
[vkGetDeviceImageSparseMemoryRequirementsKHR](../chapters/sparsemem.html#vkGetDeviceImageSparseMemoryRequirementsKHR)

* 
[VkDeviceBufferMemoryRequirementsKHR](../chapters/resources.html#VkDeviceBufferMemoryRequirementsKHR)

* 
[VkDeviceImageMemoryRequirementsKHR](../chapters/resources.html#VkDeviceImageMemoryRequirementsKHR)

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceMaintenance4FeaturesKHR](../chapters/features.html#VkPhysicalDeviceMaintenance4FeaturesKHR)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceMaintenance4PropertiesKHR](../chapters/limits.html#VkPhysicalDeviceMaintenance4PropertiesKHR)

* 
`VK_KHR_MAINTENANCE_4_EXTENSION_NAME`

* 
`VK_KHR_MAINTENANCE_4_SPEC_VERSION`

* 
Extending [VkImageAspectFlagBits](../chapters/resources.html#VkImageAspectFlagBits):

`VK_IMAGE_ASPECT_NONE_KHR`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS_KHR`

* 
`VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS_KHR`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES_KHR`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES_KHR`

Vulkan APIs in this extension are included in core Vulkan 1.3, with the KHR
suffix omitted.
External interactions defined by this extension, such as SPIR-V token names,
retain their original names.
The original Vulkan API names are still available as aliases of the core
functionality.

None.

* 
Revision 1, 2021-08-18 (Piers Daniell)

Internal revisions

Revision 2, 2021-10-25 (Yiwei Zhang)

* 
More guarantees on buffer memory requirements

**Name String**

`VK_KHR_maintenance5`

**Extension Type**

Device extension

**Registered Extension Number**

471

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

 [Vulkan Version 1.1](versions.html#versions-1.1)

 and

 [VK_KHR_dynamic_rendering](#VK_KHR_dynamic_rendering)

or

[Vulkan Version 1.3](versions.html#versions-1.3)

**API Interactions**

* 
Interacts with VK_VERSION_1_2

* 
Interacts with VK_VERSION_1_3

* 
Interacts with VK_VERSION_1_4

* 
Interacts with VK_ARM_pipeline_opacity_micromap

* 
Interacts with VK_EXT_attachment_feedback_loop_layout

* 
Interacts with VK_EXT_buffer_device_address

* 
Interacts with VK_EXT_conditional_rendering

* 
Interacts with VK_EXT_descriptor_buffer

* 
Interacts with VK_EXT_fragment_density_map

* 
Interacts with VK_EXT_graphics_pipeline_library

* 
Interacts with VK_EXT_opacity_micromap

* 
Interacts with VK_EXT_pipeline_creation_cache_control

* 
Interacts with VK_EXT_pipeline_protected_access

* 
Interacts with VK_EXT_transform_feedback

* 
Interacts with VK_KHR_acceleration_structure

* 
Interacts with VK_KHR_buffer_device_address

* 
Interacts with VK_KHR_dynamic_rendering

* 
Interacts with VK_KHR_fragment_shading_rate

* 
Interacts with VK_KHR_pipeline_executable_properties

* 
Interacts with VK_KHR_pipeline_library

* 
Interacts with VK_KHR_ray_tracing_pipeline

* 
Interacts with VK_KHR_video_decode_queue

* 
Interacts with VK_KHR_video_encode_queue

* 
Interacts with VK_NV_device_generated_commands

* 
Interacts with VK_NV_displacement_micromap

* 
Interacts with VK_NV_ray_tracing

* 
Interacts with VK_NV_ray_tracing_motion_blur

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.4](versions.html#versions-1.4-promotions)

**Contact**

* 
Stu Smith [stu-s](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_maintenance5] @stu-s%0A*Here describe the issue or question you have about the VK_KHR_maintenance5 extension*)

**Extension Proposal**

[VK_KHR_maintenance5](../../../features/latest/features/proposals/VK_KHR_maintenance5.html)

**Last Modified Date**

2023-05-02

**Interactions and External Dependencies**
**Contributors**

* 
Stu Smith, AMD

* 
Tobias Hector, AMD

* 
Shahbaz Youssefi, Google

* 
Slawomir Cygan, Intel

* 
Lionel Landwerlin, Intel

* 
James Fitzpatrick, Imagination Technologies

* 
Andrew Garrard, Imagination Technologies

* 
Ralph Potter, Samsung

* 
Pan Gao, Huawei

* 
Jan-Harald Fredriksen, ARM

* 
Jon Leech, Khronos

* 
Mike Blumenkrantz, Valve

`VK_KHR_maintenance5` adds a collection of minor features, none of which
would warrant an entire extension of their own.

The new features are as follows:

* 
A new `VK_FORMAT_A1B5G5R5_UNORM_PACK16_KHR` format

* 
A new `VK_FORMAT_A8_UNORM_KHR` format

* 
A property to indicate that multisample coverage operations are
performed after sample counting in EarlyFragmentTests mode

* 
Relax VkBufferView creation requirements by allowing subsets of the
associated VkBuffer usage using `VkBufferUsageFlags2CreateInfoKHR`

* 
A new command [vkCmdBindIndexBuffer2KHR](../chapters/drawing.html#vkCmdBindIndexBuffer2KHR), allowing a range of memory
to be bound as an index buffer

* 
[vkGetDeviceProcAddr](../chapters/initialization.html#vkGetDeviceProcAddr) must return `NULL` for supported core
functions beyond the version requested by the application.

* 
A property to indicate that the sample mask test is performed after
sample counting in EarlyFragmentTests mode

* 
`vkCmdBindVertexBuffers2` now supports using `VK_WHOLE_SIZE` in the
`pSizes` parameter.

* 
A default size of 1.0 is used if `PointSize` is not written

* 
Shader modules are deprecated - applications can now pass
[VkShaderModuleCreateInfo](../chapters/shaders.html#VkShaderModuleCreateInfo) as a chained structure to pipeline
creation via [VkPipelineShaderStageCreateInfo](../chapters/pipelines.html#VkPipelineShaderStageCreateInfo)

* 
A function [vkGetRenderingAreaGranularityKHR](../chapters/renderpass.html#vkGetRenderingAreaGranularityKHR) to query the optimal
render area for a dynamic rendering instance.

* 
A property to indicate that depth/stencil texturing operations with
`VK_COMPONENT_SWIZZLE_ONE` have defined behavior

* 
Add [vkGetImageSubresourceLayout2KHR](../chapters/resources.html#vkGetImageSubresourceLayout2KHR) and a new function
[vkGetDeviceImageSubresourceLayoutKHR](../chapters/resources.html#vkGetDeviceImageSubresourceLayoutKHR) to allow the application to
query the image memory layout without having to create an image object
and query it.

* 
Allow `VK_REMAINING_ARRAY_LAYERS` as the `layerCount` member of
[VkImageSubresourceLayers](../chapters/copies.html#VkImageSubresourceLayers)

* 
Adds stronger guarantees for propagation of `VK_ERROR_DEVICE_LOST`
return values

* 
A property to indicate whether `PointSize` controls the final
rasterization of polygons if [polygon mode](../chapters/primsrast.html#primsrast-polygonmode) is
`VK_POLYGON_MODE_POINT`

* 
Two properties to indicate the non-strict line rasterization algorithm
used

* 
Two new flags words [VkPipelineCreateFlagBits2KHR](../chapters/pipelines.html#VkPipelineCreateFlagBits2KHR) and
[VkBufferUsageFlagBits2KHR](../chapters/resources.html#VkBufferUsageFlagBits2KHR)

* 
Physical-device-level functions can now be called with any value in the
valid range for a type beyond the defined enumerants, such that
applications can avoid checking individual features, extensions, or
versions before querying supported properties of a particular enumerant.

* 
Clarification that copies between images of any type are allowed,
treating 1D images as 2D images with a height of 1.

* 
[vkCmdBindIndexBuffer2KHR](../chapters/drawing.html#vkCmdBindIndexBuffer2KHR)

* 
[vkGetDeviceImageSubresourceLayoutKHR](../chapters/resources.html#vkGetDeviceImageSubresourceLayoutKHR)

* 
[vkGetImageSubresourceLayout2KHR](../chapters/resources.html#vkGetImageSubresourceLayout2KHR)

* 
[vkGetRenderingAreaGranularityKHR](../chapters/renderpass.html#vkGetRenderingAreaGranularityKHR)

* 
[VkDeviceImageSubresourceInfoKHR](../chapters/resources.html#VkDeviceImageSubresourceInfoKHR)

* 
[VkImageSubresource2KHR](../chapters/resources.html#VkImageSubresource2KHR)

* 
[VkRenderingAreaInfoKHR](../chapters/renderpass.html#VkRenderingAreaInfoKHR)

* 
[VkSubresourceLayout2KHR](../chapters/resources.html#VkSubresourceLayout2KHR)

* 
Extending [VkBufferViewCreateInfo](../chapters/resources.html#VkBufferViewCreateInfo), [VkBufferCreateInfo](../chapters/resources.html#VkBufferCreateInfo), [VkPhysicalDeviceExternalBufferInfo](../chapters/capabilities.html#VkPhysicalDeviceExternalBufferInfo), [VkDescriptorBufferBindingInfoEXT](../chapters/descriptorsets.html#VkDescriptorBufferBindingInfoEXT):

[VkBufferUsageFlags2CreateInfoKHR](../chapters/resources.html#VkBufferUsageFlags2CreateInfoKHR)

Extending [VkComputePipelineCreateInfo](../chapters/pipelines.html#VkComputePipelineCreateInfo), [VkGraphicsPipelineCreateInfo](../chapters/pipelines.html#VkGraphicsPipelineCreateInfo), [VkRayTracingPipelineCreateInfoNV](../chapters/pipelines.html#VkRayTracingPipelineCreateInfoNV), [VkRayTracingPipelineCreateInfoKHR](../chapters/pipelines.html#VkRayTracingPipelineCreateInfoKHR):

* 
[VkPipelineCreateFlags2CreateInfoKHR](../chapters/pipelines.html#VkPipelineCreateFlags2CreateInfoKHR)

Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

* 
[VkPhysicalDeviceMaintenance5FeaturesKHR](../chapters/features.html#VkPhysicalDeviceMaintenance5FeaturesKHR)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceMaintenance5PropertiesKHR](../chapters/limits.html#VkPhysicalDeviceMaintenance5PropertiesKHR)

* 
[VkBufferUsageFlagBits2KHR](../chapters/resources.html#VkBufferUsageFlagBits2KHR)

* 
[VkPipelineCreateFlagBits2KHR](../chapters/pipelines.html#VkPipelineCreateFlagBits2KHR)

* 
[VkBufferUsageFlags2KHR](../chapters/resources.html#VkBufferUsageFlags2KHR)

* 
[VkPipelineCreateFlags2KHR](../chapters/pipelines.html#VkPipelineCreateFlags2KHR)

* 
`VK_KHR_MAINTENANCE_5_EXTENSION_NAME`

* 
`VK_KHR_MAINTENANCE_5_SPEC_VERSION`

* 
Extending [VkBufferUsageFlagBits2](../chapters/resources.html#VkBufferUsageFlagBits2):

`VK_BUFFER_USAGE_2_INDEX_BUFFER_BIT_KHR`

* 
`VK_BUFFER_USAGE_2_INDIRECT_BUFFER_BIT_KHR`

* 
`VK_BUFFER_USAGE_2_STORAGE_BUFFER_BIT_KHR`

* 
`VK_BUFFER_USAGE_2_STORAGE_TEXEL_BUFFER_BIT_KHR`

* 
`VK_BUFFER_USAGE_2_TRANSFER_DST_BIT_KHR`

* 
`VK_BUFFER_USAGE_2_TRANSFER_SRC_BIT_KHR`

* 
`VK_BUFFER_USAGE_2_UNIFORM_BUFFER_BIT_KHR`

* 
`VK_BUFFER_USAGE_2_UNIFORM_TEXEL_BUFFER_BIT_KHR`

* 
`VK_BUFFER_USAGE_2_VERTEX_BUFFER_BIT_KHR`

Extending [VkFormat](../chapters/formats.html#VkFormat):

* 
`VK_FORMAT_A1B5G5R5_UNORM_PACK16_KHR`

* 
`VK_FORMAT_A8_UNORM_KHR`

Extending [VkPipelineCreateFlagBits2](../chapters/pipelines.html#VkPipelineCreateFlagBits2):

* 
`VK_PIPELINE_CREATE_2_ALLOW_DERIVATIVES_BIT_KHR`

* 
`VK_PIPELINE_CREATE_2_DERIVATIVE_BIT_KHR`

* 
`VK_PIPELINE_CREATE_2_DISABLE_OPTIMIZATION_BIT_KHR`

* 
`VK_PIPELINE_CREATE_2_DISPATCH_BASE_BIT_KHR`

* 
`VK_PIPELINE_CREATE_2_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_KHR`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES_KHR`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES_KHR`

* 
`VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_RENDERING_AREA_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_KHR`

If [VK_KHR_dynamic_rendering](#VK_KHR_dynamic_rendering) or [Vulkan Version 1.3](versions.html#versions-1.3) and [VK_EXT_fragment_density_map](#VK_EXT_fragment_density_map) is supported:

* 
Extending [VkPipelineCreateFlagBits2](../chapters/pipelines.html#VkPipelineCreateFlagBits2):

`VK_PIPELINE_CREATE_2_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT`

If [VK_KHR_dynamic_rendering](#VK_KHR_dynamic_rendering) or [Vulkan Version 1.3](versions.html#versions-1.3) and [VK_KHR_fragment_shading_rate](#VK_KHR_fragment_shading_rate) is supported:

* 
Extending [VkPipelineCreateFlagBits2](../chapters/pipelines.html#VkPipelineCreateFlagBits2):

`VK_PIPELINE_CREATE_2_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR`

If [VK_ARM_pipeline_opacity_micromap](#VK_ARM_pipeline_opacity_micromap) is supported:

* 
Extending [VkPipelineCreateFlagBits2](../chapters/pipelines.html#VkPipelineCreateFlagBits2):

`VK_PIPELINE_CREATE_2_DISALLOW_OPACITY_MICROMAP_BIT_ARM`

If [VK_EXT_attachment_feedback_loop_layout](#VK_EXT_attachment_feedback_loop_layout) is supported:

* 
Extending [VkPipelineCreateFlagBits2](../chapters/pipelines.html#VkPipelineCreateFlagBits2):

`VK_PIPELINE_CREATE_2_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT`

* 
`VK_PIPELINE_CREATE_2_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT`

If [VK_EXT_conditional_rendering](#VK_EXT_conditional_rendering) is supported:

* 
Extending [VkBufferUsageFlagBits2](../chapters/resources.html#VkBufferUsageFlagBits2):

`VK_BUFFER_USAGE_2_CONDITIONAL_RENDERING_BIT_EXT`

If [VK_EXT_descriptor_buffer](#VK_EXT_descriptor_buffer) is supported:

* 
Extending [VkBufferUsageFlagBits2](../chapters/resources.html#VkBufferUsageFlagBits2):

`VK_BUFFER_USAGE_2_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT`

* 
`VK_BUFFER_USAGE_2_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT`

* 
`VK_BUFFER_USAGE_2_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT`

Extending [VkPipelineCreateFlagBits2](../chapters/pipelines.html#VkPipelineCreateFlagBits2):

* 
`VK_PIPELINE_CREATE_2_DESCRIPTOR_BUFFER_BIT_EXT`

If [VK_EXT_graphics_pipeline_library](#VK_EXT_graphics_pipeline_library) is supported:

* 
Extending [VkPipelineCreateFlagBits2](../chapters/pipelines.html#VkPipelineCreateFlagBits2):

`VK_PIPELINE_CREATE_2_LINK_TIME_OPTIMIZATION_BIT_EXT`

* 
`VK_PIPELINE_CREATE_2_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT`

If [VK_EXT_opacity_micromap](#VK_EXT_opacity_micromap) is supported:

* 
Extending [VkBufferUsageFlagBits2](../chapters/resources.html#VkBufferUsageFlagBits2):

`VK_BUFFER_USAGE_2_MICROMAP_BUILD_INPUT_READ_ONLY_BIT_EXT`

* 
`VK_BUFFER_USAGE_2_MICROMAP_STORAGE_BIT_EXT`

Extending [VkPipelineCreateFlagBits2](../chapters/pipelines.html#VkPipelineCreateFlagBits2):

* 
`VK_PIPELINE_CREATE_2_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT`

If [VK_EXT_transform_feedback](#VK_EXT_transform_feedback) is supported:

* 
Extending [VkBufferUsageFlagBits2](../chapters/resources.html#VkBufferUsageFlagBits2):

`VK_BUFFER_USAGE_2_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT`

* 
`VK_BUFFER_USAGE_2_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT`

If [VK_KHR_acceleration_structure](#VK_KHR_acceleration_structure) is supported:

* 
Extending [VkBufferUsageFlagBits2](../chapters/resources.html#VkBufferUsageFlagBits2):

`VK_BUFFER_USAGE_2_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR`

* 
`VK_BUFFER_USAGE_2_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR`

If [VK_KHR_pipeline_executable_properties](#VK_KHR_pipeline_executable_properties) is supported:

* 
Extending [VkPipelineCreateFlagBits2](../chapters/pipelines.html#VkPipelineCreateFlagBits2):

`VK_PIPELINE_CREATE_2_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR`

* 
`VK_PIPELINE_CREATE_2_CAPTURE_STATISTICS_BIT_KHR`

If [VK_KHR_pipeline_library](#VK_KHR_pipeline_library) is supported:

* 
Extending [VkPipelineCreateFlagBits2](../chapters/pipelines.html#VkPipelineCreateFlagBits2):

`VK_PIPELINE_CREATE_2_LIBRARY_BIT_KHR`

If [VK_KHR_ray_tracing_pipeline](#VK_KHR_ray_tracing_pipeline) is supported:

* 
Extending [VkBufferUsageFlagBits2](../chapters/resources.html#VkBufferUsageFlagBits2):

`VK_BUFFER_USAGE_2_SHADER_BINDING_TABLE_BIT_KHR`

Extending [VkPipelineCreateFlagBits2](../chapters/pipelines.html#VkPipelineCreateFlagBits2):

* 
`VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR`

* 
`VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR`

* 
`VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR`

* 
`VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR`

* 
`VK_PIPELINE_CREATE_2_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR`

* 
`VK_PIPELINE_CREATE_2_RAY_TRACING_SKIP_AABBS_BIT_KHR`

* 
`VK_PIPELINE_CREATE_2_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR`

If [VK_KHR_video_decode_queue](#VK_KHR_video_decode_queue) is supported:

* 
Extending [VkBufferUsageFlagBits2](../chapters/resources.html#VkBufferUsageFlagBits2):

`VK_BUFFER_USAGE_2_VIDEO_DECODE_DST_BIT_KHR`

* 
`VK_BUFFER_USAGE_2_VIDEO_DECODE_SRC_BIT_KHR`

If [VK_KHR_video_encode_queue](#VK_KHR_video_encode_queue) is supported:

* 
Extending [VkBufferUsageFlagBits2](../chapters/resources.html#VkBufferUsageFlagBits2):

`VK_BUFFER_USAGE_2_VIDEO_ENCODE_DST_BIT_KHR`

* 
`VK_BUFFER_USAGE_2_VIDEO_ENCODE_SRC_BIT_KHR`

If [VK_NV_device_generated_commands](#VK_NV_device_generated_commands) is supported:

* 
Extending [VkPipelineCreateFlagBits2](../chapters/pipelines.html#VkPipelineCreateFlagBits2):

`VK_PIPELINE_CREATE_2_INDIRECT_BINDABLE_BIT_NV`

If [VK_NV_displacement_micromap](#VK_NV_displacement_micromap) is supported:

* 
Extending [VkPipelineCreateFlagBits2](../chapters/pipelines.html#VkPipelineCreateFlagBits2):

`VK_PIPELINE_CREATE_2_RAY_TRACING_DISPLACEMENT_MICROMAP_BIT_NV`

If [VK_NV_ray_tracing](#VK_NV_ray_tracing) is supported:

* 
Extending [VkBufferUsageFlagBits2](../chapters/resources.html#VkBufferUsageFlagBits2):

`VK_BUFFER_USAGE_2_RAY_TRACING_BIT_NV`

Extending [VkPipelineCreateFlagBits2](../chapters/pipelines.html#VkPipelineCreateFlagBits2):

* 
`VK_PIPELINE_CREATE_2_DEFER_COMPILE_BIT_NV`

If [VK_NV_ray_tracing_motion_blur](#VK_NV_ray_tracing_motion_blur) is supported:

* 
Extending [VkPipelineCreateFlagBits2](../chapters/pipelines.html#VkPipelineCreateFlagBits2):

`VK_PIPELINE_CREATE_2_RAY_TRACING_ALLOW_MOTION_BIT_NV`

If [Vulkan Version 1.2](versions.html#versions-1.2) or [VK_KHR_buffer_device_address](#VK_KHR_buffer_device_address) or [VK_EXT_buffer_device_address](#VK_EXT_buffer_device_address) is supported:

* 
Extending [VkBufferUsageFlagBits2](../chapters/resources.html#VkBufferUsageFlagBits2):

`VK_BUFFER_USAGE_2_SHADER_DEVICE_ADDRESS_BIT_KHR`

If [Vulkan Version 1.3](versions.html#versions-1.3) or [VK_EXT_pipeline_creation_cache_control](#VK_EXT_pipeline_creation_cache_control) is supported:

* 
Extending [VkPipelineCreateFlagBits2](../chapters/pipelines.html#VkPipelineCreateFlagBits2):

`VK_PIPELINE_CREATE_2_EARLY_RETURN_ON_FAILURE_BIT_KHR`

* 
`VK_PIPELINE_CREATE_2_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_KHR`

If [Vulkan Version 1.4](versions.html#versions-1.4) or [VK_EXT_pipeline_protected_access](#VK_EXT_pipeline_protected_access) is supported:

* 
Extending [VkPipelineCreateFlagBits2](../chapters/pipelines.html#VkPipelineCreateFlagBits2):

`VK_PIPELINE_CREATE_2_NO_PROTECTED_ACCESS_BIT_EXT`

* 
`VK_PIPELINE_CREATE_2_PROTECTED_ACCESS_ONLY_BIT_EXT`

Functionality in this extension is included in core Vulkan 1.4 with the KHR
suffix omitted.
The original type, enum and command names are still available as aliases of
the core functionality.

* 
Revision 1, 2022-12-12 (Stu Smith)

Initial revision

**Name String**

`VK_KHR_maintenance6`

**Extension Type**

Device extension

**Registered Extension Number**

546

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[Vulkan Version 1.1](versions.html#versions-1.1)

**API Interactions**

* 
Interacts with VK_EXT_descriptor_buffer

* 
Interacts with VK_KHR_push_descriptor

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.4](versions.html#versions-1.4-promotions)

**Contact**

* 
Jon Leech [oddhack](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_maintenance6] @oddhack%0A*Here describe the issue or question you have about the VK_KHR_maintenance6 extension*)

**Extension Proposal**

[VK_KHR_maintenance6](../../../features/latest/features/proposals/VK_KHR_maintenance6.html)

**Last Modified Date**

2023-08-03

**Interactions and External Dependencies**

* 
Interacts with `[VK_EXT_robustness2](#VK_EXT_robustness2)`

**Contributors**

* 
Jon Leech, Khronos

* 
Stu Smith, AMD

* 
Mike Blumenkrantz, Valve

* 
Ralph Potter, Samsung

* 
James Fitzpatrick, Imagination Technologies

* 
Piers Daniell, NVIDIA

* 
Daniel Story, Nintendo

[VK_KHR_maintenance6](#VK_KHR_maintenance6) adds a collection of minor features, none of
which would warrant an entire extension of their own.

The new features are as follows:

* 
[VkBindMemoryStatusKHR](../chapters/resources.html#VkBindMemoryStatusKHR) may be included in the `pNext` chain of
[VkBindBufferMemoryInfo](../chapters/resources.html#VkBindBufferMemoryInfo) and [VkBindImageMemoryInfo](../chapters/resources.html#VkBindImageMemoryInfo), allowing
applications to identify individual resources for which memory binding
failed during calls to [vkBindBufferMemory2](../chapters/resources.html#vkBindBufferMemory2) and
[vkBindImageMemory2](../chapters/resources.html#vkBindImageMemory2).

* 
A new property `fragmentShadingRateClampCombinerInputs` to indicate
if an implementation clamps the inputs to fragment shading rate combiner
operations.

* 
[VK_NULL_HANDLE](boilerplate.html#VK_NULL_HANDLE) is allowed to be used when binding an index buffer,
instead of a valid [VkBuffer](../chapters/resources.html#VkBuffer) handle.
When the [`nullDescriptor`](../chapters/features.html#features-nullDescriptor) feature is
enabled, every index fetched results in a value of zero.

* 
A new property `maxCombinedImageSamplerDescriptorCount` to indicate
the maximum number of descriptors needed for any of the
[formats that require a    sampler YCBCR conversion](../chapters/formats.html#formats-requiring-sampler-ycbcr-conversion) supported by the implementation.

* 
A new property `blockTexelViewCompatibleMultipleLayers` indicating
whether `VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT` is allowed
to be used with `layerCount` > 1

* 
`pNext` extensible *2 versions of all descriptor binding commands.

* 
[vkCmdBindDescriptorSets2KHR](../chapters/descriptorsets.html#vkCmdBindDescriptorSets2KHR)

* 
[vkCmdPushConstants2KHR](../chapters/descriptorsets.html#vkCmdPushConstants2KHR)

If [VK_EXT_descriptor_buffer](#VK_EXT_descriptor_buffer) is supported:

* 
[vkCmdBindDescriptorBufferEmbeddedSamplers2EXT](../chapters/descriptorsets.html#vkCmdBindDescriptorBufferEmbeddedSamplers2EXT)

* 
[vkCmdSetDescriptorBufferOffsets2EXT](../chapters/descriptorsets.html#vkCmdSetDescriptorBufferOffsets2EXT)

If [VK_KHR_push_descriptor](#VK_KHR_push_descriptor) is supported:

* 
[vkCmdPushDescriptorSet2KHR](../chapters/descriptorsets.html#vkCmdPushDescriptorSet2KHR)

* 
[vkCmdPushDescriptorSetWithTemplate2KHR](../chapters/descriptorsets.html#vkCmdPushDescriptorSetWithTemplate2KHR)

* 
[VkBindDescriptorSetsInfoKHR](../chapters/descriptorsets.html#VkBindDescriptorSetsInfoKHR)

* 
[VkPushConstantsInfoKHR](../chapters/descriptorsets.html#VkPushConstantsInfoKHR)

* 
Extending [VkBindBufferMemoryInfo](../chapters/resources.html#VkBindBufferMemoryInfo), [VkBindImageMemoryInfo](../chapters/resources.html#VkBindImageMemoryInfo):

[VkBindMemoryStatusKHR](../chapters/resources.html#VkBindMemoryStatusKHR)

Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

* 
[VkPhysicalDeviceMaintenance6FeaturesKHR](../chapters/features.html#VkPhysicalDeviceMaintenance6FeaturesKHR)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceMaintenance6PropertiesKHR](../chapters/limits.html#VkPhysicalDeviceMaintenance6PropertiesKHR)

If [VK_EXT_descriptor_buffer](#VK_EXT_descriptor_buffer) is supported:

* 
[VkBindDescriptorBufferEmbeddedSamplersInfoEXT](../chapters/descriptorsets.html#VkBindDescriptorBufferEmbeddedSamplersInfoEXT)

* 
[VkSetDescriptorBufferOffsetsInfoEXT](../chapters/descriptorsets.html#VkSetDescriptorBufferOffsetsInfoEXT)

If [VK_KHR_push_descriptor](#VK_KHR_push_descriptor) is supported:

* 
[VkPushDescriptorSetInfoKHR](../chapters/descriptorsets.html#VkPushDescriptorSetInfoKHR)

* 
[VkPushDescriptorSetWithTemplateInfoKHR](../chapters/descriptorsets.html#VkPushDescriptorSetWithTemplateInfoKHR)

* 
`VK_KHR_MAINTENANCE_6_EXTENSION_NAME`

* 
`VK_KHR_MAINTENANCE_6_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS_KHR`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES_KHR`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES_KHR`

* 
`VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO_KHR`

If [VK_EXT_descriptor_buffer](#VK_EXT_descriptor_buffer) is supported:

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_BUFFER_EMBEDDED_SAMPLERS_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_SET_DESCRIPTOR_BUFFER_OFFSETS_INFO_EXT`

If [VK_KHR_push_descriptor](#VK_KHR_push_descriptor) is supported:

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_WITH_TEMPLATE_INFO_KHR`

Functionality in this extension is included in core Vulkan 1.4 with the KHR
suffix omitted.
The original type, enum and command names are still available as aliases of
the core functionality.

* 
Revision 1, 2023-08-01 (Jon Leech)

Initial revision

**Name String**

`VK_KHR_map_memory2`

**Extension Type**

Device extension

**Registered Extension Number**

272

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

None

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.4](versions.html#versions-1.4-promotions)

**Contact**

* 
Faith Ekstrand [gfxstrand](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_map_memory2] @gfxstrand%0A*Here describe the issue or question you have about the VK_KHR_map_memory2 extension*)

**Extension Proposal**

[VK_KHR_map_memory2](../../../features/latest/features/proposals/VK_KHR_map_memory2.html)

**Last Modified Date**

2023-03-14

**Interactions and External Dependencies**

* 
None

**Contributors**

* 
Faith Ekstrand, Collabora

* 
Tobias Hector, AMD

This extension provides extensible versions of the Vulkan memory map and
unmap commands.
The new commands are functionally identical to the core commands, except
that their parameters are specified using extensible structures that can be
used to pass extension-specific information.

* 
[vkMapMemory2KHR](../chapters/memory.html#vkMapMemory2KHR)

* 
[vkUnmapMemory2KHR](../chapters/memory.html#vkUnmapMemory2KHR)

* 
[VkMemoryMapInfoKHR](../chapters/memory.html#VkMemoryMapInfoKHR)

* 
[VkMemoryUnmapInfoKHR](../chapters/memory.html#VkMemoryUnmapInfoKHR)

* 
[VkMemoryUnmapFlagBitsKHR](../chapters/memory.html#VkMemoryUnmapFlagBitsKHR)

* 
[VkMemoryUnmapFlagsKHR](../chapters/memory.html#VkMemoryUnmapFlagsKHR)

* 
`VK_KHR_MAP_MEMORY_2_EXTENSION_NAME`

* 
`VK_KHR_MAP_MEMORY_2_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_MEMORY_MAP_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO_KHR`

Functionality in this extension is included in core Vulkan 1.4 with the KHR
suffix omitted.
The original type, enum and command names are still available as aliases of
the core functionality.

* 
Revision 0, 2022-08-03 (Faith Ekstrand)

Internal revisions

Revision 1, 2023-03-14

* 
Public release

**Name String**

`VK_KHR_multiview`

**Extension Type**

Device extension

**Registered Extension Number**

54

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**SPIR-V Dependencies**

* 
[SPV_KHR_multiview](https://github.khronos.org/SPIRV-Registry/extensions/KHR/SPV_KHR_multiview.html)

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.1](versions.html#versions-1.1-promotions)

**Contact**

* 
Jeff Bolz [jeffbolznv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_multiview] @jeffbolznv%0A*Here describe the issue or question you have about the VK_KHR_multiview extension*)

**Last Modified Date**

2016-10-28

**IP Status**

No known IP claims.

**Interactions and External Dependencies**

* 
This extension provides API support for
[`GL_EXT_multiview`](https://github.com/KhronosGroup/GLSL/blob/main/extensions/ext/GL_EXT_multiview.txt)

**Contributors**

* 
Jeff Bolz, NVIDIA

This extension has the same goal as the OpenGL ES `GL_OVR_multiview`
extension.
Multiview is a rendering technique originally designed for VR where it is
more efficient to record a single set of commands to be executed with
slightly different behavior for each view.

It includes a concise way to declare a render pass with multiple views, and
gives implementations freedom to render the views in the most efficient way
possible.
This is done with a multiview configuration specified during [render pass](../chapters/renderpass.html#renderpass) creation with the [VkRenderPassMultiviewCreateInfo](../chapters/renderpass.html#VkRenderPassMultiviewCreateInfo) passed
into [VkRenderPassCreateInfo](../chapters/renderpass.html#VkRenderPassCreateInfo)::`pNext`.

This extension enables the use of the
[`SPV_KHR_multiview`](https://github.khronos.org/SPIRV-Registry/extensions/KHR/SPV_KHR_multiview.html) shader extension,
which adds a new `ViewIndex` built-in type that allows shaders to control
what to do for each view.
If using GLSL there is also the
[`GL_EXT_multiview`](https://github.com/KhronosGroup/GLSL/blob/main/extensions/ext/GL_EXT_multiview.txt) extension that
introduces a `highp int gl_ViewIndex;` built-in variable for vertex,
tessellation, geometry, and fragment shaders.

All functionality in this extension is included in core Vulkan 1.1, with the
KHR suffix omitted.
The original type, enum, and command names are still available as aliases of
the core functionality.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceMultiviewFeaturesKHR](../chapters/features.html#VkPhysicalDeviceMultiviewFeaturesKHR)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceMultiviewPropertiesKHR](../chapters/limits.html#VkPhysicalDeviceMultiviewPropertiesKHR)

Extending [VkRenderPassCreateInfo](../chapters/renderpass.html#VkRenderPassCreateInfo):

* 
[VkRenderPassMultiviewCreateInfoKHR](../chapters/renderpass.html#VkRenderPassMultiviewCreateInfoKHR)

* 
`VK_KHR_MULTIVIEW_EXTENSION_NAME`

* 
`VK_KHR_MULTIVIEW_SPEC_VERSION`

* 
Extending [VkDependencyFlagBits](../chapters/synchronization.html#VkDependencyFlagBits):

`VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR`

* 
`VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR`

* 
[`ViewIndex`](../chapters/interfaces.html#interfaces-builtin-variables-viewindex)

* 
[`MultiView`](spirvenv.html#spirvenv-capabilities-table-MultiView)

* 
Revision 1, 2016-10-28 (Jeff Bolz)

Internal revisions

**Name String**

`VK_KHR_push_descriptor`

**Extension Type**

Device extension

**Registered Extension Number**

81

**Revision**

2

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**API Interactions**

* 
Interacts with VK_VERSION_1_1

* 
Interacts with VK_KHR_descriptor_update_template

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.4](versions.html#versions-1.4-promotions)

**Contact**

* 
Jeff Bolz [jeffbolznv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_push_descriptor] @jeffbolznv%0A*Here describe the issue or question you have about the VK_KHR_push_descriptor extension*)

**Last Modified Date**

2017-09-12

**IP Status**

No known IP claims.

**Contributors**

* 
Jeff Bolz, NVIDIA

* 
Michael Worcester, Imagination Technologies

This extension allows descriptors to be written into the command buffer,
while the implementation is responsible for managing their memory.
Push descriptors may enable easier porting from older APIs and in some cases
can be more efficient than writing descriptors into descriptor sets.

* 
[vkCmdPushDescriptorSetKHR](../chapters/descriptorsets.html#vkCmdPushDescriptorSetKHR)

If [Vulkan Version 1.1](versions.html#versions-1.1) or [VK_KHR_descriptor_update_template](#VK_KHR_descriptor_update_template) is supported:

* 
[vkCmdPushDescriptorSetWithTemplateKHR](../chapters/descriptorsets.html#vkCmdPushDescriptorSetWithTemplateKHR)

* 
Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

[VkPhysicalDevicePushDescriptorPropertiesKHR](../chapters/limits.html#VkPhysicalDevicePushDescriptorPropertiesKHR)

* 
`VK_KHR_PUSH_DESCRIPTOR_EXTENSION_NAME`

* 
`VK_KHR_PUSH_DESCRIPTOR_SPEC_VERSION`

* 
Extending [VkDescriptorSetLayoutCreateFlagBits](../chapters/descriptorsets.html#VkDescriptorSetLayoutCreateFlagBits):

`VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR`

If [Vulkan Version 1.1](versions.html#versions-1.1) or [VK_KHR_descriptor_update_template](#VK_KHR_descriptor_update_template) is supported:

* 
Extending [VkDescriptorUpdateTemplateType](../chapters/descriptorsets.html#VkDescriptorUpdateTemplateType):

`VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR`

Functionality in this extension is included in core Vulkan 1.4 with the KHR
suffix omitted.
The original type, enum and command names are still available as aliases of
the core functionality.

* 
Revision 1, 2016-10-15 (Jeff Bolz)

Internal revisions

Revision 2, 2017-09-12 (Tobias Hector)

* 
Added interactions with Vulkan 1.1

**Name String**

`VK_KHR_relaxed_block_layout`

**Extension Type**

Device extension

**Registered Extension Number**

145

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

None

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.1](versions.html#versions-1.1-promotions)

**Contact**

* 
John Kessenich [johnkslang](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_relaxed_block_layout] @johnkslang%0A*Here describe the issue or question you have about the VK_KHR_relaxed_block_layout extension*)

**Last Modified Date**

2017-03-26

**IP Status**

No known IP claims.

**Contributors**

* 
John Kessenich, Google

The `VK_KHR_relaxed_block_layout` extension allows implementations to
indicate they can support more variation in block `Offset` decorations.
For example, placing a vector of three floats at an offset of
16N +  4.

See [Offset and Stride Assignment](../chapters/interfaces.html#interfaces-resources-layout) for
details.

All functionality in this extension is included in core Vulkan 1.1, with the
KHR suffix omitted.
The original type, enum, and command names are still available as aliases of
the core functionality.

* 
`VK_KHR_RELAXED_BLOCK_LAYOUT_EXTENSION_NAME`

* 
`VK_KHR_RELAXED_BLOCK_LAYOUT_SPEC_VERSION`

* 
Revision 1, 2017-03-26 (JohnK)

**Name String**

`VK_KHR_sampler_mirror_clamp_to_edge`

**Extension Type**

Device extension

**Registered Extension Number**

15

**Revision**

3

**Ratification Status**

Ratified

**Extension and Version Dependencies**

None

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.2](versions.html#versions-1.2-promotions)

**Contact**

* 
Tobias Hector [tobski](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_sampler_mirror_clamp_to_edge] @tobski%0A*Here describe the issue or question you have about the VK_KHR_sampler_mirror_clamp_to_edge extension*)

**Last Modified Date**

2019-08-17

**Contributors**

* 
Tobias Hector, Imagination Technologies

* 
Jon Leech, Khronos

`VK_KHR_sampler_mirror_clamp_to_edge` extends the set of sampler address
modes to include an additional mode
(`VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE`) that effectively uses a
texture map twice as large as the original image in which the additional
half of the new image is a mirror image of the original image.

This new mode relaxes the need to generate images whose opposite edges match
by using the original image to generate a matching mirror image.
This mode allows the texture to be mirrored only once in the negative s, t,
and r directions.

All functionality in this extension is included in core Vulkan 1.2.
However, if Vulkan 1.2 is supported and this extension is not, the
[VkSamplerAddressMode](../chapters/samplers.html#VkSamplerAddressMode)
`VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE` is optional.
Since the original extension did not use an author suffix on the enum
`VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE`, it is used by both core
and extension implementations.

* 
`VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_EXTENSION_NAME`

* 
`VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_SPEC_VERSION`

* 
Extending [VkSamplerAddressMode](../chapters/samplers.html#VkSamplerAddressMode):

`VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE`

* 
`VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE_KHR`

Creating a sampler with the new address mode in each dimension

    VkSamplerCreateInfo createInfo =
    {
        .sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO,
        // Other members set to application-desired values
    };

    createInfo.addressModeU = VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE;
    createInfo.addressModeV = VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE;
    createInfo.addressModeW = VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE;

    VkSampler sampler;
    VkResult result = vkCreateSampler(
        device,
        &createInfo,
        &sampler);

1) Why are both KHR and core versions of the
`VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE` token present?

**RESOLVED**: This functionality was intended to be required in Vulkan 1.0.
We realized shortly before public release that not all implementations could
support it, and moved the functionality into an optional extension, but did
not apply the KHR extension suffix.
Adding a KHR-suffixed alias of the non-suffixed enum has been done to comply
with our own naming rules.

In a related change, before spec revision 1.1.121 this extension was
hardwiring into the spec Makefile so it was always included with the
Specification, even in the core-only versions.
This has now been reverted, and it is treated as any other extension.

* 
Revision 1, 2016-02-16 (Tobias Hector)

Initial draft

Revision 2, 2019-08-14 (Jon Leech)

* 
Add KHR-suffixed alias of non-suffixed enum.

Revision 3, 2019-08-17 (Jon Leech)

* 
Add an issue explaining the reason for the extension API not being
suffixed with KHR.

**Name String**

`VK_KHR_sampler_ycbcr_conversion`

**Extension Type**

Device extension

**Registered Extension Number**

157

**Revision**

14

**Ratification Status**

Ratified

**Extension and Version Dependencies**

 [VK_KHR_maintenance1](#VK_KHR_maintenance1)

 and

 [VK_KHR_bind_memory2](#VK_KHR_bind_memory2)

 and

 [VK_KHR_get_memory_requirements2](#VK_KHR_get_memory_requirements2)

 and

 [VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**API Interactions**

* 
Interacts with VK_EXT_debug_report

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.1](versions.html#versions-1.1-promotions)

**Contact**

* 
Andrew Garrard [fluppeteer](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_sampler_ycbcr_conversion] @fluppeteer%0A*Here describe the issue or question you have about the VK_KHR_sampler_ycbcr_conversion extension*)

**Last Modified Date**

2017-08-11

**IP Status**

No known IP claims.

**Contributors**

* 
Andrew Garrard, Samsung Electronics

* 
Tobias Hector, Imagination Technologies

* 
James Jones, NVIDIA

* 
Daniel Koch, NVIDIA

* 
Daniel Rakos, AMD

* 
Romain Guy, Google

* 
Jesse Hall, Google

* 
Tom Cooksey, ARM Ltd

* 
Jeff Leger, Qualcomm Technologies, Inc

* 
Jan-Harald Fredriksen, ARM Ltd

* 
Jan Outters, Samsung Electronics

* 
Alon Or-bach, Samsung Electronics

* 
Michael Worcester, Imagination Technologies

* 
Jeff Bolz, NVIDIA

* 
Tony Zlatinski, NVIDIA

* 
Matthew Netsch, Qualcomm Technologies, Inc

The use of YCBCR sampler conversion is an area in 3D graphics not used by
most Vulkan developers.
It is mainly used for processing inputs from video decoders and cameras.
The use of the extension assumes basic knowledge of YCBCR concepts.

This extension provides the ability to perform specified color space
conversions during texture sampling operations for the YCBCR color space
natively.
It also adds a selection of multi-planar formats, image aspect plane, and
the ability to bind memory to the planes of an image collectively or
separately.

All functionality in this extension is included in core Vulkan 1.1, with the
KHR suffix omitted.
However, if Vulkan 1.1 is supported and this extension is not, the
`samplerYcbcrConversion` capability is optional.
The original type, enum, and command names are still available as aliases of
the core functionality.

If Vulkan 1.4 is supported, support for the `samplerYcbcrConversion`
capability is required.

* 
[VkSamplerYcbcrConversionKHR](../chapters/samplers.html#VkSamplerYcbcrConversionKHR)

* 
[vkCreateSamplerYcbcrConversionKHR](../chapters/samplers.html#vkCreateSamplerYcbcrConversionKHR)

* 
[vkDestroySamplerYcbcrConversionKHR](../chapters/samplers.html#vkDestroySamplerYcbcrConversionKHR)

* 
[VkSamplerYcbcrConversionCreateInfoKHR](../chapters/samplers.html#VkSamplerYcbcrConversionCreateInfoKHR)

* 
Extending [VkBindImageMemoryInfo](../chapters/resources.html#VkBindImageMemoryInfo):

[VkBindImagePlaneMemoryInfoKHR](../chapters/resources.html#VkBindImagePlaneMemoryInfoKHR)

Extending [VkImageFormatProperties2](../chapters/capabilities.html#VkImageFormatProperties2):

* 
[VkSamplerYcbcrConversionImageFormatPropertiesKHR](../chapters/capabilities.html#VkSamplerYcbcrConversionImageFormatPropertiesKHR)

Extending [VkImageMemoryRequirementsInfo2](../chapters/resources.html#VkImageMemoryRequirementsInfo2):

* 
[VkImagePlaneMemoryRequirementsInfoKHR](../chapters/resources.html#VkImagePlaneMemoryRequirementsInfoKHR)

Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

* 
[VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR](../chapters/features.html#VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR)

Extending [VkSamplerCreateInfo](../chapters/samplers.html#VkSamplerCreateInfo), [VkImageViewCreateInfo](../chapters/resources.html#VkImageViewCreateInfo):

* 
[VkSamplerYcbcrConversionInfoKHR](../chapters/samplers.html#VkSamplerYcbcrConversionInfoKHR)

* 
[VkChromaLocationKHR](../chapters/samplers.html#VkChromaLocationKHR)

* 
[VkSamplerYcbcrModelConversionKHR](../chapters/samplers.html#VkSamplerYcbcrModelConversionKHR)

* 
[VkSamplerYcbcrRangeKHR](../chapters/samplers.html#VkSamplerYcbcrRangeKHR)

* 
`VK_KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME`

* 
`VK_KHR_SAMPLER_YCBCR_CONVERSION_SPEC_VERSION`

* 
Extending [VkChromaLocation](../chapters/samplers.html#VkChromaLocation):

`VK_CHROMA_LOCATION_COSITED_EVEN_KHR`

* 
`VK_CHROMA_LOCATION_MIDPOINT_KHR`

Extending [VkFormat](../chapters/formats.html#VkFormat):

* 
`VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR`

* 
`VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR`

* 
`VK_FORMAT_B16G16R16G16_422_UNORM_KHR`

* 
`VK_FORMAT_B8G8R8G8_422_UNORM_KHR`

* 
`VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR`

* 
`VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR`

* 
`VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR`

* 
`VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR`

* 
`VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR`

* 
`VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR`

* 
`VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR`

* 
`VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR`

* 
`VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR`

* 
`VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR`

* 
`VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR`

* 
`VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR`

* 
`VK_FORMAT_G16B16G16R16_422_UNORM_KHR`

* 
`VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR`

* 
`VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR`

* 
`VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR`

* 
`VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR`

* 
`VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR`

* 
`VK_FORMAT_G8B8G8R8_422_UNORM_KHR`

* 
`VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR`

* 
`VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR`

* 
`VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR`

* 
`VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR`

* 
`VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR`

* 
`VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR`

* 
`VK_FORMAT_R10X6G10X6_UNORM_2PACK16_KHR`

* 
`VK_FORMAT_R10X6_UNORM_PACK16_KHR`

* 
`VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR`

* 
`VK_FORMAT_R12X4G12X4_UNORM_2PACK16_KHR`

* 
`VK_FORMAT_R12X4_UNORM_PACK16_KHR`

Extending [VkFormatFeatureFlagBits](../chapters/formats.html#VkFormatFeatureFlagBits):

* 
`VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR`

* 
`VK_FORMAT_FEATURE_DISJOINT_BIT_KHR`

* 
`VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR`

* 
`VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR`

* 
`VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR`

* 
`VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR`

* 
`VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR`

Extending [VkImageAspectFlagBits](../chapters/resources.html#VkImageAspectFlagBits):

* 
`VK_IMAGE_ASPECT_PLANE_0_BIT_KHR`

* 
`VK_IMAGE_ASPECT_PLANE_1_BIT_KHR`

* 
`VK_IMAGE_ASPECT_PLANE_2_BIT_KHR`

Extending [VkImageCreateFlagBits](../chapters/resources.html#VkImageCreateFlagBits):

* 
`VK_IMAGE_CREATE_DISJOINT_BIT_KHR`

Extending [VkObjectType](../chapters/debugging.html#VkObjectType):

* 
`VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR`

Extending [VkSamplerYcbcrModelConversion](../chapters/samplers.html#VkSamplerYcbcrModelConversion):

* 
`VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY_KHR`

* 
`VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020_KHR`

* 
`VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601_KHR`

* 
`VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709_KHR`

* 
`VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY_KHR`

Extending [VkSamplerYcbcrRange](../chapters/samplers.html#VkSamplerYcbcrRange):

* 
`VK_SAMPLER_YCBCR_RANGE_ITU_FULL_KHR`

* 
`VK_SAMPLER_YCBCR_RANGE_ITU_NARROW_KHR`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR`

* 
`VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR`

* 
`VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO_KHR`

If [VK_EXT_debug_report](#VK_EXT_debug_report) is supported:

* 
Extending [VkDebugReportObjectTypeEXT](../chapters/debugging.html#VkDebugReportObjectTypeEXT):

`VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT`

* 
`VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR_EXT`

* 
Revision 1, 2017-01-24 (Andrew Garrard)

Initial draft

Revision 2, 2017-01-25 (Andrew Garrard)

* 
After initial feedback

Revision 3, 2017-01-27 (Andrew Garrard)

* 
Higher bit depth formats, renaming, swizzle

Revision 4, 2017-02-22 (Andrew Garrard)

* 
Added query function, formats as RGB, clarifications

Revision 5, 2017-04-?? (Andrew Garrard)

* 
Simplified query and removed output conversions

Revision 6, 2017-04-24 (Andrew Garrard)

* 
Tidying, incorporated new image query, restored transfer functions

Revision 7, 2017-04-25 (Andrew Garrard)

* 
Added cosited option/midpoint requirement for formats,
bypassConversion

Revision 8, 2017-04-25 (Andrew Garrard)

* 
Simplified further

Revision 9, 2017-04-27 (Andrew Garrard)

* 
Disjoint no more

Revision 10, 2017-04-28 (Andrew Garrard)

* 
Restored disjoint

Revision 11, 2017-04-29 (Andrew Garrard)

* 
Now Ycbcr conversion, and KHR

Revision 12, 2017-06-06 (Andrew Garrard)

* 
Added conversion to image view creation

Revision 13, 2017-07-13 (Andrew Garrard)

* 
Allowed cosited-only chroma samples for formats

Revision 14, 2017-08-11 (Andrew Garrard)

* 
Reflected quantization changes in BT.2100-1

**Name String**

`VK_KHR_separate_depth_stencil_layouts`

**Extension Type**

Device extension

**Registered Extension Number**

242

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

 [VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

 or

 [Vulkan Version 1.1](versions.html#versions-1.1)

 and

 [VK_KHR_create_renderpass2](#VK_KHR_create_renderpass2)

or

[Vulkan Version 1.2](versions.html#versions-1.2)

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.2](versions.html#versions-1.2-promotions)

**Contact**

* 
Piers Daniell [pdaniell-nv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_separate_depth_stencil_layouts] @pdaniell-nv%0A*Here describe the issue or question you have about the VK_KHR_separate_depth_stencil_layouts extension*)

**Last Modified Date**

2019-06-25

**Contributors**

* 
Daniel Koch, NVIDIA

* 
Jeff Bolz, NVIDIA

* 
Jesse Barker, Unity

* 
Tobias Hector, AMD

This extension allows image memory barriers for depth/stencil images to have
just one of the `VK_IMAGE_ASPECT_DEPTH_BIT` or
`VK_IMAGE_ASPECT_STENCIL_BIT` aspect bits set, rather than require both.
This allows their layouts to be set independently.
To support depth/stencil images with different layouts for the depth and
stencil aspects, the depth/stencil attachment interface has been updated to
support a separate layout for stencil.

All functionality in this extension is included in core Vulkan 1.2, with the
KHR suffix omitted.
The original type, enum, and command names are still available as aliases of
the core functionality.

* 
Extending [VkAttachmentDescription2](../chapters/renderpass.html#VkAttachmentDescription2):

[VkAttachmentDescriptionStencilLayoutKHR](../chapters/renderpass.html#VkAttachmentDescriptionStencilLayoutKHR)

Extending [VkAttachmentReference2](../chapters/renderpass.html#VkAttachmentReference2):

* 
[VkAttachmentReferenceStencilLayoutKHR](../chapters/renderpass.html#VkAttachmentReferenceStencilLayoutKHR)

Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

* 
[VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR](../chapters/features.html#VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR)

* 
`VK_KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS_EXTENSION_NAME`

* 
`VK_KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS_SPEC_VERSION`

* 
Extending [VkImageLayout](../chapters/resources.html#VkImageLayout):

`VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL_KHR`

* 
`VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL_KHR`

* 
`VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL_KHR`

* 
`VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL_KHR`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT_KHR`

* 
`VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT_KHR`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES_KHR`

* 
Revision 1, 2019-06-25 (Piers Daniell)

Internal revisions

**Name String**

`VK_KHR_shader_atomic_int64`

**Extension Type**

Device extension

**Registered Extension Number**

181

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.2](versions.html#versions-1.2-promotions)

**Contact**

* 
Aaron Hagan [ahagan](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_shader_atomic_int64] @ahagan%0A*Here describe the issue or question you have about the VK_KHR_shader_atomic_int64 extension*)

**Last Modified Date**

2018-07-05

**Interactions and External Dependencies**

* 
This extension provides API support for
[`GL_ARB_gpu_shader_int64`](https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gpu_shader_int64.txt) and
[`GL_EXT_shader_atomic_int64`](https://github.com/KhronosGroup/GLSL/blob/main/extensions/ext/GL_EXT_shader_atomic_int64.txt)

**Contributors**

* 
Aaron Hagan, AMD

* 
Daniel Rakos, AMD

* 
Jeff Bolz, NVIDIA

* 
Neil Henning, Codeplay

This extension advertises the SPIR-V **Int64Atomics** capability for Vulkan,
which allows a shader to contain 64-bit atomic operations on signed and
unsigned integers.
The supported operations include OpAtomicMin, OpAtomicMax, OpAtomicAnd,
OpAtomicOr, OpAtomicXor, OpAtomicAdd, OpAtomicExchange, and
OpAtomicCompareExchange.

All functionality in this extension is included in core Vulkan 1.2, with the
KHR suffix omitted.
However, if Vulkan 1.2 is supported and this extension is not, the
`shaderBufferInt64Atomics` capability is optional.
The original type, enum, and command names are still available as aliases of
the core functionality.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceShaderAtomicInt64FeaturesKHR](../chapters/features.html#VkPhysicalDeviceShaderAtomicInt64FeaturesKHR)

* 
`VK_KHR_SHADER_ATOMIC_INT64_EXTENSION_NAME`

* 
`VK_KHR_SHADER_ATOMIC_INT64_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR`

* 
[`Int64Atomics`](spirvenv.html#spirvenv-capabilities-table-Int64Atomics)

* 
Revision 1, 2018-07-05 (Aaron Hagan)

Internal revisions

**Name String**

`VK_KHR_shader_draw_parameters`

**Extension Type**

Device extension

**Registered Extension Number**

64

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

None

**SPIR-V Dependencies**

* 
[SPV_KHR_shader_draw_parameters](https://github.khronos.org/SPIRV-Registry/extensions/KHR/SPV_KHR_shader_draw_parameters.html)

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.1](versions.html#versions-1.1-promotions)

**Contact**

* 
Daniel Koch [dgkoch](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_shader_draw_parameters] @dgkoch%0A*Here describe the issue or question you have about the VK_KHR_shader_draw_parameters extension*)

**Last Modified Date**

2017-09-05

**IP Status**

No known IP claims.

**Interactions and External Dependencies**

* 
This extension provides API support for
[`GL_ARB_shader_draw_parameters`](https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_draw_parameters.txt)

**Contributors**

* 
Daniel Koch, NVIDIA Corporation

* 
Jeff Bolz, NVIDIA

* 
Daniel Rakos, AMD

* 
Jan-Harald Fredriksen, ARM

* 
John Kessenich, Google

* 
Stuart Smith, IMG

This extension adds support for the following SPIR-V extension in Vulkan:

* 
`SPV_KHR_shader_draw_parameters`

The extension provides access to three additional built-in shader variables
in Vulkan:

* 
`BaseInstance`, containing the `firstInstance` parameter passed
to drawing commands,

* 
`BaseVertex`, containing the `firstVertex` or `vertexOffset`
parameter passed to drawing commands, and

* 
`DrawIndex`, containing the index of the draw call currently being
processed from an indirect drawing call.

When using GLSL source-based shader languages, the following variables from
`GL_ARB_shader_draw_parameters` can map to these SPIR-V built-in
decorations:

* 
`in int gl_BaseInstanceARB;`  `BaseInstance`,

* 
`in int gl_BaseVertexARB;`  `BaseVertex`, and

* 
`in int gl_DrawIDARB;`  `DrawIndex`.

All functionality in this extension is included in core Vulkan 1.1.
However, the [`shaderDrawParameters`](../chapters/features.html#features-shaderDrawParameters)
feature bit was added to distinguish whether it is actually available or
not.

* 
`VK_KHR_SHADER_DRAW_PARAMETERS_EXTENSION_NAME`

* 
`VK_KHR_SHADER_DRAW_PARAMETERS_SPEC_VERSION`

* 
[`BaseInstance`](../chapters/interfaces.html#interfaces-builtin-variables-baseinstance)

* 
[`BaseVertex`](../chapters/interfaces.html#interfaces-builtin-variables-basevertex)

* 
[`DrawIndex`](../chapters/interfaces.html#interfaces-builtin-variables-drawindex)

* 
[`DrawParameters`](spirvenv.html#spirvenv-capabilities-table-DrawParameters)

1) Is this the same functionality as `GL_ARB_shader_draw_parameters`?

**RESOLVED**: It is actually a superset, as it also adds in support for
arrayed drawing commands.

In GL for `GL_ARB_shader_draw_parameters`, `gl_BaseVertexARB` holds the
integer value passed to the parameter to the command that resulted in the
current shader invocation.
In the case where the command has no `baseVertex` parameter, the value of
`gl_BaseVertexARB` is zero.
This means that `gl_BaseVertexARB` = `baseVertex` (for
`glDrawElements` commands with `baseVertex`) or 0.
In particular there are no `glDrawArrays` commands that take a
`baseVertex` parameter.

Now in Vulkan, we have `BaseVertex` = `vertexOffset` (for indexed
drawing commands) or `firstVertex` (for arrayed drawing commands), and
so Vulkans version is really a superset of GL functionality.

* 
Revision 1, 2016-10-05 (Daniel Koch)

Internal revisions

**Name String**

`VK_KHR_shader_expect_assume`

**Extension Type**

Device extension

**Registered Extension Number**

545

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**SPIR-V Dependencies**

* 
[SPV_KHR_expect_assume](https://github.khronos.org/SPIRV-Registry/extensions/KHR/SPV_KHR_expect_assume.html)

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.4](versions.html#versions-1.4-promotions)

**Contact**

* 
Kevin Petit [kpet](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_shader_expect_assume] @kpet%0A*Here describe the issue or question you have about the VK_KHR_shader_expect_assume extension*)

**Extension Proposal**

[VK_KHR_shader_expect_assume](../../../features/latest/features/proposals/VK_KHR_shader_expect_assume.html)

**Last Modified Date**

2023-12-06

**IP Status**

No known IP claims.

**Contributors**

* 
Kevin Petit, Arm

* 
Tobias Hector, AMD

* 
James Fitzpatrick, Imagination Technologies

This extension allows the use of the `SPV_KHR_expect_assume` extension in
SPIR-V shader modules which enables SPIR-V producers to provide optimization
hints to the Vulkan implementation.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceShaderExpectAssumeFeaturesKHR](../chapters/features.html#VkPhysicalDeviceShaderExpectAssumeFeaturesKHR)

* 
`VK_KHR_SHADER_EXPECT_ASSUME_EXTENSION_NAME`

* 
`VK_KHR_SHADER_EXPECT_ASSUME_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES_KHR`

* 
[ExpectAssumeKHR](spirvenv.html#spirvenv-capabilities-table-ExpectAssumeKHR)

Functionality in this extension is included in core Vulkan 1.4 with the KHR
suffix omitted.
The original type, enum and command names are still available as aliases of
the core functionality.

* 
Revision 1, 2023-12-06 (Kevin Petit)

Initial revision

**Name String**

`VK_KHR_shader_float16_int8`

**Extension Type**

Device extension

**Registered Extension Number**

83

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.2](versions.html#versions-1.2-promotions)

**Contact**

* 
Alexander Galazin [alegal-arm](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_shader_float16_int8] @alegal-arm%0A*Here describe the issue or question you have about the VK_KHR_shader_float16_int8 extension*)

**Last Modified Date**

2018-03-07

**Interactions and External Dependencies**

* 
This extension interacts with `[VK_KHR_8bit_storage](#VK_KHR_8bit_storage)`

* 
This extension interacts with `[VK_KHR_16bit_storage](#VK_KHR_16bit_storage)`

* 
This extension interacts with `[VK_KHR_shader_float_controls](#VK_KHR_shader_float_controls)`

* 
This extension provides API support for
[`GL_EXT_shader_explicit_arithmetic_types`](https://github.com/KhronosGroup/GLSL/blob/main/extensions/ext/GL_EXT_shader_explicit_arithmetic_types.txt)

**IP Status**

No known IP claims.

**Contributors**

* 
Alexander Galazin, Arm

* 
Jan-Harald Fredriksen, Arm

* 
Jeff Bolz, NVIDIA

* 
Graeme Leese, Broadcom

* 
Daniel Rakos, AMD

The `VK_KHR_shader_float16_int8` extension allows use of 16-bit
floating-point types and 8-bit integer types in shaders for arithmetic
operations.

It introduces two new optional features `shaderFloat16` and
`shaderInt8` which directly map to the `Float16` and the `Int8`
SPIR-V capabilities.
The `VK_KHR_shader_float16_int8` extension also specifies precision
requirements for half-precision floating-point SPIR-V operations.
This extension does not enable use of 8-bit integer types or 16-bit
floating-point types in any [shader input and output interfaces](../chapters/interfaces.html#interfaces-iointerfaces) and therefore does not supersede the
`[VK_KHR_8bit_storage](#VK_KHR_8bit_storage)` or `[VK_KHR_16bit_storage](#VK_KHR_16bit_storage)` extensions.

All functionality in this extension is included in core Vulkan 1.2, with the
KHR suffix omitted.
However, if Vulkan 1.2 is supported and this extension is not, both the
`shaderFloat16` and `shaderInt8` capabilities are optional.
The original type, enum, and command names are still available as aliases of
the core functionality.

If Vulkan 1.4 is supported, support for the `shaderInt8` capability is
required.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceFloat16Int8FeaturesKHR](../chapters/features.html#VkPhysicalDeviceFloat16Int8FeaturesKHR)

* 
[VkPhysicalDeviceShaderFloat16Int8FeaturesKHR](../chapters/features.html#VkPhysicalDeviceShaderFloat16Int8FeaturesKHR)

* 
`VK_KHR_SHADER_FLOAT16_INT8_EXTENSION_NAME`

* 
`VK_KHR_SHADER_FLOAT16_INT8_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT16_INT8_FEATURES_KHR`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR`

* 
Revision 1, 2018-03-07 (Alexander Galazin)

Initial draft

**Name String**

`VK_KHR_shader_float_controls`

**Extension Type**

Device extension

**Registered Extension Number**

198

**Revision**

4

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**SPIR-V Dependencies**

* 
[SPV_KHR_float_controls](https://github.khronos.org/SPIRV-Registry/extensions/KHR/SPV_KHR_float_controls.html)

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.2](versions.html#versions-1.2-promotions)

**Contact**

* 
Alexander Galazin [alegal-arm](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_shader_float_controls] @alegal-arm%0A*Here describe the issue or question you have about the VK_KHR_shader_float_controls extension*)

**Last Modified Date**

2018-09-11

**IP Status**

No known IP claims.

**Contributors**

* 
Alexander Galazin, Arm

* 
Jan-Harald Fredriksen, Arm

* 
Jeff Bolz, NVIDIA

* 
Graeme Leese, Broadcom

* 
Daniel Rakos, AMD

The `VK_KHR_shader_float_controls` extension enables efficient use of
floating-point computations through the ability to query and override the
implementations default behavior for rounding modes, denormals, signed
zero, and infinity.

All functionality in this extension is included in core Vulkan 1.2, with the
KHR suffix omitted.
The original type, enum, and command names are still available as aliases of
the core functionality.

* 
Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

[VkPhysicalDeviceFloatControlsPropertiesKHR](../chapters/limits.html#VkPhysicalDeviceFloatControlsPropertiesKHR)

* 
[VkShaderFloatControlsIndependenceKHR](../chapters/limits.html#VkShaderFloatControlsIndependenceKHR)

* 
`VK_KHR_SHADER_FLOAT_CONTROLS_EXTENSION_NAME`

* 
`VK_KHR_SHADER_FLOAT_CONTROLS_SPEC_VERSION`

* 
Extending [VkShaderFloatControlsIndependence](../chapters/limits.html#VkShaderFloatControlsIndependence):

`VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY_KHR`

* 
`VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL_KHR`

* 
`VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE_KHR`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR`

* 
[`DenormPreserve`](spirvenv.html#spirvenv-capabilities-table-DenormPreserve)

* 
[    `DenormFlushToZero`](spirvenv.html#spirvenv-capabilities-table-DenormFlushToZero)

* 
[    `SignedZeroInfNanPreserve`](spirvenv.html#spirvenv-capabilities-table-SignedZeroInfNanPreserve)

* 
[`RoundingModeRTE`](spirvenv.html#spirvenv-capabilities-table-RoundingModeRTE)

* 
[`RoundingModeRTZ`](spirvenv.html#spirvenv-capabilities-table-RoundingModeRTZ)

1) Which instructions must flush denorms?

**RESOLVED**: Only floating-point conversion, floating-point arithmetic,
floating-point relational (except `OpIsNaN`, `OpIsInf`), and
floating-point GLSL.std.450 extended instructions must flush denormals.

2) What is the denorm behavior for intermediate results?

**RESOLVED**: When a SPIR-V instruction is implemented as a sequence of other
instructions:

* 
in the `DenormFlushToZero` execution mode, the intermediate
instructions may flush denormals, the final result of the sequence **must**
not be denormal.

* 
in the `DenormPreserve` execution mode, denormals must be preserved
throughout the whole sequence.

3) Do denorm and rounding mode controls apply to `OpSpecConstantOp`?

**RESOLVED**: Yes, except when the opcode is `OpQuantizeToF16`.

4) The SPIR-V specification says that `OpConvertFToU` and
`OpConvertFToS` unconditionally round towards zero.
Do the rounding mode controls specified through the execution modes apply to
them?

**RESOLVED**: No, these instructions unconditionally round towards zero.

5) Do any of the Pack GLSL.std.450 instructions count as conversion
instructions and have the rounding mode applied?

**RESOLVED**: No, only instructions listed in section 3.32.11.
Conversion Instructions of the SPIR-V specification count as conversion
instructions.

6) When using inf/nan-ignore mode, what is expected of `OpIsNan` and
`OpIsInf`?

**RESOLVED**: These instructions must always accurately detect inf/nan if it
is passed to them.

The original versions of `VK_KHR_shader_float_controls` shipped with
booleans named separateDenormSettings and
separateRoundingModeSettings, which at first glance could have indicated
they can all be set independently, or not.
However the spec language as written indicated that the 32-bit value could
always be set independently, and only the 16- and 64-bit controls needed to
be the same if these values were `VK_FALSE`.

As a result of this slight disparity, and lack of test coverage for this
facet of the extension, we ended up with two different behaviors in the
wild, where some implementations worked as written, and others worked based
on the naming.
As these are hard limits in hardware with reasons for exposure as written,
it was not possible to standardize on a single way to make this work within
the existing API.

No known users of this part of the extension exist in the wild, and as such
the Vulkan WG took the unusual step of retroactively changing the once
boolean value into a tri-state enum, breaking source compatibility.
This was however done in such a way as to retain ABI compatibility, in case
any code using this did exist; with the numerical values 0 and 1 retaining
their original specified meaning, and a new value signifying the additional
all need to be set together state.
If any applications exist today, compiled binaries will continue to work as
written in most cases, but will need changes before the code can be
recompiled.

* 
Revision 4, 2019-06-18 (Tobias Hector)

Modified settings restrictions, see
[Version 4 API     incompatibility](#VK_KHR_shader_controls_v4_incompatibility)

Revision 3, 2018-09-11 (Alexander Galazin)

* 
Minor restructuring

Revision 2, 2018-04-17 (Alexander Galazin)

* 
Added issues and resolutions

Revision 1, 2018-04-11 (Alexander Galazin)

* 
Initial draft

**Name String**

`VK_KHR_shader_float_controls2`

**Extension Type**

Device extension

**Registered Extension Number**

529

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[Vulkan Version 1.1](versions.html#versions-1.1)

and

[VK_KHR_shader_float_controls](#VK_KHR_shader_float_controls)

**SPIR-V Dependencies**

* 
[SPV_KHR_float_controls2](https://github.khronos.org/SPIRV-Registry/extensions/KHR/SPV_KHR_float_controls2.html)

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.4](versions.html#versions-1.4-promotions)

**Contact**

* 
Graeme Leese [gnl21](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_shader_float_controls2] @gnl21%0A*Here describe the issue or question you have about the VK_KHR_shader_float_controls2 extension*)

**Extension Proposal**

[VK_KHR_shader_float_controls2](../../../features/latest/features/proposals/VK_KHR_shader_float_controls2.html)

**Last Modified Date**

2023-05-16

**Interactions and External Dependencies**

* 
This extension requires
[`SPV_KHR_float_controls2`](https://github.khronos.org/SPIRV-Registry/extensions/KHR/SPV_KHR_float_controls2.html).

**Contributors**

* 
Graeme Leese, Broadcom

This extension enables use of the more expressive fast floating-point math
flags in the SPV_KHR_float_controls2 extension.
These flags give finer- grained control over which optimizations compilers
may apply, potentially speeding up execution while retaining correct
results.

The extension also adds control over the fast-math modes to the GLSL
extended instruction set, making these operations more consistent with
SPIR-V and allowing their use in situations where floating-point conformance
is important.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceShaderFloatControls2FeaturesKHR](../chapters/features.html#VkPhysicalDeviceShaderFloatControls2FeaturesKHR)

* 
`VK_KHR_SHADER_FLOAT_CONTROLS_2_EXTENSION_NAME`

* 
`VK_KHR_SHADER_FLOAT_CONTROLS_2_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES_KHR`

* 
[FloatControls2](spirvenv.html#spirvenv-capabilities-table-FloatControls2)

Functionality in this extension is included in core Vulkan 1.4 with the KHR
suffix omitted.
The original type, enum and command names are still available as aliases of
the core functionality.

* 
Revision 1, 2023-05-16 (Graeme Leese)

Initial draft

**Name String**

`VK_KHR_shader_integer_dot_product`

**Extension Type**

Device extension

**Registered Extension Number**

281

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**SPIR-V Dependencies**

* 
[SPV_KHR_integer_dot_product](https://github.khronos.org/SPIRV-Registry/extensions/KHR/SPV_KHR_integer_dot_product.html)

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.3](versions.html#versions-1.3-promotions)

**Contact**

* 
Kevin Petit [kpet](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_shader_integer_dot_product] @kpet%0A*Here describe the issue or question you have about the VK_KHR_shader_integer_dot_product extension*)

**Extension Proposal**

[VK_KHR_shader_integer_dot_product](../../../features/latest/features/proposals/VK_KHR_shader_integer_dot_product.html)

**Last Modified Date**

2021-06-16

**Interactions and External Dependencies**

* 
This extension interacts with `[VK_KHR_shader_float16_int8](#VK_KHR_shader_float16_int8)`.

**IP Status**

No known IP claims.

**Contributors**

* 
Kvin Petit, Arm Ltd.

* 
Jeff Bolz, NVidia

* 
Spencer Fricke, Samsung

* 
Jesse Hall, Google

* 
John Kessenich, Google

* 
Graeme Leese, Broadcom

* 
Einar Hov, Arm Ltd.

* 
Stuart Brady, Arm Ltd.

* 
Pablo Cascon, Arm Ltd.

* 
Tobias Hector, AMD

* 
Jeff Leger, Qualcomm

* 
Ruihao Zhang, Qualcomm

* 
Pierre Boudier, NVidia

* 
Jon Leech, The Khronos Group

* 
Tom Olson, Arm Ltd.

This extension adds support for the integer dot product SPIR-V instructions
defined in SPV_KHR_integer_dot_product.
These instructions are particularly useful for neural network inference and
training but find uses in other general-purpose compute applications as
well.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR](../chapters/features.html#VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR](../chapters/devsandqueues.html#VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR)

* 
`VK_KHR_SHADER_INTEGER_DOT_PRODUCT_EXTENSION_NAME`

* 
`VK_KHR_SHADER_INTEGER_DOT_PRODUCT_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES_KHR`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES_KHR`

Vulkan APIs in this extension are included in core Vulkan 1.3, with the KHR
suffix omitted.
External interactions defined by this extension, such as SPIR-V token names,
retain their original names.
The original Vulkan API names are still available as aliases of the core
functionality.

* 
[    `DotProductInputAllKHR`](spirvenv.html#spirvenv-capabilities-table-DotProductInputAll)

* 
[    `DotProductInput4x8BitKHR`](spirvenv.html#spirvenv-capabilities-table-DotProductInput4x8Bit)

* 
[    `DotProductInput4x8BitPackedKHR`](spirvenv.html#spirvenv-capabilities-table-DotProductInput4x8BitPacked)

* 
[`DotProductKHR`](spirvenv.html#spirvenv-capabilities-table-DotProduct)

* 
Revision 1, 2021-06-16 (Kvin Petit)

Initial revision

**Name String**

`VK_KHR_shader_non_semantic_info`

**Extension Type**

Device extension

**Registered Extension Number**

294

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

None

**SPIR-V Dependencies**

* 
[SPV_KHR_non_semantic_info](https://github.khronos.org/SPIRV-Registry/extensions/KHR/SPV_KHR_non_semantic_info.html)

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.3](versions.html#versions-1.3-promotions)

**Contact**

* 
Baldur Karlsson [baldurk](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_shader_non_semantic_info] @baldurk%0A*Here describe the issue or question you have about the VK_KHR_shader_non_semantic_info extension*)

**Last Modified Date**

2019-10-16

**IP Status**

No known IP claims.

**Contributors**

* 
Baldur Karlsson, Valve

This extension allows the use of the `SPV_KHR_non_semantic_info` extension
in SPIR-V shader modules.

* 
`VK_KHR_SHADER_NON_SEMANTIC_INFO_EXTENSION_NAME`

* 
`VK_KHR_SHADER_NON_SEMANTIC_INFO_SPEC_VERSION`

Functionality in this extension is included in core Vulkan 1.3.
Because the extension has no API controlling its functionality, this results
only in a change to the [SPIR-V Extensions table](spirvenv.html#spirvenv-extensions-table).

* 
Revision 1, 2019-10-16 (Baldur Karlsson)

Initial revision

**Name String**

`VK_KHR_shader_subgroup_extended_types`

**Extension Type**

Device extension

**Registered Extension Number**

176

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[Vulkan Version 1.1](versions.html#versions-1.1)

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.2](versions.html#versions-1.2-promotions)

**Contact**

* 
Neil Henning [sheredom](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_shader_subgroup_extended_types] @sheredom%0A*Here describe the issue or question you have about the VK_KHR_shader_subgroup_extended_types extension*)

**Last Modified Date**

2019-01-08

**IP Status**

No known IP claims.

**Interactions and External Dependencies**

* 
This extension provides API support for
[`GLSL_EXT_shader_subgroup_extended_types`](https://github.com/KhronosGroup/GLSL/blob/main/extensions/ext/GLSL_EXT_shader_subgroup_extended_types.txt)

**Contributors**

* 
Jeff Bolz, NVIDIA

* 
Jan-Harald Fredriksen, Arm

* 
Neil Henning, AMD

* 
Daniel Koch, NVIDIA

* 
Jeff Leger, Qualcomm

* 
Graeme Leese, Broadcom

* 
David Neto, Google

* 
Daniel Rakos, AMD

This extension enables the Non Uniform Group Operations in SPIR-V to support
8-bit integer, 16-bit integer, 64-bit integer, 16-bit floating-point, and
vectors of these types.

All functionality in this extension is included in core Vulkan 1.2, with the
KHR suffix omitted.
The original type, enum, and command names are still available as aliases of
the core functionality.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR](../chapters/features.html#VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR)

* 
`VK_KHR_SHADER_SUBGROUP_EXTENDED_TYPES_EXTENSION_NAME`

* 
`VK_KHR_SHADER_SUBGROUP_EXTENDED_TYPES_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES_KHR`

* 
Revision 1, 2019-01-08 (Neil Henning)

Initial draft

**Name String**

`VK_KHR_shader_subgroup_rotate`

**Extension Type**

Device extension

**Registered Extension Number**

417

**Revision**

2

**Ratification Status**

Ratified

**Extension and Version Dependencies**

None

**SPIR-V Dependencies**

* 
[SPV_KHR_subgroup_rotate](https://github.khronos.org/SPIRV-Registry/extensions/KHR/SPV_KHR_subgroup_rotate.html)

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.4](versions.html#versions-1.4-promotions)

**Contact**

* 
Kevin Petit [kpet](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_shader_subgroup_rotate] @kpet%0A*Here describe the issue or question you have about the VK_KHR_shader_subgroup_rotate extension*)

**Extension Proposal**

[VK_KHR_shader_subgroup_rotate](../../../features/latest/features/proposals/VK_KHR_shader_subgroup_rotate.html)

**Last Modified Date**

2024-01-29

**IP Status**

No known IP claims.

**Contributors**

* 
Kvin Petit, Arm Ltd.

* 
Tobias Hector, AMD

* 
Jon Leech, Khronos

* 
Matthew Netsch, Qualcomm

* 
Jan-Harald Fredriksen, Arm Ltd.

* 
Graeme Leese, Broadcom

* 
Tom Olson, Arm Ltd.

* 
Spencer Fricke, LunarG Inc.

This extension adds support for the subgroup rotate instruction defined in
SPV_KHR_subgroup_rotate.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR](../chapters/features.html#VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR)

* 
`VK_KHR_SHADER_SUBGROUP_ROTATE_EXTENSION_NAME`

* 
`VK_KHR_SHADER_SUBGROUP_ROTATE_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES_KHR`

Extending [VkSubgroupFeatureFlagBits](../chapters/limits.html#VkSubgroupFeatureFlagBits):

* 
`VK_SUBGROUP_FEATURE_ROTATE_BIT_KHR`

* 
`VK_SUBGROUP_FEATURE_ROTATE_CLUSTERED_BIT_KHR`

* 
[GroupNonUniformRotateKHR](spirvenv.html#spirvenv-capabilities-table-GroupNonUniformRotateKHR)

Functionality in this extension is included in core Vulkan 1.4 with the KHR
suffix omitted.
The original type, enum and command names are still available as aliases of
the core functionality.

* 
Revision 2, 2024-01-29 (Kvin Petit)

Add `VK_SUBGROUP_FEATURE_ROTATE_BIT_KHR` and
`VK_SUBGROUP_FEATURE_ROTATE_CLUSTERED_BIT_KHR`

Revision 1, 2023-06-20 (Kvin Petit)

* 
Initial revision

**Name String**

`VK_KHR_shader_terminate_invocation`

**Extension Type**

Device extension

**Registered Extension Number**

216

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**SPIR-V Dependencies**

* 
[SPV_KHR_terminate_invocation](https://github.khronos.org/SPIRV-Registry/extensions/KHR/SPV_KHR_terminate_invocation.html)

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.3](versions.html#versions-1.3-promotions)

**Contact**

* 
Jesse Hall [critsec](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_shader_terminate_invocation] @critsec%0A*Here describe the issue or question you have about the VK_KHR_shader_terminate_invocation extension*)

**Last Modified Date**

2020-08-11

**IP Status**

No known IP claims.

**Contributors**

* 
Alan Baker, Google

* 
Jeff Bolz, NVIDIA

* 
Jesse Hall, Google

* 
Ralph Potter, Samsung

* 
Tom Olson, Arm

This extension adds Vulkan support for the
[`SPV_KHR_terminate_invocation`](https://github.khronos.org/SPIRV-Registry/extensions/KHR/SPV_KHR_terminate_invocation.html)
SPIR-V extension.
That SPIR-V extension provides a new instruction,
`OpTerminateInvocation`, which causes a shader invocation to immediately
terminate and sets the coverage of shaded samples to `0`; only previously
executed instructions will have observable effects.
The `OpTerminateInvocation` instruction, along with the
`OpDemoteToHelperInvocation` instruction from the
`[VK_EXT_shader_demote_to_helper_invocation](#VK_EXT_shader_demote_to_helper_invocation)` extension, together
replace the `OpKill` instruction, which could behave like either of these
instructions.
`OpTerminateInvocation` provides the behavior required by the GLSL
`discard` statement, and should be used when available by GLSL compilers
and applications that need the GLSL `discard` behavior.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR](../chapters/features.html#VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR)

* 
`VK_KHR_SHADER_TERMINATE_INVOCATION_EXTENSION_NAME`

* 
`VK_KHR_SHADER_TERMINATE_INVOCATION_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES_KHR`

Vulkan APIs in this extension are included in core Vulkan 1.3, with the KHR
suffix omitted.
External interactions defined by this extension, such as SPIR-V token names,
retain their original names.
The original Vulkan API names are still available as aliases of the core
functionality.

* 
Revision 1, 2020-08-11 (Jesse Hall)

**Name String**

`VK_KHR_spirv_1_4`

**Extension Type**

Device extension

**Registered Extension Number**

237

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[Vulkan Version 1.1](versions.html#versions-1.1)

and

[VK_KHR_shader_float_controls](#VK_KHR_shader_float_controls)

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.2](versions.html#versions-1.2-promotions)

**Contact**

* 
Jesse Hall [critsec](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_spirv_1_4] @critsec%0A*Here describe the issue or question you have about the VK_KHR_spirv_1_4 extension*)

**Last Modified Date**

2019-04-01

**IP Status**

No known IP claims.

**Interactions and External Dependencies**

* 
Requires SPIR-V 1.4.

**Contributors**

* 
Alexander Galazin, Arm

* 
David Neto, Google

* 
Jesse Hall, Google

* 
John Kessenich, Google

* 
Neil Henning, AMD

* 
Tom Olson, Arm

This extension allows the use of SPIR-V 1.4 shader modules.
SPIR-V 1.4s new features primarily make it an easier target for compilers
from high-level languages, rather than exposing new hardware functionality.

SPIR-V 1.4 incorporates features that are also available separately as
extensions.
SPIR-V 1.4 shader modules do not need to enable those extensions with the
`OpExtension` opcode, since they are integral parts of SPIR-V 1.4.

SPIR-V 1.4 introduces new floating-point execution mode capabilities, also
available via `SPV_KHR_float_controls`.
Implementations are not required to support all of these new capabilities;
support can be queried using
[VkPhysicalDeviceFloatControlsPropertiesKHR](../chapters/limits.html#VkPhysicalDeviceFloatControlsPropertiesKHR) from the
`[VK_KHR_shader_float_controls](#VK_KHR_shader_float_controls)` extension.

All functionality in this extension is included in core Vulkan 1.2, with the
KHR suffix omitted.
The original type, enum, and command names are still available as aliases of
the core functionality.

* 
`VK_KHR_SPIRV_1_4_EXTENSION_NAME`

* 
`VK_KHR_SPIRV_1_4_SPEC_VERSION`

1.
Should we have an extension specific to this SPIR-V version, or add a
version-generic query for SPIR-V version? SPIR-V 1.4 does not need any other
API changes.

**RESOLVED**: Just expose SPIR-V 1.4.

Most new SPIR-V versions introduce optionally-required capabilities or have
implementation-defined limits, and would need more API and specification
changes specific to that version to make them available in Vulkan.
For example, to support the subgroup capabilities added in SPIR-V 1.3
required introducing [VkPhysicalDeviceSubgroupProperties](../chapters/limits.html#VkPhysicalDeviceSubgroupProperties) to allow
querying the supported group operation categories, maximum supported
subgroup size, etc.
While we could expose the parts of a new SPIR-V version that do not need
accompanying changes generically, we will still end up writing extensions
specific to each version for the remaining parts.
Thus the generic mechanism will not reduce future spec-writing effort.
In addition, making it clear which parts of a future version are supported
by the generic mechanism and which cannot be used without specific support
would be difficult to get right ahead of time.

2.
Can different stages of the same pipeline use shaders with different SPIR-V
versions?

**RESOLVED**: Yes.

Mixing SPIR-V versions 1.0-1.3 in the same pipeline has not been disallowed,
so it would be inconsistent to disallow mixing 1.4 with previous versions.
SPIR-V 1.4 does not introduce anything that should cause new difficulties
here.

3.
Must Vulkan extensions corresponding to SPIR-V extensions that were promoted
to core in 1.4 be enabled in order to use that functionality in a SPIR-V 1.4
module?

**RESOLVED**: No, with caveats.

The SPIR-V 1.4 module does not need to declare the SPIR-V extensions, since
the functionality is now part of core, so there is no need to enable the
Vulkan extension that allows SPIR-V modules to declare the SPIR-V extension.
However, when the functionality that is now core in SPIR-V 1.4 is optionally
supported, the query for support is provided by a Vulkan extension, and that
query can only be used if the extension is enabled.

This applies to any SPIR-V version; specifically for SPIR-V 1.4 this only
applies to the functionality from `SPV_KHR_float_controls`, which was made
available in Vulkan by `[VK_KHR_shader_float_controls](#VK_KHR_shader_float_controls)`.
Even though the extension was promoted in SPIR-V 1.4, the capabilities are
still optional in implementations that support `VK_KHR_spirv_1_4`.

A SPIR-V 1.4 module does not need to enable `SPV_KHR_float_controls` in
order to use the capabilities, so if the application has *a priori*
knowledge that the implementation supports the capabilities, it does not
need to enable `[VK_KHR_shader_float_controls](#VK_KHR_shader_float_controls)`.
However, if it does not have this knowledge and has to query for support at
runtime, it must enable `[VK_KHR_shader_float_controls](#VK_KHR_shader_float_controls)` in order to
use [VkPhysicalDeviceFloatControlsPropertiesKHR](../chapters/limits.html#VkPhysicalDeviceFloatControlsPropertiesKHR).

* 
Revision 1, 2019-04-01 (Jesse Hall)

Internal draft versions

**Name String**

`VK_KHR_storage_buffer_storage_class`

**Extension Type**

Device extension

**Registered Extension Number**

132

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

None

**SPIR-V Dependencies**

* 
[SPV_KHR_storage_buffer_storage_class](https://github.khronos.org/SPIRV-Registry/extensions/KHR/SPV_KHR_storage_buffer_storage_class.html)

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.1](versions.html#versions-1.1-promotions)

**Contact**

* 
Alexander Galazin [alegal-arm](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_storage_buffer_storage_class] @alegal-arm%0A*Here describe the issue or question you have about the VK_KHR_storage_buffer_storage_class extension*)

**Last Modified Date**

2017-09-05

**IP Status**

No known IP claims.

**Contributors**

* 
Alexander Galazin, ARM

* 
David Neto, Google

This extension adds support for the following SPIR-V extension in Vulkan:

* 
`SPV_KHR_storage_buffer_storage_class`

This extension provides a new SPIR-V `StorageBuffer` storage class.
A `Block`-decorated object in this class is equivalent to a
`BufferBlock`-decorated object in the `Uniform` storage class.

All functionality in this extension is included in core Vulkan 1.1.

* 
`VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_EXTENSION_NAME`

* 
`VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_SPEC_VERSION`

* 
Revision 1, 2017-03-23 (Alexander Galazin)

Initial draft

**Name String**

`VK_KHR_synchronization2`

**Extension Type**

Device extension

**Registered Extension Number**

315

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**API Interactions**

* 
Interacts with VK_EXT_blend_operation_advanced

* 
Interacts with VK_EXT_conditional_rendering

* 
Interacts with VK_EXT_device_generated_commands

* 
Interacts with VK_EXT_fragment_density_map

* 
Interacts with VK_EXT_mesh_shader

* 
Interacts with VK_EXT_transform_feedback

* 
Interacts with VK_KHR_acceleration_structure

* 
Interacts with VK_KHR_fragment_shading_rate

* 
Interacts with VK_KHR_ray_tracing_pipeline

* 
Interacts with VK_NV_device_generated_commands

* 
Interacts with VK_NV_mesh_shader

* 
Interacts with VK_NV_ray_tracing

* 
Interacts with VK_NV_shading_rate_image

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.3](versions.html#versions-1.3-promotions)

**Contact**

* 
Tobias Hector [tobski](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_synchronization2] @tobski%0A*Here describe the issue or question you have about the VK_KHR_synchronization2 extension*)

**Last Modified Date**

2020-12-03

**Interactions and External Dependencies**

* 
Interacts with `[VK_KHR_create_renderpass2](#VK_KHR_create_renderpass2)`

**Contributors**

* 
Tobias Hector

This extension modifies the original core synchronization APIs to simplify
the interface and improve usability of these APIs.
It also adds new pipeline stage and access flag types that extend into the
64-bit range, as we have run out within the 32-bit range.
The new flags are identical to the old values within the 32-bit range, with
new stages and bits beyond that.

Pipeline stages and access flags are now specified together in memory
barrier structures, making the connection between the two more obvious.
Additionally, scoping the pipeline stages into the barrier structs allows
the use of the `MEMORY_READ` and `MEMORY_WRITE` flags without
sacrificing precision.
The per-stage access flags should be used to disambiguate specific accesses
in a given stage or set of stages - for instance, between uniform reads and
sampling operations.

Layout transitions have been simplified as well; rather than requiring a
different set of layouts for depth/stencil/color attachments, there are
generic `VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL_KHR` and
`VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR` layouts which are contextually
applied based on the image format.
For example, for a depth format image,
`VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR` is equivalent to
`VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL_KHR`.
`VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR` also functionally replaces
`VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL`.

Events are now more efficient, because they include memory dependency
information when you set them on the device.
Previously, this information was only known when waiting on an event, so the
dependencies could not be satisfied until the wait occurred.
That sometimes meant stalling the pipeline when the wait occurred.
The new API provides enough information for implementations to satisfy these
dependencies in parallel with other tasks.

Queue submission has been changed to wrap command buffers and semaphores in
extensible structures, which incorporate changes from Vulkan 1.1,
`[VK_KHR_device_group](#VK_KHR_device_group)`, and `[VK_KHR_timeline_semaphore](#VK_KHR_timeline_semaphore)`.
This also adds a pipeline stage to the semaphore signal operation, mirroring
the existing pipeline stage specification for wait operations.

Other miscellaneous changes include:

* 
Events can now be specified as interacting only with the device,
allowing more efficient access to the underlying object.

* 
Image memory barriers that do not perform an image layout transition can
be specified by setting `oldLayout` equal to `newLayout`.

E.g. the old and new layout can both be set to
`VK_IMAGE_LAYOUT_UNDEFINED`, without discarding data in the image.

Queue family ownership transfer parameters are simplified in some cases.

Extensions with commands or functions with a [VkPipelineStageFlags](../chapters/synchronization.html#VkPipelineStageFlags)
or [VkPipelineStageFlagBits](../chapters/synchronization.html#VkPipelineStageFlagBits) parameter have had those APIs replaced
with equivalents using [VkPipelineStageFlags2KHR](../chapters/synchronization.html#VkPipelineStageFlags2KHR).

The new event and barrier interfaces are now more extensible for future
changes.

Relevant pipeline stage masks can now be specified as empty with the new
`VK_PIPELINE_STAGE_NONE_KHR` and `VK_PIPELINE_STAGE_2_NONE_KHR`
values.

[VkMemoryBarrier2KHR](../chapters/synchronization.html#VkMemoryBarrier2KHR) can be chained to [VkSubpassDependency2](../chapters/renderpass.html#VkSubpassDependency2),
overriding the original 32-bit stage and access masks.

* 
`VkFlags64`

* 
[vkCmdPipelineBarrier2KHR](../chapters/synchronization.html#vkCmdPipelineBarrier2KHR)

* 
[vkCmdResetEvent2KHR](../chapters/synchronization.html#vkCmdResetEvent2KHR)

* 
[vkCmdSetEvent2KHR](../chapters/synchronization.html#vkCmdSetEvent2KHR)

* 
[vkCmdWaitEvents2KHR](../chapters/synchronization.html#vkCmdWaitEvents2KHR)

* 
[vkCmdWriteTimestamp2KHR](../chapters/queries.html#vkCmdWriteTimestamp2KHR)

* 
[vkQueueSubmit2KHR](../chapters/cmdbuffers.html#vkQueueSubmit2KHR)

* 
[VkBufferMemoryBarrier2KHR](../chapters/synchronization.html#VkBufferMemoryBarrier2KHR)

* 
[VkCommandBufferSubmitInfoKHR](../chapters/cmdbuffers.html#VkCommandBufferSubmitInfoKHR)

* 
[VkDependencyInfoKHR](../chapters/synchronization.html#VkDependencyInfoKHR)

* 
[VkImageMemoryBarrier2KHR](../chapters/synchronization.html#VkImageMemoryBarrier2KHR)

* 
[VkSemaphoreSubmitInfoKHR](../chapters/cmdbuffers.html#VkSemaphoreSubmitInfoKHR)

* 
[VkSubmitInfo2KHR](../chapters/cmdbuffers.html#VkSubmitInfo2KHR)

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceSynchronization2FeaturesKHR](../chapters/features.html#VkPhysicalDeviceSynchronization2FeaturesKHR)

Extending [VkSubpassDependency2](../chapters/renderpass.html#VkSubpassDependency2):

* 
[VkMemoryBarrier2KHR](../chapters/synchronization.html#VkMemoryBarrier2KHR)

* 
[VkAccessFlagBits2KHR](../chapters/synchronization.html#VkAccessFlagBits2KHR)

* 
[VkPipelineStageFlagBits2KHR](../chapters/synchronization.html#VkPipelineStageFlagBits2KHR)

* 
[VkSubmitFlagBitsKHR](../chapters/cmdbuffers.html#VkSubmitFlagBitsKHR)

* 
[VkAccessFlags2KHR](../chapters/synchronization.html#VkAccessFlags2KHR)

* 
[VkPipelineStageFlags2KHR](../chapters/synchronization.html#VkPipelineStageFlags2KHR)

* 
[VkSubmitFlagsKHR](../chapters/cmdbuffers.html#VkSubmitFlagsKHR)

* 
`VK_KHR_SYNCHRONIZATION_2_EXTENSION_NAME`

* 
`VK_KHR_SYNCHRONIZATION_2_SPEC_VERSION`

* 
Extending [VkAccessFlagBits](../chapters/synchronization.html#VkAccessFlagBits):

`VK_ACCESS_NONE_KHR`

Extending [VkAccessFlagBits2](../chapters/synchronization.html#VkAccessFlagBits2):

* 
`VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT_KHR`

* 
`VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT_KHR`

* 
`VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT_KHR`

* 
`VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT_KHR`

* 
`VK_ACCESS_2_HOST_READ_BIT_KHR`

* 
`VK_ACCESS_2_HOST_WRITE_BIT_KHR`

* 
`VK_ACCESS_2_INDEX_READ_BIT_KHR`

* 
`VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT_KHR`

* 
`VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT_KHR`

* 
`VK_ACCESS_2_MEMORY_READ_BIT_KHR`

* 
`VK_ACCESS_2_MEMORY_WRITE_BIT_KHR`

* 
`VK_ACCESS_2_NONE_KHR`

* 
`VK_ACCESS_2_SHADER_READ_BIT_KHR`

* 
`VK_ACCESS_2_SHADER_SAMPLED_READ_BIT_KHR`

* 
`VK_ACCESS_2_SHADER_STORAGE_READ_BIT_KHR`

* 
`VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT_KHR`

* 
`VK_ACCESS_2_SHADER_WRITE_BIT_KHR`

* 
`VK_ACCESS_2_TRANSFER_READ_BIT_KHR`

* 
`VK_ACCESS_2_TRANSFER_WRITE_BIT_KHR`

* 
`VK_ACCESS_2_UNIFORM_READ_BIT_KHR`

* 
`VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT_KHR`

Extending [VkEventCreateFlagBits](../chapters/synchronization.html#VkEventCreateFlagBits):

* 
`VK_EVENT_CREATE_DEVICE_ONLY_BIT_KHR`

Extending [VkImageLayout](../chapters/resources.html#VkImageLayout):

* 
`VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL_KHR`

* 
`VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR`

Extending [VkPipelineStageFlagBits](../chapters/synchronization.html#VkPipelineStageFlagBits):

* 
`VK_PIPELINE_STAGE_NONE_KHR`

Extending [VkPipelineStageFlagBits2](../chapters/synchronization.html#VkPipelineStageFlagBits2):

* 
`VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT_KHR`

* 
`VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT_KHR`

* 
`VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT_KHR`

* 
`VK_PIPELINE_STAGE_2_BLIT_BIT_KHR`

* 
`VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT_KHR`

* 
`VK_PIPELINE_STAGE_2_CLEAR_BIT_KHR`

* 
`VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT_KHR`

* 
`VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT_KHR`

* 
`VK_PIPELINE_STAGE_2_COPY_BIT_KHR`

* 
`VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT_KHR`

* 
`VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT_KHR`

* 
`VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT_KHR`

* 
`VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT_KHR`

* 
`VK_PIPELINE_STAGE_2_HOST_BIT_KHR`

* 
`VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT_KHR`

* 
`VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT_KHR`

* 
`VK_PIPELINE_STAGE_2_NONE_KHR`

* 
`VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT_KHR`

* 
`VK_PIPELINE_STAGE_2_RESOLVE_BIT_KHR`

* 
`VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT_KHR`

* 
`VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT_KHR`

* 
`VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT_KHR`

* 
`VK_PIPELINE_STAGE_2_TRANSFER_BIT_KHR`

* 
`VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT_KHR`

* 
`VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT_KHR`

* 
`VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT_KHR`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2_KHR`

* 
`VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_DEPENDENCY_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2_KHR`

* 
`VK_STRUCTURE_TYPE_MEMORY_BARRIER_2_KHR`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES_KHR`

* 
`VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_SUBMIT_INFO_2_KHR`

Extending [VkSubmitFlagBits](../chapters/cmdbuffers.html#VkSubmitFlagBits):

* 
`VK_SUBMIT_PROTECTED_BIT_KHR`

If [VK_EXT_blend_operation_advanced](#VK_EXT_blend_operation_advanced) is supported:

* 
Extending [VkAccessFlagBits2](../chapters/synchronization.html#VkAccessFlagBits2):

`VK_ACCESS_2_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT`

If [VK_EXT_conditional_rendering](#VK_EXT_conditional_rendering) is supported:

* 
Extending [VkAccessFlagBits2](../chapters/synchronization.html#VkAccessFlagBits2):

`VK_ACCESS_2_CONDITIONAL_RENDERING_READ_BIT_EXT`

Extending [VkPipelineStageFlagBits2](../chapters/synchronization.html#VkPipelineStageFlagBits2):

* 
`VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT`

If [VK_EXT_device_generated_commands](#VK_EXT_device_generated_commands) is supported:

* 
Extending [VkAccessFlagBits2](../chapters/synchronization.html#VkAccessFlagBits2):

`VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_EXT`

* 
`VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_EXT`

Extending [VkPipelineStageFlagBits2](../chapters/synchronization.html#VkPipelineStageFlagBits2):

* 
`VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_EXT`

If [VK_EXT_fragment_density_map](#VK_EXT_fragment_density_map) is supported:

* 
Extending [VkAccessFlagBits2](../chapters/synchronization.html#VkAccessFlagBits2):

`VK_ACCESS_2_FRAGMENT_DENSITY_MAP_READ_BIT_EXT`

Extending [VkPipelineStageFlagBits2](../chapters/synchronization.html#VkPipelineStageFlagBits2):

* 
`VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT`

If [VK_EXT_mesh_shader](#VK_EXT_mesh_shader) is supported:

* 
Extending [VkPipelineStageFlagBits2](../chapters/synchronization.html#VkPipelineStageFlagBits2):

`VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT`

* 
`VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT`

If [VK_EXT_transform_feedback](#VK_EXT_transform_feedback) is supported:

* 
Extending [VkAccessFlagBits2](../chapters/synchronization.html#VkAccessFlagBits2):

`VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT`

* 
`VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT`

* 
`VK_ACCESS_2_TRANSFORM_FEEDBACK_WRITE_BIT_EXT`

Extending [VkPipelineStageFlagBits2](../chapters/synchronization.html#VkPipelineStageFlagBits2):

* 
`VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT`

If [VK_KHR_acceleration_structure](#VK_KHR_acceleration_structure) is supported:

* 
Extending [VkAccessFlagBits2](../chapters/synchronization.html#VkAccessFlagBits2):

`VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR`

* 
`VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_KHR`

Extending [VkPipelineStageFlagBits2](../chapters/synchronization.html#VkPipelineStageFlagBits2):

* 
`VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR`

If [VK_KHR_fragment_shading_rate](#VK_KHR_fragment_shading_rate) is supported:

* 
Extending [VkAccessFlagBits2](../chapters/synchronization.html#VkAccessFlagBits2):

`VK_ACCESS_2_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR`

Extending [VkPipelineStageFlagBits2](../chapters/synchronization.html#VkPipelineStageFlagBits2):

* 
`VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR`

If [VK_KHR_ray_tracing_pipeline](#VK_KHR_ray_tracing_pipeline) is supported:

* 
Extending [VkPipelineStageFlagBits2](../chapters/synchronization.html#VkPipelineStageFlagBits2):

`VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR`

If [VK_NV_device_generated_commands](#VK_NV_device_generated_commands) is supported:

* 
Extending [VkAccessFlagBits2](../chapters/synchronization.html#VkAccessFlagBits2):

`VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_NV`

* 
`VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_NV`

Extending [VkPipelineStageFlagBits2](../chapters/synchronization.html#VkPipelineStageFlagBits2):

* 
`VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV`

If [VK_NV_mesh_shader](#VK_NV_mesh_shader) is supported:

* 
Extending [VkPipelineStageFlagBits2](../chapters/synchronization.html#VkPipelineStageFlagBits2):

`VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_NV`

* 
`VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_NV`

If [VK_NV_ray_tracing](#VK_NV_ray_tracing) is supported:

* 
Extending [VkAccessFlagBits2](../chapters/synchronization.html#VkAccessFlagBits2):

`VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_NV`

* 
`VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_NV`

Extending [VkPipelineStageFlagBits2](../chapters/synchronization.html#VkPipelineStageFlagBits2):

* 
`VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_NV`

* 
`VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_NV`

If [VK_NV_shading_rate_image](#VK_NV_shading_rate_image) is supported:

* 
Extending [VkAccessFlagBits2](../chapters/synchronization.html#VkAccessFlagBits2):

`VK_ACCESS_2_SHADING_RATE_IMAGE_READ_BIT_NV`

Extending [VkPipelineStageFlagBits2](../chapters/synchronization.html#VkPipelineStageFlagBits2):

* 
`VK_PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV`

Vulkan APIs in this extension are included in core Vulkan 1.3, with the KHR
suffix omitted.
External interactions defined by this extension, such as SPIR-V token names,
retain their original names.
The original Vulkan API names are still available as aliases of the core
functionality.

See
[https://github.com/KhronosGroup/Vulkan-Docs/wiki/Synchronization-Examples](https://github.com/KhronosGroup/Vulkan-Docs/wiki/Synchronization-Examples)

* 
Revision 1, 2020-12-03 (Tobias Hector)

Internal revisions

**Name String**

`VK_KHR_timeline_semaphore`

**Extension Type**

Device extension

**Registered Extension Number**

208

**Revision**

2

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.2](versions.html#versions-1.2-promotions)

**Contact**

* 
Faith Ekstrand [gfxstrand](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_timeline_semaphore] @gfxstrand%0A*Here describe the issue or question you have about the VK_KHR_timeline_semaphore extension*)

**Last Modified Date**

2019-06-12

**IP Status**

No known IP claims.

**Interactions and External Dependencies**

* 
This extension interacts with
`[VK_KHR_external_semaphore_capabilities](#VK_KHR_external_semaphore_capabilities)`

* 
This extension interacts with `[VK_KHR_external_semaphore](#VK_KHR_external_semaphore)`

* 
This extension interacts with `[VK_KHR_external_semaphore_win32](#VK_KHR_external_semaphore_win32)`

**Contributors**

* 
Jeff Bolz, NVIDIA

* 
Yuriy ODonnell, Epic Games

* 
Faith Ekstrand, Intel

* 
Jesse Hall, Google

* 
James Jones, NVIDIA

* 
Jeff Juliano, NVIDIA

* 
Daniel Rakos, AMD

* 
Ray Smith, Arm

This extension introduces a new type of semaphore that has an integer
payload identifying a point in a timeline.
Such timeline semaphores support the following operations:

* 
Host query - A host operation that allows querying the payload of the
timeline semaphore.

* 
Host wait - A host operation that allows a blocking wait for a timeline
semaphore to reach a specified value.

* 
Host signal - A host operation that allows advancing the timeline
semaphore to a specified value.

* 
Device wait - A device operation that allows waiting for a timeline
semaphore to reach a specified value.

* 
Device signal - A device operation that allows advancing the timeline
semaphore to a specified value.

All functionality in this extension is included in core Vulkan 1.2, with the
KHR suffix omitted.
The original type, enum, and command names are still available as aliases of
the core functionality.

* 
[vkGetSemaphoreCounterValueKHR](../chapters/synchronization.html#vkGetSemaphoreCounterValueKHR)

* 
[vkSignalSemaphoreKHR](../chapters/synchronization.html#vkSignalSemaphoreKHR)

* 
[vkWaitSemaphoresKHR](../chapters/synchronization.html#vkWaitSemaphoresKHR)

* 
[VkSemaphoreSignalInfoKHR](../chapters/synchronization.html#VkSemaphoreSignalInfoKHR)

* 
[VkSemaphoreWaitInfoKHR](../chapters/synchronization.html#VkSemaphoreWaitInfoKHR)

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceTimelineSemaphoreFeaturesKHR](../chapters/features.html#VkPhysicalDeviceTimelineSemaphoreFeaturesKHR)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceTimelineSemaphorePropertiesKHR](../chapters/limits.html#VkPhysicalDeviceTimelineSemaphorePropertiesKHR)

Extending [VkSemaphoreCreateInfo](../chapters/synchronization.html#VkSemaphoreCreateInfo), [VkPhysicalDeviceExternalSemaphoreInfo](../chapters/capabilities.html#VkPhysicalDeviceExternalSemaphoreInfo):

* 
[VkSemaphoreTypeCreateInfoKHR](../chapters/synchronization.html#VkSemaphoreTypeCreateInfoKHR)

Extending [VkSubmitInfo](../chapters/cmdbuffers.html#VkSubmitInfo), [VkBindSparseInfo](../chapters/sparsemem.html#VkBindSparseInfo):

* 
[VkTimelineSemaphoreSubmitInfoKHR](../chapters/cmdbuffers.html#VkTimelineSemaphoreSubmitInfoKHR)

* 
[VkSemaphoreTypeKHR](../chapters/synchronization.html#VkSemaphoreTypeKHR)

* 
[VkSemaphoreWaitFlagBitsKHR](../chapters/synchronization.html#VkSemaphoreWaitFlagBitsKHR)

* 
[VkSemaphoreWaitFlagsKHR](../chapters/synchronization.html#VkSemaphoreWaitFlagsKHR)

* 
`VK_KHR_TIMELINE_SEMAPHORE_EXTENSION_NAME`

* 
`VK_KHR_TIMELINE_SEMAPHORE_SPEC_VERSION`

* 
Extending [VkSemaphoreType](../chapters/synchronization.html#VkSemaphoreType):

`VK_SEMAPHORE_TYPE_BINARY_KHR`

* 
`VK_SEMAPHORE_TYPE_TIMELINE_KHR`

Extending [VkSemaphoreWaitFlagBits](../chapters/synchronization.html#VkSemaphoreWaitFlagBits):

* 
`VK_SEMAPHORE_WAIT_ANY_BIT_KHR`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES_KHR`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES_KHR`

* 
`VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO_KHR`

* 
`VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO_KHR`

1) Do we need a new object type for this?

**RESOLVED**: No, we just introduce a new type of semaphore object, as
`VK_KHR_external_semaphore_win32` already uses semaphores as the destination
for importing D3D12 fence objects, which are semantically close/identical to
the proposed synchronization primitive.

2) What type of payload the new synchronization primitive has?

**RESOLVED**: A 64-bit unsigned integer that can only be set to strictly
increasing values by signal operations and is not changed by wait
operations.

3) Does the new synchronization primitive have the same signal-before-wait
requirement as the existing semaphores do?

**RESOLVED**: No.
Timeline semaphores support signaling and waiting entirely asynchronously.
It is the responsibility of the application to avoid deadlock.

4) Does the new synchronization primitive allow resetting its payload?

**RESOLVED**: No, allowing the payload value to go backwards is
problematic.
Applications looking for reset behavior should create a new instance of the
synchronization primitive instead.

5) How do we enable host waits on the synchronization primitive?

**RESOLVED**: Both a non-blocking query of the current payload value of the
synchronization primitive, and a blocking wait operation are provided.

6) How do we enable device waits and signals on the synchronization
primitive?

**RESOLVED**: Similar to `VK_KHR_external_semaphore_win32`, this extension
introduces a new structure that can be chained to [VkSubmitInfo](../chapters/cmdbuffers.html#VkSubmitInfo) to
specify the values signaled semaphores should be set to, and the values
waited semaphores need to reach.

7) Can the new synchronization primitive be used to synchronize presentation
and swapchain image acquisition operations?

**RESOLVED**: Some implementations may have problems with supporting that
directly, thus it is not allowed in this extension.

8) Do we want to support external sharing of the new synchronization
primitive type?

**RESOLVED**: Yes.
Timeline semaphore specific external sharing capabilities can be queried
using [vkGetPhysicalDeviceExternalSemaphoreProperties](../chapters/capabilities.html#vkGetPhysicalDeviceExternalSemaphoreProperties) by chaining the
new [VkSemaphoreTypeCreateInfoKHR](../chapters/synchronization.html#VkSemaphoreTypeCreateInfoKHR) structure to its
`pExternalSemaphoreInfo` structure.
This allows having a different set of external semaphore handle types
supported for timeline semaphores vs. binary semaphores.

9) Do we need to add a host signal operation for the new synchronization
primitive type?

**RESOLVED**: Yes.
This helps in situations where one host thread submits a workload but
another host thread has the information on when the workload is ready to be
executed.

10) How should the new synchronization primitive interact with the ordering
requirements of the original `VkSemaphore`?

**RESOLVED**: Prior to calling any command which **may** cause a wait operation
on a binary semaphore, the application **must** ensure that the semaphore
signal operation that has been submitted for execution and any semaphore
signal operations on which it depends (if any) **must** have also been
submitted for execution.

11) Should we have separate feature bits for different sub-features of
timeline semaphores?

**RESOLVED**: No.
The only feature which cannot be supported universally is timeline semaphore
import/export.
For import/export, the application is already required to query available
external handle types via
[vkGetPhysicalDeviceExternalSemaphoreProperties](../chapters/capabilities.html#vkGetPhysicalDeviceExternalSemaphoreProperties) and provide the
semaphore type by adding a [VkSemaphoreTypeCreateInfoKHR](../chapters/synchronization.html#VkSemaphoreTypeCreateInfoKHR) structure to
the `pNext` chain of [VkPhysicalDeviceExternalSemaphoreInfo](../chapters/capabilities.html#VkPhysicalDeviceExternalSemaphoreInfo) so no
new feature bit is required.

* 
Revision 1, 2018-05-10 (Faith Ekstrand)

Initial version

Revision 2, 2019-06-12 (Faith Ekstrand)

* 
Added an initialValue parameter to timeline semaphore creation

**Name String**

`VK_KHR_uniform_buffer_standard_layout`

**Extension Type**

Device extension

**Registered Extension Number**

254

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.2](versions.html#versions-1.2-promotions)

**Contact**

* 
Graeme Leese [gnl21](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_uniform_buffer_standard_layout] @gnl21%0A*Here describe the issue or question you have about the VK_KHR_uniform_buffer_standard_layout extension*)

**Last Modified Date**

2019-01-25

**Contributors**

* 
Graeme Leese, Broadcom

* 
Jeff Bolz, NVIDIA

* 
Tobias Hector, AMD

* 
Faith Ekstrand, Intel

* 
Neil Henning, AMD

This extension enables tighter array and structure packing to be used with
uniform buffers.

It modifies the alignment rules for uniform buffers, allowing for tighter
packing of arrays and structures.
This allows, for example, the std430 layout, as defined in
[GLSL](https://registry.khronos.org/OpenGL/specs/gl/GLSLangSpec.4.60.pdf) to
be supported in uniform buffers.

All functionality in this extension is included in core Vulkan 1.2, with the
KHR suffix omitted.
The original type, enum, and command names are still available as aliases of
the core functionality.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR](../chapters/features.html#VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR)

* 
`VK_KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_EXTENSION_NAME`

* 
`VK_KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR`

* 
Revision 1, 2019-01-25 (Graeme Leese)

Initial draft

**Name String**

`VK_KHR_variable_pointers`

**Extension Type**

Device extension

**Registered Extension Number**

121

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

 [VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

 and

 [VK_KHR_storage_buffer_storage_class](#VK_KHR_storage_buffer_storage_class)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**SPIR-V Dependencies**

* 
[SPV_KHR_variable_pointers](https://github.khronos.org/SPIRV-Registry/extensions/KHR/SPV_KHR_variable_pointers.html)

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.1](versions.html#versions-1.1-promotions)

**Contact**

* 
Jesse Hall [critsec](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_variable_pointers] @critsec%0A*Here describe the issue or question you have about the VK_KHR_variable_pointers extension*)

**Last Modified Date**

2017-09-05

**IP Status**

No known IP claims.

**Contributors**

* 
John Kessenich, Google

* 
Neil Henning, Codeplay

* 
David Neto, Google

* 
Daniel Koch, Nvidia

* 
Graeme Leese, Broadcom

* 
Weifeng Zhang, Qualcomm

* 
Stephen Clarke, Imagination Technologies

* 
Faith Ekstrand, Intel

* 
Jesse Hall, Google

The `VK_KHR_variable_pointers` extension allows implementations to indicate
their level of support for the `SPV_KHR_variable_pointers` SPIR-V extension.
The SPIR-V extension allows shader modules to use invocation-private
pointers into uniform and/or storage buffers, where the pointer values can
be dynamic and non-uniform.

The `SPV_KHR_variable_pointers` extension introduces two capabilities.
The first, `VariablePointersStorageBuffer`, **must** be supported by all
implementations of this extension.
The second, `VariablePointers`, is optional.

All functionality in this extension is included in core Vulkan 1.1, with the
KHR suffix omitted, however support for the
[`variablePointersStorageBuffer`](../chapters/features.html#features-variablePointersStorageBuffer) feature is made optional.
The original type, enum, and command names are still available as aliases of
the core functionality.

If Vulkan 1.4 is supported, support for the [`variablePointers`](../chapters/features.html#features-variablePointers) and [`variablePointersStorageBuffer`](../chapters/features.html#features-variablePointersStorageBuffer) features is required.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceVariablePointerFeaturesKHR](../chapters/features.html#VkPhysicalDeviceVariablePointerFeaturesKHR)

* 
[VkPhysicalDeviceVariablePointersFeaturesKHR](../chapters/features.html#VkPhysicalDeviceVariablePointersFeaturesKHR)

* 
`VK_KHR_VARIABLE_POINTERS_EXTENSION_NAME`

* 
`VK_KHR_VARIABLE_POINTERS_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR`

* 
[`VariablePointers`](spirvenv.html#spirvenv-capabilities-table-VariablePointers)

* 
[    `VariablePointersStorageBuffer`](spirvenv.html#spirvenv-capabilities-table-VariablePointersStorageBuffer)

1) Do we need an optional property for the SPIR-V
`VariablePointersStorageBuffer` capability or should it be mandatory when
this extension is advertised?

**RESOLVED**: Add it as a distinct feature, but make support mandatory.
Adding it as a feature makes the extension easier to include in a future
core API version.
In the extension, the feature is mandatory, so that presence of the
extension guarantees some functionality.
When included in a core API version, the feature would be optional.

2) Can support for these capabilities vary between shader stages?

**RESOLVED**: No, if the capability is supported in any stage it must be
supported in all stages.

3) Should the capabilities be features or limits?

**RESOLVED**: Features, primarily for consistency with other similar
extensions.

* 
Revision 1, 2017-03-14 (Jesse Hall and John Kessenich)

Internal revisions

**Name String**

`VK_KHR_vertex_attribute_divisor`

**Extension Type**

Device extension

**Registered Extension Number**

526

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.4](versions.html#versions-1.4-promotions)

**Contact**

* 
Shahbaz Youssefi [syoussefi](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_vertex_attribute_divisor] @syoussefi%0A*Here describe the issue or question you have about the VK_KHR_vertex_attribute_divisor extension*)

**Extension Proposal**

[VK_KHR_vertex_attribute_divisor](../../../features/latest/features/proposals/VK_KHR_vertex_attribute_divisor.html)

**Last Modified Date**

2023-09-20

**IP Status**

No known IP claims.

**Contributors**

* 
Shahbaz Youssefi, Google

* 
Contributors to `[VK_EXT_vertex_attribute_divisor](#VK_EXT_vertex_attribute_divisor)`

This extension is based on the `[VK_EXT_vertex_attribute_divisor](#VK_EXT_vertex_attribute_divisor)`
extension.
The only difference is the new property `supportsNonZeroFirstInstance`,
which indicates support for non-zero values in `firstInstance`.
This allows the extension to be supported on implementations that have
traditionally only supported OpenGL ES.

* 
[VkVertexInputBindingDivisorDescriptionKHR](../chapters/fxvertex.html#VkVertexInputBindingDivisorDescriptionKHR)

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR](../chapters/features.html#VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR](../chapters/limits.html#VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR)

Extending [VkPipelineVertexInputStateCreateInfo](../chapters/fxvertex.html#VkPipelineVertexInputStateCreateInfo):

* 
[VkPipelineVertexInputDivisorStateCreateInfoKHR](../chapters/fxvertex.html#VkPipelineVertexInputDivisorStateCreateInfoKHR)

* 
`VK_KHR_VERTEX_ATTRIBUTE_DIVISOR_EXTENSION_NAME`

* 
`VK_KHR_VERTEX_ATTRIBUTE_DIVISOR_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_KHR`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_KHR`

* 
`VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_KHR`

Functionality in this extension is included in core Vulkan 1.4 with the KHR
suffix omitted.
The original type, enum and command names are still available as aliases of
the core functionality.

* 
Revision 1, 2023-09-20 (Shahbaz Youssefi)

First Version, based on `[VK_EXT_vertex_attribute_divisor](#VK_EXT_vertex_attribute_divisor)`

**Name String**

`VK_KHR_vulkan_memory_model`

**Extension Type**

Device extension

**Registered Extension Number**

212

**Revision**

3

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**SPIR-V Dependencies**

* 
[SPV_KHR_vulkan_memory_model](https://github.khronos.org/SPIRV-Registry/extensions/KHR/SPV_KHR_vulkan_memory_model.html)

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.2](versions.html#versions-1.2-promotions)

**Contact**

* 
Jeff Bolz [jeffbolznv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_vulkan_memory_model] @jeffbolznv%0A*Here describe the issue or question you have about the VK_KHR_vulkan_memory_model extension*)

**Last Modified Date**

2018-12-10

**IP Status**

No known IP claims.

**Contributors**

* 
Jeff Bolz, NVIDIA

* 
Alan Baker, Google

* 
Tobias Hector, AMD

* 
David Neto, Google

* 
Robert Simpson, Qualcomm Technologies, Inc.

* 
Brian Sumner, AMD

The [VK_KHR_vulkan_memory_model](#VK_KHR_vulkan_memory_model) extension allows use of the features
guarded by the `VulkanMemoryModel`, `VulkanMemoryModelDeviceScope`,
and `VulkanMemoryModelAvailabilityVisibilityChains` capabilities in
shader modules.
The [Vulkan Memory Model](memorymodel.html#memory-model) formally defines how to synchronize
memory accesses to the same memory locations performed by multiple shader
invocations.

|  | Version 3 of the spec added a member
| --- | --- |
(`vulkanMemoryModelAvailabilityVisibilityChains`) to
[VkPhysicalDeviceVulkanMemoryModelFeaturesKHR](../chapters/features.html#VkPhysicalDeviceVulkanMemoryModelFeaturesKHR), which is an incompatible
change from version 2. |

All functionality in this extension is included in core Vulkan 1.2, with the
KHR suffix omitted.
However, if Vulkan 1.2 is supported and this extension is not, the
`vulkanMemoryModel` capability is optional.
The original type, enum, and command names are still available as aliases of
the core functionality.

If Vulkan 1.3 is supported, support for the `vulkanMemoryModel` and
`vulkanMemoryModelDeviceScope` capabilities is required.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceVulkanMemoryModelFeaturesKHR](../chapters/features.html#VkPhysicalDeviceVulkanMemoryModelFeaturesKHR)

* 
`VK_KHR_VULKAN_MEMORY_MODEL_EXTENSION_NAME`

* 
`VK_KHR_VULKAN_MEMORY_MODEL_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR`

* 
[    `VulkanMemoryModelKHR`](spirvenv.html#spirvenv-capabilities-table-VulkanMemoryModel)

* 
Revision 1, 2018-06-24 (Jeff Bolz)

Initial draft

Revision 3, 2018-12-10 (Jeff Bolz)

* 
Add vulkanMemoryModelAvailabilityVisibilityChains member to the
VkPhysicalDeviceVulkanMemoryModelFeaturesKHR structure.

**Name String**

`VK_KHR_zero_initialize_workgroup_memory`

**Extension Type**

Device extension

**Registered Extension Number**

326

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.3](versions.html#versions-1.3-promotions)

**Contact**

* 
Alan Baker [alan-baker](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_KHR_zero_initialize_workgroup_memory] @alan-baker%0A*Here describe the issue or question you have about the VK_KHR_zero_initialize_workgroup_memory extension*)

**Last Modified Date**

2020-11-18

**IP Status**

No known IP claims.

**Contributors**

* 
Alan Baker, Google

* 
Jeff Bolz, Nvidia

* 
Faith Ekstrand, Intel

This extension allows the use of a null constant initializer on shader
Workgroup memory variables, allowing implementations to expose any special
hardware or instructions they may have.
Zero initialization is commonly used by applications running untrusted
content (e.g. web browsers) as way of defeating memory-scraping attacks.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR](../chapters/features.html#VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR)

* 
`VK_KHR_ZERO_INITIALIZE_WORKGROUP_MEMORY_EXTENSION_NAME`

* 
`VK_KHR_ZERO_INITIALIZE_WORKGROUP_MEMORY_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES_KHR`

Vulkan APIs in this extension are included in core Vulkan 1.3, with the KHR
suffix omitted.
External interactions defined by this extension, such as SPIR-V token names,
retain their original names.
The original Vulkan API names are still available as aliases of the core
functionality.

* 
Revision 1, 2020-11-18 (Alan Baker)

Internal draft version

**Name String**

`VK_EXT_4444_formats`

**Extension Type**

Device extension

**Registered Extension Number**

341

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.3](versions.html#versions-1.3-promotions)

**Contact**

* 
Joshua Ashton [Joshua-Ashton](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_4444_formats] @Joshua-Ashton%0A*Here describe the issue or question you have about the VK_EXT_4444_formats extension*)

**Last Modified Date**

2020-07-28

**IP Status**

No known IP claims.

**Contributors**

* 
Joshua Ashton, Valve

* 
Faith Ekstrand, Intel

This extension defines the `VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT` and
`VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT` formats which are defined in other
current graphics APIs.

This extension may be useful for building translation layers for those APIs
or for porting applications that use these formats without having to resort
to swizzles.

When VK_EXT_custom_border_color is used, these formats are not subject to
the same restrictions for border color without format as with
VK_FORMAT_B4G4R4A4_UNORM_PACK16.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDevice4444FormatsFeaturesEXT](../chapters/features.html#VkPhysicalDevice4444FormatsFeaturesEXT)

* 
`VK_EXT_4444_FORMATS_EXTENSION_NAME`

* 
`VK_EXT_4444_FORMATS_SPEC_VERSION`

* 
Extending [VkFormat](../chapters/formats.html#VkFormat):

`VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT`

* 
`VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT`

The format enumerants introduced by the extension are included in core
Vulkan 1.3, with the EXT suffix omitted.
However, runtime support for these formats is optional in core Vulkan 1.3,
while if this extension is supported, runtime support is mandatory.
The feature structure is not promoted.
The original enum names are still available as aliases of the core
functionality.

* 
Revision 1, 2020-07-04 (Joshua Ashton)

Initial draft

**Name String**

`VK_EXT_buffer_device_address`

**Extension Type**

Device extension

**Registered Extension Number**

245

**Revision**

2

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**SPIR-V Dependencies**

* 
[SPV_EXT_physical_storage_buffer](https://github.khronos.org/SPIRV-Registry/extensions/EXT/SPV_EXT_physical_storage_buffer.html)

**Deprecation State**

* 
*Deprecated* by
[VK_KHR_buffer_device_address](#VK_KHR_buffer_device_address)
extension

Which in turn was *promoted* to
[Vulkan 1.2](versions.html#versions-1.2-promotions)

**Contact**

* 
Jeff Bolz [jeffbolznv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_buffer_device_address] @jeffbolznv%0A*Here describe the issue or question you have about the VK_EXT_buffer_device_address extension*)

**Last Modified Date**

2019-01-06

**IP Status**

No known IP claims.

**Interactions and External Dependencies**

* 
This extension provides API support for
[`GLSL_EXT_buffer_reference`](https://github.com/KhronosGroup/GLSL/blob/main/extensions/ext/GLSL_EXT_buffer_reference.txt)
and
[`GLSL_EXT_buffer_reference_uvec2`](https://github.com/KhronosGroup/GLSL/blob/main/extensions/ext/GLSL_EXT_buffer_reference_uvec2.txt)

**Contributors**

* 
Jeff Bolz, NVIDIA

* 
Neil Henning, AMD

* 
Tobias Hector, AMD

* 
Faith Ekstrand, Intel

* 
Baldur Karlsson, Valve

This extension allows the application to query a 64-bit buffer device
address value for a buffer, which can be used to access the buffer memory
via the `PhysicalStorageBufferEXT` storage class in the
[`GL_EXT_buffer_reference`](https://github.com/KhronosGroup/GLSL/blob/main/extensions/ext/GLSL_EXT_buffer_reference.txt)
GLSL extension and
[`SPV_EXT_physical_storage_buffer`](https://github.khronos.org/SPIRV-Registry/extensions/EXT/SPV_EXT_physical_storage_buffer.html)
SPIR-V extension.

It also allows buffer device addresses to be provided by a trace replay
tool, so that it matches the address used when the trace was captured.

* 
[vkGetBufferDeviceAddressEXT](../chapters/descriptorsets.html#vkGetBufferDeviceAddressEXT)

* 
[VkBufferDeviceAddressInfoEXT](../chapters/descriptorsets.html#VkBufferDeviceAddressInfoEXT)

* 
Extending [VkBufferCreateInfo](../chapters/resources.html#VkBufferCreateInfo):

[VkBufferDeviceAddressCreateInfoEXT](../chapters/resources.html#VkBufferDeviceAddressCreateInfoEXT)

Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

* 
[VkPhysicalDeviceBufferAddressFeaturesEXT](../chapters/features.html#VkPhysicalDeviceBufferAddressFeaturesEXT)

* 
[VkPhysicalDeviceBufferDeviceAddressFeaturesEXT](../chapters/features.html#VkPhysicalDeviceBufferDeviceAddressFeaturesEXT)

* 
`VK_EXT_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME`

* 
`VK_EXT_BUFFER_DEVICE_ADDRESS_SPEC_VERSION`

* 
Extending [VkBufferCreateFlagBits](../chapters/resources.html#VkBufferCreateFlagBits):

`VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT`

Extending [VkBufferUsageFlagBits](../chapters/resources.html#VkBufferUsageFlagBits):

* 
`VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT`

Extending [VkResult](../chapters/fundamentals.html#VkResult):

* 
`VK_ERROR_INVALID_DEVICE_ADDRESS_EXT`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_ADDRESS_FEATURES_EXT`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT`

* 
[    `PhysicalStorageBufferAddressesEXT`](spirvenv.html#spirvenv-capabilities-table-PhysicalStorageBufferAddresses)

1) Where is VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_ADDRESS_FEATURES_EXT
and VkPhysicalDeviceBufferAddressFeaturesEXT?

**RESOLVED**: They were renamed as
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT`
and [VkPhysicalDeviceBufferDeviceAddressFeaturesEXT](../chapters/features.html#VkPhysicalDeviceBufferDeviceAddressFeaturesEXT) accordingly for
consistency.
Even though, the old names can still be found in the generated header files
for compatibility.

* 
Revision 1, 2018-11-01 (Jeff Bolz)

Internal revisions

Revision 2, 2019-01-06 (Jon Leech)

* 
Minor updates to appendix for publication

**Name String**

`VK_EXT_calibrated_timestamps`

**Extension Type**

Device extension

**Registered Extension Number**

185

**Revision**

2

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Deprecation State**

* 
*Promoted* to
[VK_KHR_calibrated_timestamps](#VK_KHR_calibrated_timestamps)
extension

**Contact**

* 
Daniel Rakos [drakos-amd](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_calibrated_timestamps] @drakos-amd%0A*Here describe the issue or question you have about the VK_EXT_calibrated_timestamps extension*)

**Extension Proposal**

[VK_EXT_calibrated_timestamps](../../../features/latest/features/proposals/VK_EXT_calibrated_timestamps.html)

**Last Modified Date**

2018-10-04

**IP Status**

No known IP claims.

**Contributors**

* 
Matthaeus G. Chajdas, AMD

* 
Alan Harrison, AMD

* 
Derrick Owens, AMD

* 
Daniel Rakos, AMD

* 
Faith Ekstrand, Intel

* 
Keith Packard, Valve

This extension provides an interface to query calibrated timestamps obtained
quasi simultaneously from two time domains.

All functionality in this extension is included in
`[VK_KHR_calibrated_timestamps](#VK_KHR_calibrated_timestamps)`, with the suffix changed to KHR.
The original enum names are still available as aliases of the KHR
functionality.

* 
[vkGetCalibratedTimestampsEXT](../chapters/synchronization.html#vkGetCalibratedTimestampsEXT)

* 
[vkGetPhysicalDeviceCalibrateableTimeDomainsEXT](../chapters/capabilities.html#vkGetPhysicalDeviceCalibrateableTimeDomainsEXT)

* 
[VkCalibratedTimestampInfoEXT](../chapters/synchronization.html#VkCalibratedTimestampInfoEXT)

* 
[VkTimeDomainEXT](../chapters/synchronization.html#VkTimeDomainEXT)

* 
`VK_EXT_CALIBRATED_TIMESTAMPS_EXTENSION_NAME`

* 
`VK_EXT_CALIBRATED_TIMESTAMPS_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT`

Extending [VkTimeDomainKHR](../chapters/synchronization.html#VkTimeDomainKHR):

* 
`VK_TIME_DOMAIN_CLOCK_MONOTONIC_EXT`

* 
`VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_EXT`

* 
`VK_TIME_DOMAIN_DEVICE_EXT`

* 
`VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_EXT`

* 
Revision 2, 2021-03-16 (Lionel Landwerlin)

Specify requirement on device timestamps

Revision 1, 2018-10-04 (Daniel Rakos)

* 
Internal revisions.

**Name String**

`VK_EXT_debug_marker`

**Extension Type**

Device extension

**Registered Extension Number**

23

**Revision**

4

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_EXT_debug_report](#VK_EXT_debug_report)

**Deprecation State**

* 
*Promoted* to
[VK_EXT_debug_utils](#VK_EXT_debug_utils)
extension

**Special Use**

* 
[Debugging tools](../chapters/extensions.html#extendingvulkan-compatibility-specialuse)

**Contact**

* 
Baldur Karlsson [baldurk](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_debug_marker] @baldurk%0A*Here describe the issue or question you have about the VK_EXT_debug_marker extension*)

**Last Modified Date**

2017-01-31

**IP Status**

No known IP claims.

**Contributors**

* 
Baldur Karlsson

* 
Dan Ginsburg, Valve

* 
Jon Ashburn, LunarG

* 
Kyle Spagnoli, NVIDIA

The `VK_EXT_debug_marker` extension is a device extension.
It introduces concepts of object naming and tagging, for better tracking of
Vulkan objects, as well as additional commands for recording annotations of
named sections of a workload to aid organization and offline analysis in
external tools.

* 
[vkCmdDebugMarkerBeginEXT](../chapters/debugging.html#vkCmdDebugMarkerBeginEXT)

* 
[vkCmdDebugMarkerEndEXT](../chapters/debugging.html#vkCmdDebugMarkerEndEXT)

* 
[vkCmdDebugMarkerInsertEXT](../chapters/debugging.html#vkCmdDebugMarkerInsertEXT)

* 
[vkDebugMarkerSetObjectNameEXT](../chapters/debugging.html#vkDebugMarkerSetObjectNameEXT)

* 
[vkDebugMarkerSetObjectTagEXT](../chapters/debugging.html#vkDebugMarkerSetObjectTagEXT)

* 
[VkDebugMarkerMarkerInfoEXT](../chapters/debugging.html#VkDebugMarkerMarkerInfoEXT)

* 
[VkDebugMarkerObjectNameInfoEXT](../chapters/debugging.html#VkDebugMarkerObjectNameInfoEXT)

* 
[VkDebugMarkerObjectTagInfoEXT](../chapters/debugging.html#VkDebugMarkerObjectTagInfoEXT)

* 
[VkDebugReportObjectTypeEXT](../chapters/debugging.html#VkDebugReportObjectTypeEXT)

* 
`VK_EXT_DEBUG_MARKER_EXTENSION_NAME`

* 
`VK_EXT_DEBUG_MARKER_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT`

**Example 1**

Associate a name with an image, for easier debugging in external tools or
with validation layers that can print a friendly name when referring to
objects in error messages.

    extern VkDevice device;
    extern VkImage image;

    // Must call extension functions through a function pointer:
    PFN_vkDebugMarkerSetObjectNameEXT pfnDebugMarkerSetObjectNameEXT = (PFN_vkDebugMarkerSetObjectNameEXT)vkGetDeviceProcAddr(device, "vkDebugMarkerSetObjectNameEXT");

    // Set a name on the image
    const VkDebugMarkerObjectNameInfoEXT imageNameInfo =
    {
        .sType = VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT,
        .pNext = NULL,
        .objectType = VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT,
        .object = (uint64_t)image,
        .pObjectName = "Brick Diffuse Texture",
    };

    pfnDebugMarkerSetObjectNameEXT(device, &imageNameInfo);

    // A subsequent error might print:
    //   Image 'Brick Diffuse Texture' (0xc0dec0dedeadbeef) is used in a
    //   command buffer with no memory bound to it.

**Example 2**

Annotating regions of a workload with naming information so that offline
analysis tools can display a more usable visualization of the commands
submitted.

    extern VkDevice device;
    extern VkCommandBuffer commandBuffer;

    // Must call extension functions through a function pointer:
    PFN_vkCmdDebugMarkerBeginEXT pfnCmdDebugMarkerBeginEXT = (PFN_vkCmdDebugMarkerBeginEXT)vkGetDeviceProcAddr(device, "vkCmdDebugMarkerBeginEXT");
    PFN_vkCmdDebugMarkerEndEXT pfnCmdDebugMarkerEndEXT = (PFN_vkCmdDebugMarkerEndEXT)vkGetDeviceProcAddr(device, "vkCmdDebugMarkerEndEXT");
    PFN_vkCmdDebugMarkerInsertEXT pfnCmdDebugMarkerInsertEXT = (PFN_vkCmdDebugMarkerInsertEXT)vkGetDeviceProcAddr(device, "vkCmdDebugMarkerInsertEXT");

    // Describe the area being rendered
    const VkDebugMarkerMarkerInfoEXT houseMarker =
    {
        .sType = VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT,
        .pNext = NULL,
        .pMarkerName = "Brick House",
        .color = { 1.0f, 0.0f, 0.0f, 1.0f },
    };

    // Start an annotated group of calls under the 'Brick House' name
    pfnCmdDebugMarkerBeginEXT(commandBuffer, &houseMarker);
    {
        // A mutable structure for each part being rendered
        VkDebugMarkerMarkerInfoEXT housePartMarker =
        {
            .sType = VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT,
            .pNext = NULL,
            .pMarkerName = NULL,
            .color = { 0.0f, 0.0f, 0.0f, 0.0f },
        };

        // Set the name and insert the marker
        housePartMarker.pMarkerName = "Walls";
        pfnCmdDebugMarkerInsertEXT(commandBuffer, &housePartMarker);

        // Insert the drawcall for the walls
        vkCmdDrawIndexed(commandBuffer, 1000, 1, 0, 0, 0);

        // Insert a recursive region for two sets of windows
        housePartMarker.pMarkerName = "Windows";
        pfnCmdDebugMarkerBeginEXT(commandBuffer, &housePartMarker);
        {
            vkCmdDrawIndexed(commandBuffer, 75, 6, 1000, 0, 0);
            vkCmdDrawIndexed(commandBuffer, 100, 2, 1450, 0, 0);
        }
        pfnCmdDebugMarkerEndEXT(commandBuffer);

        housePartMarker.pMarkerName = "Front Door";
        pfnCmdDebugMarkerInsertEXT(commandBuffer, &housePartMarker);

        vkCmdDrawIndexed(commandBuffer, 350, 1, 1650, 0, 0);

        housePartMarker.pMarkerName = "Roof";
        pfnCmdDebugMarkerInsertEXT(commandBuffer, &housePartMarker);

        vkCmdDrawIndexed(commandBuffer, 500, 1, 2000, 0, 0);
    }
    // End the house annotation started above
    pfnCmdDebugMarkerEndEXT(commandBuffer);

1) Should the tag or name for an object be specified using the `pNext`
parameter in the objects `Vk*CreateInfo` structure?

**RESOLVED**: No.
While this fits with other Vulkan patterns and would allow more type safety
and future proofing against future objects, it has notable downsides.
In particular passing the name at `Vk*CreateInfo` time does not allow
renaming, prevents late binding of naming information, and does not allow
naming of implicitly created objects such as queues and swapchain images.

2) Should the command annotation functions [vkCmdDebugMarkerBeginEXT](../chapters/debugging.html#vkCmdDebugMarkerBeginEXT)
and [vkCmdDebugMarkerEndEXT](../chapters/debugging.html#vkCmdDebugMarkerEndEXT) support the ability to specify a color?

**RESOLVED**: Yes.
The functions have been expanded to take an optional color which can be used
at will by implementations consuming the command buffer annotations in their
visualization.

3) Should the functions added in this extension accept an extensible
structure as their parameter for a more flexible API, as opposed to direct
function parameters? If so, which functions?

**RESOLVED**: Yes.
All functions have been modified to take a structure type with extensible
`pNext` pointer, to allow future extensions to add additional annotation
information in the same commands.

* 
Revision 1, 2016-02-24 (Baldur Karlsson)

Initial draft, based on LunarG marker spec

Revision 2, 2016-02-26 (Baldur Karlsson)

* 
Renamed Dbg to DebugMarker in function names

* 
Allow markers in secondary command buffers under certain circumstances

* 
Minor language tweaks and edits

Revision 3, 2016-04-23 (Baldur Karlsson)

* 
Reorganize spec layout to closer match desired organization

* 
Added optional color to markers (both regions and inserted labels)

* 
Changed functions to take extensible structs instead of direct function
parameters

Revision 4, 2017-01-31 (Baldur Karlsson)

* 
Added explicit dependency on VK_EXT_debug_report

* 
Moved definition of [VkDebugReportObjectTypeEXT](../chapters/debugging.html#VkDebugReportObjectTypeEXT) to debug report
chapter.

* 
Fixed typo in dates in revision history

**Name String**

`VK_EXT_debug_report`

**Extension Type**

Instance extension

**Registered Extension Number**

12

**Revision**

10

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

None

**API Interactions**

* 
Interacts with VK_VERSION_1_1

**Deprecation State**

* 
*Deprecated* by
[VK_EXT_debug_utils](#VK_EXT_debug_utils)
extension

**Special Use**

* 
[Debugging tools](../chapters/extensions.html#extendingvulkan-compatibility-specialuse)

**Contact**

* 
Courtney Goeltzenleuchter [courtney-g](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_debug_report] @courtney-g%0A*Here describe the issue or question you have about the VK_EXT_debug_report extension*)

**Last Modified Date**

2020-12-14

**IP Status**

No known IP claims.

**Contributors**

* 
Courtney Goeltzenleuchter, LunarG

* 
Dan Ginsburg, Valve

* 
Jon Ashburn, LunarG

* 
Mark Lobodzinski, LunarG

Due to the nature of the Vulkan interface, there is very little error
information available to the developer and application.
By enabling optional validation layers and using the `VK_EXT_debug_report`
extension, developers **can** obtain much more detailed feedback on the
applications use of Vulkan.
This extension defines a way for layers and the implementation to call back
to the application for events of interest to the application.

* 
[VkDebugReportCallbackEXT](../chapters/debugging.html#VkDebugReportCallbackEXT)

* 
[vkCreateDebugReportCallbackEXT](../chapters/debugging.html#vkCreateDebugReportCallbackEXT)

* 
[vkDebugReportMessageEXT](../chapters/debugging.html#vkDebugReportMessageEXT)

* 
[vkDestroyDebugReportCallbackEXT](../chapters/debugging.html#vkDestroyDebugReportCallbackEXT)

* 
Extending [VkInstanceCreateInfo](../chapters/initialization.html#VkInstanceCreateInfo):

[VkDebugReportCallbackCreateInfoEXT](../chapters/debugging.html#VkDebugReportCallbackCreateInfoEXT)

* 
[PFN_vkDebugReportCallbackEXT](../chapters/debugging.html#PFN_vkDebugReportCallbackEXT)

* 
[VkDebugReportFlagBitsEXT](../chapters/debugging.html#VkDebugReportFlagBitsEXT)

* 
[VkDebugReportObjectTypeEXT](../chapters/debugging.html#VkDebugReportObjectTypeEXT)

* 
[VkDebugReportFlagsEXT](../chapters/debugging.html#VkDebugReportFlagsEXT)

* 
`VK_EXT_DEBUG_REPORT_EXTENSION_NAME`

* 
`VK_EXT_DEBUG_REPORT_SPEC_VERSION`

* 
Extending [VkObjectType](../chapters/debugging.html#VkObjectType):

`VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT`

Extending [VkResult](../chapters/fundamentals.html#VkResult):

* 
`VK_ERROR_VALIDATION_FAILED_EXT`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT`

If [Vulkan Version 1.1](versions.html#versions-1.1) is supported:

* 
Extending [VkDebugReportObjectTypeEXT](../chapters/debugging.html#VkDebugReportObjectTypeEXT):

`VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT`

* 
`VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT`

`VK_EXT_debug_report` allows an application to register multiple callbacks
with the validation layers.
Some callbacks may log the information to a file, others may cause a debug
break point or other application-defined behavior.
An application **can** register callbacks even when no validation layers are
enabled, but they will only be called for loader and, if implemented, driver
events.

To capture events that occur while creating or destroying an instance an
application **can** link a [VkDebugReportCallbackCreateInfoEXT](../chapters/debugging.html#VkDebugReportCallbackCreateInfoEXT) structure
to the `pNext` chain of the [VkInstanceCreateInfo](../chapters/initialization.html#VkInstanceCreateInfo) structure passed
to [vkCreateInstance](../chapters/initialization.html#vkCreateInstance).

Example uses: Create three callback objects.
One will log errors and warnings to the debug console using Windows
`OutputDebugString`.
The second will cause the debugger to break at that callback when an error
happens and the third will log warnings to stdout.

    VkResult res;
    VkDebugReportCallbackEXT cb1, cb2, cb3;

    VkDebugReportCallbackCreateInfoEXT callback1 = {
        .sType = VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT,
        .pNext = NULL,
        .flags = VK_DEBUG_REPORT_ERROR_BIT_EXT |
                 VK_DEBUG_REPORT_WARNING_BIT_EXT,
        .pfnCallback = myOutputDebugString,
        .pUserData = NULL
    };
    res = vkCreateDebugReportCallbackEXT(instance, &callback1, &cb1);
    if (res != VK_SUCCESS)
       /* Do error handling for VK_ERROR_OUT_OF_MEMORY */

    callback.flags = VK_DEBUG_REPORT_ERROR_BIT_EXT;
    callback.pfnCallback = myDebugBreak;
    callback.pUserData = NULL;
    res = vkCreateDebugReportCallbackEXT(instance, &callback, &cb2);
    if (res != VK_SUCCESS)
       /* Do error handling for VK_ERROR_OUT_OF_MEMORY */

    VkDebugReportCallbackCreateInfoEXT callback3 = {
        .sType = VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT,
        .pNext = NULL,
        .flags = VK_DEBUG_REPORT_WARNING_BIT_EXT,
        .pfnCallback = mystdOutLogger,
        .pUserData = NULL
    };
    res = vkCreateDebugReportCallbackEXT(instance, &callback3, &cb3);
    if (res != VK_SUCCESS)
       /* Do error handling for VK_ERROR_OUT_OF_MEMORY */

    ...

    /* remove callbacks when cleaning up */
    vkDestroyDebugReportCallbackEXT(instance, cb1);
    vkDestroyDebugReportCallbackEXT(instance, cb2);
    vkDestroyDebugReportCallbackEXT(instance, cb3);

|  | In the initial release of the `VK_EXT_debug_report` extension, the token
| --- | --- |
`VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT` was used.
Starting in version 2 of the extension branch,
`VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT` is used
instead for consistency with Vulkan naming rules.
The older enum is still available for backwards compatibility. |

|  | In the initial release of the `VK_EXT_debug_report` extension, the token
| --- | --- |
`VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT` was used.
Starting in version 8 of the extension branch,
`VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT` is used
instead for consistency with Vulkan naming rules.
The older enum is still available for backwards compatibility. |

1) What is the hierarchy / seriousness of the message flags? E.g.
`ERROR` > `WARN` > `PERF_WARN` 

**RESOLVED**: There is no specific hierarchy.
Each bit is independent and should be checked via bitwise AND.
For example:

    if (localFlags & VK_DEBUG_REPORT_ERROR_BIT_EXT) {
        process error message
    }
    if (localFlags & VK_DEBUG_REPORT_DEBUG_BIT_EXT) {
        process debug message
    }

The validation layers do use them in a hierarchical way (`ERROR` >
`WARN` > `PERF`, `WARN` > `DEBUG` > `INFO`) and they (at
least at the time of this writing) only set one bit at a time.
But it is not a requirement of this extension.

It is possible that a layer may intercept and change, or augment the flags
with extension values the applications debug report handler may not be
familiar with, so it is important to treat each flag independently.

2) Should there be a VU requiring
[VkDebugReportCallbackCreateInfoEXT](../chapters/debugging.html#VkDebugReportCallbackCreateInfoEXT)::`flags` to be non-zero?

**RESOLVED**: It may not be very useful, but we do not need VU statement
requiring the `VkDebugReportCallbackCreateInfoEXT`::`msgFlags` at
create-time to be non-zero.
One can imagine that apps may prefer it as it allows them to set the mask as
desired - including nothing - at runtime without having to check.

3) What is the difference between `VK_DEBUG_REPORT_DEBUG_BIT_EXT` and
`VK_DEBUG_REPORT_INFORMATION_BIT_EXT`?

**RESOLVED**: `VK_DEBUG_REPORT_DEBUG_BIT_EXT` specifies information that
could be useful debugging the Vulkan implementation itself.

4) How do you compare handles returned by the debug_report callback to the
applications handles?

**RESOLVED**: Due to the different nature of dispatchable and nondispatchable
handles there is no generic way (that we know of) that works for common
compilers with 32bit, 64bit, C and C++.
We recommend applications use the same cast that the validation layers use:

+

reinterpret_cast(dispatchableHandle)
(uint64_t)(nondispatchableHandle)

+
This does require that the application treat dispatchable and
nondispatchable handles differently.

* 
Revision 1, 2015-05-20 (Courtney Goetzenleuchter)

Initial draft, based on LunarG KHR spec, other KHR specs

Revision 2, 2016-02-16 (Courtney Goetzenleuchter)

* 
Update usage, documentation

Revision 3, 2016-06-14 (Courtney Goetzenleuchter)

* 
Update VK_EXT_DEBUG_REPORT_SPEC_VERSION to indicate added support for
vkCreateInstance and vkDestroyInstance

Revision 4, 2016-12-08 (Mark Lobodzinski)

* 
Added Display_KHR, DisplayModeKHR extension objects

* 
Added ObjectTable_NVX, IndirectCommandsLayout_NVX extension objects

* 
Bumped spec revision

* 
Retroactively added version history

Revision 5, 2017-01-31 (Baldur Karlsson)

* 
Moved definition of [VkDebugReportObjectTypeEXT](../chapters/debugging.html#VkDebugReportObjectTypeEXT) from debug marker
chapter

Revision 6, 2017-01-31 (Baldur Karlsson)

* 
Added VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT

Revision 7, 2017-04-20 (Courtney Goeltzenleuchter)

* 
Clarify wording and address questions from developers.

Revision 8, 2017-04-21 (Courtney Goeltzenleuchter)

* 
Remove unused enum VkDebugReportErrorEXT

Revision 9, 2017-09-12 (Tobias Hector)

* 
Added interactions with Vulkan 1.1

Revision 10, 2020-12-14 (Courtney Goetzenleuchter)

* 
Add issue 4 discussing matching handles returned by the extension,
based on suggestion in public issue 368.

**Name String**

`VK_EXT_depth_clamp_zero_one`

**Extension Type**

Device extension

**Registered Extension Number**

422

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Deprecation State**

* 
*Promoted* to
[VK_KHR_depth_clamp_zero_one](#VK_KHR_depth_clamp_zero_one)
extension

**Contact**

* 
Graeme Leese [gnl21](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_depth_clamp_zero_one] @gnl21%0A*Here describe the issue or question you have about the VK_EXT_depth_clamp_zero_one extension*)

**Last Modified Date**

2021-07-29

**Contributors**

* 
Graeme Leese, Broadcom

This extension gives defined behavior to fragment depth values which end up
outside the conventional [0, 1] range.
It can be used to ensure portability in edge cases of features like
depthBias.
The particular behavior is chosen to match OpenGL to aid porting or
emulation.

All functionality in this extension is included in
`[VK_KHR_depth_clamp_zero_one](#VK_KHR_depth_clamp_zero_one)`, with the suffix change to KHR.
The original type, enum, and command names are still available as aliases of
the core functionality.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceDepthClampZeroOneFeaturesEXT](../chapters/features.html#VkPhysicalDeviceDepthClampZeroOneFeaturesEXT)

* 
`VK_EXT_DEPTH_CLAMP_ZERO_ONE_EXTENSION_NAME`

* 
`VK_EXT_DEPTH_CLAMP_ZERO_ONE_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_EXT`

* 
Revision 1, 2021-07-29 (Graeme Leese)

Internal revisions

**Name String**

`VK_EXT_descriptor_indexing`

**Extension Type**

Device extension

**Registered Extension Number**

162

**Revision**

2

**Ratification Status**

Ratified

**Extension and Version Dependencies**

 [VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

 and

 [VK_KHR_maintenance3](#VK_KHR_maintenance3)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**SPIR-V Dependencies**

* 
[SPV_EXT_descriptor_indexing](https://github.khronos.org/SPIRV-Registry/extensions/EXT/SPV_EXT_descriptor_indexing.html)

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.2](versions.html#versions-1.2-promotions)

**Contact**

* 
Jeff Bolz [jeffbolznv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_descriptor_indexing] @jeffbolznv%0A*Here describe the issue or question you have about the VK_EXT_descriptor_indexing extension*)

**Last Modified Date**

2017-10-02

**Interactions and External Dependencies**

* 
This extension provides API support for
[`GL_EXT_nonuniform_qualifier`](https://github.com/KhronosGroup/GLSL/blob/main/extensions/ext/GL_EXT_nonuniform_qualifier.txt)

**Contributors**

* 
Jeff Bolz, NVIDIA

* 
Daniel Rakos, AMD

* 
Slawomir Grajewski, Intel

* 
Tobias Hector, Imagination Technologies

This extension adds several small features which together enable
applications to create large descriptor sets containing substantially all of
their resources, and selecting amongst those resources with dynamic
(non-uniform) indexes in the shader.
There are feature enables and SPIR-V capabilities for non-uniform descriptor
indexing in the shader, and non-uniform indexing in the shader requires use
of a new `NonUniformEXT` decoration defined in the
`SPV_EXT_descriptor_indexing` SPIR-V extension.
There are descriptor set layout binding creation flags enabling several
features:

* 
Descriptors can be updated after they are bound to a command buffer,
such that the execution of the command buffer reflects the most recent
update to the descriptors.

* 
Descriptors that are not used by any pending command buffers can be
updated, which enables writing new descriptors for frame N+1 while frame
N is executing.

* 
Relax the requirement that all descriptors in a binding that is
statically used must be valid, such that descriptors that are not
accessed by a submission need not be valid and can be updated while that
submission is executing.

* 
The final binding in a descriptor set layout can have a variable size
(and unsized arrays of resources are allowed in the
`GL_EXT_nonuniform_qualifier` and `SPV_EXT_descriptor_indexing`
extensions).

Note that it is valid for multiple descriptor arrays in a shader to use the
same set and binding number, as long as they are all compatible with the
descriptor type in the pipeline layout.
This means a single array binding in the descriptor set can serve multiple
texture dimensionalities, or an array of buffer descriptors can be used with
multiple different block layouts.

There are new descriptor set layout and descriptor pool creation flags that
are required to opt in to the update-after-bind functionality, and there are
separate `maxPerStage`* and `maxDescriptorSet`* limits that apply to
these descriptor set layouts which **may** be much higher than the pre-existing
limits.
The old limits only count descriptors in non-updateAfterBind descriptor set
layouts, and the new limits count descriptors in all descriptor set layouts
in the pipeline layout.

Vulkan APIs in this extension are included in core Vulkan 1.2, with the EXT
suffix omitted.
However, if Vulkan 1.2 is supported and this extension is not, the
`descriptorIndexing` capability is optional.
External interactions defined by this extension, such as SPIR-V token names,
retain their original names.
The original Vulkan API names are still available as aliases of the core
functionality.

If Vulkan 1.4 is supported, support for the
`shaderUniformTexelBufferArrayDynamicIndexing` and
`shaderStorageTexelBufferArrayDynamicIndexing` capabilities is required.

* 
Extending [VkDescriptorSetAllocateInfo](../chapters/descriptorsets.html#VkDescriptorSetAllocateInfo):

[VkDescriptorSetVariableDescriptorCountAllocateInfoEXT](../chapters/descriptorsets.html#VkDescriptorSetVariableDescriptorCountAllocateInfoEXT)

Extending [VkDescriptorSetLayoutCreateInfo](../chapters/descriptorsets.html#VkDescriptorSetLayoutCreateInfo):

* 
[VkDescriptorSetLayoutBindingFlagsCreateInfoEXT](../chapters/descriptorsets.html#VkDescriptorSetLayoutBindingFlagsCreateInfoEXT)

Extending [VkDescriptorSetLayoutSupport](../chapters/descriptorsets.html#VkDescriptorSetLayoutSupport):

* 
[VkDescriptorSetVariableDescriptorCountLayoutSupportEXT](../chapters/descriptorsets.html#VkDescriptorSetVariableDescriptorCountLayoutSupportEXT)

Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

* 
[VkPhysicalDeviceDescriptorIndexingFeaturesEXT](../chapters/features.html#VkPhysicalDeviceDescriptorIndexingFeaturesEXT)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceDescriptorIndexingPropertiesEXT](../chapters/limits.html#VkPhysicalDeviceDescriptorIndexingPropertiesEXT)

* 
[VkDescriptorBindingFlagBitsEXT](../chapters/descriptorsets.html#VkDescriptorBindingFlagBitsEXT)

* 
[VkDescriptorBindingFlagsEXT](../chapters/descriptorsets.html#VkDescriptorBindingFlagsEXT)

* 
`VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME`

* 
`VK_EXT_DESCRIPTOR_INDEXING_SPEC_VERSION`

* 
Extending [VkDescriptorBindingFlagBits](../chapters/descriptorsets.html#VkDescriptorBindingFlagBits):

`VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT`

* 
`VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT`

* 
`VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT`

* 
`VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT`

Extending [VkDescriptorPoolCreateFlagBits](../chapters/descriptorsets.html#VkDescriptorPoolCreateFlagBits):

* 
`VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT`

Extending [VkDescriptorSetLayoutCreateFlagBits](../chapters/descriptorsets.html#VkDescriptorSetLayoutCreateFlagBits):

* 
`VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT`

Extending [VkResult](../chapters/fundamentals.html#VkResult):

* 
`VK_ERROR_FRAGMENTATION_EXT`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT`

* 
Revision 1, 2017-07-26 (Jeff Bolz)

Internal revisions

Revision 2, 2017-10-02 (Jeff Bolz)

* 
???

**Name String**

`VK_EXT_extended_dynamic_state`

**Extension Type**

Device extension

**Registered Extension Number**

268

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.3](versions.html#versions-1.3-promotions)

**Contact**

* 
Piers Daniell [pdaniell-nv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_extended_dynamic_state] @pdaniell-nv%0A*Here describe the issue or question you have about the VK_EXT_extended_dynamic_state extension*)

**Last Modified Date**

2019-12-09

**IP Status**

No known IP claims.

**Contributors**

* 
Dan Ginsburg, Valve Corporation

* 
Graeme Leese, Broadcom

* 
Hans-Kristian Arntzen, Valve Corporation

* 
Jan-Harald Fredriksen, Arm Limited

* 
Faith Ekstrand, Intel

* 
Jeff Bolz, NVIDIA

* 
Jesse Hall, Google

* 
Philip Rebohle, Valve Corporation

* 
Stuart Smith, Imagination Technologies

* 
Tobias Hector, AMD

This extension adds some more dynamic state to support applications that
need to reduce the number of pipeline state objects they compile and bind.

* 
[vkCmdBindVertexBuffers2EXT](../chapters/fxvertex.html#vkCmdBindVertexBuffers2EXT)

* 
[vkCmdSetCullModeEXT](../chapters/primsrast.html#vkCmdSetCullModeEXT)

* 
[vkCmdSetDepthBoundsTestEnableEXT](../chapters/fragops.html#vkCmdSetDepthBoundsTestEnableEXT)

* 
[vkCmdSetDepthCompareOpEXT](../chapters/fragops.html#vkCmdSetDepthCompareOpEXT)

* 
[vkCmdSetDepthTestEnableEXT](../chapters/fragops.html#vkCmdSetDepthTestEnableEXT)

* 
[vkCmdSetDepthWriteEnableEXT](../chapters/fragops.html#vkCmdSetDepthWriteEnableEXT)

* 
[vkCmdSetFrontFaceEXT](../chapters/primsrast.html#vkCmdSetFrontFaceEXT)

* 
[vkCmdSetPrimitiveTopologyEXT](../chapters/drawing.html#vkCmdSetPrimitiveTopologyEXT)

* 
[vkCmdSetScissorWithCountEXT](../chapters/vertexpostproc.html#vkCmdSetScissorWithCountEXT)

* 
[vkCmdSetStencilOpEXT](../chapters/fragops.html#vkCmdSetStencilOpEXT)

* 
[vkCmdSetStencilTestEnableEXT](../chapters/fragops.html#vkCmdSetStencilTestEnableEXT)

* 
[vkCmdSetViewportWithCountEXT](../chapters/vertexpostproc.html#vkCmdSetViewportWithCountEXT)

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceExtendedDynamicStateFeaturesEXT](../chapters/features.html#VkPhysicalDeviceExtendedDynamicStateFeaturesEXT)

* 
`VK_EXT_EXTENDED_DYNAMIC_STATE_EXTENSION_NAME`

* 
`VK_EXT_EXTENDED_DYNAMIC_STATE_SPEC_VERSION`

* 
Extending [VkDynamicState](../chapters/pipelines.html#VkDynamicState):

`VK_DYNAMIC_STATE_CULL_MODE_EXT`

* 
`VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE_EXT`

* 
`VK_DYNAMIC_STATE_DEPTH_COMPARE_OP_EXT`

* 
`VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE_EXT`

* 
`VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE_EXT`

* 
`VK_DYNAMIC_STATE_FRONT_FACE_EXT`

* 
`VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT`

* 
`VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT_EXT`

* 
`VK_DYNAMIC_STATE_STENCIL_OP_EXT`

* 
`VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE_EXT`

* 
`VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT`

* 
`VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT_EXT`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT`

All dynamic state enumerants and commands in this extension are included in
core Vulkan 1.3, with the EXT suffix omitted.
The feature structure is not promoted.
Extension interfaces that were promoted remain available as aliases of the
core functionality.

1) Why are the values of `pStrides` in [vkCmdBindVertexBuffers2](../chapters/fxvertex.html#vkCmdBindVertexBuffers2)
limited to be between 0 and the maximum extent of the binding, when this
restriction is not present for the same static state?

Implementing these edge cases adds overhead to some implementations that
would require significant cost when calling this function, and the intention
is that this state should be more or less free to change.

[VK_EXT_vertex_input_dynamic_state](#VK_EXT_vertex_input_dynamic_state) allows the stride to be changed
freely when supported via [vkCmdSetVertexInputEXT](../chapters/fxvertex.html#vkCmdSetVertexInputEXT).

* 
Revision 1, 2019-12-09 (Piers Daniell)

Internal revisions

**Name String**

`VK_EXT_extended_dynamic_state2`

**Extension Type**

Device extension

**Registered Extension Number**

378

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.3](versions.html#versions-1.3-promotions)

**Contact**

* 
Vikram Kushwaha [vkushwaha-nv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_extended_dynamic_state2] @vkushwaha-nv%0A*Here describe the issue or question you have about the VK_EXT_extended_dynamic_state2 extension*)

**Last Modified Date**

2021-04-12

**IP Status**

No known IP claims.

**Contributors**

* 
Vikram Kushwaha, NVIDIA

* 
Piers Daniell, NVIDIA

* 
Jeff Bolz, NVIDIA

This extension adds some more dynamic state to support applications that
need to reduce the number of pipeline state objects they compile and bind.

* 
[vkCmdSetDepthBiasEnableEXT](../chapters/primsrast.html#vkCmdSetDepthBiasEnableEXT)

* 
[vkCmdSetLogicOpEXT](../chapters/framebuffer.html#vkCmdSetLogicOpEXT)

* 
[vkCmdSetPatchControlPointsEXT](../chapters/shaders.html#vkCmdSetPatchControlPointsEXT)

* 
[vkCmdSetPrimitiveRestartEnableEXT](../chapters/drawing.html#vkCmdSetPrimitiveRestartEnableEXT)

* 
[vkCmdSetRasterizerDiscardEnableEXT](../chapters/primsrast.html#vkCmdSetRasterizerDiscardEnableEXT)

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceExtendedDynamicState2FeaturesEXT](../chapters/features.html#VkPhysicalDeviceExtendedDynamicState2FeaturesEXT)

* 
`VK_EXT_EXTENDED_DYNAMIC_STATE_2_EXTENSION_NAME`

* 
`VK_EXT_EXTENDED_DYNAMIC_STATE_2_SPEC_VERSION`

* 
Extending [VkDynamicState](../chapters/pipelines.html#VkDynamicState):

`VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE_EXT`

* 
`VK_DYNAMIC_STATE_LOGIC_OP_EXT`

* 
`VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT`

* 
`VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE_EXT`

* 
`VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE_EXT`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT`

The dynamic state enumerants `VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE_EXT`,
`VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE_EXT`, and
`VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE_EXT`; and the corresponding
commands in this extension are included in core Vulkan 1.3, with the EXT
suffix omitted.
The enumerants and commands for dynamic logic operation and patch control
points are not promoted, nor is the feature structure.
Extension interfaces that were promoted remain available as aliases of the
core functionality.

* 
Revision 1, 2021-04-12 (Vikram Kushwaha)

Internal revisions

**Name String**

`VK_EXT_global_priority`

**Extension Type**

Device extension

**Registered Extension Number**

175

**Revision**

2

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

None

**Deprecation State**

* 
*Promoted* to
[VK_KHR_global_priority](#VK_KHR_global_priority)
extension

Which in turn was *promoted* to
[Vulkan 1.4](versions.html#versions-1.4-promotions)

**Contact**

* 
Andres Rodriguez [lostgoat](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_global_priority] @lostgoat%0A*Here describe the issue or question you have about the VK_EXT_global_priority extension*)

**Last Modified Date**

2017-10-06

**IP Status**

No known IP claims.

**Contributors**

* 
Andres Rodriguez, Valve

* 
Pierre-Loup Griffais, Valve

* 
Dan Ginsburg, Valve

* 
Mitch Singer, AMD

In Vulkan, users can specify device-scope queue priorities.
In some cases it may be useful to extend this concept to a system-wide
scope.
This extension provides a mechanism for callers to set their system-wide
priority.
The default queue priority is `VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT`.

The driver implementation will attempt to skew hardware resource allocation
in favor of the higher-priority task.
Therefore, higher-priority work may retain similar latency and throughput
characteristics even if the system is congested with lower priority work.

The global priority level of a queue shall take precedence over the
per-process queue priority
(`VkDeviceQueueCreateInfo`::`pQueuePriorities`).

Abuse of this feature may result in starving the rest of the system from
hardware resources.
Therefore, the driver implementation may deny requests to acquire a priority
above the default priority (`VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT`) if
the caller does not have sufficient privileges.
In this scenario `VK_ERROR_NOT_PERMITTED_EXT` is returned.

The driver implementation may fail the queue allocation request if resources
required to complete the operation have been exhausted (either by the same
process or a different process).
In this scenario `VK_ERROR_INITIALIZATION_FAILED` is returned.

* 
Extending [VkDeviceQueueCreateInfo](../chapters/devsandqueues.html#VkDeviceQueueCreateInfo):

[VkDeviceQueueGlobalPriorityCreateInfoEXT](../chapters/devsandqueues.html#VkDeviceQueueGlobalPriorityCreateInfoEXT)

* 
[VkQueueGlobalPriorityEXT](../chapters/devsandqueues.html#VkQueueGlobalPriorityEXT)

* 
`VK_EXT_GLOBAL_PRIORITY_EXTENSION_NAME`

* 
`VK_EXT_GLOBAL_PRIORITY_SPEC_VERSION`

* 
Extending [VkQueueGlobalPriority](../chapters/devsandqueues.html#VkQueueGlobalPriority):

`VK_QUEUE_GLOBAL_PRIORITY_HIGH_EXT`

* 
`VK_QUEUE_GLOBAL_PRIORITY_LOW_EXT`

* 
`VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT`

* 
`VK_QUEUE_GLOBAL_PRIORITY_REALTIME_EXT`

Extending [VkResult](../chapters/fundamentals.html#VkResult):

* 
`VK_ERROR_NOT_PERMITTED_EXT`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT`

* 
Revision 2, 2017-11-03 (Andres Rodriguez)

Fixed VkQueueGlobalPriorityEXT missing _EXT suffix

Revision 1, 2017-10-06 (Andres Rodriguez)

* 
First version.

**Name String**

`VK_EXT_global_priority_query`

**Extension Type**

Device extension

**Registered Extension Number**

389

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_EXT_global_priority](#VK_EXT_global_priority)

and

 [VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

 or

 [Vulkan Version 1.1](versions.html#versions-1.1)

**Deprecation State**

* 
*Promoted* to
[VK_KHR_global_priority](#VK_KHR_global_priority)
extension

Which in turn was *promoted* to
[Vulkan 1.4](versions.html#versions-1.4-promotions)

**Contact**

* 
Yiwei Zhang [zhangyiwei](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_global_priority_query] @zhangyiwei%0A*Here describe the issue or question you have about the VK_EXT_global_priority_query extension*)

**Last Modified Date**

2021-03-29

**IP Status**

No known IP claims.

**Contributors**

* 
Yiwei Zhang, Google

This device extension allows applications to query the global queue
priorities supported by a queue family.
It allows implementations to report which global priority levels are treated
differently by the implementation, instead of silently mapping multiple
requested global priority levels to the same internal priority, or using
device creation failure to signal that a requested priority is not
supported.
It is intended primarily for use by system integration along with certain
platform-specific priority enforcement rules.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT](../chapters/features.html#VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT)

Extending [VkQueueFamilyProperties2](../chapters/devsandqueues.html#VkQueueFamilyProperties2):

* 
[VkQueueFamilyGlobalPriorityPropertiesEXT](../chapters/devsandqueues.html#VkQueueFamilyGlobalPriorityPropertiesEXT)

* 
`VK_EXT_GLOBAL_PRIORITY_QUERY_EXTENSION_NAME`

* 
`VK_EXT_GLOBAL_PRIORITY_QUERY_SPEC_VERSION`

* 
`VK_MAX_GLOBAL_PRIORITY_SIZE_EXT`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_EXT`

* 
`VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_EXT`

1) Can we additionally query whether a caller is permitted to acquire a
specific global queue priority in this extension?

**RESOLVED**: No.
Whether a caller has enough privilege goes with the OS, and the Vulkan
driver cannot really guarantee that the privilege will not change in between
this query and the actual queue creation call.

2) If more than 1 queue using global priority is requested, is there a good
way to know which queue is failing the device creation?

**RESOLVED**: No.
There is not a good way at this moment, and it is also not quite actionable
for the applications to know that because the information may not be
accurate.
Queue creation can fail because of runtime constraints like insufficient
privilege or lack of resource, and the failure is not necessarily tied to
that particular queue configuration requested.

* 
Revision 1, 2021-03-29 (Yiwei Zhang)

**Name String**

`VK_EXT_host_image_copy`

**Extension Type**

Device extension

**Registered Extension Number**

271

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

 [VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

 or

 [Vulkan Version 1.1](versions.html#versions-1.1)

 and

 [VK_KHR_copy_commands2](#VK_KHR_copy_commands2)

 and

 [VK_KHR_format_feature_flags2](#VK_KHR_format_feature_flags2)

or

[Vulkan Version 1.3](versions.html#versions-1.3)

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.4](versions.html#versions-1.4-promotions)

**Contact**

* 
Shahbaz Youssefi [syoussefi](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_host_image_copy] @syoussefi%0A*Here describe the issue or question you have about the VK_EXT_host_image_copy extension*)

**Extension Proposal**

[VK_EXT_host_image_copy](../../../features/latest/features/proposals/VK_EXT_host_image_copy.html)

**Last Modified Date**

2023-04-26

**Contributors**

* 
Shahbaz Youssefi, Google

* 
Faith Ekstrand, Collabora

* 
Hans-Kristian Arntzen, Valve

* 
Piers Daniell, NVIDIA

* 
Jan-Harald Fredriksen, Arm

* 
James Fitzpatrick, Imagination

* 
Daniel Story, Nintendo

This extension allows applications to copy data between host memory and
images on the host processor, without staging the data through a
GPU-accessible buffer.
This removes the need to allocate and manage the buffer and its associated
memory.
On some architectures it may also eliminate an extra copy operation.
This extension additionally allows applications to copy data between images
on the host.

To support initializing a new image in preparation for a host copy, it is
now possible to transition a new image to `VK_IMAGE_LAYOUT_GENERAL` or
other host-copyable layouts via [vkTransitionImageLayoutEXT](../chapters/synchronization.html#vkTransitionImageLayoutEXT).
Additionally, it is possible to perform copies that preserve the swizzling
layout of the image by using the `VK_HOST_IMAGE_COPY_MEMCPY_EXT` flag.
In that case, the memory size needed for copies to or from a buffer can be
retrieved by chaining [VkSubresourceHostMemcpySizeEXT](../chapters/resources.html#VkSubresourceHostMemcpySizeEXT) to `pLayout`
in [vkGetImageSubresourceLayout2EXT](../chapters/resources.html#vkGetImageSubresourceLayout2EXT).

* 
[vkCopyImageToImageEXT](../chapters/copies.html#vkCopyImageToImageEXT)

* 
[vkCopyImageToMemoryEXT](../chapters/copies.html#vkCopyImageToMemoryEXT)

* 
[vkCopyMemoryToImageEXT](../chapters/copies.html#vkCopyMemoryToImageEXT)

* 
[vkGetImageSubresourceLayout2EXT](../chapters/resources.html#vkGetImageSubresourceLayout2EXT)

* 
[vkTransitionImageLayoutEXT](../chapters/synchronization.html#vkTransitionImageLayoutEXT)

* 
[VkCopyImageToImageInfoEXT](../chapters/copies.html#VkCopyImageToImageInfoEXT)

* 
[VkCopyImageToMemoryInfoEXT](../chapters/copies.html#VkCopyImageToMemoryInfoEXT)

* 
[VkCopyMemoryToImageInfoEXT](../chapters/copies.html#VkCopyMemoryToImageInfoEXT)

* 
[VkHostImageLayoutTransitionInfoEXT](../chapters/synchronization.html#VkHostImageLayoutTransitionInfoEXT)

* 
[VkImageSubresource2EXT](../chapters/resources.html#VkImageSubresource2EXT)

* 
[VkImageToMemoryCopyEXT](../chapters/copies.html#VkImageToMemoryCopyEXT)

* 
[VkMemoryToImageCopyEXT](../chapters/copies.html#VkMemoryToImageCopyEXT)

* 
[VkSubresourceLayout2EXT](../chapters/resources.html#VkSubresourceLayout2EXT)

* 
Extending [VkImageFormatProperties2](../chapters/capabilities.html#VkImageFormatProperties2):

[VkHostImageCopyDevicePerformanceQueryEXT](../chapters/capabilities.html#VkHostImageCopyDevicePerformanceQueryEXT)

Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

* 
[VkPhysicalDeviceHostImageCopyFeaturesEXT](../chapters/features.html#VkPhysicalDeviceHostImageCopyFeaturesEXT)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceHostImageCopyPropertiesEXT](../chapters/limits.html#VkPhysicalDeviceHostImageCopyPropertiesEXT)

Extending [VkSubresourceLayout2](../chapters/resources.html#VkSubresourceLayout2):

* 
[VkSubresourceHostMemcpySizeEXT](../chapters/resources.html#VkSubresourceHostMemcpySizeEXT)

* 
[VkHostImageCopyFlagBitsEXT](../chapters/copies.html#VkHostImageCopyFlagBitsEXT)

* 
[VkHostImageCopyFlagsEXT](../chapters/copies.html#VkHostImageCopyFlagsEXT)

* 
`VK_EXT_HOST_IMAGE_COPY_EXTENSION_NAME`

* 
`VK_EXT_HOST_IMAGE_COPY_SPEC_VERSION`

* 
Extending [VkFormatFeatureFlagBits2](../chapters/formats.html#VkFormatFeatureFlagBits2):

`VK_FORMAT_FEATURE_2_HOST_IMAGE_TRANSFER_BIT_EXT`

Extending [VkHostImageCopyFlagBits](../chapters/copies.html#VkHostImageCopyFlagBits):

* 
`VK_HOST_IMAGE_COPY_MEMCPY_EXT`

Extending [VkImageUsageFlagBits](../chapters/resources.html#VkImageUsageFlagBits):

* 
`VK_IMAGE_USAGE_HOST_TRANSFER_BIT_EXT`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY_EXT`

* 
`VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY_EXT`

* 
`VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY_EXT`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES_EXT`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES_EXT`

* 
`VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE_EXT`

Functionality in this extension is included in core Vulkan 1.4, with the EXT
suffix omitted.
However, the feature is made optional in Vulkan 1.4.
The original type, enum and command names are still available as aliases of
the core functionality.

A Vulkan 1.4 implementation that has a `VK_QUEUE_GRAPHICS_BIT` queue
must support either:

* 
the [`hostImageCopy`](../chapters/features.html#features-hostImageCopy) feature; or

* 
an additional queue that supports `VK_QUEUE_TRANSFER_BIT`.

Additionally, all queues supporting `VK_QUEUE_GRAPHICS_BIT` or
`VK_QUEUE_COMPUTE_BIT` must also advertise `VK_QUEUE_TRANSFER_BIT`.

1) When uploading data to an image, the data is usually loaded from disk.
Why not have the application load the data directly into a `VkDeviceMemory`
bound to a buffer (instead of host memory), and use
[vkCmdCopyBufferToImage](../chapters/copies.html#vkCmdCopyBufferToImage)? The same could be done when downloading data
from an image.

**RESOLVED**: This may not always be possible.
Complicated Vulkan applications such as game engines often have decoupled
subsystems for streaming data and rendering.
It may be unreasonable to require the streaming subsystem to coordinate with
the rendering subsystem to allocate memory on its behalf, especially as
Vulkan may not be the only API supported by the engine.
In emulation layers, the image data is necessarily provided by the
application in host memory, so an optimization as suggested is not possible.
Most importantly, the device memory may not be mappable by an application,
but still accessible to the driver.

2) Are `optimalBufferCopyOffsetAlignment` and
`optimalBufferCopyRowPitchAlignment` applicable to host memory as well with
the functions introduced by this extension? Or should there be new limits?

**RESOLVED**: No alignment requirements for the host memory pointer.

3) Should there be granularity requirements for image offsets and extents?

**RESOLVED**: No granularity requirements, i.e. a granularity of 1 pixel (for
non-compressed formats) and 1 texel block (for compressed formats) is
assumed.

4) How should the application deal with layout transitions before or after
copying to or from images?

**RESOLVED**: An existing issue with linear images is that when emulating
other APIs, it is impossible to know when to transition them as they are
written to by the host and then used bindlessly.
The copy operations in this extension are affected by the same limitation.
A new command is thus introduced by this extension to address this problem
by allowing the host to perform an image layout transition between a handful
of layouts.

* 
Revision 0, 2021-01-20 (Faith Ekstrand)

Initial idea and xml

Revision 1, 2023-04-26 (Shahbaz Youssefi)

* 
Initial revision

**Name String**

`VK_EXT_host_query_reset`

**Extension Type**

Device extension

**Registered Extension Number**

262

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.2](versions.html#versions-1.2-promotions)

**Contact**

* 
Bas Nieuwenhuizen [BNieuwenhuizen](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_host_query_reset] @BNieuwenhuizen%0A*Here describe the issue or question you have about the VK_EXT_host_query_reset extension*)

**Last Modified Date**

2019-03-06

**IP Status**

No known IP claims.

**Contributors**

* 
Bas Nieuwenhuizen, Google

* 
Faith Ekstrand, Intel

* 
Jeff Bolz, NVIDIA

* 
Piers Daniell, NVIDIA

This extension adds a new function to reset queries from the host.

All functionality in this extension is included in core Vulkan 1.2, with the
EXT suffix omitted.
The original type, enum, and command names are still available as aliases of
the core functionality.

* 
[vkResetQueryPoolEXT](../chapters/queries.html#vkResetQueryPoolEXT)

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceHostQueryResetFeaturesEXT](../chapters/features.html#VkPhysicalDeviceHostQueryResetFeaturesEXT)

* 
`VK_EXT_HOST_QUERY_RESET_EXTENSION_NAME`

* 
`VK_EXT_HOST_QUERY_RESET_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT`

* 
Revision 1, 2019-03-12 (Bas Nieuwenhuizen)

Initial draft

**Name String**

`VK_EXT_image_robustness`

**Extension Type**

Device extension

**Registered Extension Number**

336

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.3](versions.html#versions-1.3-promotions)

**Contact**

* 
Graeme Leese [gnl21](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_image_robustness] @gnl21%0A*Here describe the issue or question you have about the VK_EXT_image_robustness extension*)

**Last Modified Date**

2020-04-27

**IP Status**

No known IP claims.

**Contributors**

* 
Graeme Leese, Broadcom

* 
Jan-Harald Fredriksen, ARM

* 
Jeff Bolz, NVIDIA

* 
Spencer Fricke, Samsung

* 
Courtney Goeltzenleuchter, Google

* 
Slawomir Cygan, Intel

This extension adds stricter requirements for how out of bounds reads from
images are handled.
Rather than returning undefined values, most out of bounds reads return R,
G, and B values of zero and alpha values of either zero or one.
Components not present in the image format may be set to zero or to values
based on the format as described in [Conversion to RGBA](../chapters/textures.html#textures-conversion-to-rgba).

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceImageRobustnessFeaturesEXT](../chapters/features.html#VkPhysicalDeviceImageRobustnessFeaturesEXT)

* 
`VK_EXT_IMAGE_ROBUSTNESS_EXTENSION_NAME`

* 
`VK_EXT_IMAGE_ROBUSTNESS_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES_EXT`

Vulkan APIs in this extension are included in core Vulkan 1.3, with the EXT
suffix omitted.
External interactions defined by this extension, such as SPIR-V token names,
retain their original names.
The original Vulkan API names are still available as aliases of the core
functionality.

How does this extension differ from VK_EXT_robustness2?

The guarantees provided by this extension are a subset of those provided by
the robustImageAccess2 feature of VK_EXT_robustness2.
Where this extension allows return values of (0, 0, 0, 0) or (0, 0, 0, 1),
robustImageAccess2 requires that a particular value dependent on the image
format be returned.
This extension provides no guarantees about the values returned for an
access to an invalid Lod.

None.

* 
Revision 1, 2020-04-27 (Graeme Leese)

* 
Initial draft

**Name String**

`VK_EXT_index_type_uint8`

**Extension Type**

Device extension

**Registered Extension Number**

266

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Deprecation State**

* 
*Promoted* to
[VK_KHR_index_type_uint8](#VK_KHR_index_type_uint8)
extension

Which in turn was *promoted* to
[Vulkan 1.4](versions.html#versions-1.4-promotions)

**Contact**

* 
Piers Daniell [pdaniell-nv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_index_type_uint8] @pdaniell-nv%0A*Here describe the issue or question you have about the VK_EXT_index_type_uint8 extension*)

**Last Modified Date**

2019-05-02

**IP Status**

No known IP claims.

**Contributors**

* 
Jeff Bolz, NVIDIA

This extension allows `uint8_t` indices to be used with
[vkCmdBindIndexBuffer](../chapters/drawing.html#vkCmdBindIndexBuffer).

All functionality in this extension is included in
`[VK_KHR_index_type_uint8](#VK_KHR_index_type_uint8)`, with the suffix changed to KHR.
The original enum names are still available as aliases of the KHR
functionality.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceIndexTypeUint8FeaturesEXT](../chapters/features.html#VkPhysicalDeviceIndexTypeUint8FeaturesEXT)

* 
`VK_EXT_INDEX_TYPE_UINT8_EXTENSION_NAME`

* 
`VK_EXT_INDEX_TYPE_UINT8_SPEC_VERSION`

* 
Extending [VkIndexType](../chapters/drawing.html#VkIndexType):

`VK_INDEX_TYPE_UINT8_EXT`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT`

* 
Revision 1, 2019-05-02 (Piers Daniell)

Internal revisions

**Name String**

`VK_EXT_inline_uniform_block`

**Extension Type**

Device extension

**Registered Extension Number**

139

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

 [VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

 and

 [VK_KHR_maintenance1](#VK_KHR_maintenance1)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**API Interactions**

* 
Interacts with VK_VERSION_1_2

* 
Interacts with VK_EXT_descriptor_indexing

* 
Interacts with VkPhysicalDeviceVulkan12Features::descriptorIndexing

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.3](versions.html#versions-1.3-promotions)

**Contact**

* 
Daniel Rakos [aqnuep](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_inline_uniform_block] @aqnuep%0A*Here describe the issue or question you have about the VK_EXT_inline_uniform_block extension*)

**Last Modified Date**

2018-08-01

**IP Status**

No known IP claims.

**Contributors**

* 
Daniel Rakos, AMD

* 
Jeff Bolz, NVIDIA

* 
Slawomir Grajewski, Intel

* 
Neil Henning, Codeplay

This extension introduces the ability to back uniform blocks directly with
descriptor sets by storing inline uniform data within descriptor pool
storage.
Compared to push constants this new construct allows uniform data to be
reused across multiple disjoint sets of drawing or dispatching commands and
**may** enable uniform data to be accessed with fewer indirections compared to
uniforms backed by buffer memory.

* 
Extending [VkDescriptorPoolCreateInfo](../chapters/descriptorsets.html#VkDescriptorPoolCreateInfo):

[VkDescriptorPoolInlineUniformBlockCreateInfoEXT](../chapters/descriptorsets.html#VkDescriptorPoolInlineUniformBlockCreateInfoEXT)

Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

* 
[VkPhysicalDeviceInlineUniformBlockFeaturesEXT](../chapters/features.html#VkPhysicalDeviceInlineUniformBlockFeaturesEXT)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceInlineUniformBlockPropertiesEXT](../chapters/limits.html#VkPhysicalDeviceInlineUniformBlockPropertiesEXT)

Extending [VkWriteDescriptorSet](../chapters/descriptorsets.html#VkWriteDescriptorSet):

* 
[VkWriteDescriptorSetInlineUniformBlockEXT](../chapters/descriptorsets.html#VkWriteDescriptorSetInlineUniformBlockEXT)

* 
`VK_EXT_INLINE_UNIFORM_BLOCK_EXTENSION_NAME`

* 
`VK_EXT_INLINE_UNIFORM_BLOCK_SPEC_VERSION`

* 
Extending [VkDescriptorType](../chapters/descriptorsets.html#VkDescriptorType):

`VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT`

* 
`VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT`

Vulkan APIs in this extension are included in core Vulkan 1.3, with the EXT
suffix omitted.
External interactions defined by this extension, such as SPIR-V token names,
retain their original names.
The original Vulkan API names are still available as aliases of the core
functionality.

Vulkan 1.3 adds [additional functionality related to this extension](versions.html#versions-1.3-new-features) in the form of the
[`maxInlineUniformTotalSize`](../chapters/devsandqueues.html#limits-maxInlineUniformTotalSize) limit.

1) Do we need a new storage class for inline uniform blocks vs. uniform
blocks?

**RESOLVED**: No.
The `Uniform` storage class is used to allow the same syntax used for
both uniform buffers and inline uniform blocks.

2) Is the descriptor array index and array size expressed in terms of bytes
or dwords for inline uniform block descriptors?

**RESOLVED**: In bytes, but both **must** be a multiple of 4, similar to how push
constant ranges are specified.
The `descriptorCount` of `VkDescriptorSetLayoutBinding` thus
provides the total number of bytes a particular binding with an inline
uniform block descriptor type can hold, while the `srcArrayElement`,
`dstArrayElement`, and `descriptorCount` members of
`VkWriteDescriptorSet`, `VkCopyDescriptorSet`, and
`VkDescriptorUpdateTemplateEntry` (where applicable) specify the byte
offset and number of bytes to write/copy to the bindings backing store.
Additionally, the `stride` member of
`VkDescriptorUpdateTemplateEntry` is ignored for inline uniform blocks
and a default value of one is used, meaning that the data to update inline
uniform block bindings with must be contiguous in memory.

3) What layout rules apply for uniform blocks corresponding to inline
constants?

**RESOLVED**: They use the same layout rules as uniform buffers.

4) Do we need to add non-uniform indexing features/properties as introduced
by `VK_EXT_descriptor_indexing` for inline uniform blocks?

**RESOLVED**: No, because inline uniform blocks are not allowed to be
arrayed.
A single binding with an inline uniform block descriptor type corresponds to
a single uniform block instance and the array indices inside that binding
refer to individual offsets within the uniform block (see issue #2).
However, this extension does introduce new features/properties about the
level of support for update-after-bind inline uniform blocks.

5) Is the [`descriptorBindingVariableDescriptorCount`](../chapters/features.html#features-descriptorBindingVariableDescriptorCount) feature introduced by
`VK_EXT_descriptor_indexing` supported for inline uniform blocks?

**RESOLVED**: Yes, as long as other inline uniform block specific limits are
respected.

6) Do the robustness guarantees of `robustBufferAccess` apply to inline
uniform block accesses?

**RESOLVED**: No, similarly to push constants, as they are not backed by
buffer memory like uniform buffers.

* 
Revision 1, 2018-08-01 (Daniel Rakos)

Internal revisions

**Name String**

`VK_EXT_line_rasterization`

**Extension Type**

Device extension

**Registered Extension Number**

260

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Deprecation State**

* 
*Promoted* to
[VK_KHR_line_rasterization](#VK_KHR_line_rasterization)
extension

Which in turn was *promoted* to
[Vulkan 1.4](versions.html#versions-1.4-promotions)

**Special Use**

* 
[CAD support](../chapters/extensions.html#extendingvulkan-compatibility-specialuse)

**Contact**

* 
Jeff Bolz [jeffbolznv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_line_rasterization] @jeffbolznv%0A*Here describe the issue or question you have about the VK_EXT_line_rasterization extension*)

**Last Modified Date**

2019-05-09

**IP Status**

No known IP claims.

**Contributors**

* 
Jeff Bolz, NVIDIA

* 
Allen Jensen, NVIDIA

* 
Faith Ekstrand, Intel

This extension adds some line rasterization features that are commonly used
in CAD applications and supported in other APIs like OpenGL.
Bresenham-style line rasterization is supported, smooth rectangular lines
(coverage to alpha) are supported, and stippled lines are supported for all
three line rasterization modes.

All functionality in this extension is included in
`[VK_KHR_line_rasterization](#VK_KHR_line_rasterization)`, with the suffix changed to KHR.
The original enum names are still available as aliases of the KHR
functionality.

* 
[vkCmdSetLineStippleEXT](../chapters/primsrast.html#vkCmdSetLineStippleEXT)

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceLineRasterizationFeaturesEXT](../chapters/features.html#VkPhysicalDeviceLineRasterizationFeaturesEXT)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceLineRasterizationPropertiesEXT](../chapters/limits.html#VkPhysicalDeviceLineRasterizationPropertiesEXT)

Extending [VkPipelineRasterizationStateCreateInfo](../chapters/primsrast.html#VkPipelineRasterizationStateCreateInfo):

* 
[VkPipelineRasterizationLineStateCreateInfoEXT](../chapters/primsrast.html#VkPipelineRasterizationLineStateCreateInfoEXT)

* 
[VkLineRasterizationModeEXT](../chapters/primsrast.html#VkLineRasterizationModeEXT)

* 
`VK_EXT_LINE_RASTERIZATION_EXTENSION_NAME`

* 
`VK_EXT_LINE_RASTERIZATION_SPEC_VERSION`

* 
Extending [VkDynamicState](../chapters/pipelines.html#VkDynamicState):

`VK_DYNAMIC_STATE_LINE_STIPPLE_EXT`

Extending [VkLineRasterizationMode](../chapters/primsrast.html#VkLineRasterizationMode):

* 
`VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT`

* 
`VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT`

* 
`VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT`

* 
`VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT`

* 
`VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT`

1) Do we need to support Bresenham-style and smooth lines with more than one
rasterization sample? i.e. the equivalent of glDisable(GL_MULTISAMPLE) in
OpenGL when the framebuffer has more than one sample?

**RESOLVED**: Yes.
For simplicity, Bresenham line rasterization carries forward a few
restrictions from OpenGL, such as not supporting per-sample shading, alpha
to coverage, or alpha to one.

* 
Revision 1, 2019-05-09 (Jeff Bolz)

Initial draft

**Name String**

`VK_EXT_load_store_op_none`

**Extension Type**

Device extension

**Registered Extension Number**

401

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

None

**Deprecation State**

* 
*Promoted* to
[VK_KHR_load_store_op_none](#VK_KHR_load_store_op_none)
extension

Which in turn was *promoted* to
[Vulkan 1.4](versions.html#versions-1.4-promotions)

**Contact**

* 
Shahbaz Youssefi [syoussefi](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_load_store_op_none] @syoussefi%0A*Here describe the issue or question you have about the VK_EXT_load_store_op_none extension*)

**Last Modified Date**

2021-06-06

**Contributors**

* 
Shahbaz Youssefi, Google

* 
Bill Licea-Kane, Qualcomm Technologies, Inc.

* 
Tobias Hector, AMD

This extension incorporates `VK_ATTACHMENT_STORE_OP_NONE_EXT` from
`[VK_QCOM_render_pass_store_ops](#VK_QCOM_render_pass_store_ops)`, enabling applications to avoid
unnecessary synchronization when an attachment is not written during a
render pass.

Additionally, `VK_ATTACHMENT_LOAD_OP_NONE_EXT` is introduced to avoid
unnecessary synchronization when an attachment is not used during a render
pass at all.
In combination with `VK_ATTACHMENT_STORE_OP_NONE_EXT`, this is useful as
an alternative to preserve attachments in applications that cannot decide if
an attachment will be used in a render pass until after the necessary
pipelines have been created.

All functionality in this extension is included in
`[VK_KHR_load_store_op_none](#VK_KHR_load_store_op_none)`, with the suffix changed to KHR.
The original enum names are still available as aliases of the KHR
functionality.

* 
`VK_EXT_LOAD_STORE_OP_NONE_EXTENSION_NAME`

* 
`VK_EXT_LOAD_STORE_OP_NONE_SPEC_VERSION`

* 
Extending [VkAttachmentLoadOp](../chapters/renderpass.html#VkAttachmentLoadOp):

`VK_ATTACHMENT_LOAD_OP_NONE_EXT`

Extending [VkAttachmentStoreOp](../chapters/renderpass.html#VkAttachmentStoreOp):

* 
`VK_ATTACHMENT_STORE_OP_NONE_EXT`

|  | While `VK_ATTACHMENT_STORE_OP_NONE` is part of Vulkan 1.3, this
| --- | --- |
extension was not promoted to core either in whole or in part.
This functionality was promoted from `[VK_KHR_dynamic_rendering](#VK_KHR_dynamic_rendering)`. |

* 
Revision 1, 2021-06-06 (Shahbaz Youssefi)

Initial revision, based on VK_QCOM_render_pass_store_ops.

* 
Added VK_ATTACHMENT_LOAD_OP_NONE_EXT.

**Name String**

`VK_EXT_pipeline_creation_cache_control`

**Extension Type**

Device extension

**Registered Extension Number**

298

**Revision**

3

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.3](versions.html#versions-1.3-promotions)

**Contact**

* 
Gregory Grebe [grgrebe_amd](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_pipeline_creation_cache_control] @grgrebe_amd%0A*Here describe the issue or question you have about the VK_EXT_pipeline_creation_cache_control extension*)

**Last Modified Date**

2020-03-23

**IP Status**

No known IP claims.

**Contributors**

* 
Gregory Grebe, AMD

* 
Tobias Hector, AMD

* 
Matthaeus Chajdas, AMD

* 
Mitch Singer, AMD

* 
Spencer Fricke, Samsung Electronics

* 
Stuart Smith, Imagination Technologies

* 
Jeff Bolz, NVIDIA Corporation

* 
Daniel Koch, NVIDIA Corporation

* 
Dan Ginsburg, Valve Corporation

* 
Jeff Leger, QUALCOMM

* 
Michal Pietrasiuk, Intel

* 
Jan-Harald Fredriksen, Arm Limited

This extension adds flags to `Vk*PipelineCreateInfo` and
[VkPipelineCacheCreateInfo](../chapters/pipelines.html#VkPipelineCacheCreateInfo) structures with the aim of improving the
predictability of pipeline creation cost.
The goal is to provide information about potentially expensive hazards
within the client driver during pipeline creation to the application before
carrying them out rather than after.

Pipeline creation is a costly operation, and the explicit nature of the
Vulkan design means that cost is not hidden from the developer.
Applications are also expected to schedule, prioritize, and load balance all
calls for pipeline creation.
It is strongly advised that applications create pipelines sufficiently ahead
of their usage.
Failure to do so will result in an unresponsive application, intermittent
stuttering, or other poor user experiences.
Proper usage of pipeline caches and/or derivative pipelines help mitigate
this but is not assured to eliminate disruption in all cases.
In the event that an ahead-of-time creation is not possible, considerations
should be taken to ensure that the current execution context is suitable for
the workload of pipeline creation including possible shader compilation.

Applications making API calls to create a pipeline must be prepared for any
of the following to occur:

* 
OS/kernel calls to be made by the ICD

* 
Internal memory allocation not tracked by the `pAllocator` passed to
`vkCreate*Pipelines`

* 
Internal thread synchronization or yielding of the current threads core

* 
Extremely long (multi-millisecond+), blocking, compilation times

* 
Arbitrary call stacks depths and stack memory usage

The job or task based game engines that are being developed to take
advantage of explicit graphics APIs like Vulkan may behave exceptionally
poorly if any of the above scenarios occur.
However, most game engines are already built to stream in assets
dynamically as the user plays the game.
By adding control by way of [VkPipelineCreateFlags](../chapters/pipelines.html#VkPipelineCreateFlags), we can require an
ICD to report back a failure in critical execution paths rather than forcing
an unexpected wait.

Applications can prevent unexpected compilation by setting
`VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_EXT` on
`Vk*PipelineCreateInfo`::`flags`.
When set, an ICD must not attempt pipeline or shader compilation to create
the pipeline object.
In such a case, if the implementation fails to create a pipeline without
compilation, the implementation **must** return the result
`VK_PIPELINE_COMPILE_REQUIRED_EXT` and return [VK_NULL_HANDLE](boilerplate.html#VK_NULL_HANDLE) for
the pipeline.

By default `vkCreate*Pipelines` calls must attempt to create all
pipelines before returning.
Setting `VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT_EXT` on
`Vk*PipelineCreateInfo`::`flags` can be used as an escape hatch for
batched pipeline creates.

Hidden locks also add to the unpredictability of the cost of pipeline
creation.
The most common case of locks inside the `vkCreate*Pipelines` is
internal synchronization of the [VkPipelineCache](../chapters/pipelines.html#VkPipelineCache) object.
`VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT_EXT` can be set
when calling [vkCreatePipelineCache](../chapters/pipelines.html#vkCreatePipelineCache) to state the cache is
[externally synchronized](../chapters/fundamentals.html#fundamentals-threadingbehavior).

The hope is that armed with this information application and engine
developers can leverage existing asset streaming systems to recover from
"just-in-time" pipeline creation stalls.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT](../chapters/features.html#VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT)

* 
[VkPipelineCacheCreateFlagBits](../chapters/pipelines.html#VkPipelineCacheCreateFlagBits)

* 
`VK_EXT_PIPELINE_CREATION_CACHE_CONTROL_EXTENSION_NAME`

* 
`VK_EXT_PIPELINE_CREATION_CACHE_CONTROL_SPEC_VERSION`

* 
Extending [VkPipelineCacheCreateFlagBits](../chapters/pipelines.html#VkPipelineCacheCreateFlagBits):

`VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT_EXT`

Extending [VkPipelineCreateFlagBits](../chapters/pipelines.html#VkPipelineCreateFlagBits):

* 
`VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT_EXT`

* 
`VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_EXT`

Extending [VkResult](../chapters/fundamentals.html#VkResult):

* 
`VK_ERROR_PIPELINE_COMPILE_REQUIRED_EXT`

* 
`VK_PIPELINE_COMPILE_REQUIRED_EXT`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES_EXT`

Vulkan APIs in this extension are included in core Vulkan 1.3, with the EXT
suffix omitted.
External interactions defined by this extension, such as SPIR-V token names,
retain their original names.
The original Vulkan API names are still available as aliases of the core
functionality.

* 
Revision 1, 2019-11-01 (Gregory Grebe)

Initial revision

Revision 2, 2020-02-24 (Gregory Grebe)

* 
Initial public revision

Revision 3, 2020-03-23 (Tobias Hector)

* 
Changed `VK_PIPELINE_COMPILE_REQUIRED_EXT` to a success code,
adding an alias for the original
`VK_ERROR_PIPELINE_COMPILE_REQUIRED_EXT`.
Also updated the xml to include these codes as return values.

**Name String**

`VK_EXT_pipeline_creation_feedback`

**Extension Type**

Device extension

**Registered Extension Number**

193

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

None

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.3](versions.html#versions-1.3-promotions)

**Special Use**

* 
[Developer tools](../chapters/extensions.html#extendingvulkan-compatibility-specialuse)

**Contact**

* 
Jean-Francois Roy [jfroy](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_pipeline_creation_feedback] @jfroy%0A*Here describe the issue or question you have about the VK_EXT_pipeline_creation_feedback extension*)

**Last Modified Date**

2019-03-12

**IP Status**

No known IP claims.

**Contributors**

* 
Jean-Francois Roy, Google

* 
Hai Nguyen, Google

* 
Andrew Ellem, Google

* 
Bob Fraser, Google

* 
Sujeevan Rajayogam, Google

* 
Jan-Harald Fredriksen, ARM

* 
Jeff Leger, Qualcomm Technologies, Inc.

* 
Jeff Bolz, NVIDIA

* 
Daniel Koch, NVIDIA

* 
Neil Henning, AMD

This extension adds a mechanism to provide feedback to an application about
pipeline creation, with the specific goal of allowing a feedback loop
between build systems and in-the-field application executions to ensure
effective pipeline caches are shipped to customers.

* 
[VkPipelineCreationFeedbackEXT](../chapters/pipelines.html#VkPipelineCreationFeedbackEXT)

* 
Extending [VkGraphicsPipelineCreateInfo](../chapters/pipelines.html#VkGraphicsPipelineCreateInfo), [VkComputePipelineCreateInfo](../chapters/pipelines.html#VkComputePipelineCreateInfo), [VkRayTracingPipelineCreateInfoNV](../chapters/pipelines.html#VkRayTracingPipelineCreateInfoNV), [VkRayTracingPipelineCreateInfoKHR](../chapters/pipelines.html#VkRayTracingPipelineCreateInfoKHR), [VkExecutionGraphPipelineCreateInfoAMDX](../chapters/executiongraphs.html#VkExecutionGraphPipelineCreateInfoAMDX):

[VkPipelineCreationFeedbackCreateInfoEXT](../chapters/pipelines.html#VkPipelineCreationFeedbackCreateInfoEXT)

* 
[VkPipelineCreationFeedbackFlagBitsEXT](../chapters/pipelines.html#VkPipelineCreationFeedbackFlagBitsEXT)

* 
[VkPipelineCreationFeedbackFlagsEXT](../chapters/pipelines.html#VkPipelineCreationFeedbackFlagsEXT)

* 
`VK_EXT_PIPELINE_CREATION_FEEDBACK_EXTENSION_NAME`

* 
`VK_EXT_PIPELINE_CREATION_FEEDBACK_SPEC_VERSION`

* 
Extending [VkPipelineCreationFeedbackFlagBits](../chapters/pipelines.html#VkPipelineCreationFeedbackFlagBits):

`VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT`

* 
`VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT_EXT`

* 
`VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT`

Vulkan APIs in this extension are included in core Vulkan 1.3, with the EXT
suffix omitted.
External interactions defined by this extension, such as SPIR-V token names,
retain their original names.
The original Vulkan API names are still available as aliases of the core
functionality.

* 
Revision 1, 2019-03-12 (Jean-Francois Roy)

Initial revision

**Name String**

`VK_EXT_pipeline_protected_access`

**Extension Type**

Device extension

**Registered Extension Number**

467

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.4](versions.html#versions-1.4-promotions)

**Contact**

* 
Shahbaz Youssefi [syoussefi](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_pipeline_protected_access] @syoussefi%0A*Here describe the issue or question you have about the VK_EXT_pipeline_protected_access extension*)

**Extension Proposal**

[VK_EXT_pipeline_protected_access](../../../features/latest/features/proposals/VK_EXT_pipeline_protected_access.html)

**Last Modified Date**

2022-07-28

**Contributors**

* 
Shahbaz Youssefi, Google

* 
Jrg Wagner, Arm

* 
Ralph Potter, Samsung

* 
Daniel Koch, NVIDIA

This extension allows protected memory access to be specified per pipeline
as opposed to per device.
Through the usage of this extension, any performance penalty paid due to
access to protected memory will be limited to the specific pipelines that
make such accesses.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDevicePipelineProtectedAccessFeaturesEXT](../chapters/features.html#VkPhysicalDevicePipelineProtectedAccessFeaturesEXT)

* 
`VK_EXT_PIPELINE_PROTECTED_ACCESS_EXTENSION_NAME`

* 
`VK_EXT_PIPELINE_PROTECTED_ACCESS_SPEC_VERSION`

* 
Extending [VkPipelineCreateFlagBits](../chapters/pipelines.html#VkPipelineCreateFlagBits):

`VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT_EXT`

* 
`VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT_EXT`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES_EXT`

Functionality in this extension is included in core Vulkan 1.4 with the EXT
suffix omitted.
The original type, enum and command names are still available as aliases of
the core functionality.

* 
Revision 1, 2022-07-28 (Shahbaz Youssefi)

Internal revisions

**Name String**

`VK_EXT_pipeline_robustness`

**Extension Type**

Device extension

**Registered Extension Number**

69

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.4](versions.html#versions-1.4-promotions)

**Contact**

* 
Jarred Davies

**Last Modified Date**

2022-07-12

**Interactions and External Dependencies**

* 
Interacts with `[VK_EXT_robustness2](#VK_EXT_robustness2)`

* 
Interacts with `[VK_EXT_image_robustness](#VK_EXT_image_robustness)`

* 
Interacts with `[VK_KHR_ray_tracing_pipeline](#VK_KHR_ray_tracing_pipeline)`

**Contributors**

* 
Jarred Davies, Imagination Technologies

* 
Alex Walters, Imagination Technologies

* 
Piers Daniell, NVIDIA

* 
Graeme Leese, Broadcom Corporation

* 
Jeff Leger, Qualcomm Technologies, Inc.

* 
Faith Ekstrand, Intel

* 
Lionel Landwerlin, Intel

* 
Shahbaz Youssefi, Google, Inc.

This extension allows users to request robustness on a per-pipeline stage
basis.

As [`robustBufferAccess`](../chapters/features.html#features-robustBufferAccess) and other
robustness features may have an adverse effect on performance, this
extension is designed to allow users to request robust behavior only where
it may be needed.

* 
Extending [VkGraphicsPipelineCreateInfo](../chapters/pipelines.html#VkGraphicsPipelineCreateInfo), [VkComputePipelineCreateInfo](../chapters/pipelines.html#VkComputePipelineCreateInfo), [VkPipelineShaderStageCreateInfo](../chapters/pipelines.html#VkPipelineShaderStageCreateInfo), [VkRayTracingPipelineCreateInfoKHR](../chapters/pipelines.html#VkRayTracingPipelineCreateInfoKHR):

[VkPipelineRobustnessCreateInfoEXT](../chapters/pipelines.html#VkPipelineRobustnessCreateInfoEXT)

Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

* 
[VkPhysicalDevicePipelineRobustnessFeaturesEXT](../chapters/features.html#VkPhysicalDevicePipelineRobustnessFeaturesEXT)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDevicePipelineRobustnessPropertiesEXT](../chapters/limits.html#VkPhysicalDevicePipelineRobustnessPropertiesEXT)

* 
[VkPipelineRobustnessBufferBehaviorEXT](../chapters/pipelines.html#VkPipelineRobustnessBufferBehaviorEXT)

* 
[VkPipelineRobustnessImageBehaviorEXT](../chapters/pipelines.html#VkPipelineRobustnessImageBehaviorEXT)

* 
`VK_EXT_PIPELINE_ROBUSTNESS_EXTENSION_NAME`

* 
`VK_EXT_PIPELINE_ROBUSTNESS_SPEC_VERSION`

* 
Extending [VkPipelineRobustnessBufferBehavior](../chapters/pipelines.html#VkPipelineRobustnessBufferBehavior):

`VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT_EXT`

* 
`VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED_EXT`

* 
`VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT`

* 
`VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT`

Extending [VkPipelineRobustnessImageBehavior](../chapters/pipelines.html#VkPipelineRobustnessImageBehavior):

* 
`VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT_EXT`

* 
`VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DISABLED_EXT`

* 
`VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2_EXT`

* 
`VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_EXT`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES_EXT`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES_EXT`

* 
`VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT`

Functionality in this extension is included in core Vulkan 1.4 with the EXT
suffix omitted.
The original type, enum and command names are still available as aliases of
the core functionality.

* 
Revision 1, 2022-07-12 (Jarred Davies)

Initial version

**Name String**

`VK_EXT_private_data`

**Extension Type**

Device extension

**Registered Extension Number**

296

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.3](versions.html#versions-1.3-promotions)

**Contact**

* 
Matthew Rusch [mattruschnv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_private_data] @mattruschnv%0A*Here describe the issue or question you have about the VK_EXT_private_data extension*)

**Last Modified Date**

2020-03-25

**IP Status**

No known IP claims.

**Contributors**

* 
Matthew Rusch, NVIDIA

* 
Nuno Subtil, NVIDIA

* 
Piers Daniell, NVIDIA

* 
Jeff Bolz, NVIDIA

This extension is a device extension which enables attaching arbitrary
payloads to Vulkan objects.
It introduces the idea of private data slots as a means of storing a 64-bit
unsigned integer of application-defined data.
Private data slots can be created or destroyed any time an associated device
is available.
Private data slots can be reserved at device creation time, and limiting use
to the amount reserved will allow the extension to exhibit better
performance characteristics.

* 
[VkPrivateDataSlotEXT](../chapters/VK_EXT_private_data.html#VkPrivateDataSlotEXT)

* 
[vkCreatePrivateDataSlotEXT](../chapters/VK_EXT_private_data.html#vkCreatePrivateDataSlotEXT)

* 
[vkDestroyPrivateDataSlotEXT](../chapters/VK_EXT_private_data.html#vkDestroyPrivateDataSlotEXT)

* 
[vkGetPrivateDataEXT](../chapters/VK_EXT_private_data.html#vkGetPrivateDataEXT)

* 
[vkSetPrivateDataEXT](../chapters/VK_EXT_private_data.html#vkSetPrivateDataEXT)

* 
[VkPrivateDataSlotCreateInfoEXT](../chapters/VK_EXT_private_data.html#VkPrivateDataSlotCreateInfoEXT)

* 
Extending [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkDevicePrivateDataCreateInfoEXT](../chapters/devsandqueues.html#VkDevicePrivateDataCreateInfoEXT)

Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

* 
[VkPhysicalDevicePrivateDataFeaturesEXT](../chapters/features.html#VkPhysicalDevicePrivateDataFeaturesEXT)

* 
[VkPrivateDataSlotCreateFlagsEXT](../chapters/VK_EXT_private_data.html#VkPrivateDataSlotCreateFlagsEXT)

* 
`VK_EXT_PRIVATE_DATA_EXTENSION_NAME`

* 
`VK_EXT_PRIVATE_DATA_SPEC_VERSION`

* 
Extending [VkObjectType](../chapters/debugging.html#VkObjectType):

`VK_OBJECT_TYPE_PRIVATE_DATA_SLOT_EXT`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO_EXT`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES_EXT`

* 
`VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO_EXT`

Vulkan APIs in this extension are included in core Vulkan 1.3, with the EXT
suffix omitted.
External interactions defined by this extension, such as SPIR-V token names,
retain their original names.
The original Vulkan API names are still available as aliases of the core
functionality.

* 
In progress

(1) If I have to create a [VkPrivateDataSlot](../chapters/VK_EXT_private_data.html#VkPrivateDataSlot) to store and retrieve data
on an object, how does this extension help me? Will I not need to store the
[VkPrivateDataSlot](../chapters/VK_EXT_private_data.html#VkPrivateDataSlot) mapping with each object, and if I am doing that, I
might as well just store the original data!

**RESOLVED:** The [VkPrivateDataSlot](../chapters/VK_EXT_private_data.html#VkPrivateDataSlot) can be thought of as an opaque
index into storage that is reserved in each object.
That is, you can use the same [VkPrivateDataSlot](../chapters/VK_EXT_private_data.html#VkPrivateDataSlot) with each object for a
specific piece of information.
For example, if a layer wishes to track per-object information, the layer
only needs to allocate one [VkPrivateDataSlot](../chapters/VK_EXT_private_data.html#VkPrivateDataSlot) per device and it can use
that private data slot for all of the devices child objects.
This allows multiple layers to store private data without conflicting with
each others and/or the applications private data.

(2) What if I need to store more than 64-bits of information per object?

**RESOLVED:** The data that you store per object could be a pointer to
another object or structure of your own allocation.

* 
Revision 1, 2020-01-15 (Matthew Rusch)

Initial draft

**Name String**

`VK_EXT_robustness2`

**Extension Type**

Device extension

**Registered Extension Number**

287

**Revision**

1

**Ratification Status**

Ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Deprecation State**

* 
*Promoted* to
[VK_KHR_robustness2](#VK_KHR_robustness2)
extension

**Contact**

* 
Liam Middlebrook [liam-middlebrook](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_robustness2] @liam-middlebrook%0A*Here describe the issue or question you have about the VK_EXT_robustness2 extension*)

**Last Modified Date**

2020-01-29

**IP Status**

No known IP claims.

**Contributors**

* 
Liam Middlebrook, NVIDIA

* 
Jeff Bolz, NVIDIA

This extension adds stricter requirements for how out of bounds reads and
writes are handled.
Most accesses **must** be tightly bounds-checked, out of bounds writes **must** be
discarded, out of bound reads **must** return zero.
Rather than allowing multiple possible (0,0,0,x) vectors, the out of
bounds values are treated as zero, and then missing components are inserted
based on the format as described in [Conversion to RGBA](../chapters/textures.html#textures-conversion-to-rgba) and [vertex input attribute extraction](../chapters/fxvertex.html#fxvertex-input-extraction).

These additional requirements **may** be expensive on some implementations, and
should only be enabled when truly necessary.

This extension also adds support for null descriptors, where
[VK_NULL_HANDLE](boilerplate.html#VK_NULL_HANDLE) **can** be used instead of a valid handle.
Accesses to null descriptors have well-defined behavior, and do not rely on
robustness.

All functionality in this extension is included in
`[VK_KHR_robustness2](#VK_KHR_robustness2)`, with the suffix changed to KHR.
The original type, enum, and command names are still available as aliases of
the core functionality.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceRobustness2FeaturesEXT](../chapters/features.html#VkPhysicalDeviceRobustness2FeaturesEXT)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceRobustness2PropertiesEXT](../chapters/limits.html#VkPhysicalDeviceRobustness2PropertiesEXT)

* 
`VK_EXT_ROBUSTNESS_2_EXTENSION_NAME`

* 
`VK_EXT_ROBUSTNESS_2_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT`

Why do
[VkPhysicalDeviceRobustness2PropertiesEXT](../chapters/limits.html#VkPhysicalDeviceRobustness2PropertiesEXT)::`robustUniformBufferAccessSizeAlignment`
and
[VkPhysicalDeviceRobustness2PropertiesEXT](../chapters/limits.html#VkPhysicalDeviceRobustness2PropertiesEXT)::`robustStorageBufferAccessSizeAlignment`
exist?

**RESOLVED**: Some implementations cannot efficiently tightly bounds-check all
buffer accesses.
Rather, the size of the bound range is padded to some power of two multiple,
up to 256 bytes for uniform buffers and up to 4 bytes for storage buffers,
and that padded size is bounds-checked.
This is sufficient to implement D3D-like behavior, because D3D only allows
binding whole uniform buffers or ranges that are a multiple of 256 bytes,
and D3D raw and structured buffers only support 32-bit accesses.

None.

* 
Revision 1, 2019-11-01 (Jeff Bolz, Liam Middlebrook)

Initial draft

**Name String**

`VK_EXT_sampler_filter_minmax`

**Extension Type**

Device extension

**Registered Extension Number**

131

**Revision**

2

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.2](versions.html#versions-1.2-promotions)

**Contact**

* 
Jeff Bolz [jeffbolznv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_sampler_filter_minmax] @jeffbolznv%0A*Here describe the issue or question you have about the VK_EXT_sampler_filter_minmax extension*)

**Last Modified Date**

2017-05-19

**IP Status**

No known IP claims.

**Contributors**

* 
Jeff Bolz, NVIDIA

* 
Piers Daniell, NVIDIA

In unextended Vulkan, minification and magnification filters such as LINEAR
allow sampled image lookups to return a filtered texel value produced by
computing a weighted average of a collection of texels in the neighborhood
of the texture coordinate provided.

This extension provides a new sampler parameter which allows applications to
produce a filtered texel value by computing a component-wise minimum (MIN)
or maximum (MAX) of the texels that would normally be averaged.
The reduction mode is orthogonal to the minification and magnification
filter parameters.
The filter parameters are used to identify the set of texels used to produce
a final filtered value; the reduction mode identifies how these texels are
combined.

All functionality in this extension is included in core Vulkan 1.2, with the
EXT suffix omitted.
The original type, enum, and command names are still available as aliases of
the core functionality.

* 
Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

[VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT](../chapters/limits.html#VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT)

Extending [VkSamplerCreateInfo](../chapters/samplers.html#VkSamplerCreateInfo):

* 
[VkSamplerReductionModeCreateInfoEXT](../chapters/samplers.html#VkSamplerReductionModeCreateInfoEXT)

* 
[VkSamplerReductionModeEXT](../chapters/samplers.html#VkSamplerReductionModeEXT)

* 
`VK_EXT_SAMPLER_FILTER_MINMAX_EXTENSION_NAME`

* 
`VK_EXT_SAMPLER_FILTER_MINMAX_SPEC_VERSION`

* 
Extending [VkFormatFeatureFlagBits](../chapters/formats.html#VkFormatFeatureFlagBits):

`VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT`

Extending [VkSamplerReductionMode](../chapters/samplers.html#VkSamplerReductionMode):

* 
`VK_SAMPLER_REDUCTION_MODE_MAX_EXT`

* 
`VK_SAMPLER_REDUCTION_MODE_MIN_EXT`

* 
`VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT`

* 
`VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT`

* 
Revision 2, 2017-05-19 (Piers Daniell)

Renamed to EXT

Revision 1, 2017-03-25 (Jeff Bolz)

* 
Internal revisions

**Name String**

`VK_EXT_scalar_block_layout`

**Extension Type**

Device extension

**Registered Extension Number**

222

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.2](versions.html#versions-1.2-promotions)

**Contact**

* 
Tobias Hector [tobski](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_scalar_block_layout] @tobski%0A*Here describe the issue or question you have about the VK_EXT_scalar_block_layout extension*)

**Last Modified Date**

2018-11-14

**Contributors**

* 
Jeff Bolz

* 
Jan-Harald Fredriksen

* 
Graeme Leese

* 
Faith Ekstrand

* 
John Kessenich

This extension enables C-like structure layout for SPIR-V blocks.
It modifies the alignment rules for uniform buffers, storage buffers and
push constants, allowing non-scalar types to be aligned solely based on the
size of their components, without additional requirements.

Vulkan APIs in this extension are included in core Vulkan 1.2, with the EXT
suffix omitted.
However, if Vulkan 1.2 is supported and this extension is not, the
`scalarBlockLayout` capability is optional.
External interactions defined by this extension, such as SPIR-V token names,
retain their original names.
The original Vulkan API names are still available as aliases of the core
functionality.

If Vulkan 1.4 is supported, support for the `scalarBlockLayout`
capability is required.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceScalarBlockLayoutFeaturesEXT](../chapters/features.html#VkPhysicalDeviceScalarBlockLayoutFeaturesEXT)

* 
`VK_EXT_SCALAR_BLOCK_LAYOUT_EXTENSION_NAME`

* 
`VK_EXT_SCALAR_BLOCK_LAYOUT_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT`

* 
Revision 1, 2018-11-14 (Tobias Hector)

Initial draft

**Name String**

`VK_EXT_separate_stencil_usage`

**Extension Type**

Device extension

**Registered Extension Number**

247

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

None

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.2](versions.html#versions-1.2-promotions)

**Contact**

* 
Daniel Rakos [drakos-amd](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_separate_stencil_usage] @drakos-amd%0A*Here describe the issue or question you have about the VK_EXT_separate_stencil_usage extension*)

**Last Modified Date**

2018-11-08

**IP Status**

No known IP claims.

**Contributors**

* 
Daniel Rakos, AMD

* 
Jordan Logan, AMD

This extension allows specifying separate usage flags for the stencil aspect
of images with a depth-stencil format at image creation time.

All functionality in this extension is included in core Vulkan 1.2, with the
EXT suffix omitted.
The original type, enum, and command names are still available as aliases of
the core functionality.

* 
Extending [VkImageCreateInfo](../chapters/resources.html#VkImageCreateInfo), [VkPhysicalDeviceImageFormatInfo2](../chapters/capabilities.html#VkPhysicalDeviceImageFormatInfo2):

[VkImageStencilUsageCreateInfoEXT](../chapters/resources.html#VkImageStencilUsageCreateInfoEXT)

* 
`VK_EXT_SEPARATE_STENCIL_USAGE_EXTENSION_NAME`

* 
`VK_EXT_SEPARATE_STENCIL_USAGE_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO_EXT`

* 
Revision 1, 2018-11-08 (Daniel Rakos)

Internal revisions.

**Name String**

`VK_EXT_shader_demote_to_helper_invocation`

**Extension Type**

Device extension

**Registered Extension Number**

277

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**SPIR-V Dependencies**

* 
[SPV_EXT_demote_to_helper_invocation](https://github.khronos.org/SPIRV-Registry/extensions/EXT/SPV_EXT_demote_to_helper_invocation.html)

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.3](versions.html#versions-1.3-promotions)

**Contact**

* 
Jeff Bolz [jeffbolznv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_shader_demote_to_helper_invocation] @jeffbolznv%0A*Here describe the issue or question you have about the VK_EXT_shader_demote_to_helper_invocation extension*)

**Last Modified Date**

2019-06-01

**IP Status**

No known IP claims.

**Interactions and External Dependencies**

* 
This extension provides API support for
[`GL_EXT_demote_to_helper_invocation`](https://github.com/KhronosGroup/GLSL/blob/main/extensions/ext/GLSL_EXT_demote_to_helper_invocation.txt)

**Contributors**

* 
Jeff Bolz, NVIDIA

This extension adds Vulkan support for the
[`SPV_EXT_demote_to_helper_invocation`](https://github.khronos.org/SPIRV-Registry/extensions/EXT/SPV_EXT_demote_to_helper_invocation.html)
SPIR-V extension.
That SPIR-V extension provides a new instruction
`OpDemoteToHelperInvocationEXT` allowing shaders to demote a fragment
shader invocation to behave like a helper invocation for its duration.
The demoted invocation will have no further side effects and will not output
to the framebuffer, but remains active and can participate in computing
derivatives and in [group operations](../chapters/shaders.html#shaders-group-operations).
This is a better match for the discard instruction in HLSL.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT](../chapters/features.html#VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT)

* 
`VK_EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_EXTENSION_NAME`

* 
`VK_EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT`

* 
[    `DemoteToHelperInvocationEXT`](spirvenv.html#spirvenv-capabilities-table-DemoteToHelperInvocation)

Vulkan APIs in this extension are included in core Vulkan 1.3, with the EXT
suffix omitted.
External interactions defined by this extension, such as SPIR-V token names,
retain their original names.
The original Vulkan API names are still available as aliases of the core
functionality.

* 
Revision 1, 2019-06-01 (Jeff Bolz)

Initial draft

**Name String**

`VK_EXT_shader_subgroup_ballot`

**Extension Type**

Device extension

**Registered Extension Number**

65

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

None

**SPIR-V Dependencies**

* 
[SPV_KHR_shader_ballot](https://github.khronos.org/SPIRV-Registry/extensions/KHR/SPV_KHR_shader_ballot.html)

**Deprecation State**

* 
*Deprecated* by
[Vulkan 1.2](versions.html#versions-1.2-new-features)

**Contact**

* 
Daniel Koch [dgkoch](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_shader_subgroup_ballot] @dgkoch%0A*Here describe the issue or question you have about the VK_EXT_shader_subgroup_ballot extension*)

**Last Modified Date**

2016-11-28

**IP Status**

No known IP claims.

**Interactions and External Dependencies**

* 
This extension provides API support for
[`GL_ARB_shader_ballot`](https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_ballot.txt)

**Contributors**

* 
Jeff Bolz, NVIDIA

* 
Neil Henning, Codeplay

* 
Daniel Koch, NVIDIA Corporation

This extension adds support for the following SPIR-V extension in Vulkan:

* 
`SPV_KHR_shader_ballot`

This extension provides the ability for a group of invocations, which
execute in parallel, to do limited forms of cross-invocation communication
via a group broadcast of an invocation value, or broadcast of a bit array
representing a predicate value from each invocation in the group.

This extension provides access to a number of additional built-in shader
variables in Vulkan:

* 
`SubgroupEqMaskKHR`, containing the subgroup mask of the current
subgroup invocation,

* 
`SubgroupGeMaskKHR`, containing the subgroup mask of the invocations
greater than or equal to the current invocation,

* 
`SubgroupGtMaskKHR`, containing the subgroup mask of the invocations
greater than the current invocation,

* 
`SubgroupLeMaskKHR`, containing the subgroup mask of the invocations
less than or equal to the current invocation,

* 
`SubgroupLtMaskKHR`, containing the subgroup mask of the invocations
less than the current invocation,

* 
`SubgroupLocalInvocationId`, containing the index of an invocation
within a subgroup, and

* 
`SubgroupSize`, containing the maximum number of invocations in a
subgroup.

Additionally, this extension provides access to the new SPIR-V instructions:

* 
`OpSubgroupBallotKHR`,

* 
`OpSubgroupFirstInvocationKHR`, and

* 
`OpSubgroupReadInvocationKHR`,

When using GLSL source-based shader languages, the following variables and
shader functions from GL_ARB_shader_ballot can map to these SPIR-V built-in
decorations and instructions:

* 
`in uint64_t gl_SubGroupEqMaskARB;`  `SubgroupEqMaskKHR`,

* 
`in uint64_t gl_SubGroupGeMaskARB;`  `SubgroupGeMaskKHR`,

* 
`in uint64_t gl_SubGroupGtMaskARB;`  `SubgroupGtMaskKHR`,

* 
`in uint64_t gl_SubGroupLeMaskARB;`  `SubgroupLeMaskKHR`,

* 
`in uint64_t gl_SubGroupLtMaskARB;`  `SubgroupLtMaskKHR`,

* 
`in uint gl_SubGroupInvocationARB;`  `SubgroupLocalInvocationId`,

* 
`uniform uint gl_SubGroupSizeARB;`  `SubgroupSize`,

* 
`ballotARB`()  `OpSubgroupBallotKHR`,

* 
`readFirstInvocationARB`()  `OpSubgroupFirstInvocationKHR`, and

* 
`readInvocationARB`()  `OpSubgroupReadInvocationKHR`.

Most of the functionality in this extension is superseded by the core Vulkan
1.1 [subgroup operations](../chapters/limits.html#VkPhysicalDeviceSubgroupProperties).
However, Vulkan 1.1 required the `OpGroupNonUniformBroadcast` Id to
be constant.
This restriction was removed in Vulkan 1.2 with the addition of the
[`subgroupBroadcastDynamicId`](../chapters/features.html#features-subgroupBroadcastDynamicId)
feature.

* 
`VK_EXT_SHADER_SUBGROUP_BALLOT_EXTENSION_NAME`

* 
`VK_EXT_SHADER_SUBGROUP_BALLOT_SPEC_VERSION`

* 
[`SubgroupEqMaskKHR`](../chapters/interfaces.html#interfaces-builtin-variables-sgeq)

* 
[`SubgroupGeMaskKHR`](../chapters/interfaces.html#interfaces-builtin-variables-sgge)

* 
[`SubgroupGtMaskKHR`](../chapters/interfaces.html#interfaces-builtin-variables-sggt)

* 
[`SubgroupLeMaskKHR`](../chapters/interfaces.html#interfaces-builtin-variables-sgle)

* 
[`SubgroupLtMaskKHR`](../chapters/interfaces.html#interfaces-builtin-variables-sglt)

* 
[`SubgroupLocalInvocationId`](../chapters/interfaces.html#interfaces-builtin-variables-sgli)

* 
[`SubgroupSize`](../chapters/interfaces.html#interfaces-builtin-variables-sgs)

* 
[    `SubgroupBallotKHR`](spirvenv.html#spirvenv-capabilities-table-SubgroupBallotKHR)

* 
Revision 1, 2016-11-28 (Daniel Koch)

Initial draft

**Name String**

`VK_EXT_shader_subgroup_vote`

**Extension Type**

Device extension

**Registered Extension Number**

66

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

None

**SPIR-V Dependencies**

* 
[SPV_KHR_subgroup_vote](https://github.khronos.org/SPIRV-Registry/extensions/KHR/SPV_KHR_subgroup_vote.html)

**Deprecation State**

* 
*Deprecated* by
[Vulkan 1.1](versions.html#versions-1.1-new-features)

**Contact**

* 
Daniel Koch [dgkoch](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_shader_subgroup_vote] @dgkoch%0A*Here describe the issue or question you have about the VK_EXT_shader_subgroup_vote extension*)

**Last Modified Date**

2016-11-28

**IP Status**

No known IP claims.

**Interactions and External Dependencies**

* 
This extension provides API support for
[`GL_ARB_shader_group_vote`](https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_group_vote.txt)

**Contributors**

* 
Neil Henning, Codeplay

* 
Daniel Koch, NVIDIA Corporation

This extension adds support for the following SPIR-V extension in Vulkan:

* 
`SPV_KHR_subgroup_vote`

This extension provides new SPIR-V instructions:

* 
`OpSubgroupAllKHR`,

* 
`OpSubgroupAnyKHR`, and

* 
`OpSubgroupAllEqualKHR`.

to compute the composite of a set of boolean conditions across a group of
shader invocations that are running concurrently (a *subgroup*).
These composite results may be used to execute shaders more efficiently on a
[VkPhysicalDevice](../chapters/devsandqueues.html#VkPhysicalDevice).

When using GLSL source-based shader languages, the following shader
functions from GL_ARB_shader_group_vote can map to these SPIR-V
instructions:

* 
`anyInvocationARB`()  `OpSubgroupAnyKHR`,

* 
`allInvocationsARB`()  `OpSubgroupAllKHR`, and

* 
`allInvocationsEqualARB`()  `OpSubgroupAllEqualKHR`.

The subgroup across which the boolean conditions are evaluated is
implementation-dependent, and this extension provides no guarantee over how
individual shader invocations are assigned to subgroups.
In particular, a subgroup has no necessary relationship with the compute
shader *local workgroup*any pair of shader invocations in a compute
local workgroup may execute in different subgroups as used by these
instructions.

Compute shaders operate on an explicitly specified group of threads (a local
workgroup), but many implementations will also group non-compute shader
invocations and execute them concurrently.
When executing code like

if (condition) {
  result = do_fast_path();
} else {
  result = do_general_path();
}

where `condition` diverges between invocations, an implementation might
first execute `do_fast_path`() for the invocations where `condition`
is true and leave the other invocations dormant.
Once `do_fast_path`() returns, it might call `do_general_path`() for
invocations where `condition` is `false` and leave the other
invocations dormant.
In this case, the shader executes **both** the fast and the general path and
might be better off just using the general path for all invocations.

This extension provides the ability to avoid divergent execution by
evaluating a condition across an entire subgroup using code like:

if (allInvocationsARB(condition)) {
  result = do_fast_path();
} else {
  result = do_general_path();
}

The built-in function `allInvocationsARB`() will return the same value
for all invocations in the group, so the group will either execute
`do_fast_path`() or `do_general_path`(), but never both.
For example, shader code might want to evaluate a complex function
iteratively by starting with an approximation of the result and then
refining the approximation.
Some input values may require a small number of iterations to generate an
accurate result (`do_fast_path`) while others require a larger number
(`do_general_path`).
In another example, shader code might want to evaluate a complex function
(`do_general_path`) that can be greatly simplified when assuming a
specific value for one of its inputs (`do_fast_path`).

All functionality in this extension is superseded by the core Vulkan 1.1
[subgroup operations](../chapters/limits.html#VkPhysicalDeviceSubgroupProperties).

* 
`VK_EXT_SHADER_SUBGROUP_VOTE_EXTENSION_NAME`

* 
`VK_EXT_SHADER_SUBGROUP_VOTE_SPEC_VERSION`

* 
[`SubgroupVoteKHR`](spirvenv.html#spirvenv-capabilities-table-SubgroupVoteKHR)

* 
Revision 1, 2016-11-28 (Daniel Koch)

Initial draft

**Name String**

`VK_EXT_shader_viewport_index_layer`

**Extension Type**

Device extension

**Registered Extension Number**

163

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

None

**SPIR-V Dependencies**

* 
[SPV_EXT_shader_viewport_index_layer](https://github.khronos.org/SPIRV-Registry/extensions/EXT/SPV_EXT_shader_viewport_index_layer.html)

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.2](versions.html#versions-1.2-promotions)

**Contact**

* 
Daniel Koch [dgkoch](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_shader_viewport_index_layer] @dgkoch%0A*Here describe the issue or question you have about the VK_EXT_shader_viewport_index_layer extension*)

**Last Modified Date**

2017-08-08

**Interactions and External Dependencies**

* 
This extension provides API support for
[`GL_ARB_shader_viewport_layer_array`](https://registry.khronos.org/OpenGL/extensions/ARB/ARB_shader_viewport_layer_array.txt),
[`GL_AMD_vertex_shader_layer`](https://registry.khronos.org/OpenGL/extensions/AMD/AMD_vertex_shader_layer.txt),
[`GL_AMD_vertex_shader_viewport_index`](https://registry.khronos.org/OpenGL/extensions/AMD/AMD_vertex_shader_viewport_index.txt),
and [`GL_NV_viewport_array2`](https://registry.khronos.org/OpenGL/extensions/NV/NV_viewport_array2.txt)

* 
This extension requires the [    `multiViewport`](../chapters/features.html#features-multiViewport) feature.

* 
This extension interacts with the [    `tessellationShader`](../chapters/features.html#features-tessellationShader) feature.

**Contributors**

* 
Piers Daniell, NVIDIA

* 
Jeff Bolz, NVIDIA

* 
Jan-Harald Fredriksen, ARM

* 
Daniel Rakos, AMD

* 
Slawomir Grajeswki, Intel

This extension adds support for the `ShaderViewportIndexLayerEXT`
capability from the `SPV_EXT_shader_viewport_index_layer` extension in
Vulkan.

This extension allows variables decorated with the `Layer` and
`ViewportIndex` built-ins to be exported from vertex or tessellation
shaders, using the `ShaderViewportIndexLayerEXT` capability.

When using GLSL source-based shading languages, the `gl_ViewportIndex`
and `gl_Layer` built-in variables map to the SPIR-V `ViewportIndex`
and `Layer` built-in decorations, respectively.
Behavior of these variables is extended as described in the
`GL_ARB_shader_viewport_layer_array` (or the precursor
`GL_AMD_vertex_shader_layer`, `GL_AMD_vertex_shader_viewport_index`, and
`GL_NV_viewport_array2` extensions).

|  | The `ShaderViewportIndexLayerEXT` capability is equivalent to the
| --- | --- |
`ShaderViewportIndexLayerNV` capability added by
`[VK_NV_viewport_array2](#VK_NV_viewport_array2)`. |

All functionality in this extension is included in core Vulkan 1.2.

The single `ShaderViewportIndexLayerEXT` capability from the
`SPV_EXT_shader_viewport_index_layer` extension is replaced by the
[`ShaderViewportIndex`](spirvenv.html#spirvenv-capabilities-table-ShaderViewportIndex) and [`ShaderLayer`](spirvenv.html#spirvenv-capabilities-table-ShaderLayer) capabilities from SPIR-V 1.5 which are enabled by the
[`shaderOutputViewportIndex`](../chapters/features.html#features-shaderOutputViewportIndex) and
[`shaderOutputLayer`](../chapters/features.html#features-shaderOutputLayer) features,
respectively.
Additionally, if Vulkan 1.2 is supported but this extension is not, these
capabilities are optional.

Enabling both features is equivalent to enabling the
`VK_EXT_shader_viewport_index_layer` extension.

* 
`VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_EXTENSION_NAME`

* 
`VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_SPEC_VERSION`

* 
(modified) [`Layer`](../chapters/interfaces.html#interfaces-builtin-variables-layer)

* 
(modified)
[`ViewportIndex`](../chapters/interfaces.html#interfaces-builtin-variables-viewportindex)

* 
[    `ShaderViewportIndexLayerEXT`](spirvenv.html#spirvenv-capabilities-table-ShaderViewportIndexLayerEXT)

* 
Revision 1, 2017-08-08 (Daniel Koch)

Internal drafts

**Name String**

`VK_EXT_subgroup_size_control`

**Extension Type**

Device extension

**Registered Extension Number**

226

**Revision**

2

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[Vulkan Version 1.1](versions.html#versions-1.1)

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.3](versions.html#versions-1.3-promotions)

**Contact**

* 
Neil Henning [sheredom](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_subgroup_size_control] @sheredom%0A*Here describe the issue or question you have about the VK_EXT_subgroup_size_control extension*)

**Last Modified Date**

2019-03-05

**Contributors**

* 
Jeff Bolz, NVIDIA

* 
Faith Ekstrand, Intel

* 
Sawek Grajewski, Intel

* 
Jesse Hall, Google

* 
Neil Henning, AMD

* 
Daniel Koch, NVIDIA

* 
Jeff Leger, Qualcomm

* 
Graeme Leese, Broadcom

* 
Allan MacKinnon, Google

* 
Mariusz Merecki, Intel

* 
Graham Wihlidal, Electronic Arts

This extension enables an implementation to control the subgroup size by
allowing a varying subgroup size and also specifying a required subgroup
size.

It extends the subgroup support in Vulkan 1.1 to allow an implementation to
expose a varying subgroup size.
Previously Vulkan exposed a single subgroup size per physical device, with
the expectation that implementations will behave as if all subgroups have
the same size.
Some implementations **may** dispatch shaders with a varying subgroup size for
different subgroups.
As a result they could implicitly split a large subgroup into smaller
subgroups or represent a small subgroup as a larger subgroup, some of whose
invocations were inactive on launch.

To aid developers in understanding the performance characteristics of their
programs, this extension exposes a minimum and maximum subgroup size that a
physical device supports and a pipeline create flag to enable that pipeline
to vary its subgroup size.
If enabled, any `SubgroupSize` decorated variables in the SPIR-V shader
modules provided to pipeline creation **may** vary between the
[minimum](../chapters/devsandqueues.html#limits-minSubgroupSize) and [maximum](../chapters/devsandqueues.html#limits-maxSubgroupSize)
subgroup sizes.

An implementation is also optionally allowed to support specifying a
required subgroup size for a given pipeline stage.
Implementations advertise which [stages support a required subgroup size](../chapters/devsandqueues.html#limits-requiredSubgroupSizeStages), and any pipeline of a supported stage
can be passed a [VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT](../chapters/pipelines.html#VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT)
structure to set the subgroup size for that shader stage of the pipeline.
For compute shaders, this requires the developer to query the
[`maxComputeWorkgroupSubgroups`](../chapters/devsandqueues.html#limits-maxComputeWorkgroupSubgroups)
and ensure that:

  

  

Developers can also specify a new pipeline shader stage create flag that
requires the implementation to have fully populated subgroups within local
workgroups.
This requires the workgroup size in the X dimension to be a multiple of the
subgroup size.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceSubgroupSizeControlFeaturesEXT](../chapters/features.html#VkPhysicalDeviceSubgroupSizeControlFeaturesEXT)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceSubgroupSizeControlPropertiesEXT](../chapters/limits.html#VkPhysicalDeviceSubgroupSizeControlPropertiesEXT)

Extending [VkPipelineShaderStageCreateInfo](../chapters/pipelines.html#VkPipelineShaderStageCreateInfo), [VkShaderCreateInfoEXT](../chapters/shaders.html#VkShaderCreateInfoEXT):

* 
[VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT](../chapters/pipelines.html#VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT)

* 
`VK_EXT_SUBGROUP_SIZE_CONTROL_EXTENSION_NAME`

* 
`VK_EXT_SUBGROUP_SIZE_CONTROL_SPEC_VERSION`

* 
Extending [VkPipelineShaderStageCreateFlagBits](../chapters/pipelines.html#VkPipelineShaderStageCreateFlagBits):

`VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT`

* 
`VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT`

* 
`VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT`

Vulkan APIs in this extension are included in core Vulkan 1.3, with the EXT
suffix omitted.
External interactions defined by this extension, such as SPIR-V token names,
retain their original names.
The original Vulkan API names are still available as aliases of the core
functionality.

* 
Revision 1, 2019-03-05 (Neil Henning)

Initial draft

Revision 2, 2019-07-26 (Faith Ekstrand)

* 
Add the missing [VkPhysicalDeviceSubgroupSizeControlFeaturesEXT](../chapters/features.html#VkPhysicalDeviceSubgroupSizeControlFeaturesEXT)
for querying subgroup size control features.

**Name String**

`VK_EXT_texel_buffer_alignment`

**Extension Type**

Device extension

**Registered Extension Number**

282

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.3](versions.html#versions-1.3-promotions)

**Contact**

* 
Jeff Bolz [jeffbolznv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_texel_buffer_alignment] @jeffbolznv%0A*Here describe the issue or question you have about the VK_EXT_texel_buffer_alignment extension*)

**Last Modified Date**

2019-06-06

**IP Status**

No known IP claims.

**Contributors**

* 
Jeff Bolz, NVIDIA

This extension adds more expressive alignment requirements for uniform and
storage texel buffers.
Some implementations have single texel alignment requirements that cannot be
expressed via
[VkPhysicalDeviceLimits](../chapters/limits.html#VkPhysicalDeviceLimits)::`minTexelBufferOffsetAlignment`.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT](../chapters/features.html#VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT](../chapters/limits.html#VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT)

* 
`VK_EXT_TEXEL_BUFFER_ALIGNMENT_EXTENSION_NAME`

* 
`VK_EXT_TEXEL_BUFFER_ALIGNMENT_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT`

Vulkan APIs in this extension are included in core Vulkan 1.3, with the EXT
suffix omitted.
However, only the properties structure is promoted.
The feature structure is not promoted and `texelBufferAlignment` is
enabled if using a Vulkan 1.3 instance.
External interactions defined by this extension, such as SPIR-V token names,
retain their original names.
The original Vulkan API name is still available as an alias of the core
functionality.

* 
Revision 1, 2019-06-06 (Jeff Bolz)

Initial draft

**Name String**

`VK_EXT_texture_compression_astc_hdr`

**Extension Type**

Device extension

**Registered Extension Number**

67

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.3](versions.html#versions-1.3-promotions)

**Contact**

* 
Jan-Harald Fredriksen [janharaldfredriksen-arm](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_texture_compression_astc_hdr] @janharaldfredriksen-arm%0A*Here describe the issue or question you have about the VK_EXT_texture_compression_astc_hdr extension*)

**Last Modified Date**

2019-05-28

**IP Status**

No known issues.

**Contributors**

* 
Jan-Harald Fredriksen, Arm

This extension adds support for textures compressed using the Adaptive
Scalable Texture Compression (ASTC) High Dynamic Range (HDR) profile.

When this extension is enabled, the HDR profile is supported for all ASTC
formats listed in [ASTC Compressed Image Formats](compressedtex.html#appendix-compressedtex-astc).

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT](../chapters/features.html#VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT)

* 
`VK_EXT_TEXTURE_COMPRESSION_ASTC_HDR_EXTENSION_NAME`

* 
`VK_EXT_TEXTURE_COMPRESSION_ASTC_HDR_SPEC_VERSION`

* 
Extending [VkFormat](../chapters/formats.html#VkFormat):

`VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT`

* 
`VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT`

* 
`VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT`

* 
`VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT`

* 
`VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT`

* 
`VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT`

* 
`VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT`

* 
`VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT`

* 
`VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT`

* 
`VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT`

* 
`VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT`

* 
`VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT`

* 
`VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT`

* 
`VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT`

Vulkan APIs in this extension are included in core Vulkan 1.3, with the EXT
suffix omitted.
However, the feature is made optional in Vulkan 1.3.
External interactions defined by this extension, such as SPIR-V token names,
retain their original names.
The original Vulkan API names are still available as aliases of the core
functionality.

1) Should we add a feature or limit for this functionality?

Yes.
It is consistent with the ASTC LDR support to add a feature like
textureCompressionASTC_HDR.

The feature is strictly speaking redundant as long as this is just an
extension; it would be sufficient to just enable the extension.
But adding the feature is more forward-looking if wanted to make this an
optional core feature in the future.

2) Should we introduce new format enums for HDR?

Yes.
Vulkan 1.0 describes the ASTC format enums as UNORM, e.g.
`VK_FORMAT_ASTC_4x4_UNORM_BLOCK`, so it is confusing to make these
contain HDR data.
Note that the OpenGL (ES) extensions did not make this distinction because a
single ASTC HDR texture may contain both unorm and float blocks.
Implementations **may** not be able to distinguish between LDR and HDR ASTC
textures internally and just treat them as the same format, i.e. if this
extension is supported then sampling from a
`VK_FORMAT_ASTC_4x4_UNORM_BLOCK` image format **may** return HDR results.
Applications **can** get predictable results by using the appropriate image
format.

* 
Revision 1, 2019-05-28 (Jan-Harald Fredriksen)

Initial version

**Name String**

`VK_EXT_tooling_info`

**Extension Type**

Device extension

**Registered Extension Number**

246

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

None

**API Interactions**

* 
Interacts with VK_EXT_debug_marker

* 
Interacts with VK_EXT_debug_report

* 
Interacts with VK_EXT_debug_utils

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.3](versions.html#versions-1.3-promotions)

**Contact**

* 
Tobias Hector [tobski](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_tooling_info] @tobski%0A*Here describe the issue or question you have about the VK_EXT_tooling_info extension*)

**Last Modified Date**

2018-11-05

**Contributors**

* 
Rolando Caloca

* 
Matthaeus Chajdas

* 
Baldur Karlsson

* 
Daniel Rakos

When an error occurs during application development, a common question is
"What tools are actually running right now?" This extension adds the ability
to query that information directly from the Vulkan implementation.

Outdated versions of one tool might not play nicely with another, or perhaps
a tool is not actually running when it should have been.
Trying to figure that out can cause headaches as it is necessary to consult
each known tool to figure out what is going onin some cases the tool
might not even be known.

Typically, the expectation is that developers will simply print out this
information for visual inspection when an issue occurs, however a small
amount of semantic information about what the tool is doing is provided to
help identify it programmatically.
For example, if the advertised limits or features of an implementation are
unexpected, is there a tool active which modifies these limits? Or if an
application is providing debug markers, but the implementation is not
actually doing anything with that information, this can quickly point that
out.

* 
[vkGetPhysicalDeviceToolPropertiesEXT](../chapters/debugging.html#vkGetPhysicalDeviceToolPropertiesEXT)

* 
[VkPhysicalDeviceToolPropertiesEXT](../chapters/debugging.html#VkPhysicalDeviceToolPropertiesEXT)

* 
[VkToolPurposeFlagBitsEXT](../chapters/debugging.html#VkToolPurposeFlagBitsEXT)

* 
[VkToolPurposeFlagsEXT](../chapters/debugging.html#VkToolPurposeFlagsEXT)

* 
`VK_EXT_TOOLING_INFO_EXTENSION_NAME`

* 
`VK_EXT_TOOLING_INFO_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES_EXT`

Extending [VkToolPurposeFlagBits](../chapters/debugging.html#VkToolPurposeFlagBits):

* 
`VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT_EXT`

* 
`VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT_EXT`

* 
`VK_TOOL_PURPOSE_PROFILING_BIT_EXT`

* 
`VK_TOOL_PURPOSE_TRACING_BIT_EXT`

* 
`VK_TOOL_PURPOSE_VALIDATION_BIT_EXT`

If [VK_EXT_debug_marker](#VK_EXT_debug_marker) is supported:

* 
Extending [VkToolPurposeFlagBits](../chapters/debugging.html#VkToolPurposeFlagBits):

`VK_TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT`

If [VK_EXT_debug_report](#VK_EXT_debug_report) is supported:

* 
Extending [VkToolPurposeFlagBits](../chapters/debugging.html#VkToolPurposeFlagBits):

`VK_TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT`

If [VK_EXT_debug_utils](#VK_EXT_debug_utils) is supported:

* 
Extending [VkToolPurposeFlagBits](../chapters/debugging.html#VkToolPurposeFlagBits):

`VK_TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT`

* 
`VK_TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT`

Vulkan APIs in this extension are included in core Vulkan 1.3, with the EXT
suffix omitted.
External interactions defined by this extension, such as SPIR-V token names,
retain their original names.
The original Vulkan API names are still available as aliases of the core
functionality.

Printing Tool Information

uint32_t num_tools;
VkPhysicalDeviceToolPropertiesEXT *pToolProperties;
vkGetPhysicalDeviceToolPropertiesEXT(physicalDevice, &num_tools, NULL);

pToolProperties = (VkPhysicalDeviceToolPropertiesEXT*)malloc(sizeof(VkPhysicalDeviceToolPropertiesEXT) * num_tools);

vkGetPhysicalDeviceToolPropertiesEXT(physicalDevice, &num_tools, pToolProperties);

for (int i = 0; i  0) {
        printf("Corresponding Layer:\n");
        printf("\t%s\n", pToolProperties[i].layer);
    }
}

1) Why is this information separate from the layer mechanism?

Some tooling may be built into a driver, or be part of the Vulkan loader
etc.
Tying this information directly to layers would have been awkward at best.

* 
Revision 1, 2018-11-05 (Tobias Hector)

Initial draft

**Name String**

`VK_EXT_validation_features`

**Extension Type**

Instance extension

**Registered Extension Number**

248

**Revision**

6

**Ratification Status**

Ratified

**Extension and Version Dependencies**

None

**Deprecation State**

* 
*Deprecated* by
[VK_EXT_layer_settings](#VK_EXT_layer_settings)
extension

**Special Use**

* 
[Debugging tools](../chapters/extensions.html#extendingvulkan-compatibility-specialuse)

**Contact**

* 
Karl Schultz [karl-lunarg](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_validation_features] @karl-lunarg%0A*Here describe the issue or question you have about the VK_EXT_validation_features extension*)

**Last Modified Date**

2018-11-14

**IP Status**

No known IP claims.

**Contributors**

* 
Karl Schultz, LunarG

* 
Dave Houlton, LunarG

* 
Mark Lobodzinski, LunarG

* 
Camden Stocker, LunarG

* 
Tony Barbour, LunarG

* 
John Zulauf, LunarG

This extension provides the [VkValidationFeaturesEXT](../chapters/initialization.html#VkValidationFeaturesEXT) structure that can
be included in the `pNext` chain of the [VkInstanceCreateInfo](../chapters/initialization.html#VkInstanceCreateInfo)
structure passed as the `pCreateInfo` parameter of
[vkCreateInstance](../chapters/initialization.html#vkCreateInstance).
The structure contains an array of [VkValidationFeatureEnableEXT](../chapters/initialization.html#VkValidationFeatureEnableEXT) enum
values that enable specific validation features that are disabled by
default.
The structure also contains an array of [VkValidationFeatureDisableEXT](../chapters/initialization.html#VkValidationFeatureDisableEXT)
enum values that disable specific validation layer features that are enabled
by default.

Functionality in this extension is subsumed into the
`[VK_EXT_layer_settings](#VK_EXT_layer_settings)` extension.

* 
Extending [VkInstanceCreateInfo](../chapters/initialization.html#VkInstanceCreateInfo), [VkShaderModuleCreateInfo](../chapters/shaders.html#VkShaderModuleCreateInfo), [VkShaderCreateInfoEXT](../chapters/shaders.html#VkShaderCreateInfoEXT):

[VkValidationFeaturesEXT](../chapters/initialization.html#VkValidationFeaturesEXT)

* 
[VkValidationFeatureDisableEXT](../chapters/initialization.html#VkValidationFeatureDisableEXT)

* 
[VkValidationFeatureEnableEXT](../chapters/initialization.html#VkValidationFeatureEnableEXT)

* 
`VK_EXT_VALIDATION_FEATURES_EXTENSION_NAME`

* 
`VK_EXT_VALIDATION_FEATURES_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT`

* 
Revision 1, 2018-11-14 (Karl Schultz)

Initial revision

Revision 2, 2019-08-06 (Mark Lobodzinski)

* 
Add Best Practices enable

Revision 3, 2020-03-04 (Tony Barbour)

* 
Add Debug Printf enable

Revision 4, 2020-07-29 (John Zulauf)

* 
Add Synchronization Validation enable

Revision 5, 2021-05-18 (Tony Barbour)

* 
Add Shader Validation Cache disable

Revision 6, 2023-09-25 (Christophe Riccio)

* 
Marked as deprecated by VK_EXT_layer_settings

**Name String**

`VK_EXT_validation_flags`

**Extension Type**

Instance extension

**Registered Extension Number**

62

**Revision**

3

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

None

**Deprecation State**

* 
*Deprecated* by
[VK_EXT_layer_settings](#VK_EXT_layer_settings)
extension

**Special Use**

* 
[Debugging tools](../chapters/extensions.html#extendingvulkan-compatibility-specialuse)

**Contact**

* 
Tobin Ehlis [tobine](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_validation_flags] @tobine%0A*Here describe the issue or question you have about the VK_EXT_validation_flags extension*)

**Last Modified Date**

2019-08-19

**IP Status**

No known IP claims.

**Contributors**

* 
Tobin Ehlis, Google

* 
Courtney Goeltzenleuchter, Google

This extension provides the [VkValidationFlagsEXT](../chapters/initialization.html#VkValidationFlagsEXT) structure that can be
included in the `pNext` chain of the [VkInstanceCreateInfo](../chapters/initialization.html#VkInstanceCreateInfo)
structure passed as the `pCreateInfo` parameter of
[vkCreateInstance](../chapters/initialization.html#vkCreateInstance).
The structure contains an array of [VkValidationCheckEXT](../chapters/initialization.html#VkValidationCheckEXT) values that
will be disabled by the validation layers.

Functionality in this extension is subsumed into the
`[VK_EXT_layer_settings](#VK_EXT_layer_settings)` extension.

* 
Extending [VkInstanceCreateInfo](../chapters/initialization.html#VkInstanceCreateInfo):

[VkValidationFlagsEXT](../chapters/initialization.html#VkValidationFlagsEXT)

* 
[VkValidationCheckEXT](../chapters/initialization.html#VkValidationCheckEXT)

* 
`VK_EXT_VALIDATION_FLAGS_EXTENSION_NAME`

* 
`VK_EXT_VALIDATION_FLAGS_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT`

* 
Revision 3, 2023-09-25 (Christophe Riccio)

Marked as deprecated by VK_EXT_layer_settings

Revision 2, 2019-08-19 (Mark Lobodzinski)

* 
Marked as deprecated by VK_EXT_validation_features

Revision 1, 2016-08-26 (Courtney Goeltzenleuchter)

* 
Initial draft

**Name String**

`VK_EXT_vertex_attribute_divisor`

**Extension Type**

Device extension

**Registered Extension Number**

191

**Revision**

3

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Deprecation State**

* 
*Promoted* to
[VK_KHR_vertex_attribute_divisor](#VK_KHR_vertex_attribute_divisor)
extension

Which in turn was *promoted* to
[Vulkan 1.4](versions.html#versions-1.4-promotions)

**Contact**

* 
Vikram Kushwaha [vkushwaha](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_vertex_attribute_divisor] @vkushwaha%0A*Here describe the issue or question you have about the VK_EXT_vertex_attribute_divisor extension*)

**Last Modified Date**

2018-08-03

**IP Status**

No known IP claims.

**Contributors**

* 
Vikram Kushwaha, NVIDIA

* 
Faith Ekstrand, Intel

This extension allows instance-rate vertex attributes to be repeated for
certain number of instances instead of advancing for every instance when
instanced rendering is enabled.

* 
[VkVertexInputBindingDivisorDescriptionEXT](../chapters/fxvertex.html#VkVertexInputBindingDivisorDescriptionEXT)

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT](../chapters/features.html#VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT](../chapters/limits.html#VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT)

Extending [VkPipelineVertexInputStateCreateInfo](../chapters/fxvertex.html#VkPipelineVertexInputStateCreateInfo):

* 
[VkPipelineVertexInputDivisorStateCreateInfoEXT](../chapters/fxvertex.html#VkPipelineVertexInputDivisorStateCreateInfoEXT)

* 
`VK_EXT_VERTEX_ATTRIBUTE_DIVISOR_EXTENSION_NAME`

* 
`VK_EXT_VERTEX_ATTRIBUTE_DIVISOR_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT`

* 
`VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT`

1) What is the effect of a non-zero value for `firstInstance`?

**RESOLVED**: The Vulkan API should follow the OpenGL convention and offset
attribute fetching by `firstInstance` while computing vertex attribute
offsets.

2) Should zero be an allowed divisor?

**RESOLVED**: Yes.
A zero divisor means the vertex attribute is repeated for all instances.

To create a vertex binding such that the first binding uses instanced
rendering and the same attribute is used for every 4 draw instances, an
application could use the following set of structures:

    const VkVertexInputBindingDivisorDescriptionEXT divisorDesc =
    {
        .binding = 0,
        .divisor = 4
    };

    const VkPipelineVertexInputDivisorStateCreateInfoEXT divisorInfo =
    {
        .sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT,
        .pNext = NULL,
        .vertexBindingDivisorCount = 1,
        .pVertexBindingDivisors = &divisorDesc
    }

    const VkVertexInputBindingDescription binding =
    {
        .binding = 0,
        .stride = sizeof(Vertex),
        .inputRate = VK_VERTEX_INPUT_RATE_INSTANCE
    };

    const VkPipelineVertexInputStateCreateInfo viInfo =
    {
        .sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_CREATE_INFO,
        .pNext = &divisorInfo,
        ...
    };
    //...

* 
Revision 1, 2017-12-04 (Vikram Kushwaha)

First Version

Revision 2, 2018-07-16 (Faith Ekstrand)

* 
Adjust the interaction between `divisor` and `firstInstance` to
match the OpenGL convention.

* 
Disallow divisors of zero.

Revision 3, 2018-08-03 (Vikram Kushwaha)

* 
Allow a zero divisor.

* 
Add a physical device features structure to query/enable this feature.

**Name String**

`VK_EXT_ycbcr_2plane_444_formats`

**Extension Type**

Device extension

**Registered Extension Number**

331

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_sampler_ycbcr_conversion](#VK_KHR_sampler_ycbcr_conversion)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Deprecation State**

* 
*Promoted* to
[Vulkan 1.3](versions.html#versions-1.3-promotions)

**Contact**

* 
Tony Zlatinski [tzlatinski](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_EXT_ycbcr_2plane_444_formats] @tzlatinski%0A*Here describe the issue or question you have about the VK_EXT_ycbcr_2plane_444_formats extension*)

**Last Modified Date**

2020-07-28

**IP Status**

No known IP claims.

**Contributors**

* 
Piers Daniell, NVIDIA

* 
Ping Liu, Intel

This extension adds some YCBCR formats that are in common use for video
encode and decode, but were not part of the
`[VK_KHR_sampler_ycbcr_conversion](#VK_KHR_sampler_ycbcr_conversion)` extension.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT](../chapters/features.html#VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT)

* 
`VK_EXT_YCBCR_2PLANE_444_FORMATS_EXTENSION_NAME`

* 
`VK_EXT_YCBCR_2PLANE_444_FORMATS_SPEC_VERSION`

* 
Extending [VkFormat](../chapters/formats.html#VkFormat):

`VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16_EXT`

* 
`VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16_EXT`

* 
`VK_FORMAT_G16_B16R16_2PLANE_444_UNORM_EXT`

* 
`VK_FORMAT_G8_B8R8_2PLANE_444_UNORM_EXT`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT`

The format enumerants introduced by the extension are included in core
Vulkan 1.3, with the EXT suffix omitted.
However, runtime support for these formats is optional in core Vulkan 1.3,
while if this extension is supported, runtime support is mandatory.
The feature structure is not promoted.
The original enum names are still available as aliases of the core
functionality.

* 
Revision 1, 2020-03-08 (Piers Daniell)

Initial draft

**Name String**

`VK_AMD_draw_indirect_count`

**Extension Type**

Device extension

**Registered Extension Number**

34

**Revision**

2

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

None

**Deprecation State**

* 
*Promoted* to
[VK_KHR_draw_indirect_count](#VK_KHR_draw_indirect_count)
extension

Which in turn was *promoted* to
[Vulkan 1.2](versions.html#versions-1.2-promotions)

**Contact**

* 
Daniel Rakos [drakos-amd](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_AMD_draw_indirect_count] @drakos-amd%0A*Here describe the issue or question you have about the VK_AMD_draw_indirect_count extension*)

**Last Modified Date**

2016-08-23

**IP Status**

No known IP claims.

**Contributors**

* 
Matthaeus G. Chajdas, AMD

* 
Derrick Owens, AMD

* 
Graham Sellers, AMD

* 
Daniel Rakos, AMD

* 
Dominik Witczak, AMD

This extension allows an application to source the number of draws for
indirect drawing commands from a buffer.
This enables applications to generate an arbitrary number of drawing
commands and execute them without host intervention.

All functionality in this extension is included in
`[VK_KHR_draw_indirect_count](#VK_KHR_draw_indirect_count)`, with the suffix changed to KHR.
The original type, enum, and command names are still available as aliases of
the core functionality.

* 
[vkCmdDrawIndexedIndirectCountAMD](../chapters/drawing.html#vkCmdDrawIndexedIndirectCountAMD)

* 
[vkCmdDrawIndirectCountAMD](../chapters/drawing.html#vkCmdDrawIndirectCountAMD)

* 
`VK_AMD_DRAW_INDIRECT_COUNT_EXTENSION_NAME`

* 
`VK_AMD_DRAW_INDIRECT_COUNT_SPEC_VERSION`

* 
Revision 2, 2016-08-23 (Dominik Witczak)

Minor fixes

Revision 1, 2016-07-21 (Matthaeus Chajdas)

* 
Initial draft

**Name String**

`VK_AMD_gpu_shader_half_float`

**Extension Type**

Device extension

**Registered Extension Number**

37

**Revision**

2

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

None

**SPIR-V Dependencies**

* 
[SPV_AMD_gpu_shader_half_float](https://github.khronos.org/SPIRV-Registry/extensions/AMD/SPV_AMD_gpu_shader_half_float.html)

**Deprecation State**

* 
*Deprecated* by
[VK_KHR_shader_float16_int8](#VK_KHR_shader_float16_int8)
extension

Which in turn was *promoted* to
[Vulkan 1.2](versions.html#versions-1.2-promotions)

**Contact**

* 
Dominik Witczak [dominikwitczakamd](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_AMD_gpu_shader_half_float] @dominikwitczakamd%0A*Here describe the issue or question you have about the VK_AMD_gpu_shader_half_float extension*)

**Last Modified Date**

2019-04-11

**IP Status**

No known IP claims.

**Interactions and External Dependencies**

* 
This extension provides API support for
[`GL_AMD_gpu_shader_half_float`](https://registry.khronos.org/OpenGL/extensions/AMD/AMD_gpu_shader_half_float.txt)

**Contributors**

* 
Daniel Rakos, AMD

* 
Dominik Witczak, AMD

* 
Donglin Wei, AMD

* 
Graham Sellers, AMD

* 
Qun Lin, AMD

* 
Rex Xu, AMD

This extension adds support for using half float variables in shaders.

Functionality in this extension is included in the
`[VK_KHR_shader_float16_int8](#VK_KHR_shader_float16_int8)` extension, when the
[`shaderFloat16`](../chapters/features.html#features-shaderFloat16) feature is enabled.

* 
`VK_AMD_GPU_SHADER_HALF_FLOAT_EXTENSION_NAME`

* 
`VK_AMD_GPU_SHADER_HALF_FLOAT_SPEC_VERSION`

* 
Revision 2, 2019-04-11 (Tobias Hector)

Marked as deprecated

Revision 1, 2016-09-21 (Dominik Witczak)

* 
Initial draft

**Name String**

`VK_AMD_gpu_shader_int16`

**Extension Type**

Device extension

**Registered Extension Number**

133

**Revision**

2

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

None

**SPIR-V Dependencies**

* 
[SPV_AMD_gpu_shader_int16](https://github.khronos.org/SPIRV-Registry/extensions/AMD/SPV_AMD_gpu_shader_int16.html)

**Deprecation State**

* 
*Deprecated* by
[VK_KHR_shader_float16_int8](#VK_KHR_shader_float16_int8)
extension

Which in turn was *promoted* to
[Vulkan 1.2](versions.html#versions-1.2-promotions)

**Contact**

* 
Qun Lin [linqun](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_AMD_gpu_shader_int16] @linqun%0A*Here describe the issue or question you have about the VK_AMD_gpu_shader_int16 extension*)

**Last Modified Date**

2019-04-11

**IP Status**

No known IP claims.

**Interactions and External Dependencies**

* 
This extension provides API support for
[`GL_AMD_gpu_shader_int16`](https://registry.khronos.org/OpenGL/extensions/AMD/AMD_gpu_shader_int16.txt)

**Contributors**

* 
Daniel Rakos, AMD

* 
Dominik Witczak, AMD

* 
Matthaeus G. Chajdas, AMD

* 
Rex Xu, AMD

* 
Timothy Lottes, AMD

* 
Zhi Cai, AMD

This extension adds support for using 16-bit integer variables in shaders.

Functionality in this extension is included in the
`[VK_KHR_shader_float16_int8](#VK_KHR_shader_float16_int8)` extension, when the
[`shaderInt16`](../chapters/features.html#features-shaderInt16) and [`shaderFloat16`](../chapters/features.html#features-shaderFloat16) features are enabled.

* 
`VK_AMD_GPU_SHADER_INT16_EXTENSION_NAME`

* 
`VK_AMD_GPU_SHADER_INT16_SPEC_VERSION`

* 
Revision 2, 2019-04-11 (Tobias Hector)

Marked as deprecated

Revision 1, 2017-06-18 (Dominik Witczak)

* 
First version

**Name String**

`VK_AMD_negative_viewport_height`

**Extension Type**

Device extension

**Registered Extension Number**

36

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

None

**Deprecation State**

* 
*Obsoleted* by
[VK_KHR_maintenance1](#VK_KHR_maintenance1)
extension

Which in turn was *promoted* to
[Vulkan 1.1](versions.html#versions-1.1-promotions)

**Contact**

* 
Matthaeus G. Chajdas [anteru](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_AMD_negative_viewport_height] @anteru%0A*Here describe the issue or question you have about the VK_AMD_negative_viewport_height extension*)

**Last Modified Date**

2016-09-02

**IP Status**

No known IP claims.

**Contributors**

* 
Matthaeus G. Chajdas, AMD

* 
Graham Sellers, AMD

* 
Baldur Karlsson

This extension allows an application to specify a negative viewport height.
The result is that the viewport transformation will flip along the y-axis.

* 
Allow negative height to be specified in the
[VkViewport](../chapters/vertexpostproc.html#VkViewport)::`height` field to perform y-inversion of the
clip-space to framebuffer-space transform.
This allows apps to avoid having to use `gl_Position.y = -gl_Position.y`
in shaders also targeting other APIs.

Functionality in this extension is included in the
`[VK_KHR_maintenance1](#VK_KHR_maintenance1)` extension and subsequently Vulkan 1.1.
Due to some slight behavioral differences, this extension **must** not be
enabled alongside `VK_KHR_maintenance1`, or in an instance created with
version 1.1 or later requested in [VkApplicationInfo](../chapters/initialization.html#VkApplicationInfo)::`apiVersion`.

* 
`VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_EXTENSION_NAME`

* 
`VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_SPEC_VERSION`

* 
Revision 1, 2016-09-02 (Matthaeus Chajdas)

Initial draft

**Name String**

`VK_ARM_rasterization_order_attachment_access`

**Extension Type**

Device extension

**Registered Extension Number**

343

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**Deprecation State**

* 
*Promoted* to
[VK_EXT_rasterization_order_attachment_access](#VK_EXT_rasterization_order_attachment_access)
extension

**Contact**

* 
Jan-Harald Fredriksen [janharaldfredriksen-arm](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_ARM_rasterization_order_attachment_access] @janharaldfredriksen-arm%0A*Here describe the issue or question you have about the VK_ARM_rasterization_order_attachment_access extension*)

**Last Modified Date**

2021-11-12

**IP Status**

No known IP claims.

**Contributors**

* 
Tobias Hector, AMD

* 
Jan-Harald Fredriksen, Arm

Render passes, and specifically subpass dependencies, enable much of the
same functionality as the framebuffer fetch and pixel local storage
extensions did for OpenGL ES.
But certain techniques such as programmable blending are awkward or
impractical to implement with these alone, in part because a self-dependency
is required every time a fragment will read a value at a given sample
coordinate.

This extension extends the mechanism of input attachments to allow access to
framebuffer attachments when used as both input and color, or depth/stencil,
attachments from one fragment to the next, in rasterization order, without
explicit synchronization.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM](../chapters/features.html#VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM)

* 
`VK_ARM_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_EXTENSION_NAME`

* 
`VK_ARM_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_SPEC_VERSION`

* 
Extending [VkPipelineColorBlendStateCreateFlagBits](../chapters/framebuffer.html#VkPipelineColorBlendStateCreateFlagBits):

`VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_ARM`

Extending [VkPipelineDepthStencilStateCreateFlagBits](../chapters/fragops.html#VkPipelineDepthStencilStateCreateFlagBits):

* 
`VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM`

* 
`VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_ARM`

Extending [VkSubpassDescriptionFlagBits](../chapters/renderpass.html#VkSubpassDescriptionFlagBits):

* 
`VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_ARM`

* 
`VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM`

* 
`VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM`

1) Is there any interaction with the `[VK_KHR_dynamic_rendering](#VK_KHR_dynamic_rendering)`
extension?

No.
This extension only affects reads from input attachments.
Render pass instances begun with [vkCmdBeginRenderingKHR](../chapters/renderpass.html#vkCmdBeginRenderingKHR) do not have
input attachments and a different mechanism will be needed to provide
similar functionality in this case.

None.

* 
Revision 1, 2021-11-12 (Jan-Harald Fredriksen)

Initial draft

**Name String**

`VK_IMG_format_pvrtc`

**Extension Type**

Device extension

**Registered Extension Number**

55

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

None

**Deprecation State**

* 
*Deprecated* without replacement

**Contact**

* 
Stuart Smith

**Last Modified Date**

2019-09-02

**IP Status**

Imagination Technologies Proprietary

**Contributors**

* 
Stuart Smith, Imagination Technologies

`VK_IMG_format_pvrtc` provides additional texture compression functionality
specific to Imagination Technologies PowerVR Texture compression format
(called PVRTC).

|  | As also noted in the [Khronos Data Format Specification](../chapters/introduction.html#data-format),
| --- | --- |
PVRTC1 images must have dimensions that are a power of two. |

Both PVRTC1 and PVRTC2 are slower than standard image formats on PowerVR
GPUs, and support will be removed from future hardware.

* 
`VK_IMG_FORMAT_PVRTC_EXTENSION_NAME`

* 
`VK_IMG_FORMAT_PVRTC_SPEC_VERSION`

* 
Extending [VkFormat](../chapters/formats.html#VkFormat):

`VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG`

* 
`VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG`

* 
`VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG`

* 
`VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG`

* 
`VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG`

* 
`VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG`

* 
`VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG`

* 
`VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG`

* 
Revision 1, 2019-09-02 (Stuart Smith)

Initial version

**Name String**

`VK_MVK_ios_surface`

**Extension Type**

Instance extension

**Registered Extension Number**

123

**Revision**

3

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_surface](#VK_KHR_surface)

**Deprecation State**

* 
*Deprecated* by
[VK_EXT_metal_surface](#VK_EXT_metal_surface)
extension

**Contact**

* 
Bill Hollings [billhollings](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_MVK_ios_surface] @billhollings%0A*Here describe the issue or question you have about the VK_MVK_ios_surface extension*)

**Last Modified Date**

2020-07-31

**IP Status**

No known IP claims.

**Contributors**

* 
Bill Hollings, The Brenwill Workshop Ltd.

The `VK_MVK_ios_surface` extension is an instance extension.
It provides a mechanism to create a [VkSurfaceKHR](../chapters/VK_KHR_surface/wsi.html#VkSurfaceKHR) object (defined by
the `[VK_KHR_surface](#VK_KHR_surface)` extension) based on a `UIView`, the native
surface type of iOS, which is underpinned by a `CAMetalLayer`, to
support rendering to the surface using Apples Metal framework.

The `VK_MVK_ios_surface` extension is considered deprecated and has been
superseded by the `[VK_EXT_metal_surface](#VK_EXT_metal_surface)` extension.

* 
[vkCreateIOSSurfaceMVK](../chapters/VK_KHR_surface/wsi.html#vkCreateIOSSurfaceMVK)

* 
[VkIOSSurfaceCreateInfoMVK](../chapters/VK_KHR_surface/wsi.html#VkIOSSurfaceCreateInfoMVK)

* 
[VkIOSSurfaceCreateFlagsMVK](../chapters/VK_KHR_surface/wsi.html#VkIOSSurfaceCreateFlagsMVK)

* 
`VK_MVK_IOS_SURFACE_EXTENSION_NAME`

* 
`VK_MVK_IOS_SURFACE_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK`

* 
Revision 1, 2017-02-15 (Bill Hollings)

Initial draft.

Revision 2, 2017-02-24 (Bill Hollings)

* 
Minor syntax fix to emphasize firm requirement for `UIView` to be
backed by a `CAMetalLayer`.

Revision 3, 2020-07-31 (Bill Hollings)

* 
Update documentation on requirements for `UIView`.

* 
Mark as deprecated by `VK_EXT_metal_surface`.

**Name String**

`VK_MVK_macos_surface`

**Extension Type**

Instance extension

**Registered Extension Number**

124

**Revision**

3

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_surface](#VK_KHR_surface)

**Deprecation State**

* 
*Deprecated* by
[VK_EXT_metal_surface](#VK_EXT_metal_surface)
extension

**Contact**

* 
Bill Hollings [billhollings](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_MVK_macos_surface] @billhollings%0A*Here describe the issue or question you have about the VK_MVK_macos_surface extension*)

**Last Modified Date**

2020-07-31

**IP Status**

No known IP claims.

**Contributors**

* 
Bill Hollings, The Brenwill Workshop Ltd.

The `VK_MVK_macos_surface` extension is an instance extension.
It provides a mechanism to create a [VkSurfaceKHR](../chapters/VK_KHR_surface/wsi.html#VkSurfaceKHR) object (defined by
the `[VK_KHR_surface](#VK_KHR_surface)` extension) based on an `NSView`, the native
surface type of macOS, which is underpinned by a `CAMetalLayer`, to
support rendering to the surface using Apples Metal framework.

The `VK_MVK_macos_surface` extension is considered deprecated and has been
superseded by the `[VK_EXT_metal_surface](#VK_EXT_metal_surface)` extension.

* 
[vkCreateMacOSSurfaceMVK](../chapters/VK_KHR_surface/wsi.html#vkCreateMacOSSurfaceMVK)

* 
[VkMacOSSurfaceCreateInfoMVK](../chapters/VK_KHR_surface/wsi.html#VkMacOSSurfaceCreateInfoMVK)

* 
[VkMacOSSurfaceCreateFlagsMVK](../chapters/VK_KHR_surface/wsi.html#VkMacOSSurfaceCreateFlagsMVK)

* 
`VK_MVK_MACOS_SURFACE_EXTENSION_NAME`

* 
`VK_MVK_MACOS_SURFACE_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK`

* 
Revision 1, 2017-02-15 (Bill Hollings)

Initial draft.

Revision 2, 2017-02-24 (Bill Hollings)

* 
Minor syntax fix to emphasize firm requirement for `NSView` to be
backed by a `CAMetalLayer`.

Revision 3, 2020-07-31 (Bill Hollings)

* 
Update documentation on requirements for `NSView`.

* 
Mark as deprecated by `VK_EXT_metal_surface`.

**Name String**

`VK_NV_compute_shader_derivatives`

**Extension Type**

Device extension

**Registered Extension Number**

202

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**SPIR-V Dependencies**

* 
[SPV_NV_compute_shader_derivatives](https://github.khronos.org/SPIRV-Registry/extensions/NV/SPV_NV_compute_shader_derivatives.html)

**Deprecation State**

* 
*Promoted* to
[VK_KHR_compute_shader_derivatives](#VK_KHR_compute_shader_derivatives)
extension

**Contact**

* 
Pat Brown [nvpbrown](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NV_compute_shader_derivatives] @nvpbrown%0A*Here describe the issue or question you have about the VK_NV_compute_shader_derivatives extension*)

**Last Modified Date**

2018-07-19

**IP Status**

No known IP claims.

**Interactions and External Dependencies**

* 
This extension provides API support for
[`GL_NV_compute_shader_derivatives`](https://github.com/KhronosGroup/GLSL/blob/main/extensions/nv/GLSL_NV_compute_shader_derivatives.txt)

**Contributors**

* 
Pat Brown, NVIDIA

This extension adds Vulkan support for the
[`SPV_NV_compute_shader_derivatives`](https://github.khronos.org/SPIRV-Registry/extensions/NV/SPV_NV_compute_shader_derivatives.html)
SPIR-V extension.

The SPIR-V extension provides two new execution modes, both of which allow
compute shaders to use built-ins that evaluate compute derivatives
explicitly or implicitly.
Derivatives will be computed via differencing over a 2x2 group of shader
invocations.
The `DerivativeGroupQuadsNV` execution mode assembles shader invocations
into 2x2 groups, where each group has x and y coordinates of the local
invocation ID of the form (2m+{0,1}, 2n+{0,1}).
The `DerivativeGroupLinearNV` execution mode assembles shader invocations
into 2x2 groups, where each group has local invocation index values of the
form 4m+{0,1,2,3}.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceComputeShaderDerivativesFeaturesNV](../chapters/features.html#VkPhysicalDeviceComputeShaderDerivativesFeaturesNV)

* 
`VK_NV_COMPUTE_SHADER_DERIVATIVES_EXTENSION_NAME`

* 
`VK_NV_COMPUTE_SHADER_DERIVATIVES_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV`

* 
[    `ComputeDerivativeGroupQuadsNV`](spirvenv.html#spirvenv-capabilities-table-ComputeDerivativeGroupQuadsKHR)

* 
[    `ComputeDerivativeGroupLinearNV`](spirvenv.html#spirvenv-capabilities-table-ComputeDerivativeGroupLinearKHR)

(1) Should we specify that the groups of four shader invocations used for
derivatives in a compute shader are the same groups of four invocations that
form a quad in shader subgroups?

**RESOLVED**: Yes.

None.

* 
Revision 1, 2018-07-19 (Pat Brown)

Initial draft

**Name String**

`VK_NV_dedicated_allocation`

**Extension Type**

Device extension

**Registered Extension Number**

27

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

None

**Deprecation State**

* 
*Deprecated* by
[VK_KHR_dedicated_allocation](#VK_KHR_dedicated_allocation)
extension

Which in turn was *promoted* to
[Vulkan 1.1](versions.html#versions-1.1-promotions)

**Contact**

* 
Jeff Bolz [jeffbolznv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NV_dedicated_allocation] @jeffbolznv%0A*Here describe the issue or question you have about the VK_NV_dedicated_allocation extension*)

**Last Modified Date**

2016-05-31

**IP Status**

No known IP claims.

**Contributors**

* 
Jeff Bolz, NVIDIA

This extension allows device memory to be allocated for a particular buffer
or image resource, which on some devices can significantly improve the
performance of that resource.
Normal device memory allocations must support memory aliasing and sparse
binding, which could interfere with optimizations like framebuffer
compression or efficient page table usage.
This is important for render targets and very large resources, but need not
(and probably should not) be used for smaller resources that can benefit
from suballocation.

This extension adds a few small structures to resource creation and memory
allocation: a new structure that flags whether am image/buffer will have a
dedicated allocation, and a structure indicating the image or buffer that an
allocation will be bound to.

* 
Extending [VkBufferCreateInfo](../chapters/resources.html#VkBufferCreateInfo):

[VkDedicatedAllocationBufferCreateInfoNV](../chapters/resources.html#VkDedicatedAllocationBufferCreateInfoNV)

Extending [VkImageCreateInfo](../chapters/resources.html#VkImageCreateInfo):

* 
[VkDedicatedAllocationImageCreateInfoNV](../chapters/resources.html#VkDedicatedAllocationImageCreateInfoNV)

Extending [VkMemoryAllocateInfo](../chapters/memory.html#VkMemoryAllocateInfo):

* 
[VkDedicatedAllocationMemoryAllocateInfoNV](../chapters/memory.html#VkDedicatedAllocationMemoryAllocateInfoNV)

* 
`VK_NV_DEDICATED_ALLOCATION_EXTENSION_NAME`

* 
`VK_NV_DEDICATED_ALLOCATION_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV`

* 
`VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV`

* 
`VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV`

    // Create an image with
    // VkDedicatedAllocationImageCreateInfoNV::dedicatedAllocation
    // set to VK_TRUE

    VkDedicatedAllocationImageCreateInfoNV dedicatedImageInfo =
    {
        .sType = VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV,
        .pNext = NULL,
        .dedicatedAllocation = VK_TRUE,
    };

    VkImageCreateInfo imageCreateInfo =
    {
        .sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,
        .pNext = &dedicatedImageInfo
        // Other members set as usual
    };

    VkImage image;
    VkResult result = vkCreateImage(
        device,
        &imageCreateInfo,
        NULL,               // pAllocator
        &image);

    VkMemoryRequirements memoryRequirements;
    vkGetImageMemoryRequirements(
        device,
        image,
        &memoryRequirements);

    // Allocate memory with VkDedicatedAllocationMemoryAllocateInfoNV::image
    // pointing to the image we are allocating the memory for

    VkDedicatedAllocationMemoryAllocateInfoNV dedicatedInfo =
    {
        .sType = VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV,
        .pNext = NULL,
        .image = image,
        .buffer = VK_NULL_HANDLE,
    };

    VkMemoryAllocateInfo memoryAllocateInfo =
    {
        .sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
        .pNext = &dedicatedInfo,
        .allocationSize = memoryRequirements.size,
        .memoryTypeIndex = FindMemoryTypeIndex(memoryRequirements.memoryTypeBits),
    };

    VkDeviceMemory memory;
    vkAllocateMemory(
        device,
        &memoryAllocateInfo,
        NULL,               // pAllocator
        &memory);

    // Bind the image to the memory

    vkBindImageMemory(
        device,
        image,
        memory,
        0);

* 
Revision 1, 2016-05-31 (Jeff Bolz)

Internal revisions

**Name String**

`VK_NV_displacement_micromap`

**Extension Type**

Device extension

**Registered Extension Number**

398

**Revision**

2

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_EXT_opacity_micromap](#VK_EXT_opacity_micromap)

* 
**This is a *provisional* extension and must** be used with caution.
See the [description](boilerplate.html#boilerplate-provisional-header) of provisional header files for enablement and stability details.

**Deprecation State**

* 
*Deprecated* by
[VK_NV_cluster_acceleration_structure](#VK_NV_cluster_acceleration_structure)
extension

**Contact**

* 
Christoph Kubisch [pixeljetstream](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NV_displacement_micromap] @pixeljetstream%0A*Here describe the issue or question you have about the VK_NV_displacement_micromap extension*)

* 
Eric Werness [ewerness-nv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NV_displacement_micromap] @ewerness-nv%0A*Here describe the issue or question you have about the VK_NV_displacement_micromap extension*)

**Last Modified Date**

2023-03-17

**Interactions and External Dependencies**

TBD

**Contributors**

* 
Christoph Kubisch, NVIDIA

* 
Eric Werness, NVIDIA

Ray tracing can very efficiently render from geometry which has very fine
detail, but when using only a basic triangle representation, memory
consumption can be an issue.
This extension adds the ability to add a *displacement map* to add more
detail to triangles in an acceleration structure with an efficient in-memory
format.
The format is externally visible to allow the application to compress its
internal geometry representations into the compressed format ahead of time.
This format adds displacements along a defined vector to subtriangle
vertices which are subdivided from the main triangles.

This extension provides:

* 
a new [VkMicromapTypeEXT](../chapters/resources.html#VkMicromapTypeEXT) format for the displacement micromap,

* 
a structure to extend
[VkAccelerationStructureGeometryTrianglesDataKHR](../chapters/accelstructures.html#VkAccelerationStructureGeometryTrianglesDataKHR) to attach a
displacement micromap to the geometry of the acceleration structure,

* 
enums extending [VkBuildAccelerationStructureFlagBitsKHR](../chapters/resources.html#VkBuildAccelerationStructureFlagBitsKHR) to allow
for updates.

* 
Extending [VkAccelerationStructureGeometryTrianglesDataKHR](../chapters/accelstructures.html#VkAccelerationStructureGeometryTrianglesDataKHR):

[VkAccelerationStructureTrianglesDisplacementMicromapNV](../chapters/accelstructures.html#VkAccelerationStructureTrianglesDisplacementMicromapNV)

Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

* 
[VkPhysicalDeviceDisplacementMicromapFeaturesNV](../chapters/features.html#VkPhysicalDeviceDisplacementMicromapFeaturesNV)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceDisplacementMicromapPropertiesNV](../chapters/limits.html#VkPhysicalDeviceDisplacementMicromapPropertiesNV)

* 
[VkDisplacementMicromapFormatNV](../chapters/VK_EXT_opacity_micromap/micromaps.html#VkDisplacementMicromapFormatNV)

* 
`VK_NV_DISPLACEMENT_MICROMAP_EXTENSION_NAME`

* 
`VK_NV_DISPLACEMENT_MICROMAP_SPEC_VERSION`

* 
Extending [VkBuildAccelerationStructureFlagBitsKHR](../chapters/resources.html#VkBuildAccelerationStructureFlagBitsKHR):

`VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISPLACEMENT_MICROMAP_UPDATE_NV`

Extending [VkMicromapTypeEXT](../chapters/resources.html#VkMicromapTypeEXT):

* 
`VK_MICROMAP_TYPE_DISPLACEMENT_MICROMAP_NV`

Extending [VkPipelineCreateFlagBits](../chapters/pipelines.html#VkPipelineCreateFlagBits):

* 
`VK_PIPELINE_CREATE_RAY_TRACING_DISPLACEMENT_MICROMAP_BIT_NV`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_DISPLACEMENT_MICROMAP_NV`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_FEATURES_NV`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_PROPERTIES_NV`

(1) What is the status of this extension?

* 
Deprecated.
The VK_NV_cluster_acceleration_structure extension is not a one-to-one
replacement for this extension but enables similar performance
improvements for high-tessellation geometry and is considered the
preferred direction to improve high-tessellation geometry performance.

* 
Revision 1, 2023-03-17 (Eric Werness)

Initial public revision

Revision 2, 2023-07-07 (Eric Werness)

* 
Add shader support for decode intrinsics

**Name String**

`VK_NV_external_memory`

**Extension Type**

Device extension

**Registered Extension Number**

57

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_NV_external_memory_capabilities](#VK_NV_external_memory_capabilities)

**Deprecation State**

* 
*Deprecated* by
[VK_KHR_external_memory](#VK_KHR_external_memory)
extension

Which in turn was *promoted* to
[Vulkan 1.1](versions.html#versions-1.1-promotions)

**Contact**

* 
James Jones [cubanismo](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NV_external_memory] @cubanismo%0A*Here describe the issue or question you have about the VK_NV_external_memory extension*)

**Last Modified Date**

2016-08-19

**IP Status**

No known IP claims.

**Contributors**

* 
James Jones, NVIDIA

* 
Carsten Rohde, NVIDIA

Applications may wish to export memory to other Vulkan instances or other
APIs, or import memory from other Vulkan instances or other APIs to enable
Vulkan workloads to be split up across application module, process, or API
boundaries.
This extension enables applications to create exportable Vulkan memory
objects such that the underlying resources can be referenced outside the
Vulkan instance that created them.

* 
Extending [VkImageCreateInfo](../chapters/resources.html#VkImageCreateInfo):

[VkExternalMemoryImageCreateInfoNV](../chapters/resources.html#VkExternalMemoryImageCreateInfoNV)

Extending [VkMemoryAllocateInfo](../chapters/memory.html#VkMemoryAllocateInfo):

* 
[VkExportMemoryAllocateInfoNV](../chapters/memory.html#VkExportMemoryAllocateInfoNV)

* 
`VK_NV_EXTERNAL_MEMORY_EXTENSION_NAME`

* 
`VK_NV_EXTERNAL_MEMORY_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV`

* 
`VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV`

1) If memory objects are shared between processes and APIs, is this
considered aliasing according to the rules outlined in the
[Memory Aliasing](../chapters/resources.html#resources-memory-aliasing) section?

**RESOLVED**: Yes, but strict exceptions to the rules are added to allow some
forms of aliasing in these cases.
Further, other extensions may build upon these new aliasing rules to define
specific support usage within Vulkan for imported native memory objects, or
memory objects from other APIs.

2) Are new image layouts or metadata required to specify image layouts and
layout transitions compatible with non-Vulkan APIs, or with other instances
of the same Vulkan driver?

**RESOLVED**: No.
Separate instances of the same Vulkan driver running on the same GPU should
have identical internal layout semantics, so applications have the tools
they need to ensure views of images are consistent between the two
instances.
Other APIs will fall into two categories: Those that are Vulkan compatible
(a term to be defined by subsequent interopability extensions), or Vulkan
incompatible.
When sharing images with Vulkan incompatible APIs, the Vulkan image must be
transitioned to the `VK_IMAGE_LAYOUT_GENERAL` layout before handing it
off to the external API.

Note this does not attempt to address cross-device transitions, nor
transitions to engines on the same device which are not visible within the
Vulkan API.
Both of these are beyond the scope of this extension.

    // TODO: Write some sample code here.

* 
Revision 1, 2016-08-19 (James Jones)

Initial draft

**Name String**

`VK_NV_external_memory_capabilities`

**Extension Type**

Instance extension

**Registered Extension Number**

56

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

None

**Deprecation State**

* 
*Deprecated* by
[VK_KHR_external_memory_capabilities](#VK_KHR_external_memory_capabilities)
extension

Which in turn was *promoted* to
[Vulkan 1.1](versions.html#versions-1.1-promotions)

**Contact**

* 
James Jones [cubanismo](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NV_external_memory_capabilities] @cubanismo%0A*Here describe the issue or question you have about the VK_NV_external_memory_capabilities extension*)

**Last Modified Date**

2016-08-19

**IP Status**

No known IP claims.

**Interactions and External Dependencies**

* 
Interacts with Vulkan 1.1.

* 
Interacts with `[VK_KHR_dedicated_allocation](#VK_KHR_dedicated_allocation)`.

* 
Interacts with `[VK_NV_dedicated_allocation](#VK_NV_dedicated_allocation)`.

**Contributors**

* 
James Jones, NVIDIA

Applications may wish to import memory from the Direct 3D API, or export
memory to other Vulkan instances.
This extension provides a set of capability queries that allow applications
determine what types of win32 memory handles an implementation supports for
a given set of use cases.

* 
[vkGetPhysicalDeviceExternalImageFormatPropertiesNV](../chapters/capabilities.html#vkGetPhysicalDeviceExternalImageFormatPropertiesNV)

* 
[VkExternalImageFormatPropertiesNV](../chapters/capabilities.html#VkExternalImageFormatPropertiesNV)

* 
[VkExternalMemoryFeatureFlagBitsNV](../chapters/capabilities.html#VkExternalMemoryFeatureFlagBitsNV)

* 
[VkExternalMemoryHandleTypeFlagBitsNV](../chapters/memory.html#VkExternalMemoryHandleTypeFlagBitsNV)

* 
[VkExternalMemoryFeatureFlagsNV](../chapters/capabilities.html#VkExternalMemoryFeatureFlagsNV)

* 
[VkExternalMemoryHandleTypeFlagsNV](../chapters/memory.html#VkExternalMemoryHandleTypeFlagsNV)

* 
`VK_NV_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME`

* 
`VK_NV_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION`

1) Why do so many external memory capabilities need to be queried on a
per-memory-handle-type basis?

**RESOLVED**: This is because some handle types are based on OS-native objects
that have far more limited capabilities than the very generic Vulkan memory
objects.
Not all memory handle types can name memory objects that support 3D images,
for example.
Some handle types cannot even support the deferred image and memory binding
behavior of Vulkan and require specifying the image when allocating or
importing the memory object.

2) Does the [VkExternalImageFormatPropertiesNV](../chapters/capabilities.html#VkExternalImageFormatPropertiesNV) structure need to
include a list of memory type bits that support the given handle type?

**RESOLVED**: No.
The memory types that do not support the handle types will simply be
filtered out of the results returned by [vkGetImageMemoryRequirements](../chapters/resources.html#vkGetImageMemoryRequirements)
when a set of handle types was specified at image creation time.

3) Should the non-opaque handle types be moved to their own extension?

**RESOLVED**: Perhaps.
However, defining the handle type bits does very little and does not require
any platform-specific types on its own, and it is easier to maintain the
bitmask values in a single extension for now.
Presumably more handle types could be added by separate extensions though,
and it would be midly weird to have some platform-specific ones defined in
the core spec and some in extensions

* 
Revision 1, 2016-08-19 (James Jones)

Initial version

**Name String**

`VK_NV_external_memory_win32`

**Extension Type**

Device extension

**Registered Extension Number**

58

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_NV_external_memory](#VK_NV_external_memory)

**Deprecation State**

* 
*Deprecated* by
[VK_KHR_external_memory_win32](#VK_KHR_external_memory_win32)
extension

**Contact**

* 
James Jones [cubanismo](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NV_external_memory_win32] @cubanismo%0A*Here describe the issue or question you have about the VK_NV_external_memory_win32 extension*)

**Last Modified Date**

2016-08-19

**IP Status**

No known IP claims.

**Contributors**

* 
James Jones, NVIDIA

* 
Carsten Rohde, NVIDIA

Applications may wish to export memory to other Vulkan instances or other
APIs, or import memory from other Vulkan instances or other APIs to enable
Vulkan workloads to be split up across application module, process, or API
boundaries.
This extension enables win32 applications to export win32 handles from
Vulkan memory objects such that the underlying resources can be referenced
outside the Vulkan instance that created them, and import win32 handles
created in the Direct3D API to Vulkan memory objects.

* 
[vkGetMemoryWin32HandleNV](../chapters/memory.html#vkGetMemoryWin32HandleNV)

* 
Extending [VkMemoryAllocateInfo](../chapters/memory.html#VkMemoryAllocateInfo):

[VkExportMemoryWin32HandleInfoNV](../chapters/memory.html#VkExportMemoryWin32HandleInfoNV)

* 
[VkImportMemoryWin32HandleInfoNV](../chapters/memory.html#VkImportMemoryWin32HandleInfoNV)

* 
`VK_NV_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME`

* 
`VK_NV_EXTERNAL_MEMORY_WIN32_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV`

* 
`VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV`

1) If memory objects are shared between processes and APIs, is this
considered aliasing according to the rules outlined in the
[Memory Aliasing](../chapters/resources.html#resources-memory-aliasing) section?

**RESOLVED**: Yes, but strict exceptions to the rules are added to allow some
forms of aliasing in these cases.
Further, other extensions may build upon these new aliasing rules to define
specific support usage within Vulkan for imported native memory objects, or
memory objects from other APIs.

2) Are new image layouts or metadata required to specify image layouts and
layout transitions compatible with non-Vulkan APIs, or with other instances
of the same Vulkan driver?

**RESOLVED**: No.
Separate instances of the same Vulkan driver running on the same GPU should
have identical internal layout semantics, so applications have the tools
they need to ensure views of images are consistent between the two
instances.
Other APIs will fall into two categories: Those that are Vulkan compatible
(a term to be defined by subsequent interopability extensions), or Vulkan
incompatible.
When sharing images with Vulkan incompatible APIs, the Vulkan image must be
transitioned to the `VK_IMAGE_LAYOUT_GENERAL` layout before handing it
off to the external API.

Note this does not attempt to address cross-device transitions, nor
transitions to engines on the same device which are not visible within the
Vulkan API.
Both of these are beyond the scope of this extension.

3) Do applications need to call `CloseHandle`() on the values returned
from [vkGetMemoryWin32HandleNV](../chapters/memory.html#vkGetMemoryWin32HandleNV) when `handleType` is
`VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV`?

**RESOLVED**: Yes, unless it is passed back in to another driver instance to
import the object.
A successful get call transfers ownership of the handle to the application,
while an import transfers ownership to the associated driver.
Destroying the memory object will not destroy the handle or the handles
reference to the underlying memory resource.

    //
    // Create an exportable memory object and export an external
    // handle from it.
    //

    // Pick an external format and handle type.
    static const VkFormat format = VK_FORMAT_R8G8B8A8_UNORM;
    static const VkExternalMemoryHandleTypeFlagsNV handleType =
        VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV;

    extern VkPhysicalDevice physicalDevice;
    extern VkDevice device;

    VkPhysicalDeviceMemoryProperties memoryProperties;
    VkExternalImageFormatPropertiesNV properties;
    VkExternalMemoryImageCreateInfoNV externalMemoryImageCreateInfo;
    VkDedicatedAllocationImageCreateInfoNV dedicatedImageCreateInfo;
    VkImageCreateInfo imageCreateInfo;
    VkImage image;
    VkMemoryRequirements imageMemoryRequirements;
    uint32_t numMemoryTypes;
    uint32_t memoryType;
    VkExportMemoryAllocateInfoNV exportMemoryAllocateInfo;
    VkDedicatedAllocationMemoryAllocateInfoNV dedicatedAllocationInfo;
    VkMemoryAllocateInfo memoryAllocateInfo;
    VkDeviceMemory memory;
    VkResult result;
    HANDLE memoryHnd;

    // Figure out how many memory types the device supports
    vkGetPhysicalDeviceMemoryProperties(physicalDevice,
                                        &memoryProperties);
    numMemoryTypes = memoryProperties.memoryTypeCount;

    // Check the external handle type capabilities for the chosen format
    // Exportable 2D image support with at least 1 mip level, 1 array
    // layer, and VK_SAMPLE_COUNT_1_BIT using optimal tiling and supporting
    // texturing and color rendering is required.
    result = vkGetPhysicalDeviceExternalImageFormatPropertiesNV(
        physicalDevice,
        format,
        VK_IMAGE_TYPE_2D,
        VK_IMAGE_TILING_OPTIMAL,
        VK_IMAGE_USAGE_SAMPLED_BIT |
        VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT,
        0,
        handleType,
        &properties);

    if ((result != VK_SUCCESS) ||
        !(properties.externalMemoryFeatures &
          VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV)) {
        abort();
    }

    // Set up the external memory image creation info
    memset(&externalMemoryImageCreateInfo,
           0, sizeof(externalMemoryImageCreateInfo));
    externalMemoryImageCreateInfo.sType =
        VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV;
    externalMemoryImageCreateInfo.handleTypes = handleType;
    if (properties.externalMemoryFeatures &
        VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV) {
        memset(&dedicatedImageCreateInfo, 0, sizeof(dedicatedImageCreateInfo));
        dedicatedImageCreateInfo.sType =
            VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV;
        dedicatedImageCreateInfo.dedicatedAllocation = VK_TRUE;
        externalMemoryImageCreateInfo.pNext = &dedicatedImageCreateInfo;
    }
    // Set up the  core image creation info
    memset(&imageCreateInfo, 0, sizeof(imageCreateInfo));
    imageCreateInfo.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
    imageCreateInfo.pNext = &externalMemoryImageCreateInfo;
    imageCreateInfo.format = format;
    imageCreateInfo.extent.width = 64;
    imageCreateInfo.extent.height = 64;
    imageCreateInfo.extent.depth = 1;
    imageCreateInfo.mipLevels = 1;
    imageCreateInfo.arrayLayers = 1;
    imageCreateInfo.samples = VK_SAMPLE_COUNT_1_BIT;
    imageCreateInfo.tiling = VK_IMAGE_TILING_OPTIMAL;
    imageCreateInfo.usage = VK_IMAGE_USAGE_SAMPLED_BIT |
        VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT;
    imageCreateInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;
    imageCreateInfo.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;

    vkCreateImage(device, &imageCreateInfo, NULL, &image);

    vkGetImageMemoryRequirements(device,
                                 image,
                                 &imageMemoryRequirements);

    // For simplicity, just pick the first compatible memory type.
    for (memoryType = 0; memoryType 

* 
Revision 1, 2016-08-11 (James Jones)

Initial draft

**Name String**

`VK_NV_fragment_shader_barycentric`

**Extension Type**

Device extension

**Registered Extension Number**

204

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**SPIR-V Dependencies**

* 
[SPV_NV_fragment_shader_barycentric](https://github.khronos.org/SPIRV-Registry/extensions/NV/SPV_NV_fragment_shader_barycentric.html)

**Deprecation State**

* 
*Promoted* to
[VK_KHR_fragment_shader_barycentric](#VK_KHR_fragment_shader_barycentric)
extension

**Contact**

* 
Pat Brown [nvpbrown](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NV_fragment_shader_barycentric] @nvpbrown%0A*Here describe the issue or question you have about the VK_NV_fragment_shader_barycentric extension*)

**Last Modified Date**

2018-08-03

**IP Status**

No known IP claims.

**Interactions and External Dependencies**

* 
This extension provides API support for
[`GL_NV_fragment_shader_barycentric`](https://github.com/KhronosGroup/GLSL/blob/main/extensions/nv/GLSL_NV_fragment_shader_barycentric.txt)

**Contributors**

* 
Pat Brown, NVIDIA

* 
Daniel Koch, NVIDIA

This extension adds support for the following SPIR-V extension in Vulkan:

* 
[`SPV_NV_fragment_shader_barycentric`](https://github.khronos.org/SPIRV-Registry/extensions/NV/SPV_NV_fragment_shader_barycentric.html)

The extension provides access to three additional fragment shader variable
decorations in SPIR-V:

* 
`PerVertexNV`, which indicates that a fragment shader input will not
have interpolated values, but instead must be accessed with an extra
array index that identifies one of the vertices of the primitive
producing the fragment

* 
`BaryCoordNV`, which indicates that the variable is a three-component
floating-point vector holding barycentric weights for the fragment
produced using perspective interpolation

* 
`BaryCoordNoPerspNV`, which indicates that the variable is a
three-component floating-point vector holding barycentric weights for
the fragment produced using linear interpolation

When using GLSL source-based shader languages, the following variables from
`GL_NV_fragment_shader_barycentric` maps to these SPIR-V built-in
decorations:

* 
`in vec3 gl_BaryCoordNV;`  `BaryCoordNV`

* 
`in vec3 gl_BaryCoordNoPerspNV;`  `BaryCoordNoPerspNV`

GLSL variables declared using the `__pervertexNV` GLSL qualifier are
expected to be decorated with `PerVertexNV` in SPIR-V.

All functionality in this extension is included in
`[VK_KHR_fragment_shader_barycentric](#VK_KHR_fragment_shader_barycentric)`, with the suffix changed to KHR.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV](../chapters/features.html#VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV)

* 
`VK_NV_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION_NAME`

* 
`VK_NV_FRAGMENT_SHADER_BARYCENTRIC_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV`

* 
[`BaryCoordNV`](../chapters/interfaces.html#interfaces-builtin-variables-barycoordkhr)

* 
[`BaryCoordNoPerspNV`](../chapters/interfaces.html#interfaces-builtin-variables-barycoordnoperspkhr)

* 
[`PerVertexNV`](../chapters/shaders.html#shaders-interpolation-decorations-pervertexkhr)

* 
[    `FragmentBarycentricNV`](spirvenv.html#spirvenv-capabilities-table-FragmentBarycentricKHR)

(1) The AMD_shader_explicit_vertex_parameter extension provides similar
    functionality.
    Why write a new extension, and how is this extension different?

**RESOLVED**: For the purposes of Vulkan/SPIR-V, we chose to implement a
separate extension due to several functional differences.

First, the hardware supporting this extension can provide a three-component
barycentric weight vector for variables decorated with `BaryCoordNV`,
while variables decorated with `BaryCoordSmoothAMD` provide only two
components.
In some cases, it may be more efficient to explicitly interpolate an
attribute via:

float value = (baryCoordNV.x * v[0].attrib +
               baryCoordNV.y * v[1].attrib +
               baryCoordNV.z * v[2].attrib);

instead of

float value = (baryCoordSmoothAMD.x * (v[0].attrib - v[2].attrib) +
               baryCoordSmoothAMD.y * (v[1].attrib - v[2].attrib) +
               v[2].attrib);

Additionally, the semantics of the decoration `BaryCoordPullModelAMD` do
not appear to map to anything supported by the initial hardware
implementation of this extension.

This extension provides a smaller number of decorations than the AMD
extension, as we expect that shaders could derive variables decorated with
things like `BaryCoordNoPerspCentroidAMD` with explicit attribute
interpolation instructions.
One other relevant difference is that explicit per-vertex attribute access
using this extension does not require a constant vertex number.

(2) Why do the built-in SPIR-V decorations for this extension include two
separate built-ins `BaryCoordNV` and `BaryCoordNoPerspNV` when a no
perspective variable could be decorated with `BaryCoordNV` and
`NoPerspective`?

**RESOLVED**: The SPIR-V extension for this feature chose to mirror the
behavior of the GLSL extension, which provides two built-in variables.
Additionally, it is not clear that its a good idea (or even legal) to have
two variables using the same attribute, but with different interpolation
modifiers.

* 
Revision 1, 2018-08-03 (Pat Brown)

Internal revisions

**Name String**

`VK_NV_glsl_shader`

**Extension Type**

Device extension

**Registered Extension Number**

13

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

None

**Deprecation State**

* 
*Deprecated* without replacement

**Contact**

* 
Piers Daniell [pdaniell-nv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NV_glsl_shader] @pdaniell-nv%0A*Here describe the issue or question you have about the VK_NV_glsl_shader extension*)

**Last Modified Date**

2016-02-14

**IP Status**

No known IP claims.

**Contributors**

* 
Piers Daniell, NVIDIA

This extension allows GLSL shaders written to the `GL_KHR_vulkan_glsl`
extension specification to be used instead of SPIR-V.
The implementation will automatically detect whether the shader is SPIR-V or
GLSL, and compile it appropriately.

Functionality in this extension is outside of the scope of Vulkan and is
better served by a compiler library such as
[glslang](https://github.com/KhronosGroup/glslang).
No new implementations will support this extension, so applications **should**
not use it.

* 
`VK_NV_GLSL_SHADER_EXTENSION_NAME`

* 
`VK_NV_GLSL_SHADER_SPEC_VERSION`

* 
Extending [VkResult](../chapters/fundamentals.html#VkResult):

`VK_ERROR_INVALID_SHADER_NV`

**Example 1**

Passing in GLSL code

    char const vss[] =
        "#version 450 core\n"
        "layout(location = 0) in vec2 aVertex;\n"
        "layout(location = 1) in vec4 aColor;\n"
        "out vec4 vColor;\n"
        "void main()\n"
        "{\n"
        "    vColor = aColor;\n"
        "    gl_Position = vec4(aVertex, 0, 1);\n"
        "}\n"
    ;
    VkShaderModuleCreateInfo vertexShaderInfo = { VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO };
    vertexShaderInfo.codeSize = sizeof vss;
    vertexShaderInfo.pCode = vss;
    VkShaderModule vertexShader;
    vkCreateShaderModule(device, &vertexShaderInfo, 0, &vertexShader);

* 
Revision 1, 2016-02-14 (Piers Daniell)

Initial draft

**Name String**

`VK_NV_ray_tracing`

**Extension Type**

Device extension

**Registered Extension Number**

166

**Revision**

3

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

 [VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

 and

 [VK_KHR_get_memory_requirements2](#VK_KHR_get_memory_requirements2)

or

[Vulkan Version 1.1](versions.html#versions-1.1)

**API Interactions**

* 
Interacts with VK_VERSION_1_1

* 
Interacts with VK_EXT_debug_report

* 
Interacts with VK_KHR_get_memory_requirements2

**SPIR-V Dependencies**

* 
[SPV_NV_ray_tracing](https://github.khronos.org/SPIRV-Registry/extensions/NV/SPV_NV_ray_tracing.html)

**Deprecation State**

* 
*Deprecated* by
[VK_KHR_ray_tracing_pipeline](#VK_KHR_ray_tracing_pipeline)
extension

**Contact**

* 
Eric Werness [ewerness-nv](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NV_ray_tracing] @ewerness-nv%0A*Here describe the issue or question you have about the VK_NV_ray_tracing extension*)

**Last Modified Date**

2018-11-20

**Interactions and External Dependencies**

* 
This extension provides API support for
[`GL_NV_ray_tracing`](https://github.com/KhronosGroup/GLSL/blob/main/extensions/nv/GLSL_NV_ray_tracing.txt)

**Contributors**

* 
Eric Werness, NVIDIA

* 
Ashwin Lele, NVIDIA

* 
Robert Stepinski, NVIDIA

* 
Nuno Subtil, NVIDIA

* 
Christoph Kubisch, NVIDIA

* 
Martin Stich, NVIDIA

* 
Daniel Koch, NVIDIA

* 
Jeff Bolz, NVIDIA

* 
Joshua Barczak, Intel

* 
Tobias Hector, AMD

* 
Henrik Rydgard, NVIDIA

* 
Pascal Gautron, NVIDIA

Rasterization has been the dominant method to produce interactive graphics,
but increasing performance of graphics hardware has made ray tracing a
viable option for interactive rendering.
Being able to integrate ray tracing with traditional rasterization makes it
easier for applications to incrementally add ray traced effects to existing
applications or to do hybrid approaches with rasterization for primary
visibility and ray tracing for secondary queries.

To enable ray tracing, this extension adds a few different categories of new
functionality:

* 
Acceleration structure objects and build commands

* 
A new pipeline type with new shader domains

* 
An indirection table to link shader groups with acceleration structure
items

This extension adds support for the following SPIR-V extension in Vulkan:

* 
`SPV_NV_ray_tracing`

* 
[VkAccelerationStructureNV](../chapters/resources.html#VkAccelerationStructureNV)

* 
[vkBindAccelerationStructureMemoryNV](../chapters/resources.html#vkBindAccelerationStructureMemoryNV)

* 
[vkCmdBuildAccelerationStructureNV](../chapters/accelstructures.html#vkCmdBuildAccelerationStructureNV)

* 
[vkCmdCopyAccelerationStructureNV](../chapters/accelstructures.html#vkCmdCopyAccelerationStructureNV)

* 
[vkCmdTraceRaysNV](../chapters/raytracing.html#vkCmdTraceRaysNV)

* 
[vkCmdWriteAccelerationStructuresPropertiesNV](../chapters/accelstructures.html#vkCmdWriteAccelerationStructuresPropertiesNV)

* 
[vkCompileDeferredNV](../chapters/pipelines.html#vkCompileDeferredNV)

* 
[vkCreateAccelerationStructureNV](../chapters/resources.html#vkCreateAccelerationStructureNV)

* 
[vkCreateRayTracingPipelinesNV](../chapters/pipelines.html#vkCreateRayTracingPipelinesNV)

* 
[vkDestroyAccelerationStructureNV](../chapters/resources.html#vkDestroyAccelerationStructureNV)

* 
[vkGetAccelerationStructureHandleNV](../chapters/resources.html#vkGetAccelerationStructureHandleNV)

* 
[vkGetAccelerationStructureMemoryRequirementsNV](../chapters/resources.html#vkGetAccelerationStructureMemoryRequirementsNV)

* 
[vkGetRayTracingShaderGroupHandlesNV](../chapters/pipelines.html#vkGetRayTracingShaderGroupHandlesNV)

* 
[VkAabbPositionsNV](../chapters/accelstructures.html#VkAabbPositionsNV)

* 
[VkAccelerationStructureCreateInfoNV](../chapters/resources.html#VkAccelerationStructureCreateInfoNV)

* 
[VkAccelerationStructureInfoNV](../chapters/resources.html#VkAccelerationStructureInfoNV)

* 
[VkAccelerationStructureInstanceNV](../chapters/accelstructures.html#VkAccelerationStructureInstanceNV)

* 
[VkAccelerationStructureMemoryRequirementsInfoNV](../chapters/resources.html#VkAccelerationStructureMemoryRequirementsInfoNV)

* 
[VkBindAccelerationStructureMemoryInfoNV](../chapters/resources.html#VkBindAccelerationStructureMemoryInfoNV)

* 
[VkGeometryAABBNV](../chapters/resources.html#VkGeometryAABBNV)

* 
[VkGeometryDataNV](../chapters/resources.html#VkGeometryDataNV)

* 
[VkGeometryNV](../chapters/resources.html#VkGeometryNV)

* 
[VkGeometryTrianglesNV](../chapters/resources.html#VkGeometryTrianglesNV)

* 
[VkRayTracingPipelineCreateInfoNV](../chapters/pipelines.html#VkRayTracingPipelineCreateInfoNV)

* 
[VkRayTracingShaderGroupCreateInfoNV](../chapters/pipelines.html#VkRayTracingShaderGroupCreateInfoNV)

* 
[VkTransformMatrixNV](../chapters/accelstructures.html#VkTransformMatrixNV)

* 
Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

[VkPhysicalDeviceRayTracingPropertiesNV](../chapters/limits.html#VkPhysicalDeviceRayTracingPropertiesNV)

Extending [VkWriteDescriptorSet](../chapters/descriptorsets.html#VkWriteDescriptorSet):

* 
[VkWriteDescriptorSetAccelerationStructureNV](../chapters/descriptorsets.html#VkWriteDescriptorSetAccelerationStructureNV)

If [VK_KHR_get_memory_requirements2](#VK_KHR_get_memory_requirements2) or [Vulkan Version 1.1](versions.html#versions-1.1) is supported:

* 
[VkMemoryRequirements2KHR](../chapters/resources.html#VkMemoryRequirements2KHR)

* 
[VkAccelerationStructureMemoryRequirementsTypeNV](../chapters/resources.html#VkAccelerationStructureMemoryRequirementsTypeNV)

* 
[VkAccelerationStructureTypeNV](../chapters/resources.html#VkAccelerationStructureTypeNV)

* 
[VkBuildAccelerationStructureFlagBitsNV](../chapters/resources.html#VkBuildAccelerationStructureFlagBitsNV)

* 
[VkCopyAccelerationStructureModeNV](../chapters/accelstructures.html#VkCopyAccelerationStructureModeNV)

* 
[VkGeometryFlagBitsNV](../chapters/resources.html#VkGeometryFlagBitsNV)

* 
[VkGeometryInstanceFlagBitsNV](../chapters/accelstructures.html#VkGeometryInstanceFlagBitsNV)

* 
[VkGeometryTypeNV](../chapters/resources.html#VkGeometryTypeNV)

* 
[VkRayTracingShaderGroupTypeNV](../chapters/pipelines.html#VkRayTracingShaderGroupTypeNV)

* 
[VkBuildAccelerationStructureFlagsNV](../chapters/resources.html#VkBuildAccelerationStructureFlagsNV)

* 
[VkGeometryFlagsNV](../chapters/resources.html#VkGeometryFlagsNV)

* 
[VkGeometryInstanceFlagsNV](../chapters/accelstructures.html#VkGeometryInstanceFlagsNV)

* 
`VK_NV_RAY_TRACING_EXTENSION_NAME`

* 
`VK_NV_RAY_TRACING_SPEC_VERSION`

* 
`VK_SHADER_UNUSED_NV`

* 
Extending [VkAccelerationStructureTypeKHR](../chapters/resources.html#VkAccelerationStructureTypeKHR):

`VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_NV`

* 
`VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_NV`

Extending [VkAccessFlagBits](../chapters/synchronization.html#VkAccessFlagBits):

* 
`VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV`

* 
`VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV`

Extending [VkBufferUsageFlagBits](../chapters/resources.html#VkBufferUsageFlagBits):

* 
`VK_BUFFER_USAGE_RAY_TRACING_BIT_NV`

Extending [VkBuildAccelerationStructureFlagBitsKHR](../chapters/resources.html#VkBuildAccelerationStructureFlagBitsKHR):

* 
`VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_NV`

* 
`VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NV`

* 
`VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_NV`

* 
`VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NV`

* 
`VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_NV`

Extending [VkCopyAccelerationStructureModeKHR](../chapters/accelstructures.html#VkCopyAccelerationStructureModeKHR):

* 
`VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_NV`

* 
`VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_NV`

Extending [VkDescriptorType](../chapters/descriptorsets.html#VkDescriptorType):

* 
`VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV`

Extending [VkGeometryFlagBitsKHR](../chapters/resources.html#VkGeometryFlagBitsKHR):

* 
`VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_NV`

* 
`VK_GEOMETRY_OPAQUE_BIT_NV`

Extending [VkGeometryInstanceFlagBitsKHR](../chapters/accelstructures.html#VkGeometryInstanceFlagBitsKHR):

* 
`VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_NV`

* 
`VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_NV`

* 
`VK_GEOMETRY_INSTANCE_TRIANGLE_CULL_DISABLE_BIT_NV`

* 
`VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_NV`

Extending [VkGeometryTypeKHR](../chapters/resources.html#VkGeometryTypeKHR):

* 
`VK_GEOMETRY_TYPE_AABBS_NV`

* 
`VK_GEOMETRY_TYPE_TRIANGLES_NV`

Extending [VkIndexType](../chapters/drawing.html#VkIndexType):

* 
`VK_INDEX_TYPE_NONE_NV`

Extending [VkObjectType](../chapters/debugging.html#VkObjectType):

* 
`VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV`

Extending [VkPipelineBindPoint](../chapters/pipelines.html#VkPipelineBindPoint):

* 
`VK_PIPELINE_BIND_POINT_RAY_TRACING_NV`

Extending [VkPipelineCreateFlagBits](../chapters/pipelines.html#VkPipelineCreateFlagBits):

* 
`VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV`

Extending [VkPipelineStageFlagBits](../chapters/synchronization.html#VkPipelineStageFlagBits):

* 
`VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV`

* 
`VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV`

Extending [VkQueryType](../chapters/queries.html#VkQueryType):

* 
`VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV`

Extending [VkRayTracingShaderGroupTypeKHR](../chapters/pipelines.html#VkRayTracingShaderGroupTypeKHR):

* 
`VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV`

* 
`VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV`

* 
`VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV`

Extending [VkShaderStageFlagBits](../chapters/pipelines.html#VkShaderStageFlagBits):

* 
`VK_SHADER_STAGE_ANY_HIT_BIT_NV`

* 
`VK_SHADER_STAGE_CALLABLE_BIT_NV`

* 
`VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV`

* 
`VK_SHADER_STAGE_INTERSECTION_BIT_NV`

* 
`VK_SHADER_STAGE_MISS_BIT_NV`

* 
`VK_SHADER_STAGE_RAYGEN_BIT_NV`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV`

* 
`VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV`

* 
`VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV`

* 
`VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV`

* 
`VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV`

* 
`VK_STRUCTURE_TYPE_GEOMETRY_NV`

* 
`VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV`

* 
`VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV`

* 
`VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV`

* 
`VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV`

If [VK_EXT_debug_report](#VK_EXT_debug_report) is supported:

* 
Extending [VkDebugReportObjectTypeEXT](../chapters/debugging.html#VkDebugReportObjectTypeEXT):

`VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV_EXT`

* 
[`LaunchIdNV`](../chapters/interfaces.html#interfaces-builtin-variables-launchid)

* 
[`LaunchSizeNV`](../chapters/interfaces.html#interfaces-builtin-variables-launchsize)

* 
[`WorldRayOriginNV`](../chapters/interfaces.html#interfaces-builtin-variables-worldrayorigin)

* 
[`WorldRayDirectionNV`](../chapters/interfaces.html#interfaces-builtin-variables-worldraydirection)

* 
[`ObjectRayOriginNV`](../chapters/interfaces.html#interfaces-builtin-variables-objectrayorigin)

* 
[`ObjectRayDirectionNV`](../chapters/interfaces.html#interfaces-builtin-variables-objectraydirection)

* 
[`RayTminNV`](../chapters/interfaces.html#interfaces-builtin-variables-raytmin)

* 
[`RayTmaxNV`](../chapters/interfaces.html#interfaces-builtin-variables-raytmax)

* 
[`InstanceCustomIndexNV`](../chapters/interfaces.html#interfaces-builtin-variables-instancecustomindex)

* 
[`InstanceId`](../chapters/interfaces.html#interfaces-builtin-variables-instanceid)

* 
[`ObjectToWorldNV`](../chapters/interfaces.html#interfaces-builtin-variables-objecttoworld)

* 
[`WorldToObjectNV`](../chapters/interfaces.html#interfaces-builtin-variables-worldtoobject)

* 
[`HitTNV`](../chapters/interfaces.html#interfaces-builtin-variables-hitt)

* 
[`HitKindNV`](../chapters/interfaces.html#interfaces-builtin-variables-hitkind)

* 
[`IncomingRayFlagsNV`](../chapters/interfaces.html#interfaces-builtin-variables-incomingrayflags)

* 
(modified)`PrimitiveId`

* 
[`RayTracingNV`](spirvenv.html#spirvenv-capabilities-table-RayTracingNV)

1) Are there issues?

**RESOLVED**: Yes.

Example ray generation GLSL shader

#version 450 core
#extension GL_NV_ray_tracing : require
layout(set = 0, binding = 0, rgba8) uniform image2D image;
layout(set = 0, binding = 1) uniform accelerationStructureNV as;
layout(location = 0) rayPayloadNV float payload;

void main()
{
   vec4 col = vec4(0, 0, 0, 1);

   vec3 origin = vec3(float(gl_LaunchIDNV.x)/float(gl_LaunchSizeNV.x), float(gl_LaunchIDNV.y)/float(gl_LaunchSizeNV.y), 1.0);
   vec3 dir = vec3(0.0, 0.0, -1.0);

   traceNV(as, 0, 0xff, 0, 1, 0, origin, 0.0, dir, 1000.0, 0);

   col.y = payload;

   imageStore(image, ivec2(gl_LaunchIDNV.xy), col);
}

* 
Revision 1, 2018-09-11 (Robert Stepinski, Nuno Subtil, Eric Werness)

Internal revisions

Revision 2, 2018-10-19 (Eric Werness)

* 
rename to VK_NV_ray_tracing, add support for callables.

* 
too many updates to list

Revision 3, 2018-11-20 (Daniel Koch)

* 
update to use InstanceId instead of InstanceIndex as implemented.

**Name String**

`VK_NV_win32_keyed_mutex`

**Extension Type**

Device extension

**Registered Extension Number**

59

**Revision**

2

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_NV_external_memory_win32](#VK_NV_external_memory_win32)

**Deprecation State**

* 
*Promoted* to
[VK_KHR_win32_keyed_mutex](#VK_KHR_win32_keyed_mutex)
extension

**Contact**

* 
Carsten Rohde [crohde](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_NV_win32_keyed_mutex] @crohde%0A*Here describe the issue or question you have about the VK_NV_win32_keyed_mutex extension*)

**Last Modified Date**

2016-08-19

**IP Status**

No known IP claims.

**Contributors**

* 
James Jones, NVIDIA

* 
Carsten Rohde, NVIDIA

Applications that wish to import Direct3D 11 memory objects into the Vulkan
API may wish to use the native keyed mutex mechanism to synchronize access
to the memory between Vulkan and Direct3D.
This extension provides a way for an application to access the keyed mutex
associated with an imported Vulkan memory object when submitting command
buffers to a queue.

* 
Extending [VkSubmitInfo](../chapters/cmdbuffers.html#VkSubmitInfo), [VkSubmitInfo2](../chapters/cmdbuffers.html#VkSubmitInfo2):

[VkWin32KeyedMutexAcquireReleaseInfoNV](../chapters/cmdbuffers.html#VkWin32KeyedMutexAcquireReleaseInfoNV)

* 
`VK_NV_WIN32_KEYED_MUTEX_EXTENSION_NAME`

* 
`VK_NV_WIN32_KEYED_MUTEX_SPEC_VERSION`

* 
Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

`VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV`

    //
    // Import a memory object from Direct3D 11, and synchronize
    // access to it in Vulkan using keyed mutex objects.
    //

    extern VkPhysicalDevice physicalDevice;
    extern VkDevice device;
    extern HANDLE sharedNtHandle;

    static const VkFormat format = VK_FORMAT_R8G8B8A8_UNORM;
    static const VkExternalMemoryHandleTypeFlagsNV handleType =
        VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV;

    VkPhysicalDeviceMemoryProperties memoryProperties;
    VkExternalImageFormatPropertiesNV properties;
    VkExternalMemoryImageCreateInfoNV externalMemoryImageCreateInfo;
    VkImageCreateInfo imageCreateInfo;
    VkImage image;
    VkMemoryRequirements imageMemoryRequirements;
    uint32_t numMemoryTypes;
    uint32_t memoryType;
    VkImportMemoryWin32HandleInfoNV importMemoryInfo;
    VkMemoryAllocateInfo memoryAllocateInfo;
    VkDeviceMemory mem;
    VkResult result;

    // Figure out how many memory types the device supports
    vkGetPhysicalDeviceMemoryProperties(physicalDevice,
                                        &memoryProperties);
    numMemoryTypes = memoryProperties.memoryTypeCount;

    // Check the external handle type capabilities for the chosen format
    // Importable 2D image support with at least 1 mip level, 1 array
    // layer, and VK_SAMPLE_COUNT_1_BIT using optimal tiling and supporting
    // texturing and color rendering is required.
    result = vkGetPhysicalDeviceExternalImageFormatPropertiesNV(
        physicalDevice,
        format,
        VK_IMAGE_TYPE_2D,
        VK_IMAGE_TILING_OPTIMAL,
        VK_IMAGE_USAGE_SAMPLED_BIT |
        VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT,
        0,
        handleType,
        &properties);

    if ((result != VK_SUCCESS) ||
        !(properties.externalMemoryFeatures &
          VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV)) {
        abort();
    }

    // Set up the external memory image creation info
    memset(&externalMemoryImageCreateInfo,
           0, sizeof(externalMemoryImageCreateInfo));
    externalMemoryImageCreateInfo.sType =
        VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV;
    externalMemoryImageCreateInfo.handleTypes = handleType;
    // Set up the  core image creation info
    memset(&imageCreateInfo, 0, sizeof(imageCreateInfo));
    imageCreateInfo.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
    imageCreateInfo.pNext = &externalMemoryImageCreateInfo;
    imageCreateInfo.format = format;
    imageCreateInfo.extent.width = 64;
    imageCreateInfo.extent.height = 64;
    imageCreateInfo.extent.depth = 1;
    imageCreateInfo.mipLevels = 1;
    imageCreateInfo.arrayLayers = 1;
    imageCreateInfo.samples = VK_SAMPLE_COUNT_1_BIT;
    imageCreateInfo.tiling = VK_IMAGE_TILING_OPTIMAL;
    imageCreateInfo.usage = VK_IMAGE_USAGE_SAMPLED_BIT |
        VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT;
    imageCreateInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;
    imageCreateInfo.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;

    vkCreateImage(device, &imageCreateInfo, NULL, &image);
    vkGetImageMemoryRequirements(device,
                                 image,
                                 &imageMemoryRequirements);

    // For simplicity, just pick the first compatible memory type.
    for (memoryType = 0; memoryType 

* 
Revision 2, 2016-08-11 (James Jones)

Updated sample code based on the NV external memory extensions.

* 
Renamed from NVX to NV extension.

* 
Added Overview and Description sections.

* 
Updated sample code to use the NV external memory extensions.

Revision 1, 2016-06-14 (Carsten Rohde)

* 
Initial draft.

**Name String**

`VK_QCOM_fragment_density_map_offset`

**Extension Type**

Device extension

**Registered Extension Number**

426

**Revision**

3

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

 [VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)

 or

 [Vulkan Version 1.1](versions.html#versions-1.1)

and

[VK_EXT_fragment_density_map](#VK_EXT_fragment_density_map)

**Deprecation State**

* 
*Promoted* to
[VK_EXT_fragment_density_map_offset](#VK_EXT_fragment_density_map_offset)
extension

**Contact**

* 
Matthew Netsch [mnetsch](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_QCOM_fragment_density_map_offset] @mnetsch%0A*Here describe the issue or question you have about the VK_QCOM_fragment_density_map_offset extension*)

**Last Modified Date**

2024-06-17

**Contributors**

* 
Matthew Netsch, Qualcomm Technologies, Inc.

* 
Jonathan Wicks, Qualcomm Technologies, Inc.

* 
Jonathan Tinkham, Qualcomm Technologies, Inc.

* 
Jeff Leger, Qualcomm Technologies, Inc.

* 
Manan Katwala, Qualcomm Technologies, Inc.

* 
Connor Abbott, Valve Corporation

This extension allows an application to specify offsets to a fragment
density map attachment, changing the location where the fragment density map
is applied to the framebuffer.
This is helpful for eye-tracking use cases where the fovea needs to be moved
around the framebuffer to match the eye pose.

* 
Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

[VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM](../chapters/features.html#VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM)

Extending [VkPhysicalDeviceProperties2](../chapters/devsandqueues.html#VkPhysicalDeviceProperties2):

* 
[VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM](../chapters/limits.html#VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM)

Extending [VkSubpassEndInfo](../chapters/renderpass.html#VkSubpassEndInfo), [VkRenderingEndInfoEXT](../chapters/renderpass.html#VkRenderingEndInfoEXT):

* 
[VkSubpassFragmentDensityMapOffsetEndInfoQCOM](../chapters/renderpass.html#VkSubpassFragmentDensityMapOffsetEndInfoQCOM)

* 
`VK_QCOM_FRAGMENT_DENSITY_MAP_OFFSET_EXTENSION_NAME`

* 
`VK_QCOM_FRAGMENT_DENSITY_MAP_OFFSET_SPEC_VERSION`

* 
Extending [VkImageCreateFlagBits](../chapters/resources.html#VkImageCreateFlagBits):

`VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM`

* 
`VK_STRUCTURE_TYPE_SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM`

* 
Revision 3, 2025-03-20 (Connor Abbott/Matthew Netsch)

Fix clamp equation and clarify the offsets are FDM relative (editorial
only)

Revision 2, 2024-06-17 (Matthew Netsch)

* 
Fix typo in spec regarding fragmentDensityMapOffset feature

Revision 1, 2021-09-03 (Matthew Netsch)

* 
Initial version

**Name String**

`VK_VALVE_mutable_descriptor_type`

**Extension Type**

Device extension

**Registered Extension Number**

352

**Revision**

1

**Ratification Status**

Not ratified

**Extension and Version Dependencies**

[VK_KHR_maintenance3](#VK_KHR_maintenance3)

**Deprecation State**

* 
*Promoted* to
[VK_EXT_mutable_descriptor_type](#VK_EXT_mutable_descriptor_type)
extension

**Special Use**

* 
[D3D support](../chapters/extensions.html#extendingvulkan-compatibility-specialuse)

**Contact**

* 
Joshua Ashton [Joshua-Ashton](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_VALVE_mutable_descriptor_type] @Joshua-Ashton%0A*Here describe the issue or question you have about the VK_VALVE_mutable_descriptor_type extension*)

* 
Hans-Kristian Arntzen [HansKristian-Work](https://github.com/KhronosGroup/Vulkan-Docs/issues/new?body=[VK_VALVE_mutable_descriptor_type] @HansKristian-Work%0A*Here describe the issue or question you have about the VK_VALVE_mutable_descriptor_type extension*)

**Last Modified Date**

2020-12-02

**IP Status**

No known IP claims.

**Contributors**

* 
Joshua Ashton, Valve

* 
Hans-Kristian Arntzen, Valve

This extension allows applications to reduce descriptor memory footprint by
allowing a descriptor to be able to mutate to a given list of descriptor
types depending on which descriptor types are written into, or copied into a
descriptor set.

The main use case this extension intends to address is descriptor indexing
with `VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT` where the
descriptor types are completely generic, as this means applications can
allocate one large descriptor set, rather than having one large descriptor
set per descriptor type, which significantly bloats descriptor memory usage
and causes performance issues.

This extension also adds a mechanism to declare that a descriptor pool, and
therefore the descriptor sets that are allocated from it, reside only in
host memory; as such these descriptors can only be updated/copied, but not
bound.

These features together allow much more efficient emulation of the raw D3D12
binding model.
This extension is primarily intended to be useful for API layering efforts.

* 
[VkMutableDescriptorTypeListVALVE](../chapters/descriptorsets.html#VkMutableDescriptorTypeListVALVE)

* 
Extending [VkDescriptorSetLayoutCreateInfo](../chapters/descriptorsets.html#VkDescriptorSetLayoutCreateInfo), [VkDescriptorPoolCreateInfo](../chapters/descriptorsets.html#VkDescriptorPoolCreateInfo):

[VkMutableDescriptorTypeCreateInfoVALVE](../chapters/descriptorsets.html#VkMutableDescriptorTypeCreateInfoVALVE)

Extending [VkPhysicalDeviceFeatures2](../chapters/features.html#VkPhysicalDeviceFeatures2), [VkDeviceCreateInfo](../chapters/devsandqueues.html#VkDeviceCreateInfo):

* 
[VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE](../chapters/features.html#VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE)

* 
`VK_VALVE_MUTABLE_DESCRIPTOR_TYPE_EXTENSION_NAME`

* 
`VK_VALVE_MUTABLE_DESCRIPTOR_TYPE_SPEC_VERSION`

* 
Extending [VkDescriptorPoolCreateFlagBits](../chapters/descriptorsets.html#VkDescriptorPoolCreateFlagBits):

`VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_VALVE`

Extending [VkDescriptorSetLayoutCreateFlagBits](../chapters/descriptorsets.html#VkDescriptorSetLayoutCreateFlagBits):

* 
`VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_VALVE`

Extending [VkDescriptorType](../chapters/descriptorsets.html#VkDescriptorType):

* 
`VK_DESCRIPTOR_TYPE_MUTABLE_VALVE`

Extending [VkStructureType](../chapters/fundamentals.html#VkStructureType):

* 
`VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_VALVE`

* 
`VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_VALVE`

* 
Revision 1, 2020-12-01 (Joshua Ashton, Hans-Kristian Arntzen)

Initial specification, squashed from public draft.

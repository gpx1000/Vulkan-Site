# Layers & Extensions (Informative)

## Metadata

- **Component**: spec
- **Version**: latest
- **URL**: /spec/latest/appendices/extensions.html

## Table of Contents

- [Extension Dependencies](#_extension_dependencies)
- [Extension Interactions](#_extension_interactions)
- [List of Current Extensions](#current-extension-appendices-list)
- [List_of_Current_Extensions](#current-extension-appendices-list)
- [VK_KHR_acceleration_structure](#VK_KHR_acceleration_structure)
- [Other Extension Metadata](#_other_extension_metadata)
- [Other_Extension_Metadata](#_other_extension_metadata)
- [Description](#_description)
- [New Object Types](#_new_object_types)
- [New_Object_Types](#_new_object_types)
- [New Commands](#_new_commands)
- [New Structures](#_new_structures)
- [New Unions](#_new_unions)
- [New Enums](#_new_enums)
- [New Bitmasks](#_new_bitmasks)
- [New Enum Constants](#_new_enum_constants)
- [New_Enum_Constants](#_new_enum_constants)
- [Issues](#_issues)
- [Version History](#_version_history)
- [VK_KHR_android_surface](#VK_KHR_android_surface)
- [Other Extension Metadata](#_other_extension_metadata_2)
- [Other_Extension_Metadata](#_other_extension_metadata_2)
- [Description](#_description_2)
- [New Base Types](#_new_base_types)
- [New_Base_Types](#_new_base_types)
- [New Commands](#_new_commands_2)
- [New Structures](#_new_structures_2)
- [New Bitmasks](#_new_bitmasks_2)
- [New Enum Constants](#_new_enum_constants_2)
- [New_Enum_Constants](#_new_enum_constants_2)
- [Issues](#_issues_2)
- [Version History](#_version_history_2)
- [VK_KHR_calibrated_timestamps](#VK_KHR_calibrated_timestamps)
- [Other Extension Metadata](#_other_extension_metadata_3)
- [Other_Extension_Metadata](#_other_extension_metadata_3)
- [Description](#_description_3)
- [New Commands](#_new_commands_3)
- [New Structures](#_new_structures_3)
- [New Enums](#_new_enums_2)
- [New Enum Constants](#_new_enum_constants_3)
- [New_Enum_Constants](#_new_enum_constants_3)
- [Version History](#_version_history_3)
- [VK_KHR_compute_shader_derivatives](#VK_KHR_compute_shader_derivatives)
- [Other Extension Metadata](#_other_extension_metadata_4)
- [Other_Extension_Metadata](#_other_extension_metadata_4)
- [Description](#_description_4)
- [New Structures](#_new_structures_4)
- [New Enum Constants](#_new_enum_constants_4)
- [New_Enum_Constants](#_new_enum_constants_4)
- [New SPIR-V Capability](#_new_spir_v_capability)
- [New_SPIR-V_Capability](#_new_spir_v_capability)
- [Examples](#_examples)
- [Version History](#_version_history_4)
- [VK_KHR_cooperative_matrix](#VK_KHR_cooperative_matrix)
- [Other Extension Metadata](#_other_extension_metadata_5)
- [Other_Extension_Metadata](#_other_extension_metadata_5)
- [Description](#_description_5)
- [New Commands](#_new_commands_4)
- [New Structures](#_new_structures_5)
- [New Enums](#_new_enums_3)
- [New Enum Constants](#_new_enum_constants_5)
- [New_Enum_Constants](#_new_enum_constants_5)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities)
- [Issues](#_issues_3)
- [Version History](#_version_history_5)
- [VK_KHR_deferred_host_operations](#VK_KHR_deferred_host_operations)
- [Other Extension Metadata](#_other_extension_metadata_6)
- [Other_Extension_Metadata](#_other_extension_metadata_6)
- [Description](#_description_6)
- [New Object Types](#_new_object_types_2)
- [New_Object_Types](#_new_object_types_2)
- [New Commands](#_new_commands_5)
- [New Enum Constants](#_new_enum_constants_6)
- [New_Enum_Constants](#_new_enum_constants_6)
- [Code Examples](#_code_examples)
- [Issues](#_issues_4)
- [Version History](#_version_history_6)
- [VK_KHR_depth_clamp_zero_one](#VK_KHR_depth_clamp_zero_one)
- [Other Extension Metadata](#_other_extension_metadata_7)
- [Other_Extension_Metadata](#_other_extension_metadata_7)
- [Description](#_description_7)
- [New Structures](#_new_structures_6)
- [New Enum Constants](#_new_enum_constants_7)
- [New_Enum_Constants](#_new_enum_constants_7)
- [Version History](#_version_history_7)
- [VK_KHR_display](#VK_KHR_display)
- [Other Extension Metadata](#_other_extension_metadata_8)
- [Other_Extension_Metadata](#_other_extension_metadata_8)
- [Description](#_description_8)
- [New Object Types](#_new_object_types_3)
- [New_Object_Types](#_new_object_types_3)
- [New Commands](#_new_commands_6)
- [New Structures](#_new_structures_7)
- [New Enums](#_new_enums_4)
- [New Bitmasks](#_new_bitmasks_3)
- [New Enum Constants](#_new_enum_constants_8)
- [New_Enum_Constants](#_new_enum_constants_8)
- [Issues](#_issues_5)
- [Examples](#_examples_2)
- [Version History](#_version_history_8)
- [VK_KHR_display_swapchain](#VK_KHR_display_swapchain)
- [Other Extension Metadata](#_other_extension_metadata_9)
- [Other_Extension_Metadata](#_other_extension_metadata_9)
- [Description](#_description_9)
- [New Commands](#_new_commands_7)
- [New Structures](#_new_structures_8)
- [New Enum Constants](#_new_enum_constants_9)
- [New_Enum_Constants](#_new_enum_constants_9)
- [Issues](#_issues_6)
- [Examples](#_examples_3)
- [Version History](#_version_history_9)
- [VK_KHR_external_fence_fd](#VK_KHR_external_fence_fd)
- [Other Extension Metadata](#_other_extension_metadata_10)
- [Other_Extension_Metadata](#_other_extension_metadata_10)
- [Description](#_description_10)
- [New Commands](#_new_commands_8)
- [New Structures](#_new_structures_9)
- [New Enum Constants](#_new_enum_constants_10)
- [New_Enum_Constants](#_new_enum_constants_10)
- [Issues](#_issues_7)
- [Version History](#_version_history_10)
- [VK_KHR_external_fence_win32](#VK_KHR_external_fence_win32)
- [Other Extension Metadata](#_other_extension_metadata_11)
- [Other_Extension_Metadata](#_other_extension_metadata_11)
- [Description](#_description_11)
- [New Commands](#_new_commands_9)
- [New Structures](#_new_structures_10)
- [New Enum Constants](#_new_enum_constants_11)
- [New_Enum_Constants](#_new_enum_constants_11)
- [Issues](#_issues_8)
- [Version History](#_version_history_11)
- [VK_KHR_external_memory_fd](#VK_KHR_external_memory_fd)
- [Other Extension Metadata](#_other_extension_metadata_12)
- [Other_Extension_Metadata](#_other_extension_metadata_12)
- [Description](#_description_12)
- [New Commands](#_new_commands_10)
- [New Structures](#_new_structures_11)
- [New Enum Constants](#_new_enum_constants_12)
- [New_Enum_Constants](#_new_enum_constants_12)
- [Issues](#_issues_9)
- [Version History](#_version_history_12)
- [VK_KHR_external_memory_win32](#VK_KHR_external_memory_win32)
- [Other Extension Metadata](#_other_extension_metadata_13)
- [Other_Extension_Metadata](#_other_extension_metadata_13)
- [Description](#_description_13)
- [New Commands](#_new_commands_11)
- [New Structures](#_new_structures_12)
- [New Enum Constants](#_new_enum_constants_13)
- [New_Enum_Constants](#_new_enum_constants_13)
- [Issues](#_issues_10)
- [Version History](#_version_history_13)
- [VK_KHR_external_semaphore_fd](#VK_KHR_external_semaphore_fd)
- [Other Extension Metadata](#_other_extension_metadata_14)
- [Other_Extension_Metadata](#_other_extension_metadata_14)
- [Description](#_description_14)
- [New Commands](#_new_commands_12)
- [New Structures](#_new_structures_13)
- [New Enum Constants](#_new_enum_constants_14)
- [New_Enum_Constants](#_new_enum_constants_14)
- [Issues](#_issues_11)
- [Version History](#_version_history_14)
- [VK_KHR_external_semaphore_win32](#VK_KHR_external_semaphore_win32)
- [Other Extension Metadata](#_other_extension_metadata_15)
- [Other_Extension_Metadata](#_other_extension_metadata_15)
- [Description](#_description_15)
- [New Commands](#_new_commands_13)
- [New Structures](#_new_structures_14)
- [New Enum Constants](#_new_enum_constants_15)
- [New_Enum_Constants](#_new_enum_constants_15)
- [Issues](#_issues_12)
- [Version History](#_version_history_15)
- [VK_KHR_fragment_shader_barycentric](#VK_KHR_fragment_shader_barycentric)
- [Other Extension Metadata](#_other_extension_metadata_16)
- [Other_Extension_Metadata](#_other_extension_metadata_16)
- [Description](#_description_16)
- [New Structures](#_new_structures_15)
- [New Enum Constants](#_new_enum_constants_16)
- [New_Enum_Constants](#_new_enum_constants_16)
- [New Built-In Variables](#_new_built_in_variables)
- [New_Built-In_Variables](#_new_built_in_variables)
- [New SPIR-V Decorations](#_new_spir_v_decorations)
- [New_SPIR-V_Decorations](#_new_spir_v_decorations)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_2)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_2)
- [Issues](#_issues_13)
- [Version History](#_version_history_16)
- [VK_KHR_fragment_shading_rate](#VK_KHR_fragment_shading_rate)
- [Other Extension Metadata](#_other_extension_metadata_17)
- [Other_Extension_Metadata](#_other_extension_metadata_17)
- [Description](#_description_17)
- [New Commands](#_new_commands_14)
- [New Structures](#_new_structures_16)
- [New Enums](#_new_enums_5)
- [New Enum Constants](#_new_enum_constants_17)
- [New_Enum_Constants](#_new_enum_constants_17)
- [Version History](#_version_history_17)
- [VK_KHR_get_display_properties2](#VK_KHR_get_display_properties2)
- [Other Extension Metadata](#_other_extension_metadata_18)
- [Other_Extension_Metadata](#_other_extension_metadata_18)
- [Description](#_description_18)
- [New Commands](#_new_commands_15)
- [New Structures](#_new_structures_17)
- [New Enum Constants](#_new_enum_constants_18)
- [New_Enum_Constants](#_new_enum_constants_18)
- [Issues](#_issues_14)
- [Version History](#_version_history_18)
- [VK_KHR_get_surface_capabilities2](#VK_KHR_get_surface_capabilities2)
- [Other Extension Metadata](#_other_extension_metadata_19)
- [Other_Extension_Metadata](#_other_extension_metadata_19)
- [Description](#_description_19)
- [New Commands](#_new_commands_16)
- [New Structures](#_new_structures_18)
- [New Enum Constants](#_new_enum_constants_19)
- [New_Enum_Constants](#_new_enum_constants_19)
- [Issues](#_issues_15)
- [Version History](#_version_history_19)
- [VK_KHR_incremental_present](#VK_KHR_incremental_present)
- [Other Extension Metadata](#_other_extension_metadata_20)
- [Other_Extension_Metadata](#_other_extension_metadata_20)
- [Description](#_description_20)
- [New Structures](#_new_structures_19)
- [New Enum Constants](#_new_enum_constants_20)
- [New_Enum_Constants](#_new_enum_constants_20)
- [Issues](#_issues_16)
- [Version History](#_version_history_20)
- [VK_KHR_maintenance7](#VK_KHR_maintenance7)
- [Other Extension Metadata](#_other_extension_metadata_21)
- [Other_Extension_Metadata](#_other_extension_metadata_21)
- [Description](#_description_21)
- [New Structures](#_new_structures_20)
- [New Enums](#_new_enums_6)
- [New Enum Constants](#_new_enum_constants_21)
- [New_Enum_Constants](#_new_enum_constants_21)
- [Issues](#_issues_17)
- [Version History](#_version_history_21)
- [VK_KHR_maintenance8](#VK_KHR_maintenance8)
- [Other Extension Metadata](#_other_extension_metadata_22)
- [Other_Extension_Metadata](#_other_extension_metadata_22)
- [Description](#_description_22)
- [New Structures](#_new_structures_21)
- [New Enums](#_new_enums_7)
- [New Bitmasks](#_new_bitmasks_4)
- [New Enum Constants](#_new_enum_constants_22)
- [New_Enum_Constants](#_new_enum_constants_22)
- [Issues](#_issues_18)
- [Version History](#_version_history_22)
- [VK_KHR_performance_query](#VK_KHR_performance_query)
- [Other Extension Metadata](#_other_extension_metadata_23)
- [Other_Extension_Metadata](#_other_extension_metadata_23)
- [Description](#_description_23)
- [New Commands](#_new_commands_17)
- [New Structures](#_new_structures_22)
- [New Unions](#_new_unions_2)
- [New Enums](#_new_enums_8)
- [New Bitmasks](#_new_bitmasks_5)
- [New Enum Constants](#_new_enum_constants_23)
- [New_Enum_Constants](#_new_enum_constants_23)
- [Issues](#_issues_19)
- [Examples](#_examples_4)
- [Version History](#_version_history_23)
- [VK_KHR_pipeline_binary](#VK_KHR_pipeline_binary)
- [Other Extension Metadata](#_other_extension_metadata_24)
- [Other_Extension_Metadata](#_other_extension_metadata_24)
- [Description](#_description_24)
- [New Object Types](#_new_object_types_4)
- [New_Object_Types](#_new_object_types_4)
- [New Commands](#_new_commands_18)
- [New Structures](#_new_structures_23)
- [New Enum Constants](#_new_enum_constants_24)
- [New_Enum_Constants](#_new_enum_constants_24)
- [Version History](#_version_history_24)
- [VK_KHR_pipeline_executable_properties](#VK_KHR_pipeline_executable_properties)
- [Other Extension Metadata](#_other_extension_metadata_25)
- [Other_Extension_Metadata](#_other_extension_metadata_25)
- [Description](#_description_25)
- [New Commands](#_new_commands_19)
- [New Structures](#_new_structures_24)
- [New Unions](#_new_unions_3)
- [New Enums](#_new_enums_9)
- [New Enum Constants](#_new_enum_constants_25)
- [New_Enum_Constants](#_new_enum_constants_25)
- [Issues](#_issues_20)
- [Version History](#_version_history_25)
- [VK_KHR_pipeline_library](#VK_KHR_pipeline_library)
- [Other Extension Metadata](#_other_extension_metadata_26)
- [Other_Extension_Metadata](#_other_extension_metadata_26)
- [Description](#_description_26)
- [New Structures](#_new_structures_25)
- [New Enum Constants](#_new_enum_constants_26)
- [New_Enum_Constants](#_new_enum_constants_26)
- [Version History](#_version_history_26)
- [VK_KHR_portability_enumeration](#VK_KHR_portability_enumeration)
- [Other Extension Metadata](#_other_extension_metadata_27)
- [Other_Extension_Metadata](#_other_extension_metadata_27)
- [Description](#_description_27)
- [New Enum Constants](#_new_enum_constants_27)
- [New_Enum_Constants](#_new_enum_constants_27)
- [Version History](#_version_history_27)
- [VK_KHR_present_id](#VK_KHR_present_id)
- [Other Extension Metadata](#_other_extension_metadata_28)
- [Other_Extension_Metadata](#_other_extension_metadata_28)
- [Description](#_description_28)
- [New Structures](#_new_structures_26)
- [New Enum Constants](#_new_enum_constants_28)
- [New_Enum_Constants](#_new_enum_constants_28)
- [Issues](#_issues_21)
- [Examples](#_examples_5)
- [Version History](#_version_history_28)
- [VK_KHR_present_wait](#VK_KHR_present_wait)
- [Other Extension Metadata](#_other_extension_metadata_29)
- [Other_Extension_Metadata](#_other_extension_metadata_29)
- [Description](#_description_29)
- [New Commands](#_new_commands_20)
- [New Structures](#_new_structures_27)
- [New Enum Constants](#_new_enum_constants_29)
- [New_Enum_Constants](#_new_enum_constants_29)
- [Issues](#_issues_22)
- [Examples](#_examples_6)
- [Version History](#_version_history_29)
- [VK_KHR_ray_query](#VK_KHR_ray_query)
- [Other Extension Metadata](#_other_extension_metadata_30)
- [Other_Extension_Metadata](#_other_extension_metadata_30)
- [Description](#_description_30)
- [New Structures](#_new_structures_28)
- [New Enum Constants](#_new_enum_constants_30)
- [New_Enum_Constants](#_new_enum_constants_30)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_3)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_3)
- [Sample Code](#_sample_code)
- [Issues](#_issues_23)
- [Version History](#_version_history_30)
- [VK_KHR_ray_tracing_maintenance1](#VK_KHR_ray_tracing_maintenance1)
- [Other Extension Metadata](#_other_extension_metadata_31)
- [Other_Extension_Metadata](#_other_extension_metadata_31)
- [Description](#_description_31)
- [New Commands](#_new_commands_21)
- [New Structures](#_new_structures_29)
- [New Enum Constants](#_new_enum_constants_31)
- [New_Enum_Constants](#_new_enum_constants_31)
- [New Built-In Variables](#_new_built_in_variables_2)
- [New_Built-In_Variables](#_new_built_in_variables_2)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_4)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_4)
- [Issues](#_issues_24)
- [Version History](#_version_history_31)
- [VK_KHR_ray_tracing_pipeline](#VK_KHR_ray_tracing_pipeline)
- [Other Extension Metadata](#_other_extension_metadata_32)
- [Other_Extension_Metadata](#_other_extension_metadata_32)
- [Description](#_description_32)
- [New Commands](#_new_commands_22)
- [New Structures](#_new_structures_30)
- [New Enums](#_new_enums_10)
- [New Enum Constants](#_new_enum_constants_32)
- [New_Enum_Constants](#_new_enum_constants_32)
- [New or Modified Built-In Variables](#_new_or_modified_built_in_variables)
- [New_or_Modified_Built-In_Variables](#_new_or_modified_built_in_variables)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_5)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_5)
- [Issues](#_issues_25)
- [Sample Code](#_sample_code_2)
- [Version History](#_version_history_32)
- [VK_KHR_ray_tracing_position_fetch](#VK_KHR_ray_tracing_position_fetch)
- [Other Extension Metadata](#_other_extension_metadata_33)
- [Other_Extension_Metadata](#_other_extension_metadata_33)
- [Description](#_description_33)
- [New Structures](#_new_structures_31)
- [New Enum Constants](#_new_enum_constants_33)
- [New_Enum_Constants](#_new_enum_constants_33)
- [New Built-In Variables](#_new_built_in_variables_3)
- [New_Built-In_Variables](#_new_built_in_variables_3)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_6)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_6)
- [Issues](#_issues_26)
- [Version History](#_version_history_33)
- [VK_KHR_robustness2](#VK_KHR_robustness2)
- [Other Extension Metadata](#_other_extension_metadata_34)
- [Other_Extension_Metadata](#_other_extension_metadata_34)
- [Description](#_description_34)
- [New Structures](#_new_structures_32)
- [New Enum Constants](#_new_enum_constants_34)
- [New_Enum_Constants](#_new_enum_constants_34)
- [Issues](#_issues_27)
- [Version History](#_version_history_34)
- [VK_KHR_shader_bfloat16](#VK_KHR_shader_bfloat16)
- [Other Extension Metadata](#_other_extension_metadata_35)
- [Other_Extension_Metadata](#_other_extension_metadata_35)
- [Description](#_description_35)
- [New Structures](#_new_structures_33)
- [New Enum Constants](#_new_enum_constants_35)
- [New_Enum_Constants](#_new_enum_constants_35)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_7)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_7)
- [Version History](#_version_history_35)
- [VK_KHR_shader_clock](#VK_KHR_shader_clock)
- [Other Extension Metadata](#_other_extension_metadata_36)
- [Other_Extension_Metadata](#_other_extension_metadata_36)
- [Description](#_description_36)
- [New Structures](#_new_structures_34)
- [New Enum Constants](#_new_enum_constants_36)
- [New_Enum_Constants](#_new_enum_constants_36)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_8)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_8)
- [Version History](#_version_history_36)
- [VK_KHR_shader_maximal_reconvergence](#VK_KHR_shader_maximal_reconvergence)
- [Other Extension Metadata](#_other_extension_metadata_37)
- [Other_Extension_Metadata](#_other_extension_metadata_37)
- [Description](#_description_37)
- [New Structures](#_new_structures_35)
- [New Enum Constants](#_new_enum_constants_37)
- [New_Enum_Constants](#_new_enum_constants_37)
- [Version History](#_version_history_37)
- [VK_KHR_shader_quad_control](#VK_KHR_shader_quad_control)
- [Other Extension Metadata](#_other_extension_metadata_38)
- [Other_Extension_Metadata](#_other_extension_metadata_38)
- [Description](#_description_38)
- [New Structures](#_new_structures_36)
- [New Enum Constants](#_new_enum_constants_38)
- [New_Enum_Constants](#_new_enum_constants_38)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_9)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_9)
- [Version History](#_version_history_38)
- [VK_KHR_shader_relaxed_extended_instruction](#VK_KHR_shader_relaxed_extended_instruction)
- [Other Extension Metadata](#_other_extension_metadata_39)
- [Other_Extension_Metadata](#_other_extension_metadata_39)
- [Description](#_description_39)
- [New Structures](#_new_structures_37)
- [New Enum Constants](#_new_enum_constants_39)
- [New_Enum_Constants](#_new_enum_constants_39)
- [Version History](#_version_history_39)
- [VK_KHR_shader_subgroup_uniform_control_flow](#VK_KHR_shader_subgroup_uniform_control_flow)
- [Other Extension Metadata](#_other_extension_metadata_40)
- [Other_Extension_Metadata](#_other_extension_metadata_40)
- [Description](#_description_40)
- [New Structures](#_new_structures_38)
- [New Enum Constants](#_new_enum_constants_40)
- [New_Enum_Constants](#_new_enum_constants_40)
- [Version History](#_version_history_40)
- [VK_KHR_shared_presentable_image](#VK_KHR_shared_presentable_image)
- [Other Extension Metadata](#_other_extension_metadata_41)
- [Other_Extension_Metadata](#_other_extension_metadata_41)
- [Description](#_description_41)
- [New Commands](#_new_commands_23)
- [New Structures](#_new_structures_39)
- [New Enum Constants](#_new_enum_constants_41)
- [New_Enum_Constants](#_new_enum_constants_41)
- [Issues](#_issues_28)
- [Version History](#_version_history_41)
- [VK_KHR_surface](#VK_KHR_surface)
- [Other Extension Metadata](#_other_extension_metadata_42)
- [Other_Extension_Metadata](#_other_extension_metadata_42)
- [Description](#_description_42)
- [New Object Types](#_new_object_types_5)
- [New_Object_Types](#_new_object_types_5)
- [New Commands](#_new_commands_24)
- [New Structures](#_new_structures_40)
- [New Enums](#_new_enums_11)
- [New Bitmasks](#_new_bitmasks_6)
- [New Enum Constants](#_new_enum_constants_42)
- [New_Enum_Constants](#_new_enum_constants_42)
- [Examples](#_examples_7)
- [Issues](#_issues_29)
- [Version History](#_version_history_42)
- [VK_KHR_surface_protected_capabilities](#VK_KHR_surface_protected_capabilities)
- [Other Extension Metadata](#_other_extension_metadata_43)
- [Other_Extension_Metadata](#_other_extension_metadata_43)
- [Description](#_description_43)
- [New Structures](#_new_structures_41)
- [New Enum Constants](#_new_enum_constants_43)
- [New_Enum_Constants](#_new_enum_constants_43)
- [Version History](#_version_history_43)
- [VK_KHR_swapchain](#VK_KHR_swapchain)
- [Other Extension Metadata](#_other_extension_metadata_44)
- [Other_Extension_Metadata](#_other_extension_metadata_44)
- [Description](#_description_44)
- [New Object Types](#_new_object_types_6)
- [New_Object_Types](#_new_object_types_6)
- [New Commands](#_new_commands_25)
- [New Structures](#_new_structures_42)
- [New Enums](#_new_enums_12)
- [New Bitmasks](#_new_bitmasks_7)
- [New Enum Constants](#_new_enum_constants_44)
- [New_Enum_Constants](#_new_enum_constants_44)
- [Issues](#_issues_30)
- [Examples](#_examples_8)
- [Version History](#_version_history_44)
- [VK_KHR_swapchain_mutable_format](#VK_KHR_swapchain_mutable_format)
- [Other Extension Metadata](#_other_extension_metadata_45)
- [Other_Extension_Metadata](#_other_extension_metadata_45)
- [Description](#_description_45)
- [New Enum Constants](#_new_enum_constants_45)
- [New_Enum_Constants](#_new_enum_constants_45)
- [Issues](#_issues_31)
- [Version History](#_version_history_45)
- [VK_KHR_video_decode_av1](#VK_KHR_video_decode_av1)
- [Other Extension Metadata](#_other_extension_metadata_46)
- [Other_Extension_Metadata](#_other_extension_metadata_46)
- [Description](#_description_46)
- [New Structures](#_new_structures_43)
- [New Enum Constants](#_new_enum_constants_46)
- [New_Enum_Constants](#_new_enum_constants_46)
- [Version History](#_version_history_46)
- [VK_KHR_video_decode_h264](#VK_KHR_video_decode_h264)
- [Other Extension Metadata](#_other_extension_metadata_47)
- [Other_Extension_Metadata](#_other_extension_metadata_47)
- [Description](#_description_47)
- [New Structures](#_new_structures_44)
- [New Enums](#_new_enums_13)
- [New Bitmasks](#_new_bitmasks_8)
- [New Enum Constants](#_new_enum_constants_47)
- [New_Enum_Constants](#_new_enum_constants_47)
- [Version History](#_version_history_47)
- [VK_KHR_video_decode_h265](#VK_KHR_video_decode_h265)
- [Other Extension Metadata](#_other_extension_metadata_48)
- [Other_Extension_Metadata](#_other_extension_metadata_48)
- [Description](#_description_48)
- [New Structures](#_new_structures_45)
- [New Enum Constants](#_new_enum_constants_48)
- [New_Enum_Constants](#_new_enum_constants_48)
- [Version History](#_version_history_48)
- [VK_KHR_video_decode_queue](#VK_KHR_video_decode_queue)
- [Other Extension Metadata](#_other_extension_metadata_49)
- [Other_Extension_Metadata](#_other_extension_metadata_49)
- [Description](#_description_49)
- [New Commands](#_new_commands_26)
- [New Structures](#_new_structures_46)
- [New Enums](#_new_enums_14)
- [New Bitmasks](#_new_bitmasks_9)
- [New Enum Constants](#_new_enum_constants_49)
- [New_Enum_Constants](#_new_enum_constants_49)
- [Version History](#_version_history_49)
- [VK_KHR_video_encode_av1](#VK_KHR_video_encode_av1)
- [Other Extension Metadata](#_other_extension_metadata_50)
- [Other_Extension_Metadata](#_other_extension_metadata_50)
- [Description](#_description_50)
- [New Structures](#_new_structures_47)
- [New Enums](#_new_enums_15)
- [New Bitmasks](#_new_bitmasks_10)
- [New Enum Constants](#_new_enum_constants_50)
- [New_Enum_Constants](#_new_enum_constants_50)
- [Version History](#_version_history_50)
- [VK_KHR_video_encode_h264](#VK_KHR_video_encode_h264)
- [Other Extension Metadata](#_other_extension_metadata_51)
- [Other_Extension_Metadata](#_other_extension_metadata_51)
- [Description](#_description_51)
- [New Structures](#_new_structures_48)
- [New Enums](#_new_enums_16)
- [New Bitmasks](#_new_bitmasks_11)
- [New Enum Constants](#_new_enum_constants_51)
- [New_Enum_Constants](#_new_enum_constants_51)
- [Version History](#_version_history_51)
- [VK_KHR_video_encode_h265](#VK_KHR_video_encode_h265)
- [Other Extension Metadata](#_other_extension_metadata_52)
- [Other_Extension_Metadata](#_other_extension_metadata_52)
- [Description](#_description_52)
- [New Structures](#_new_structures_49)
- [New Enums](#_new_enums_17)
- [New Bitmasks](#_new_bitmasks_12)
- [New Enum Constants](#_new_enum_constants_52)
- [New_Enum_Constants](#_new_enum_constants_52)
- [Version History](#_version_history_52)
- [VK_KHR_video_encode_quantization_map](#VK_KHR_video_encode_quantization_map)
- [Other Extension Metadata](#_other_extension_metadata_53)
- [Other_Extension_Metadata](#_other_extension_metadata_53)
- [Description](#_description_53)
- [New Structures](#_new_structures_50)
- [New Enums](#_new_enums_18)
- [New Enum Constants](#_new_enum_constants_53)
- [New_Enum_Constants](#_new_enum_constants_53)
- [Version History](#_version_history_53)
- [VK_KHR_video_encode_queue](#VK_KHR_video_encode_queue)
- [Other Extension Metadata](#_other_extension_metadata_54)
- [Other_Extension_Metadata](#_other_extension_metadata_54)
- [Description](#_description_54)
- [New Commands](#_new_commands_27)
- [New Structures](#_new_structures_51)
- [New Enums](#_new_enums_19)
- [New Bitmasks](#_new_bitmasks_13)
- [New Enum Constants](#_new_enum_constants_54)
- [New_Enum_Constants](#_new_enum_constants_54)
- [Version History](#_version_history_54)
- [VK_KHR_video_maintenance1](#VK_KHR_video_maintenance1)
- [Other Extension Metadata](#_other_extension_metadata_55)
- [Other_Extension_Metadata](#_other_extension_metadata_55)
- [Description](#_description_55)
- [New Structures](#_new_structures_52)
- [New Enum Constants](#_new_enum_constants_55)
- [New_Enum_Constants](#_new_enum_constants_55)
- [Version History](#_version_history_55)
- [VK_KHR_video_maintenance2](#VK_KHR_video_maintenance2)
- [Other Extension Metadata](#_other_extension_metadata_56)
- [Other_Extension_Metadata](#_other_extension_metadata_56)
- [Description](#_description_56)
- [New Structures](#_new_structures_53)
- [New Enum Constants](#_new_enum_constants_56)
- [New_Enum_Constants](#_new_enum_constants_56)
- [Version History](#_version_history_56)
- [VK_KHR_video_queue](#VK_KHR_video_queue)
- [Other Extension Metadata](#_other_extension_metadata_57)
- [Other_Extension_Metadata](#_other_extension_metadata_57)
- [Description](#_description_57)
- [New Object Types](#_new_object_types_7)
- [New_Object_Types](#_new_object_types_7)
- [New Commands](#_new_commands_28)
- [New Structures](#_new_structures_54)
- [New Enums](#_new_enums_20)
- [New Bitmasks](#_new_bitmasks_14)
- [New Enum Constants](#_new_enum_constants_57)
- [New_Enum_Constants](#_new_enum_constants_57)
- [Version History](#_version_history_57)
- [VK_KHR_wayland_surface](#VK_KHR_wayland_surface)
- [Other Extension Metadata](#_other_extension_metadata_58)
- [Other_Extension_Metadata](#_other_extension_metadata_58)
- [Description](#_description_58)
- [New Commands](#_new_commands_29)
- [New Structures](#_new_structures_55)
- [New Bitmasks](#_new_bitmasks_15)
- [New Enum Constants](#_new_enum_constants_58)
- [New_Enum_Constants](#_new_enum_constants_58)
- [Issues](#_issues_32)
- [Version History](#_version_history_58)
- [VK_KHR_win32_keyed_mutex](#VK_KHR_win32_keyed_mutex)
- [Other Extension Metadata](#_other_extension_metadata_59)
- [Other_Extension_Metadata](#_other_extension_metadata_59)
- [Description](#_description_59)
- [New Structures](#_new_structures_56)
- [New Enum Constants](#_new_enum_constants_59)
- [New_Enum_Constants](#_new_enum_constants_59)
- [Version History](#_version_history_59)
- [VK_KHR_win32_surface](#VK_KHR_win32_surface)
- [Other Extension Metadata](#_other_extension_metadata_60)
- [Other_Extension_Metadata](#_other_extension_metadata_60)
- [Description](#_description_60)
- [New Commands](#_new_commands_30)
- [New Structures](#_new_structures_57)
- [New Bitmasks](#_new_bitmasks_16)
- [New Enum Constants](#_new_enum_constants_60)
- [New_Enum_Constants](#_new_enum_constants_60)
- [Issues](#_issues_33)
- [Version History](#_version_history_60)
- [VK_KHR_workgroup_memory_explicit_layout](#VK_KHR_workgroup_memory_explicit_layout)
- [Other Extension Metadata](#_other_extension_metadata_61)
- [Other_Extension_Metadata](#_other_extension_metadata_61)
- [Description](#_description_61)
- [New Structures](#_new_structures_58)
- [New Enum Constants](#_new_enum_constants_61)
- [New_Enum_Constants](#_new_enum_constants_61)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_10)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_10)
- [Version History](#_version_history_61)
- [VK_KHR_xcb_surface](#VK_KHR_xcb_surface)
- [Other Extension Metadata](#_other_extension_metadata_62)
- [Other_Extension_Metadata](#_other_extension_metadata_62)
- [Description](#_description_62)
- [New Commands](#_new_commands_31)
- [New Structures](#_new_structures_59)
- [New Bitmasks](#_new_bitmasks_17)
- [New Enum Constants](#_new_enum_constants_62)
- [New_Enum_Constants](#_new_enum_constants_62)
- [Issues](#_issues_34)
- [Version History](#_version_history_62)
- [VK_KHR_xlib_surface](#VK_KHR_xlib_surface)
- [Other Extension Metadata](#_other_extension_metadata_63)
- [Other_Extension_Metadata](#_other_extension_metadata_63)
- [Description](#_description_63)
- [New Commands](#_new_commands_32)
- [New Structures](#_new_structures_60)
- [New Bitmasks](#_new_bitmasks_18)
- [New Enum Constants](#_new_enum_constants_63)
- [New_Enum_Constants](#_new_enum_constants_63)
- [Issues](#_issues_35)
- [Version History](#_version_history_63)
- [VK_EXT_acquire_drm_display](#VK_EXT_acquire_drm_display)
- [Other Extension Metadata](#_other_extension_metadata_64)
- [Other_Extension_Metadata](#_other_extension_metadata_64)
- [Description](#_description_64)
- [New Commands](#_new_commands_33)
- [New Enum Constants](#_new_enum_constants_64)
- [New_Enum_Constants](#_new_enum_constants_64)
- [Issues](#_issues_36)
- [Version History](#_version_history_64)
- [VK_EXT_acquire_xlib_display](#VK_EXT_acquire_xlib_display)
- [Other Extension Metadata](#_other_extension_metadata_65)
- [Other_Extension_Metadata](#_other_extension_metadata_65)
- [Description](#_description_65)
- [New Commands](#_new_commands_34)
- [New Enum Constants](#_new_enum_constants_65)
- [New_Enum_Constants](#_new_enum_constants_65)
- [Issues](#_issues_37)
- [Version History](#_version_history_65)
- [VK_EXT_astc_decode_mode](#VK_EXT_astc_decode_mode)
- [Other Extension Metadata](#_other_extension_metadata_66)
- [Other_Extension_Metadata](#_other_extension_metadata_66)
- [Description](#_description_66)
- [New Structures](#_new_structures_61)
- [New Enum Constants](#_new_enum_constants_66)
- [New_Enum_Constants](#_new_enum_constants_66)
- [Issues](#_issues_38)
- [Example](#_example)
- [Version History](#_version_history_66)
- [VK_EXT_attachment_feedback_loop_dynamic_state](#VK_EXT_attachment_feedback_loop_dynamic_state)
- [Other Extension Metadata](#_other_extension_metadata_67)
- [Other_Extension_Metadata](#_other_extension_metadata_67)
- [Description](#_description_67)
- [New Commands](#_new_commands_35)
- [New Structures](#_new_structures_62)
- [New Enum Constants](#_new_enum_constants_67)
- [New_Enum_Constants](#_new_enum_constants_67)
- [Version History](#_version_history_67)
- [VK_EXT_attachment_feedback_loop_layout](#VK_EXT_attachment_feedback_loop_layout)
- [Other Extension Metadata](#_other_extension_metadata_68)
- [Other_Extension_Metadata](#_other_extension_metadata_68)
- [Description](#_description_68)
- [New Structures](#_new_structures_63)
- [New Enum Constants](#_new_enum_constants_68)
- [New_Enum_Constants](#_new_enum_constants_68)
- [Version History](#_version_history_68)
- [VK_EXT_blend_operation_advanced](#VK_EXT_blend_operation_advanced)
- [Other Extension Metadata](#_other_extension_metadata_69)
- [Other_Extension_Metadata](#_other_extension_metadata_69)
- [Description](#_description_69)
- [New Structures](#_new_structures_64)
- [New Enums](#_new_enums_21)
- [New Enum Constants](#_new_enum_constants_69)
- [New_Enum_Constants](#_new_enum_constants_69)
- [Issues](#_issues_39)
- [Version History](#_version_history_69)
- [VK_EXT_border_color_swizzle](#VK_EXT_border_color_swizzle)
- [Other Extension Metadata](#_other_extension_metadata_70)
- [Other_Extension_Metadata](#_other_extension_metadata_70)
- [Description](#_description_70)
- [New Structures](#_new_structures_65)
- [New Enum Constants](#_new_enum_constants_70)
- [New_Enum_Constants](#_new_enum_constants_70)
- [Issues](#_issues_40)
- [Version History](#_version_history_70)
- [VK_EXT_color_write_enable](#VK_EXT_color_write_enable)
- [Other Extension Metadata](#_other_extension_metadata_71)
- [Other_Extension_Metadata](#_other_extension_metadata_71)
- [Description](#_description_71)
- [New Commands](#_new_commands_36)
- [New Structures](#_new_structures_66)
- [New Enum Constants](#_new_enum_constants_71)
- [New_Enum_Constants](#_new_enum_constants_71)
- [Version History](#_version_history_71)
- [VK_EXT_conditional_rendering](#VK_EXT_conditional_rendering)
- [Other Extension Metadata](#_other_extension_metadata_72)
- [Other_Extension_Metadata](#_other_extension_metadata_72)
- [Description](#_description_72)
- [New Commands](#_new_commands_37)
- [New Structures](#_new_structures_67)
- [New Enums](#_new_enums_22)
- [New Bitmasks](#_new_bitmasks_19)
- [New Enum Constants](#_new_enum_constants_72)
- [New_Enum_Constants](#_new_enum_constants_72)
- [Issues](#_issues_41)
- [Examples](#_examples_9)
- [Version History](#_version_history_72)
- [VK_EXT_conservative_rasterization](#VK_EXT_conservative_rasterization)
- [Other Extension Metadata](#_other_extension_metadata_73)
- [Other_Extension_Metadata](#_other_extension_metadata_73)
- [Description](#_description_73)
- [New Structures](#_new_structures_68)
- [New Enums](#_new_enums_23)
- [New Bitmasks](#_new_bitmasks_20)
- [New Enum Constants](#_new_enum_constants_73)
- [New_Enum_Constants](#_new_enum_constants_73)
- [New Built-In Variables](#_new_built_in_variables_4)
- [New_Built-In_Variables](#_new_built_in_variables_4)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_11)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_11)
- [Version History](#_version_history_73)
- [VK_EXT_custom_border_color](#VK_EXT_custom_border_color)
- [Other Extension Metadata](#_other_extension_metadata_74)
- [Other_Extension_Metadata](#_other_extension_metadata_74)
- [Description](#_description_74)
- [New Structures](#_new_structures_69)
- [New Enum Constants](#_new_enum_constants_74)
- [New_Enum_Constants](#_new_enum_constants_74)
- [Issues](#_issues_42)
- [Version History](#_version_history_74)
- [VK_EXT_debug_utils](#VK_EXT_debug_utils)
- [Other Extension Metadata](#_other_extension_metadata_75)
- [Other_Extension_Metadata](#_other_extension_metadata_75)
- [Description](#_description_75)
- [New Object Types](#_new_object_types_8)
- [New_Object_Types](#_new_object_types_8)
- [New Commands](#_new_commands_38)
- [New Structures](#_new_structures_70)
- [New Function Pointers](#_new_function_pointers)
- [New_Function_Pointers](#_new_function_pointers)
- [New Enums](#_new_enums_24)
- [New Bitmasks](#_new_bitmasks_21)
- [New Enum Constants](#_new_enum_constants_75)
- [New_Enum_Constants](#_new_enum_constants_75)
- [Examples](#_examples_10)
- [Issues](#_issues_43)
- [Version History](#_version_history_75)
- [VK_EXT_depth_bias_control](#VK_EXT_depth_bias_control)
- [Other Extension Metadata](#_other_extension_metadata_76)
- [Other_Extension_Metadata](#_other_extension_metadata_76)
- [Description](#_description_76)
- [New Commands](#_new_commands_39)
- [New Structures](#_new_structures_71)
- [New Enums](#_new_enums_25)
- [New Enum Constants](#_new_enum_constants_76)
- [New_Enum_Constants](#_new_enum_constants_76)
- [Version History](#_version_history_76)
- [VK_EXT_depth_clamp_control](#VK_EXT_depth_clamp_control)
- [Other Extension Metadata](#_other_extension_metadata_77)
- [Other_Extension_Metadata](#_other_extension_metadata_77)
- [Description](#_description_77)
- [New Commands](#_new_commands_40)
- [New Structures](#_new_structures_72)
- [New Enums](#_new_enums_26)
- [New Enum Constants](#_new_enum_constants_77)
- [New_Enum_Constants](#_new_enum_constants_77)
- [Issues](#_issues_44)
- [Version History](#_version_history_77)
- [VK_EXT_depth_clip_control](#VK_EXT_depth_clip_control)
- [Other Extension Metadata](#_other_extension_metadata_78)
- [Other_Extension_Metadata](#_other_extension_metadata_78)
- [Description](#_description_78)
- [New Structures](#_new_structures_73)
- [New Enum Constants](#_new_enum_constants_78)
- [New_Enum_Constants](#_new_enum_constants_78)
- [Issues](#_issues_45)
- [Version History](#_version_history_78)
- [VK_EXT_depth_clip_enable](#VK_EXT_depth_clip_enable)
- [Other Extension Metadata](#_other_extension_metadata_79)
- [Other_Extension_Metadata](#_other_extension_metadata_79)
- [Description](#_description_79)
- [New Structures](#_new_structures_74)
- [New Bitmasks](#_new_bitmasks_22)
- [New Enum Constants](#_new_enum_constants_79)
- [New_Enum_Constants](#_new_enum_constants_79)
- [Version History](#_version_history_79)
- [VK_EXT_depth_range_unrestricted](#VK_EXT_depth_range_unrestricted)
- [Other Extension Metadata](#_other_extension_metadata_80)
- [Other_Extension_Metadata](#_other_extension_metadata_80)
- [Description](#_description_80)
- [New Enum Constants](#_new_enum_constants_80)
- [New_Enum_Constants](#_new_enum_constants_80)
- [Issues](#_issues_46)
- [Version History](#_version_history_80)
- [VK_EXT_descriptor_buffer](#VK_EXT_descriptor_buffer)
- [Other Extension Metadata](#_other_extension_metadata_81)
- [Other_Extension_Metadata](#_other_extension_metadata_81)
- [Description](#_description_81)
- [New Commands](#_new_commands_41)
- [New Structures](#_new_structures_75)
- [New Unions](#_new_unions_4)
- [New Enum Constants](#_new_enum_constants_81)
- [New_Enum_Constants](#_new_enum_constants_81)
- [Version History](#_version_history_81)
- [VK_EXT_device_address_binding_report](#VK_EXT_device_address_binding_report)
- [Other Extension Metadata](#_other_extension_metadata_82)
- [Other_Extension_Metadata](#_other_extension_metadata_82)
- [Description](#_description_82)
- [New Structures](#_new_structures_76)
- [New Enums](#_new_enums_27)
- [New Bitmasks](#_new_bitmasks_23)
- [New Enum Constants](#_new_enum_constants_82)
- [New_Enum_Constants](#_new_enum_constants_82)
- [Issues](#_issues_47)
- [Version History](#_version_history_82)
- [VK_EXT_device_fault](#VK_EXT_device_fault)
- [Other Extension Metadata](#_other_extension_metadata_83)
- [Other_Extension_Metadata](#_other_extension_metadata_83)
- [Description](#_description_83)
- [New Commands](#_new_commands_42)
- [New Structures](#_new_structures_77)
- [New Enums](#_new_enums_28)
- [New Enum Constants](#_new_enum_constants_83)
- [New_Enum_Constants](#_new_enum_constants_83)
- [Version History](#_version_history_83)
- [VK_EXT_device_generated_commands](#VK_EXT_device_generated_commands)
- [Other Extension Metadata](#_other_extension_metadata_84)
- [Other_Extension_Metadata](#_other_extension_metadata_84)
- [Description](#_description_84)
- [New Object Types](#_new_object_types_9)
- [New_Object_Types](#_new_object_types_9)
- [New Commands](#_new_commands_43)
- [New Structures](#_new_structures_78)
- [New Unions](#_new_unions_5)
- [New Enums](#_new_enums_29)
- [New Bitmasks](#_new_bitmasks_24)
- [New Enum Constants](#_new_enum_constants_84)
- [New_Enum_Constants](#_new_enum_constants_84)
- [Example Code](#_example_code)
- [Version History](#_version_history_84)
- [VK_EXT_device_memory_report](#VK_EXT_device_memory_report)
- [Other Extension Metadata](#_other_extension_metadata_85)
- [Other_Extension_Metadata](#_other_extension_metadata_85)
- [Description](#_description_85)
- [New Structures](#_new_structures_79)
- [New Function Pointers](#_new_function_pointers_2)
- [New_Function_Pointers](#_new_function_pointers_2)
- [New Enums](#_new_enums_30)
- [New Bitmasks](#_new_bitmasks_25)
- [New Enum Constants](#_new_enum_constants_85)
- [New_Enum_Constants](#_new_enum_constants_85)
- [Issues](#_issues_48)
- [Version History](#_version_history_85)
- [VK_EXT_direct_mode_display](#VK_EXT_direct_mode_display)
- [Other Extension Metadata](#_other_extension_metadata_86)
- [Other_Extension_Metadata](#_other_extension_metadata_86)
- [Description](#_description_86)
- [New Commands](#_new_commands_44)
- [New Enum Constants](#_new_enum_constants_86)
- [New_Enum_Constants](#_new_enum_constants_86)
- [Issues](#_issues_49)
- [Version History](#_version_history_86)
- [VK_EXT_directfb_surface](#VK_EXT_directfb_surface)
- [Other Extension Metadata](#_other_extension_metadata_87)
- [Other_Extension_Metadata](#_other_extension_metadata_87)
- [Description](#_description_87)
- [New Commands](#_new_commands_45)
- [New Structures](#_new_structures_80)
- [New Bitmasks](#_new_bitmasks_26)
- [New Enum Constants](#_new_enum_constants_87)
- [New_Enum_Constants](#_new_enum_constants_87)
- [Version History](#_version_history_87)
- [VK_EXT_discard_rectangles](#VK_EXT_discard_rectangles)
- [Other Extension Metadata](#_other_extension_metadata_88)
- [Other_Extension_Metadata](#_other_extension_metadata_88)
- [Description](#_description_88)
- [New Commands](#_new_commands_46)
- [New Structures](#_new_structures_81)
- [New Enums](#_new_enums_31)
- [New Bitmasks](#_new_bitmasks_27)
- [New Enum Constants](#_new_enum_constants_88)
- [New_Enum_Constants](#_new_enum_constants_88)
- [Version History](#_version_history_88)
- [VK_EXT_display_control](#VK_EXT_display_control)
- [Other Extension Metadata](#_other_extension_metadata_89)
- [Other_Extension_Metadata](#_other_extension_metadata_89)
- [Description](#_description_89)
- [New Commands](#_new_commands_47)
- [New Structures](#_new_structures_82)
- [New Enums](#_new_enums_32)
- [New Enum Constants](#_new_enum_constants_89)
- [New_Enum_Constants](#_new_enum_constants_89)
- [Issues](#_issues_50)
- [Version History](#_version_history_89)
- [VK_EXT_display_surface_counter](#VK_EXT_display_surface_counter)
- [Other Extension Metadata](#_other_extension_metadata_90)
- [Other_Extension_Metadata](#_other_extension_metadata_90)
- [Description](#_description_90)
- [New Commands](#_new_commands_48)
- [New Structures](#_new_structures_83)
- [New Enums](#_new_enums_33)
- [New Bitmasks](#_new_bitmasks_28)
- [New Enum Constants](#_new_enum_constants_90)
- [New_Enum_Constants](#_new_enum_constants_90)
- [Version History](#_version_history_90)
- [VK_EXT_dynamic_rendering_unused_attachments](#VK_EXT_dynamic_rendering_unused_attachments)
- [Other Extension Metadata](#_other_extension_metadata_91)
- [Other_Extension_Metadata](#_other_extension_metadata_91)
- [Description](#_description_91)
- [New Structures](#_new_structures_84)
- [New Enum Constants](#_new_enum_constants_91)
- [New_Enum_Constants](#_new_enum_constants_91)
- [Issues](#_issues_51)
- [Version History](#_version_history_91)
- [VK_EXT_extended_dynamic_state3](#VK_EXT_extended_dynamic_state3)
- [Other Extension Metadata](#_other_extension_metadata_92)
- [Other_Extension_Metadata](#_other_extension_metadata_92)
- [Description](#_description_92)
- [New Commands](#_new_commands_49)
- [New Structures](#_new_structures_85)
- [New Enum Constants](#_new_enum_constants_92)
- [New_Enum_Constants](#_new_enum_constants_92)
- [Issues](#_issues_52)
- [Version History](#_version_history_92)
- [VK_EXT_external_memory_acquire_unmodified](#VK_EXT_external_memory_acquire_unmodified)
- [Other Extension Metadata](#_other_extension_metadata_93)
- [Other_Extension_Metadata](#_other_extension_metadata_93)
- [Description](#_description_93)
- [New Structures](#_new_structures_86)
- [New Enum Constants](#_new_enum_constants_93)
- [New_Enum_Constants](#_new_enum_constants_93)
- [Version History](#_version_history_93)
- [VK_EXT_external_memory_dma_buf](#VK_EXT_external_memory_dma_buf)
- [Other Extension Metadata](#_other_extension_metadata_94)
- [Other_Extension_Metadata](#_other_extension_metadata_94)
- [Description](#_description_94)
- [New Enum Constants](#_new_enum_constants_94)
- [New_Enum_Constants](#_new_enum_constants_94)
- [Issues](#_issues_53)
- [Version History](#_version_history_94)
- [VK_EXT_external_memory_host](#VK_EXT_external_memory_host)
- [Other Extension Metadata](#_other_extension_metadata_95)
- [Other_Extension_Metadata](#_other_extension_metadata_95)
- [Description](#_description_95)
- [New Commands](#_new_commands_50)
- [New Structures](#_new_structures_87)
- [New Enum Constants](#_new_enum_constants_95)
- [New_Enum_Constants](#_new_enum_constants_95)
- [Issues](#_issues_54)
- [Version History](#_version_history_95)
- [VK_EXT_external_memory_metal](#VK_EXT_external_memory_metal)
- [Other Extension Metadata](#_other_extension_metadata_96)
- [Other_Extension_Metadata](#_other_extension_metadata_96)
- [Description](#_description_96)
- [New Commands](#_new_commands_51)
- [New Structures](#_new_structures_88)
- [New Enum Constants](#_new_enum_constants_96)
- [New_Enum_Constants](#_new_enum_constants_96)
- [Version History](#_version_history_96)
- [VK_EXT_filter_cubic](#VK_EXT_filter_cubic)
- [Other Extension Metadata](#_other_extension_metadata_97)
- [Other_Extension_Metadata](#_other_extension_metadata_97)
- [Description](#_description_97)
- [New Structures](#_new_structures_89)
- [New Enum Constants](#_new_enum_constants_97)
- [New_Enum_Constants](#_new_enum_constants_97)
- [Version History](#_version_history_97)
- [VK_EXT_fragment_density_map](#VK_EXT_fragment_density_map)
- [Other Extension Metadata](#_other_extension_metadata_98)
- [Other_Extension_Metadata](#_other_extension_metadata_98)
- [Description](#_description_98)
- [New Structures](#_new_structures_90)
- [New Enum Constants](#_new_enum_constants_98)
- [New_Enum_Constants](#_new_enum_constants_98)
- [New or Modified Built-In Variables](#_new_or_modified_built_in_variables_2)
- [New_or_Modified_Built-In_Variables](#_new_or_modified_built_in_variables_2)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_12)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_12)
- [Version History](#_version_history_98)
- [VK_EXT_fragment_density_map2](#VK_EXT_fragment_density_map2)
- [Other Extension Metadata](#_other_extension_metadata_99)
- [Other_Extension_Metadata](#_other_extension_metadata_99)
- [Description](#_description_99)
- [New Structures](#_new_structures_91)
- [New Enum Constants](#_new_enum_constants_99)
- [New_Enum_Constants](#_new_enum_constants_99)
- [Version History](#_version_history_99)
- [VK_EXT_fragment_density_map_offset](#VK_EXT_fragment_density_map_offset)
- [Other Extension Metadata](#_other_extension_metadata_100)
- [Other_Extension_Metadata](#_other_extension_metadata_100)
- [Description](#_description_100)
- [New Commands](#_new_commands_52)
- [New Structures](#_new_structures_92)
- [New Enum Constants](#_new_enum_constants_100)
- [New_Enum_Constants](#_new_enum_constants_100)
- [Version History](#_version_history_100)
- [VK_EXT_fragment_shader_interlock](#VK_EXT_fragment_shader_interlock)
- [Other Extension Metadata](#_other_extension_metadata_101)
- [Other_Extension_Metadata](#_other_extension_metadata_101)
- [Description](#_description_101)
- [New Structures](#_new_structures_93)
- [New Enum Constants](#_new_enum_constants_101)
- [New_Enum_Constants](#_new_enum_constants_101)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_13)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_13)
- [Version History](#_version_history_101)
- [VK_EXT_frame_boundary](#VK_EXT_frame_boundary)
- [Other Extension Metadata](#_other_extension_metadata_102)
- [Other_Extension_Metadata](#_other_extension_metadata_102)
- [Description](#_description_102)
- [New Structures](#_new_structures_94)
- [New Enums](#_new_enums_34)
- [New Bitmasks](#_new_bitmasks_29)
- [New Enum Constants](#_new_enum_constants_102)
- [New_Enum_Constants](#_new_enum_constants_102)
- [Version History](#_version_history_102)
- [VK_EXT_full_screen_exclusive](#VK_EXT_full_screen_exclusive)
- [Other Extension Metadata](#_other_extension_metadata_103)
- [Other_Extension_Metadata](#_other_extension_metadata_103)
- [Description](#_description_103)
- [New Commands](#_new_commands_53)
- [New Structures](#_new_structures_95)
- [New Enums](#_new_enums_35)
- [New Enum Constants](#_new_enum_constants_103)
- [New_Enum_Constants](#_new_enum_constants_103)
- [Issues](#_issues_55)
- [Version History](#_version_history_103)
- [VK_EXT_graphics_pipeline_library](#VK_EXT_graphics_pipeline_library)
- [Other Extension Metadata](#_other_extension_metadata_104)
- [Other_Extension_Metadata](#_other_extension_metadata_104)
- [Description](#_description_104)
- [New Structures](#_new_structures_96)
- [New Enums](#_new_enums_36)
- [New Bitmasks](#_new_bitmasks_30)
- [New Enum Constants](#_new_enum_constants_104)
- [New_Enum_Constants](#_new_enum_constants_104)
- [Version History](#_version_history_104)
- [VK_EXT_hdr_metadata](#VK_EXT_hdr_metadata)
- [Other Extension Metadata](#_other_extension_metadata_105)
- [Other_Extension_Metadata](#_other_extension_metadata_105)
- [Description](#_description_105)
- [New Commands](#_new_commands_54)
- [New Structures](#_new_structures_97)
- [New Enum Constants](#_new_enum_constants_105)
- [New_Enum_Constants](#_new_enum_constants_105)
- [Issues](#_issues_56)
- [Version History](#_version_history_105)
- [VK_EXT_headless_surface](#VK_EXT_headless_surface)
- [Other Extension Metadata](#_other_extension_metadata_106)
- [Other_Extension_Metadata](#_other_extension_metadata_106)
- [Description](#_description_106)
- [New Commands](#_new_commands_55)
- [New Structures](#_new_structures_98)
- [New Bitmasks](#_new_bitmasks_31)
- [New Enum Constants](#_new_enum_constants_106)
- [New_Enum_Constants](#_new_enum_constants_106)
- [Version History](#_version_history_106)
- [VK_EXT_image_2d_view_of_3d](#VK_EXT_image_2d_view_of_3d)
- [Other Extension Metadata](#_other_extension_metadata_107)
- [Other_Extension_Metadata](#_other_extension_metadata_107)
- [Description](#_description_107)
- [New Structures](#_new_structures_99)
- [New Enum Constants](#_new_enum_constants_107)
- [New_Enum_Constants](#_new_enum_constants_107)
- [Version History](#_version_history_107)
- [VK_EXT_image_compression_control](#VK_EXT_image_compression_control)
- [Other Extension Metadata](#_other_extension_metadata_108)
- [Other_Extension_Metadata](#_other_extension_metadata_108)
- [Description](#_description_108)
- [New Commands](#_new_commands_56)
- [New Structures](#_new_structures_100)
- [New Enums](#_new_enums_37)
- [New Bitmasks](#_new_bitmasks_32)
- [New Enum Constants](#_new_enum_constants_108)
- [New_Enum_Constants](#_new_enum_constants_108)
- [Version History](#_version_history_108)
- [VK_EXT_image_compression_control_swapchain](#VK_EXT_image_compression_control_swapchain)
- [Other Extension Metadata](#_other_extension_metadata_109)
- [Other_Extension_Metadata](#_other_extension_metadata_109)
- [Description](#_description_109)
- [New Structures](#_new_structures_101)
- [New Enum Constants](#_new_enum_constants_109)
- [New_Enum_Constants](#_new_enum_constants_109)
- [Version History](#_version_history_109)
- [VK_EXT_image_drm_format_modifier](#VK_EXT_image_drm_format_modifier)
- [Other Extension Metadata](#_other_extension_metadata_110)
- [Other_Extension_Metadata](#_other_extension_metadata_110)
- [Description](#_description_110)
- [Introduction to DRM Format Modifiers](#_introduction_to_drm_format_modifiers)
- [Introduction_to_DRM_Format_Modifiers](#_introduction_to_drm_format_modifiers)
- [Format Translation](#_format_translation)
- [Usage Patterns](#_usage_patterns)
- [Prior Art](#_prior_art)
- [New Commands](#_new_commands_57)
- [New Structures](#_new_structures_102)
- [New Enum Constants](#_new_enum_constants_110)
- [New_Enum_Constants](#_new_enum_constants_110)
- [Issues](#_issues_57)
- [References](#_references)
- [Version History](#_version_history_110)
- [VK_EXT_image_sliced_view_of_3d](#VK_EXT_image_sliced_view_of_3d)
- [Other Extension Metadata](#_other_extension_metadata_111)
- [Other_Extension_Metadata](#_other_extension_metadata_111)
- [Description](#_description_111)
- [New Structures](#_new_structures_103)
- [New Enum Constants](#_new_enum_constants_111)
- [New_Enum_Constants](#_new_enum_constants_111)
- [Version History](#_version_history_111)
- [VK_EXT_image_view_min_lod](#VK_EXT_image_view_min_lod)
- [Other Extension Metadata](#_other_extension_metadata_112)
- [Other_Extension_Metadata](#_other_extension_metadata_112)
- [Description](#_description_112)
- [New Structures](#_new_structures_104)
- [New Enum Constants](#_new_enum_constants_112)
- [New_Enum_Constants](#_new_enum_constants_112)
- [Version History](#_version_history_112)
- [VK_EXT_layer_settings](#VK_EXT_layer_settings)
- [Other Extension Metadata](#_other_extension_metadata_113)
- [Other_Extension_Metadata](#_other_extension_metadata_113)
- [Description](#_description_113)
- [New Structures](#_new_structures_105)
- [New Enums](#_new_enums_38)
- [New Enum Constants](#_new_enum_constants_113)
- [New_Enum_Constants](#_new_enum_constants_113)
- [Example](#_example_2)
- [Issues](#_issues_58)
- [Version History](#_version_history_113)
- [VK_EXT_legacy_dithering](#VK_EXT_legacy_dithering)
- [Other Extension Metadata](#_other_extension_metadata_114)
- [Other_Extension_Metadata](#_other_extension_metadata_114)
- [Description](#_description_114)
- [New Structures](#_new_structures_106)
- [New Enum Constants](#_new_enum_constants_114)
- [New_Enum_Constants](#_new_enum_constants_114)
- [Version History](#_version_history_114)
- [Issues](#_issues_59)
- [VK_EXT_legacy_vertex_attributes](#VK_EXT_legacy_vertex_attributes)
- [Other Extension Metadata](#_other_extension_metadata_115)
- [Other_Extension_Metadata](#_other_extension_metadata_115)
- [Description](#_description_115)
- [New Structures](#_new_structures_107)
- [New Enum Constants](#_new_enum_constants_115)
- [New_Enum_Constants](#_new_enum_constants_115)
- [Issues](#_issues_60)
- [Version History](#_version_history_115)
- [VK_EXT_map_memory_placed](#VK_EXT_map_memory_placed)
- [Other Extension Metadata](#_other_extension_metadata_116)
- [Other_Extension_Metadata](#_other_extension_metadata_116)
- [Description](#_description_116)
- [New Structures](#_new_structures_108)
- [New Enum Constants](#_new_enum_constants_116)
- [New_Enum_Constants](#_new_enum_constants_116)
- [Version History](#_version_history_116)
- [VK_EXT_memory_budget](#VK_EXT_memory_budget)
- [Other Extension Metadata](#_other_extension_metadata_117)
- [Other_Extension_Metadata](#_other_extension_metadata_117)
- [Description](#_description_117)
- [New Structures](#_new_structures_109)
- [New Enum Constants](#_new_enum_constants_117)
- [New_Enum_Constants](#_new_enum_constants_117)
- [Version History](#_version_history_117)
- [VK_EXT_memory_priority](#VK_EXT_memory_priority)
- [Other Extension Metadata](#_other_extension_metadata_118)
- [Other_Extension_Metadata](#_other_extension_metadata_118)
- [Description](#_description_118)
- [New Structures](#_new_structures_110)
- [New Enum Constants](#_new_enum_constants_118)
- [New_Enum_Constants](#_new_enum_constants_118)
- [Version History](#_version_history_118)
- [VK_EXT_mesh_shader](#VK_EXT_mesh_shader)
- [Other Extension Metadata](#_other_extension_metadata_119)
- [Other_Extension_Metadata](#_other_extension_metadata_119)
- [Description](#_description_119)
- [New Commands](#_new_commands_58)
- [New Structures](#_new_structures_111)
- [New Enum Constants](#_new_enum_constants_119)
- [New_Enum_Constants](#_new_enum_constants_119)
- [New or Modified Built-In Variables](#_new_or_modified_built_in_variables_3)
- [New_or_Modified_Built-In_Variables](#_new_or_modified_built_in_variables_3)
- [New SPIR-V Capability](#_new_spir_v_capability_2)
- [New_SPIR-V_Capability](#_new_spir_v_capability_2)
- [Version History](#_version_history_119)
- [VK_EXT_metal_objects](#VK_EXT_metal_objects)
- [Other Extension Metadata](#_other_extension_metadata_120)
- [Other_Extension_Metadata](#_other_extension_metadata_120)
- [Description](#_description_120)
- [New Base Types](#_new_base_types_2)
- [New_Base_Types](#_new_base_types_2)
- [New Commands](#_new_commands_59)
- [New Structures](#_new_structures_112)
- [New Enums](#_new_enums_39)
- [New Bitmasks](#_new_bitmasks_33)
- [New Enum Constants](#_new_enum_constants_120)
- [New_Enum_Constants](#_new_enum_constants_120)
- [Issues](#_issues_61)
- [Version History](#_version_history_120)
- [VK_EXT_metal_surface](#VK_EXT_metal_surface)
- [Other Extension Metadata](#_other_extension_metadata_121)
- [Other_Extension_Metadata](#_other_extension_metadata_121)
- [Description](#_description_121)
- [New Base Types](#_new_base_types_3)
- [New_Base_Types](#_new_base_types_3)
- [New Commands](#_new_commands_60)
- [New Structures](#_new_structures_113)
- [New Bitmasks](#_new_bitmasks_34)
- [New Enum Constants](#_new_enum_constants_121)
- [New_Enum_Constants](#_new_enum_constants_121)
- [Version History](#_version_history_121)
- [VK_EXT_multi_draw](#VK_EXT_multi_draw)
- [Other Extension Metadata](#_other_extension_metadata_122)
- [Other_Extension_Metadata](#_other_extension_metadata_122)
- [Description](#_description_122)
- [New Commands](#_new_commands_61)
- [New Structures](#_new_structures_114)
- [New Enum Constants](#_new_enum_constants_122)
- [New_Enum_Constants](#_new_enum_constants_122)
- [New or Modified Built-In Variables](#_new_or_modified_built_in_variables_4)
- [New_or_Modified_Built-In_Variables](#_new_or_modified_built_in_variables_4)
- [Version History](#_version_history_122)
- [VK_EXT_multisampled_render_to_single_sampled](#VK_EXT_multisampled_render_to_single_sampled)
- [Other Extension Metadata](#_other_extension_metadata_123)
- [Other_Extension_Metadata](#_other_extension_metadata_123)
- [Description](#_description_123)
- [New Structures](#_new_structures_115)
- [New Enum Constants](#_new_enum_constants_123)
- [New_Enum_Constants](#_new_enum_constants_123)
- [Issues](#_issues_62)
- [Version History](#_version_history_123)
- [VK_EXT_mutable_descriptor_type](#VK_EXT_mutable_descriptor_type)
- [Other Extension Metadata](#_other_extension_metadata_124)
- [Other_Extension_Metadata](#_other_extension_metadata_124)
- [Description](#_description_124)
- [New Structures](#_new_structures_116)
- [New Enum Constants](#_new_enum_constants_124)
- [New_Enum_Constants](#_new_enum_constants_124)
- [Version History](#_version_history_124)
- [VK_EXT_nested_command_buffer](#VK_EXT_nested_command_buffer)
- [Other Extension Metadata](#_other_extension_metadata_125)
- [Other_Extension_Metadata](#_other_extension_metadata_125)
- [Description](#_description_125)
- [New Structures](#_new_structures_117)
- [New Enum Constants](#_new_enum_constants_125)
- [New_Enum_Constants](#_new_enum_constants_125)
- [Issues](#_issues_63)
- [Version History](#_version_history_125)
- [VK_EXT_non_seamless_cube_map](#VK_EXT_non_seamless_cube_map)
- [Other Extension Metadata](#_other_extension_metadata_126)
- [Other_Extension_Metadata](#_other_extension_metadata_126)
- [Description](#_description_126)
- [New Structures](#_new_structures_118)
- [New Enum Constants](#_new_enum_constants_126)
- [New_Enum_Constants](#_new_enum_constants_126)
- [Version History](#_version_history_126)
- [VK_EXT_opacity_micromap](#VK_EXT_opacity_micromap)
- [Other Extension Metadata](#_other_extension_metadata_127)
- [Other_Extension_Metadata](#_other_extension_metadata_127)
- [Description](#_description_127)
- [New Object Types](#_new_object_types_10)
- [New_Object_Types](#_new_object_types_10)
- [New Commands](#_new_commands_62)
- [New Structures](#_new_structures_119)
- [New Enums](#_new_enums_40)
- [New Bitmasks](#_new_bitmasks_35)
- [New Enum Constants](#_new_enum_constants_127)
- [New_Enum_Constants](#_new_enum_constants_127)
- [Reference Code](#_reference_code)
- [Issues](#_issues_64)
- [Version History](#_version_history_127)
- [VK_EXT_pageable_device_local_memory](#VK_EXT_pageable_device_local_memory)
- [Other Extension Metadata](#_other_extension_metadata_128)
- [Other_Extension_Metadata](#_other_extension_metadata_128)
- [Description](#_description_128)
- [New Commands](#_new_commands_63)
- [New Structures](#_new_structures_120)
- [New Enum Constants](#_new_enum_constants_128)
- [New_Enum_Constants](#_new_enum_constants_128)
- [Version History](#_version_history_128)
- [VK_EXT_pci_bus_info](#VK_EXT_pci_bus_info)
- [Other Extension Metadata](#_other_extension_metadata_129)
- [Other_Extension_Metadata](#_other_extension_metadata_129)
- [Description](#_description_129)
- [New Structures](#_new_structures_121)
- [New Enum Constants](#_new_enum_constants_129)
- [New_Enum_Constants](#_new_enum_constants_129)
- [Version History](#_version_history_129)
- [VK_EXT_physical_device_drm](#VK_EXT_physical_device_drm)
- [Other Extension Metadata](#_other_extension_metadata_130)
- [Other_Extension_Metadata](#_other_extension_metadata_130)
- [Description](#_description_130)
- [New Structures](#_new_structures_122)
- [New Enum Constants](#_new_enum_constants_130)
- [New_Enum_Constants](#_new_enum_constants_130)
- [References](#_references_2)
- [Version History](#_version_history_130)
- [VK_EXT_pipeline_library_group_handles](#VK_EXT_pipeline_library_group_handles)
- [Other Extension Metadata](#_other_extension_metadata_131)
- [Other_Extension_Metadata](#_other_extension_metadata_131)
- [Description](#_description_131)
- [New Structures](#_new_structures_123)
- [New Enum Constants](#_new_enum_constants_131)
- [New_Enum_Constants](#_new_enum_constants_131)
- [Version History](#_version_history_131)
- [VK_EXT_pipeline_properties](#VK_EXT_pipeline_properties)
- [Other Extension Metadata](#_other_extension_metadata_132)
- [Other_Extension_Metadata](#_other_extension_metadata_132)
- [Description](#_description_132)
- [New Commands](#_new_commands_64)
- [New Structures](#_new_structures_124)
- [New Enum Constants](#_new_enum_constants_132)
- [New_Enum_Constants](#_new_enum_constants_132)
- [Issues](#_issues_65)
- [Version History](#_version_history_132)
- [VK_EXT_post_depth_coverage](#VK_EXT_post_depth_coverage)
- [Other Extension Metadata](#_other_extension_metadata_133)
- [Other_Extension_Metadata](#_other_extension_metadata_133)
- [Description](#_description_133)
- [New Enum Constants](#_new_enum_constants_133)
- [New_Enum_Constants](#_new_enum_constants_133)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_14)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_14)
- [Version History](#_version_history_133)
- [VK_EXT_present_mode_fifo_latest_ready](#VK_EXT_present_mode_fifo_latest_ready)
- [Other Extension Metadata](#_other_extension_metadata_134)
- [Other_Extension_Metadata](#_other_extension_metadata_134)
- [Description](#_description_134)
- [New Structures](#_new_structures_125)
- [New Enum Constants](#_new_enum_constants_134)
- [New_Enum_Constants](#_new_enum_constants_134)
- [Version History](#_version_history_134)
- [VK_EXT_primitive_topology_list_restart](#VK_EXT_primitive_topology_list_restart)
- [Other Extension Metadata](#_other_extension_metadata_135)
- [Other_Extension_Metadata](#_other_extension_metadata_135)
- [Description](#_description_135)
- [New Structures](#_new_structures_126)
- [New Enum Constants](#_new_enum_constants_135)
- [New_Enum_Constants](#_new_enum_constants_135)
- [Version History](#_version_history_135)
- [VK_EXT_primitives_generated_query](#VK_EXT_primitives_generated_query)
- [Other Extension Metadata](#_other_extension_metadata_136)
- [Other_Extension_Metadata](#_other_extension_metadata_136)
- [Description](#_description_136)
- [New Structures](#_new_structures_127)
- [New Enum Constants](#_new_enum_constants_136)
- [New_Enum_Constants](#_new_enum_constants_136)
- [Issues](#_issues_66)
- [Version History](#_version_history_136)
- [VK_EXT_provoking_vertex](#VK_EXT_provoking_vertex)
- [Other Extension Metadata](#_other_extension_metadata_137)
- [Other_Extension_Metadata](#_other_extension_metadata_137)
- [Description](#_description_137)
- [New Structures](#_new_structures_128)
- [New Enums](#_new_enums_41)
- [New Enum Constants](#_new_enum_constants_137)
- [New_Enum_Constants](#_new_enum_constants_137)
- [Issues](#_issues_67)
- [Version History](#_version_history_137)
- [VK_EXT_queue_family_foreign](#VK_EXT_queue_family_foreign)
- [Other Extension Metadata](#_other_extension_metadata_138)
- [Other_Extension_Metadata](#_other_extension_metadata_138)
- [Description](#_description_138)
- [New Enum Constants](#_new_enum_constants_138)
- [New_Enum_Constants](#_new_enum_constants_138)
- [Version History](#_version_history_138)
- [VK_EXT_rasterization_order_attachment_access](#VK_EXT_rasterization_order_attachment_access)
- [Other Extension Metadata](#_other_extension_metadata_139)
- [Other_Extension_Metadata](#_other_extension_metadata_139)
- [Description](#_description_139)
- [New Structures](#_new_structures_129)
- [New Enums](#_new_enums_42)
- [New Enum Constants](#_new_enum_constants_139)
- [New_Enum_Constants](#_new_enum_constants_139)
- [Examples](#_examples_11)
- [Version History](#_version_history_139)
- [VK_EXT_rgba10x6_formats](#VK_EXT_rgba10x6_formats)
- [Other Extension Metadata](#_other_extension_metadata_140)
- [Other_Extension_Metadata](#_other_extension_metadata_140)
- [Description](#_description_140)
- [New Structures](#_new_structures_130)
- [New Enum Constants](#_new_enum_constants_140)
- [New_Enum_Constants](#_new_enum_constants_140)
- [Issues](#_issues_68)
- [Version History](#_version_history_140)
- [VK_EXT_sample_locations](#VK_EXT_sample_locations)
- [Other Extension Metadata](#_other_extension_metadata_141)
- [Other_Extension_Metadata](#_other_extension_metadata_141)
- [Description](#_description_141)
- [New Commands](#_new_commands_65)
- [New Structures](#_new_structures_131)
- [New Enum Constants](#_new_enum_constants_141)
- [New_Enum_Constants](#_new_enum_constants_141)
- [Version History](#_version_history_141)
- [VK_EXT_shader_atomic_float](#VK_EXT_shader_atomic_float)
- [Other Extension Metadata](#_other_extension_metadata_142)
- [Other_Extension_Metadata](#_other_extension_metadata_142)
- [Description](#_description_142)
- [New Structures](#_new_structures_132)
- [New Enum Constants](#_new_enum_constants_142)
- [New_Enum_Constants](#_new_enum_constants_142)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_15)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_15)
- [Version History](#_version_history_142)
- [VK_EXT_shader_atomic_float2](#VK_EXT_shader_atomic_float2)
- [Other Extension Metadata](#_other_extension_metadata_143)
- [Other_Extension_Metadata](#_other_extension_metadata_143)
- [Description](#_description_143)
- [New Structures](#_new_structures_133)
- [New Enum Constants](#_new_enum_constants_143)
- [New_Enum_Constants](#_new_enum_constants_143)
- [Issues](#_issues_69)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_16)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_16)
- [Version History](#_version_history_143)
- [VK_EXT_shader_image_atomic_int64](#VK_EXT_shader_image_atomic_int64)
- [Other Extension Metadata](#_other_extension_metadata_144)
- [Other_Extension_Metadata](#_other_extension_metadata_144)
- [Description](#_description_144)
- [New Structures](#_new_structures_134)
- [New Enum Constants](#_new_enum_constants_144)
- [New_Enum_Constants](#_new_enum_constants_144)
- [Version History](#_version_history_144)
- [VK_EXT_shader_module_identifier](#VK_EXT_shader_module_identifier)
- [Other Extension Metadata](#_other_extension_metadata_145)
- [Other_Extension_Metadata](#_other_extension_metadata_145)
- [Description](#_description_145)
- [New Commands](#_new_commands_66)
- [New Structures](#_new_structures_135)
- [New Enum Constants](#_new_enum_constants_145)
- [New_Enum_Constants](#_new_enum_constants_145)
- [Version History](#_version_history_145)
- [VK_EXT_shader_object](#VK_EXT_shader_object)
- [Other Extension Metadata](#_other_extension_metadata_146)
- [Other_Extension_Metadata](#_other_extension_metadata_146)
- [Description](#_description_146)
- [New Object Types](#_new_object_types_11)
- [New_Object_Types](#_new_object_types_11)
- [New Commands](#_new_commands_67)
- [New Structures](#_new_structures_136)
- [New Enums](#_new_enums_43)
- [New Bitmasks](#_new_bitmasks_36)
- [New Enum Constants](#_new_enum_constants_146)
- [New_Enum_Constants](#_new_enum_constants_146)
- [Examples](#_examples_12)
- [Version History](#_version_history_146)
- [VK_EXT_shader_replicated_composites](#VK_EXT_shader_replicated_composites)
- [New Structures](#_new_structures_137)
- [New Enum Constants](#_new_enum_constants_147)
- [New_Enum_Constants](#_new_enum_constants_147)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_17)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_17)
- [Version History](#_version_history_147)
- [VK_EXT_shader_stencil_export](#VK_EXT_shader_stencil_export)
- [Other Extension Metadata](#_other_extension_metadata_147)
- [Other_Extension_Metadata](#_other_extension_metadata_147)
- [Description](#_description_147)
- [New Enum Constants](#_new_enum_constants_148)
- [New_Enum_Constants](#_new_enum_constants_148)
- [Version History](#_version_history_148)
- [VK_EXT_shader_tile_image](#VK_EXT_shader_tile_image)
- [Other Extension Metadata](#_other_extension_metadata_148)
- [Other_Extension_Metadata](#_other_extension_metadata_148)
- [Description](#_description_148)
- [New Structures](#_new_structures_138)
- [New Enum Constants](#_new_enum_constants_149)
- [New_Enum_Constants](#_new_enum_constants_149)
- [Issues](#_issues_70)
- [Examples](#_examples_13)
- [Version History](#_version_history_149)
- [VK_EXT_subpass_merge_feedback](#VK_EXT_subpass_merge_feedback)
- [Other Extension Metadata](#_other_extension_metadata_149)
- [Other_Extension_Metadata](#_other_extension_metadata_149)
- [Description](#_description_149)
- [New Structures](#_new_structures_139)
- [New Enums](#_new_enums_44)
- [New Enum Constants](#_new_enum_constants_150)
- [New_Enum_Constants](#_new_enum_constants_150)
- [Version History](#_version_history_150)
- [VK_EXT_surface_maintenance1](#VK_EXT_surface_maintenance1)
- [Other Extension Metadata](#_other_extension_metadata_150)
- [Other_Extension_Metadata](#_other_extension_metadata_150)
- [Description](#_description_150)
- [New Structures](#_new_structures_140)
- [New Enums](#_new_enums_45)
- [New Bitmasks](#_new_bitmasks_37)
- [New Enum Constants](#_new_enum_constants_151)
- [New_Enum_Constants](#_new_enum_constants_151)
- [Version History](#_version_history_151)
- [VK_EXT_swapchain_colorspace](#VK_EXT_swapchain_colorspace)
- [Other Extension Metadata](#_other_extension_metadata_151)
- [Other_Extension_Metadata](#_other_extension_metadata_151)
- [Description](#_description_151)
- [New Enum Constants](#_new_enum_constants_152)
- [New_Enum_Constants](#_new_enum_constants_152)
- [Issues](#_issues_71)
- [Version History](#_version_history_152)
- [VK_EXT_swapchain_maintenance1](#VK_EXT_swapchain_maintenance1)
- [Other Extension Metadata](#_other_extension_metadata_152)
- [Other_Extension_Metadata](#_other_extension_metadata_152)
- [Description](#_description_152)
- [New Commands](#_new_commands_68)
- [New Structures](#_new_structures_141)
- [New Enum Constants](#_new_enum_constants_153)
- [New_Enum_Constants](#_new_enum_constants_153)
- [Version History](#_version_history_153)
- [VK_EXT_transform_feedback](#VK_EXT_transform_feedback)
- [Other Extension Metadata](#_other_extension_metadata_153)
- [Other_Extension_Metadata](#_other_extension_metadata_153)
- [Description](#_description_153)
- [New Commands](#_new_commands_69)
- [New Structures](#_new_structures_142)
- [New Bitmasks](#_new_bitmasks_38)
- [New Enum Constants](#_new_enum_constants_154)
- [New_Enum_Constants](#_new_enum_constants_154)
- [Issues](#_issues_72)
- [Version History](#_version_history_154)
- [VK_EXT_validation_cache](#VK_EXT_validation_cache)
- [Other Extension Metadata](#_other_extension_metadata_154)
- [Other_Extension_Metadata](#_other_extension_metadata_154)
- [Description](#_description_154)
- [New Object Types](#_new_object_types_12)
- [New_Object_Types](#_new_object_types_12)
- [New Commands](#_new_commands_70)
- [New Structures](#_new_structures_143)
- [New Enums](#_new_enums_46)
- [New Bitmasks](#_new_bitmasks_39)
- [New Enum Constants](#_new_enum_constants_155)
- [New_Enum_Constants](#_new_enum_constants_155)
- [Version History](#_version_history_155)
- [VK_EXT_vertex_attribute_robustness](#VK_EXT_vertex_attribute_robustness)
- [Other Extension Metadata](#_other_extension_metadata_155)
- [Other_Extension_Metadata](#_other_extension_metadata_155)
- [Description](#_description_155)
- [New Structures](#_new_structures_144)
- [New Enum Constants](#_new_enum_constants_156)
- [New_Enum_Constants](#_new_enum_constants_156)
- [Issues](#_issues_73)
- [Version History](#_version_history_156)
- [VK_EXT_vertex_input_dynamic_state](#VK_EXT_vertex_input_dynamic_state)
- [Other Extension Metadata](#_other_extension_metadata_156)
- [Other_Extension_Metadata](#_other_extension_metadata_156)
- [Description](#_description_156)
- [New Commands](#_new_commands_71)
- [New Structures](#_new_structures_145)
- [New Enum Constants](#_new_enum_constants_157)
- [New_Enum_Constants](#_new_enum_constants_157)
- [Version History](#_version_history_157)
- [VK_EXT_ycbcr_image_arrays](#VK_EXT_ycbcr_image_arrays)
- [Other Extension Metadata](#_other_extension_metadata_157)
- [Other_Extension_Metadata](#_other_extension_metadata_157)
- [Description](#_description_157)
- [New Structures](#_new_structures_146)
- [New Enum Constants](#_new_enum_constants_158)
- [New_Enum_Constants](#_new_enum_constants_158)
- [Version History](#_version_history_158)
- [VK_EXT_zero_initialize_device_memory](#VK_EXT_zero_initialize_device_memory)
- [Other Extension Metadata](#_other_extension_metadata_158)
- [Other_Extension_Metadata](#_other_extension_metadata_158)
- [Description](#_description_158)
- [New Structures](#_new_structures_147)
- [New Enum Constants](#_new_enum_constants_159)
- [New_Enum_Constants](#_new_enum_constants_159)
- [Version History](#_version_history_159)
- [VK_AMD_anti_lag](#VK_AMD_anti_lag)
- [Other Extension Metadata](#_other_extension_metadata_159)
- [Other_Extension_Metadata](#_other_extension_metadata_159)
- [Description](#_description_159)
- [New Commands](#_new_commands_72)
- [New Structures](#_new_structures_148)
- [New Enums](#_new_enums_47)
- [New Enum Constants](#_new_enum_constants_160)
- [New_Enum_Constants](#_new_enum_constants_160)
- [Version History](#_version_history_160)
- [VK_AMD_buffer_marker](#VK_AMD_buffer_marker)
- [Other Extension Metadata](#_other_extension_metadata_160)
- [Other_Extension_Metadata](#_other_extension_metadata_160)
- [Description](#_description_160)
- [New Commands](#_new_commands_73)
- [New Enum Constants](#_new_enum_constants_161)
- [New_Enum_Constants](#_new_enum_constants_161)
- [Examples](#_examples_14)
- [Version History](#_version_history_161)
- [VK_AMD_device_coherent_memory](#VK_AMD_device_coherent_memory)
- [Other Extension Metadata](#_other_extension_metadata_161)
- [Other_Extension_Metadata](#_other_extension_metadata_161)
- [Description](#_description_161)
- [New Structures](#_new_structures_149)
- [New Enum Constants](#_new_enum_constants_162)
- [New_Enum_Constants](#_new_enum_constants_162)
- [Version History](#_version_history_162)
- [VK_AMD_display_native_hdr](#VK_AMD_display_native_hdr)
- [Other Extension Metadata](#_other_extension_metadata_162)
- [Other_Extension_Metadata](#_other_extension_metadata_162)
- [Description](#_description_162)
- [New Commands](#_new_commands_74)
- [New Structures](#_new_structures_150)
- [New Enum Constants](#_new_enum_constants_163)
- [New_Enum_Constants](#_new_enum_constants_163)
- [Issues](#_issues_74)
- [Examples](#_examples_15)
- [Version History](#_version_history_163)
- [VK_AMD_gcn_shader](#VK_AMD_gcn_shader)
- [Other Extension Metadata](#_other_extension_metadata_163)
- [Other_Extension_Metadata](#_other_extension_metadata_163)
- [Description](#_description_163)
- [New Enum Constants](#_new_enum_constants_164)
- [New_Enum_Constants](#_new_enum_constants_164)
- [Version History](#_version_history_164)
- [VK_AMD_memory_overallocation_behavior](#VK_AMD_memory_overallocation_behavior)
- [Other Extension Metadata](#_other_extension_metadata_164)
- [Other_Extension_Metadata](#_other_extension_metadata_164)
- [Description](#_description_164)
- [New Structures](#_new_structures_151)
- [New Enums](#_new_enums_48)
- [New Enum Constants](#_new_enum_constants_165)
- [New_Enum_Constants](#_new_enum_constants_165)
- [Version History](#_version_history_165)
- [VK_AMD_mixed_attachment_samples](#VK_AMD_mixed_attachment_samples)
- [Other Extension Metadata](#_other_extension_metadata_165)
- [Other_Extension_Metadata](#_other_extension_metadata_165)
- [Description](#_description_165)
- [New Structures](#_new_structures_152)
- [New Enum Constants](#_new_enum_constants_166)
- [New_Enum_Constants](#_new_enum_constants_166)
- [Issues](#_issues_75)
- [Version History](#_version_history_166)
- [VK_AMD_pipeline_compiler_control](#VK_AMD_pipeline_compiler_control)
- [Other Extension Metadata](#_other_extension_metadata_166)
- [Other_Extension_Metadata](#_other_extension_metadata_166)
- [Description](#_description_166)
- [New Structures](#_new_structures_153)
- [New Enums](#_new_enums_49)
- [New Bitmasks](#_new_bitmasks_40)
- [New Enum Constants](#_new_enum_constants_167)
- [New_Enum_Constants](#_new_enum_constants_167)
- [Issues](#_issues_76)
- [Examples](#_examples_16)
- [Version History](#_version_history_167)
- [VK_AMD_rasterization_order](#VK_AMD_rasterization_order)
- [Other Extension Metadata](#_other_extension_metadata_167)
- [Other_Extension_Metadata](#_other_extension_metadata_167)
- [Description](#_description_167)
- [New Structures](#_new_structures_154)
- [New Enums](#_new_enums_50)
- [New Enum Constants](#_new_enum_constants_168)
- [New_Enum_Constants](#_new_enum_constants_168)
- [Issues](#_issues_77)
- [Examples](#_examples_17)
- [Issues](#_issues_78)
- [Version History](#_version_history_168)
- [VK_AMD_shader_ballot](#VK_AMD_shader_ballot)
- [Other Extension Metadata](#_other_extension_metadata_168)
- [Other_Extension_Metadata](#_other_extension_metadata_168)
- [Description](#_description_168)
- [New Enum Constants](#_new_enum_constants_169)
- [New_Enum_Constants](#_new_enum_constants_169)
- [Version History](#_version_history_169)
- [VK_AMD_shader_core_properties](#VK_AMD_shader_core_properties)
- [Other Extension Metadata](#_other_extension_metadata_169)
- [Other_Extension_Metadata](#_other_extension_metadata_169)
- [Description](#_description_169)
- [New Structures](#_new_structures_155)
- [New Enum Constants](#_new_enum_constants_170)
- [New_Enum_Constants](#_new_enum_constants_170)
- [Examples](#_examples_18)
- [Version History](#_version_history_170)
- [VK_AMD_shader_core_properties2](#VK_AMD_shader_core_properties2)
- [Other Extension Metadata](#_other_extension_metadata_170)
- [Other_Extension_Metadata](#_other_extension_metadata_170)
- [Description](#_description_170)
- [New Structures](#_new_structures_156)
- [New Enums](#_new_enums_51)
- [New Bitmasks](#_new_bitmasks_41)
- [New Enum Constants](#_new_enum_constants_171)
- [New_Enum_Constants](#_new_enum_constants_171)
- [Examples](#_examples_19)
- [Version History](#_version_history_171)
- [VK_AMD_shader_early_and_late_fragment_tests](#VK_AMD_shader_early_and_late_fragment_tests)
- [Other Extension Metadata](#_other_extension_metadata_171)
- [Other_Extension_Metadata](#_other_extension_metadata_171)
- [Description](#_description_171)
- [New Structures](#_new_structures_157)
- [New Enum Constants](#_new_enum_constants_172)
- [New_Enum_Constants](#_new_enum_constants_172)
- [Version History](#_version_history_172)
- [VK_AMD_shader_explicit_vertex_parameter](#VK_AMD_shader_explicit_vertex_parameter)
- [Other Extension Metadata](#_other_extension_metadata_172)
- [Other_Extension_Metadata](#_other_extension_metadata_172)
- [Description](#_description_172)
- [New Enum Constants](#_new_enum_constants_173)
- [New_Enum_Constants](#_new_enum_constants_173)
- [Version History](#_version_history_173)
- [VK_AMD_shader_fragment_mask](#VK_AMD_shader_fragment_mask)
- [Other Extension Metadata](#_other_extension_metadata_173)
- [Other_Extension_Metadata](#_other_extension_metadata_173)
- [Description](#_description_173)
- [New Enum Constants](#_new_enum_constants_174)
- [New_Enum_Constants](#_new_enum_constants_174)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_18)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_18)
- [Examples](#_examples_20)
- [Version History](#_version_history_174)
- [VK_AMD_shader_image_load_store_lod](#VK_AMD_shader_image_load_store_lod)
- [Other Extension Metadata](#_other_extension_metadata_174)
- [Other_Extension_Metadata](#_other_extension_metadata_174)
- [Description](#_description_174)
- [New Enum Constants](#_new_enum_constants_175)
- [New_Enum_Constants](#_new_enum_constants_175)
- [Version History](#_version_history_175)
- [VK_AMD_shader_info](#VK_AMD_shader_info)
- [Other Extension Metadata](#_other_extension_metadata_175)
- [Other_Extension_Metadata](#_other_extension_metadata_175)
- [Description](#_description_175)
- [New Commands](#_new_commands_75)
- [New Structures](#_new_structures_158)
- [New Enums](#_new_enums_52)
- [New Enum Constants](#_new_enum_constants_176)
- [New_Enum_Constants](#_new_enum_constants_176)
- [Examples](#_examples_21)
- [Version History](#_version_history_176)
- [VK_AMD_shader_trinary_minmax](#VK_AMD_shader_trinary_minmax)
- [Other Extension Metadata](#_other_extension_metadata_176)
- [Other_Extension_Metadata](#_other_extension_metadata_176)
- [Description](#_description_176)
- [New Enum Constants](#_new_enum_constants_177)
- [New_Enum_Constants](#_new_enum_constants_177)
- [Version History](#_version_history_177)
- [VK_AMD_texture_gather_bias_lod](#VK_AMD_texture_gather_bias_lod)
- [Other Extension Metadata](#_other_extension_metadata_177)
- [Other_Extension_Metadata](#_other_extension_metadata_177)
- [Description](#_description_177)
- [New Structures](#_new_structures_159)
- [New Enum Constants](#_new_enum_constants_178)
- [New_Enum_Constants](#_new_enum_constants_178)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_19)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_19)
- [Examples](#_examples_22)
- [Version History](#_version_history_178)
- [VK_ANDROID_external_format_resolve](#VK_ANDROID_external_format_resolve)
- [Other Extension Metadata](#_other_extension_metadata_178)
- [Other_Extension_Metadata](#_other_extension_metadata_178)
- [Description](#_description_178)
- [New Structures](#_new_structures_160)
- [New Enum Constants](#_new_enum_constants_179)
- [New_Enum_Constants](#_new_enum_constants_179)
- [Version History](#_version_history_179)
- [VK_ANDROID_external_memory_android_hardware_buffer](#VK_ANDROID_external_memory_android_hardware_buffer)
- [Other Extension Metadata](#_other_extension_metadata_179)
- [Other_Extension_Metadata](#_other_extension_metadata_179)
- [Description](#_description_179)
- [New Base Types](#_new_base_types_4)
- [New_Base_Types](#_new_base_types_4)
- [New Commands](#_new_commands_76)
- [New Structures](#_new_structures_161)
- [New Enum Constants](#_new_enum_constants_180)
- [New_Enum_Constants](#_new_enum_constants_180)
- [Issues](#_issues_79)
- [Version History](#_version_history_180)
- [VK_ARM_pipeline_opacity_micromap](#VK_ARM_pipeline_opacity_micromap)
- [Other Extension Metadata](#_other_extension_metadata_180)
- [Other_Extension_Metadata](#_other_extension_metadata_180)
- [Description](#_description_180)
- [New Structures](#_new_structures_162)
- [New Enum Constants](#_new_enum_constants_181)
- [New_Enum_Constants](#_new_enum_constants_181)
- [Issues](#_issues_80)
- [Examples](#_examples_23)
- [Version History](#_version_history_181)
- [VK_ARM_render_pass_striped](#VK_ARM_render_pass_striped)
- [Other Extension Metadata](#_other_extension_metadata_181)
- [Other_Extension_Metadata](#_other_extension_metadata_181)
- [Description](#_description_181)
- [New Structures](#_new_structures_163)
- [New Enum Constants](#_new_enum_constants_182)
- [New_Enum_Constants](#_new_enum_constants_182)
- [Examples](#_examples_24)
- [Version History](#_version_history_182)
- [VK_ARM_scheduling_controls](#VK_ARM_scheduling_controls)
- [Other Extension Metadata](#_other_extension_metadata_182)
- [Other_Extension_Metadata](#_other_extension_metadata_182)
- [Description](#_description_182)
- [New Structures](#_new_structures_164)
- [New Enums](#_new_enums_53)
- [New Bitmasks](#_new_bitmasks_42)
- [New Enum Constants](#_new_enum_constants_183)
- [New_Enum_Constants](#_new_enum_constants_183)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_20)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_20)
- [Issues](#_issues_81)
- [Version History](#_version_history_183)
- [VK_ARM_shader_core_builtins](#VK_ARM_shader_core_builtins)
- [Other Extension Metadata](#_other_extension_metadata_183)
- [Other_Extension_Metadata](#_other_extension_metadata_183)
- [Description](#_description_183)
- [New Structures](#_new_structures_165)
- [New Enum Constants](#_new_enum_constants_184)
- [New_Enum_Constants](#_new_enum_constants_184)
- [New or Modified Built-In Variables](#_new_or_modified_built_in_variables_5)
- [New_or_Modified_Built-In_Variables](#_new_or_modified_built_in_variables_5)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_21)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_21)
- [Issues](#_issues_82)
- [Version History](#_version_history_184)
- [VK_ARM_shader_core_properties](#VK_ARM_shader_core_properties)
- [Other Extension Metadata](#_other_extension_metadata_184)
- [Other_Extension_Metadata](#_other_extension_metadata_184)
- [Description](#_description_184)
- [New Structures](#_new_structures_166)
- [New Enum Constants](#_new_enum_constants_185)
- [New_Enum_Constants](#_new_enum_constants_185)
- [Version History](#_version_history_185)
- [VK_FUCHSIA_buffer_collection](#VK_FUCHSIA_buffer_collection)
- [Other Extension Metadata](#_other_extension_metadata_185)
- [Other_Extension_Metadata](#_other_extension_metadata_185)
- [Description](#_description_185)
- [New Object Types](#_new_object_types_13)
- [New_Object_Types](#_new_object_types_13)
- [New Commands](#_new_commands_77)
- [New Structures](#_new_structures_167)
- [New Enums](#_new_enums_54)
- [New Bitmasks](#_new_bitmasks_43)
- [New Enum Constants](#_new_enum_constants_186)
- [New_Enum_Constants](#_new_enum_constants_186)
- [Issues](#_issues_83)
- [Version History](#_version_history_186)
- [VK_FUCHSIA_external_memory](#VK_FUCHSIA_external_memory)
- [Other Extension Metadata](#_other_extension_metadata_186)
- [Other_Extension_Metadata](#_other_extension_metadata_186)
- [Description](#_description_186)
- [New Commands](#_new_commands_78)
- [New Structures](#_new_structures_168)
- [New Enum Constants](#_new_enum_constants_187)
- [New_Enum_Constants](#_new_enum_constants_187)
- [Issues](#_issues_84)
- [Version History](#_version_history_187)
- [VK_FUCHSIA_external_semaphore](#VK_FUCHSIA_external_semaphore)
- [Other Extension Metadata](#_other_extension_metadata_187)
- [Other_Extension_Metadata](#_other_extension_metadata_187)
- [Description](#_description_187)
- [New Commands](#_new_commands_79)
- [New Structures](#_new_structures_169)
- [New Enum Constants](#_new_enum_constants_188)
- [New_Enum_Constants](#_new_enum_constants_188)
- [Issues](#_issues_85)
- [Version History](#_version_history_188)
- [VK_FUCHSIA_imagepipe_surface](#VK_FUCHSIA_imagepipe_surface)
- [Other Extension Metadata](#_other_extension_metadata_188)
- [Other_Extension_Metadata](#_other_extension_metadata_188)
- [Description](#_description_188)
- [New Commands](#_new_commands_80)
- [New Structures](#_new_structures_170)
- [New Bitmasks](#_new_bitmasks_44)
- [New Enum Constants](#_new_enum_constants_189)
- [New_Enum_Constants](#_new_enum_constants_189)
- [Version History](#_version_history_189)
- [VK_GGP_frame_token](#VK_GGP_frame_token)
- [Other Extension Metadata](#_other_extension_metadata_189)
- [Other_Extension_Metadata](#_other_extension_metadata_189)
- [Description](#_description_189)
- [New Structures](#_new_structures_171)
- [New Enum Constants](#_new_enum_constants_190)
- [New_Enum_Constants](#_new_enum_constants_190)
- [Version History](#_version_history_190)
- [VK_GGP_stream_descriptor_surface](#VK_GGP_stream_descriptor_surface)
- [Other Extension Metadata](#_other_extension_metadata_190)
- [Other_Extension_Metadata](#_other_extension_metadata_190)
- [Description](#_description_190)
- [New Commands](#_new_commands_81)
- [New Structures](#_new_structures_172)
- [New Bitmasks](#_new_bitmasks_45)
- [New Enum Constants](#_new_enum_constants_191)
- [New_Enum_Constants](#_new_enum_constants_191)
- [Version History](#_version_history_191)
- [VK_GOOGLE_decorate_string](#VK_GOOGLE_decorate_string)
- [Other Extension Metadata](#_other_extension_metadata_191)
- [Other_Extension_Metadata](#_other_extension_metadata_191)
- [Description](#_description_191)
- [New Enum Constants](#_new_enum_constants_192)
- [New_Enum_Constants](#_new_enum_constants_192)
- [Version History](#_version_history_192)
- [VK_GOOGLE_display_timing](#VK_GOOGLE_display_timing)
- [Other Extension Metadata](#_other_extension_metadata_192)
- [Other_Extension_Metadata](#_other_extension_metadata_192)
- [Description](#_description_192)
- [New Commands](#_new_commands_82)
- [New Structures](#_new_structures_173)
- [New Enum Constants](#_new_enum_constants_193)
- [New_Enum_Constants](#_new_enum_constants_193)
- [Examples](#_examples_25)
- [Version History](#_version_history_193)
- [VK_GOOGLE_hlsl_functionality1](#VK_GOOGLE_hlsl_functionality1)
- [Other Extension Metadata](#_other_extension_metadata_193)
- [Other_Extension_Metadata](#_other_extension_metadata_193)
- [Description](#_description_193)
- [New Enum Constants](#_new_enum_constants_194)
- [New_Enum_Constants](#_new_enum_constants_194)
- [Version History](#_version_history_194)
- [VK_GOOGLE_surfaceless_query](#VK_GOOGLE_surfaceless_query)
- [Other Extension Metadata](#_other_extension_metadata_194)
- [Other_Extension_Metadata](#_other_extension_metadata_194)
- [Description](#_description_194)
- [New Enum Constants](#_new_enum_constants_195)
- [New_Enum_Constants](#_new_enum_constants_195)
- [Version History](#_version_history_195)
- [VK_GOOGLE_user_type](#VK_GOOGLE_user_type)
- [Other Extension Metadata](#_other_extension_metadata_195)
- [Other_Extension_Metadata](#_other_extension_metadata_195)
- [Description](#_description_195)
- [New Enum Constants](#_new_enum_constants_196)
- [New_Enum_Constants](#_new_enum_constants_196)
- [Version History](#_version_history_196)
- [VK_HUAWEI_cluster_culling_shader](#VK_HUAWEI_cluster_culling_shader)
- [Other Extension Metadata](#_other_extension_metadata_196)
- [Other_Extension_Metadata](#_other_extension_metadata_196)
- [Description](#_description_196)
- [New Commands](#_new_commands_83)
- [New Structures](#_new_structures_174)
- [New Enum Constants](#_new_enum_constants_197)
- [New_Enum_Constants](#_new_enum_constants_197)
- [New Built-In Variables](#_new_built_in_variables_5)
- [New_Built-In_Variables](#_new_built_in_variables_5)
- [New SPIR-V Capability](#_new_spir_v_capability_3)
- [New_SPIR-V_Capability](#_new_spir_v_capability_3)
- [Sample Code](#_sample_code_3)
- [Version History](#_version_history_197)
- [VK_HUAWEI_hdr_vivid](#VK_HUAWEI_hdr_vivid)
- [Other Extension Metadata](#_other_extension_metadata_197)
- [Other_Extension_Metadata](#_other_extension_metadata_197)
- [Description](#_description_197)
- [New Structures](#_new_structures_175)
- [New Enum Constants](#_new_enum_constants_198)
- [New_Enum_Constants](#_new_enum_constants_198)
- [Version History](#_version_history_198)
- [VK_HUAWEI_invocation_mask](#VK_HUAWEI_invocation_mask)
- [Other Extension Metadata](#_other_extension_metadata_198)
- [Other_Extension_Metadata](#_other_extension_metadata_198)
- [Description](#_description_198)
- [New Commands](#_new_commands_84)
- [New Structures](#_new_structures_176)
- [New Enum Constants](#_new_enum_constants_199)
- [New_Enum_Constants](#_new_enum_constants_199)
- [Examples](#_examples_26)
- [Version History](#_version_history_199)
- [VK_HUAWEI_subpass_shading](#VK_HUAWEI_subpass_shading)
- [Other Extension Metadata](#_other_extension_metadata_199)
- [Other_Extension_Metadata](#_other_extension_metadata_199)
- [Description](#_description_199)
- [New Commands](#_new_commands_85)
- [New Structures](#_new_structures_177)
- [New Enum Constants](#_new_enum_constants_200)
- [New_Enum_Constants](#_new_enum_constants_200)
- [Sample Code](#_sample_code_4)
- [Version History](#_version_history_200)
- [VK_IMG_filter_cubic](#VK_IMG_filter_cubic)
- [Other Extension Metadata](#_other_extension_metadata_200)
- [Other_Extension_Metadata](#_other_extension_metadata_200)
- [Description](#_description_200)
- [New Enum Constants](#_new_enum_constants_201)
- [New_Enum_Constants](#_new_enum_constants_201)
- [Example](#_example_3)
- [Version History](#_version_history_201)
- [VK_IMG_relaxed_line_rasterization](#VK_IMG_relaxed_line_rasterization)
- [Other Extension Metadata](#_other_extension_metadata_201)
- [Other_Extension_Metadata](#_other_extension_metadata_201)
- [Description](#_description_201)
- [New Structures](#_new_structures_178)
- [New Enum Constants](#_new_enum_constants_202)
- [New_Enum_Constants](#_new_enum_constants_202)
- [Issues](#_issues_86)
- [Version History](#_version_history_202)
- [VK_INTEL_performance_query](#VK_INTEL_performance_query)
- [Other Extension Metadata](#_other_extension_metadata_202)
- [Other_Extension_Metadata](#_other_extension_metadata_202)
- [Description](#_description_202)
- [New Object Types](#_new_object_types_14)
- [New_Object_Types](#_new_object_types_14)
- [New Commands](#_new_commands_86)
- [New Structures](#_new_structures_179)
- [New Unions](#_new_unions_6)
- [New Enums](#_new_enums_55)
- [New Enum Constants](#_new_enum_constants_203)
- [New_Enum_Constants](#_new_enum_constants_203)
- [Example Code](#_example_code_2)
- [Version History](#_version_history_203)
- [VK_INTEL_shader_integer_functions2](#VK_INTEL_shader_integer_functions2)
- [Other Extension Metadata](#_other_extension_metadata_203)
- [Other_Extension_Metadata](#_other_extension_metadata_203)
- [Description](#_description_203)
- [New Structures](#_new_structures_180)
- [New Enum Constants](#_new_enum_constants_204)
- [New_Enum_Constants](#_new_enum_constants_204)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_22)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_22)
- [Version History](#_version_history_204)
- [VK_LUNARG_direct_driver_loading](#VK_LUNARG_direct_driver_loading)
- [Other Extension Metadata](#_other_extension_metadata_204)
- [Other_Extension_Metadata](#_other_extension_metadata_204)
- [Description](#_description_204)
- [New Structures](#_new_structures_181)
- [New Function Pointers](#_new_function_pointers_3)
- [New_Function_Pointers](#_new_function_pointers_3)
- [New Enums](#_new_enums_56)
- [New Bitmasks](#_new_bitmasks_46)
- [New Enum Constants](#_new_enum_constants_205)
- [New_Enum_Constants](#_new_enum_constants_205)
- [Version History](#_version_history_205)
- [VK_MESA_image_alignment_control](#VK_MESA_image_alignment_control)
- [Other Extension Metadata](#_other_extension_metadata_205)
- [Other_Extension_Metadata](#_other_extension_metadata_205)
- [Description](#_description_205)
- [New Structures](#_new_structures_182)
- [New Enum Constants](#_new_enum_constants_206)
- [New_Enum_Constants](#_new_enum_constants_206)
- [Version History](#_version_history_206)
- [VK_MSFT_layered_driver](#VK_MSFT_layered_driver)
- [Other Extension Metadata](#_other_extension_metadata_206)
- [Other_Extension_Metadata](#_other_extension_metadata_206)
- [Description](#_description_206)
- [New Structures](#_new_structures_183)
- [New Enums](#_new_enums_57)
- [New Enum Constants](#_new_enum_constants_207)
- [New_Enum_Constants](#_new_enum_constants_207)
- [Examples](#_examples_27)
- [Version History](#_version_history_207)
- [VK_NN_vi_surface](#VK_NN_vi_surface)
- [Other Extension Metadata](#_other_extension_metadata_207)
- [Other_Extension_Metadata](#_other_extension_metadata_207)
- [Description](#_description_207)
- [New Commands](#_new_commands_87)
- [New Structures](#_new_structures_184)
- [New Bitmasks](#_new_bitmasks_47)
- [New Enum Constants](#_new_enum_constants_208)
- [New_Enum_Constants](#_new_enum_constants_208)
- [Issues](#_issues_87)
- [Version History](#_version_history_208)
- [VK_NV_acquire_winrt_display](#VK_NV_acquire_winrt_display)
- [Other Extension Metadata](#_other_extension_metadata_208)
- [Other_Extension_Metadata](#_other_extension_metadata_208)
- [Description](#_description_208)
- [New Commands](#_new_commands_88)
- [New Enum Constants](#_new_enum_constants_209)
- [New_Enum_Constants](#_new_enum_constants_209)
- [Issues](#_issues_88)
- [Version History](#_version_history_209)
- [VK_NV_clip_space_w_scaling](#VK_NV_clip_space_w_scaling)
- [Other Extension Metadata](#_other_extension_metadata_209)
- [Other_Extension_Metadata](#_other_extension_metadata_209)
- [Description](#_description_209)
- [New Commands](#_new_commands_89)
- [New Structures](#_new_structures_185)
- [New Enum Constants](#_new_enum_constants_210)
- [New_Enum_Constants](#_new_enum_constants_210)
- [Issues](#_issues_89)
- [Examples](#_examples_28)
- [Version History](#_version_history_210)
- [VK_NV_cluster_acceleration_structure](#VK_NV_cluster_acceleration_structure)
- [Other Extension Metadata](#_other_extension_metadata_210)
- [Other_Extension_Metadata](#_other_extension_metadata_210)
- [Description](#_description_210)
- [New Commands](#_new_commands_90)
- [New Structures](#_new_structures_186)
- [New Unions](#_new_unions_7)
- [New Enums](#_new_enums_58)
- [New Bitmasks](#_new_bitmasks_48)
- [New Enum Constants](#_new_enum_constants_211)
- [New_Enum_Constants](#_new_enum_constants_211)
- [New or Modified Built-In Variables](#_new_or_modified_built_in_variables_6)
- [New_or_Modified_Built-In_Variables](#_new_or_modified_built_in_variables_6)
- [New SPIR-V Capability](#_new_spir_v_capability_4)
- [New_SPIR-V_Capability](#_new_spir_v_capability_4)
- [Version History](#_version_history_211)
- [VK_NV_command_buffer_inheritance](#VK_NV_command_buffer_inheritance)
- [Other Extension Metadata](#_other_extension_metadata_211)
- [Other_Extension_Metadata](#_other_extension_metadata_211)
- [Description](#_description_211)
- [New Structures](#_new_structures_187)
- [New Enum Constants](#_new_enum_constants_212)
- [New_Enum_Constants](#_new_enum_constants_212)
- [Issues](#_issues_90)
- [Version History](#_version_history_212)
- [VK_NV_cooperative_matrix](#VK_NV_cooperative_matrix)
- [Other Extension Metadata](#_other_extension_metadata_212)
- [Other_Extension_Metadata](#_other_extension_metadata_212)
- [Description](#_description_212)
- [New Commands](#_new_commands_91)
- [New Structures](#_new_structures_188)
- [New Enums](#_new_enums_59)
- [New Enum Constants](#_new_enum_constants_213)
- [New_Enum_Constants](#_new_enum_constants_213)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_23)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_23)
- [Issues](#_issues_91)
- [Version History](#_version_history_213)
- [VK_NV_cooperative_matrix2](#VK_NV_cooperative_matrix2)
- [Other Extension Metadata](#_other_extension_metadata_213)
- [Other_Extension_Metadata](#_other_extension_metadata_213)
- [Description](#_description_213)
- [New Commands](#_new_commands_92)
- [New Structures](#_new_structures_189)
- [New Enum Constants](#_new_enum_constants_214)
- [New_Enum_Constants](#_new_enum_constants_214)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_24)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_24)
- [Issues](#_issues_92)
- [Version History](#_version_history_214)
- [VK_NV_cooperative_vector](#VK_NV_cooperative_vector)
- [Other Extension Metadata](#_other_extension_metadata_214)
- [Other_Extension_Metadata](#_other_extension_metadata_214)
- [Description](#_description_214)
- [New Commands](#_new_commands_93)
- [New Structures](#_new_structures_190)
- [New Unions](#_new_unions_8)
- [New Enums](#_new_enums_60)
- [New Enum Constants](#_new_enum_constants_215)
- [New_Enum_Constants](#_new_enum_constants_215)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_25)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_25)
- [Issues](#_issues_93)
- [Version History](#_version_history_215)
- [VK_NV_copy_memory_indirect](#VK_NV_copy_memory_indirect)
- [Other Extension Metadata](#_other_extension_metadata_215)
- [Other_Extension_Metadata](#_other_extension_metadata_215)
- [Description](#_description_215)
- [New Commands](#_new_commands_94)
- [New Structures](#_new_structures_191)
- [New Enum Constants](#_new_enum_constants_216)
- [New_Enum_Constants](#_new_enum_constants_216)
- [Version History](#_version_history_216)
- [VK_NV_corner_sampled_image](#VK_NV_corner_sampled_image)
- [Other Extension Metadata](#_other_extension_metadata_216)
- [Other_Extension_Metadata](#_other_extension_metadata_216)
- [Description](#_description_216)
- [New Structures](#_new_structures_192)
- [New Enum Constants](#_new_enum_constants_217)
- [New_Enum_Constants](#_new_enum_constants_217)
- [Issues](#_issues_94)
- [Version History](#_version_history_217)
- [VK_NV_coverage_reduction_mode](#VK_NV_coverage_reduction_mode)
- [Other Extension Metadata](#_other_extension_metadata_217)
- [Other_Extension_Metadata](#_other_extension_metadata_217)
- [Description](#_description_217)
- [New Commands](#_new_commands_95)
- [New Structures](#_new_structures_193)
- [New Enums](#_new_enums_61)
- [New Bitmasks](#_new_bitmasks_49)
- [New Enum Constants](#_new_enum_constants_218)
- [New_Enum_Constants](#_new_enum_constants_218)
- [Version History](#_version_history_218)
- [VK_NV_dedicated_allocation_image_aliasing](#VK_NV_dedicated_allocation_image_aliasing)
- [Other Extension Metadata](#_other_extension_metadata_218)
- [Other_Extension_Metadata](#_other_extension_metadata_218)
- [Description](#_description_218)
- [New Structures](#_new_structures_194)
- [New Enum Constants](#_new_enum_constants_219)
- [New_Enum_Constants](#_new_enum_constants_219)
- [Version History](#_version_history_219)
- [VK_NV_descriptor_pool_overallocation](#VK_NV_descriptor_pool_overallocation)
- [Other Extension Metadata](#_other_extension_metadata_219)
- [Other_Extension_Metadata](#_other_extension_metadata_219)
- [Description](#_description_219)
- [New Structures](#_new_structures_195)
- [New Enum Constants](#_new_enum_constants_220)
- [New_Enum_Constants](#_new_enum_constants_220)
- [Version History](#_version_history_220)
- [VK_NV_device_diagnostic_checkpoints](#VK_NV_device_diagnostic_checkpoints)
- [Other Extension Metadata](#_other_extension_metadata_220)
- [Other_Extension_Metadata](#_other_extension_metadata_220)
- [Description](#_description_220)
- [New Commands](#_new_commands_96)
- [New Structures](#_new_structures_196)
- [New Enum Constants](#_new_enum_constants_221)
- [New_Enum_Constants](#_new_enum_constants_221)
- [Version History](#_version_history_221)
- [VK_NV_device_diagnostics_config](#VK_NV_device_diagnostics_config)
- [Other Extension Metadata](#_other_extension_metadata_221)
- [Other_Extension_Metadata](#_other_extension_metadata_221)
- [Description](#_description_221)
- [New Structures](#_new_structures_197)
- [New Enums](#_new_enums_62)
- [New Bitmasks](#_new_bitmasks_50)
- [New Enum Constants](#_new_enum_constants_222)
- [New_Enum_Constants](#_new_enum_constants_222)
- [Version History](#_version_history_222)
- [VK_NV_device_generated_commands](#VK_NV_device_generated_commands)
- [Other Extension Metadata](#_other_extension_metadata_222)
- [Other_Extension_Metadata](#_other_extension_metadata_222)
- [Description](#_description_222)
- [New Object Types](#_new_object_types_15)
- [New_Object_Types](#_new_object_types_15)
- [New Commands](#_new_commands_97)
- [New Structures](#_new_structures_198)
- [New Enums](#_new_enums_63)
- [New Bitmasks](#_new_bitmasks_51)
- [New Enum Constants](#_new_enum_constants_223)
- [New_Enum_Constants](#_new_enum_constants_223)
- [Issues](#_issues_95)
- [Example Code](#_example_code_3)
- [Version History](#_version_history_223)
- [VK_NV_device_generated_commands_compute](#VK_NV_device_generated_commands_compute)
- [Other Extension Metadata](#_other_extension_metadata_223)
- [Other_Extension_Metadata](#_other_extension_metadata_223)
- [Description](#_description_223)
- [New Commands](#_new_commands_98)
- [New Structures](#_new_structures_199)
- [New Enum Constants](#_new_enum_constants_224)
- [New_Enum_Constants](#_new_enum_constants_224)
- [Version History](#_version_history_224)
- [VK_NV_display_stereo](#VK_NV_display_stereo)
- [Other Extension Metadata](#_other_extension_metadata_224)
- [Other_Extension_Metadata](#_other_extension_metadata_224)
- [Description](#_description_224)
- [New Structures](#_new_structures_200)
- [New Enums](#_new_enums_64)
- [New Enum Constants](#_new_enum_constants_225)
- [New_Enum_Constants](#_new_enum_constants_225)
- [Version History](#_version_history_225)
- [VK_NV_extended_sparse_address_space](#VK_NV_extended_sparse_address_space)
- [Other Extension Metadata](#_other_extension_metadata_225)
- [Other_Extension_Metadata](#_other_extension_metadata_225)
- [Description](#_description_225)
- [New Structures](#_new_structures_201)
- [New Enum Constants](#_new_enum_constants_226)
- [New_Enum_Constants](#_new_enum_constants_226)
- [Version History](#_version_history_226)
- [VK_NV_external_compute_queue](#VK_NV_external_compute_queue)
- [Other Extension Metadata](#_other_extension_metadata_226)
- [Other_Extension_Metadata](#_other_extension_metadata_226)
- [Description](#_description_226)
- [New Object Types](#_new_object_types_16)
- [New_Object_Types](#_new_object_types_16)
- [New Commands](#_new_commands_99)
- [New Structures](#_new_structures_202)
- [New Enum Constants](#_new_enum_constants_227)
- [New_Enum_Constants](#_new_enum_constants_227)
- [Issues](#_issues_96)
- [Version History](#_version_history_227)
- [VK_NV_external_memory_rdma](#VK_NV_external_memory_rdma)
- [Other Extension Metadata](#_other_extension_metadata_227)
- [Other_Extension_Metadata](#_other_extension_metadata_227)
- [Description](#_description_227)
- [New Base Types](#_new_base_types_5)
- [New_Base_Types](#_new_base_types_5)
- [New Commands](#_new_commands_100)
- [New Structures](#_new_structures_203)
- [New Enum Constants](#_new_enum_constants_228)
- [New_Enum_Constants](#_new_enum_constants_228)
- [Issues](#_issues_97)
- [Examples](#_examples_29)
- [Version History](#_version_history_228)
- [VK_NV_fill_rectangle](#VK_NV_fill_rectangle)
- [Other Extension Metadata](#_other_extension_metadata_228)
- [Other_Extension_Metadata](#_other_extension_metadata_228)
- [Description](#_description_228)
- [New Enum Constants](#_new_enum_constants_229)
- [New_Enum_Constants](#_new_enum_constants_229)
- [Version History](#_version_history_229)
- [VK_NV_fragment_coverage_to_color](#VK_NV_fragment_coverage_to_color)
- [Other Extension Metadata](#_other_extension_metadata_229)
- [Other_Extension_Metadata](#_other_extension_metadata_229)
- [Description](#_description_229)
- [New Structures](#_new_structures_204)
- [New Bitmasks](#_new_bitmasks_52)
- [New Enum Constants](#_new_enum_constants_230)
- [New_Enum_Constants](#_new_enum_constants_230)
- [Version History](#_version_history_230)
- [VK_NV_fragment_shading_rate_enums](#VK_NV_fragment_shading_rate_enums)
- [Other Extension Metadata](#_other_extension_metadata_230)
- [Other_Extension_Metadata](#_other_extension_metadata_230)
- [Description](#_description_230)
- [New Commands](#_new_commands_101)
- [New Structures](#_new_structures_205)
- [New Enums](#_new_enums_65)
- [New Enum Constants](#_new_enum_constants_231)
- [New_Enum_Constants](#_new_enum_constants_231)
- [Issues](#_issues_98)
- [Version History](#_version_history_231)
- [VK_NV_framebuffer_mixed_samples](#VK_NV_framebuffer_mixed_samples)
- [Other Extension Metadata](#_other_extension_metadata_231)
- [Other_Extension_Metadata](#_other_extension_metadata_231)
- [Description](#_description_231)
- [New Structures](#_new_structures_206)
- [New Enums](#_new_enums_66)
- [New Bitmasks](#_new_bitmasks_53)
- [New Enum Constants](#_new_enum_constants_232)
- [New_Enum_Constants](#_new_enum_constants_232)
- [Version History](#_version_history_232)
- [VK_NV_geometry_shader_passthrough](#VK_NV_geometry_shader_passthrough)
- [Other Extension Metadata](#_other_extension_metadata_232)
- [Other_Extension_Metadata](#_other_extension_metadata_232)
- [Description](#_description_232)
- [New Enum Constants](#_new_enum_constants_233)
- [New_Enum_Constants](#_new_enum_constants_233)
- [New Variable Decoration](#_new_variable_decoration)
- [New_Variable_Decoration](#_new_variable_decoration)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_26)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_26)
- [Issues](#_issues_99)
- [Sample Code](#_sample_code_5)
- [Version History](#_version_history_233)
- [VK_NV_inherited_viewport_scissor](#VK_NV_inherited_viewport_scissor)
- [Other Extension Metadata](#_other_extension_metadata_233)
- [Other_Extension_Metadata](#_other_extension_metadata_233)
- [Description](#_description_233)
- [New Structures](#_new_structures_207)
- [New Enum Constants](#_new_enum_constants_234)
- [New_Enum_Constants](#_new_enum_constants_234)
- [Issues](#_issues_100)
- [Version History](#_version_history_234)
- [VK_NV_linear_color_attachment](#VK_NV_linear_color_attachment)
- [Other Extension Metadata](#_other_extension_metadata_234)
- [Other_Extension_Metadata](#_other_extension_metadata_234)
- [Description](#_description_234)
- [New Structures](#_new_structures_208)
- [New Enum Constants](#_new_enum_constants_235)
- [New_Enum_Constants](#_new_enum_constants_235)
- [Version History](#_version_history_235)
- [VK_NV_low_latency](#VK_NV_low_latency)
- [Other Extension Metadata](#_other_extension_metadata_235)
- [Other_Extension_Metadata](#_other_extension_metadata_235)
- [Description](#_description_235)
- [New Structures](#_new_structures_209)
- [New Enum Constants](#_new_enum_constants_236)
- [New_Enum_Constants](#_new_enum_constants_236)
- [Issues](#_issues_101)
- [Version History](#_version_history_236)
- [VK_NV_low_latency2](#VK_NV_low_latency2)
- [Other Extension Metadata](#_other_extension_metadata_236)
- [Other_Extension_Metadata](#_other_extension_metadata_236)
- [New Commands](#_new_commands_102)
- [New Structures](#_new_structures_210)
- [New Enums](#_new_enums_67)
- [New Enum Constants](#_new_enum_constants_237)
- [New_Enum_Constants](#_new_enum_constants_237)
- [Description](#_description_236)
- [Issues](#_issues_102)
- [Version History](#_version_history_237)
- [VK_NV_memory_decompression](#VK_NV_memory_decompression)
- [Other Extension Metadata](#_other_extension_metadata_237)
- [Other_Extension_Metadata](#_other_extension_metadata_237)
- [Description](#_description_237)
- [New Commands](#_new_commands_103)
- [New Structures](#_new_structures_211)
- [New Enums](#_new_enums_68)
- [New Bitmasks](#_new_bitmasks_54)
- [New Enum Constants](#_new_enum_constants_238)
- [New_Enum_Constants](#_new_enum_constants_238)
- [Version History](#_version_history_238)
- [VK_NV_mesh_shader](#VK_NV_mesh_shader)
- [Other Extension Metadata](#_other_extension_metadata_238)
- [Other_Extension_Metadata](#_other_extension_metadata_238)
- [Description](#_description_238)
- [New Commands](#_new_commands_104)
- [New Structures](#_new_structures_212)
- [New Enum Constants](#_new_enum_constants_239)
- [New_Enum_Constants](#_new_enum_constants_239)
- [New or Modified Built-In Variables](#_new_or_modified_built_in_variables_7)
- [New_or_Modified_Built-In_Variables](#_new_or_modified_built_in_variables_7)
- [New SPIR-V Capability](#_new_spir_v_capability_5)
- [New_SPIR-V_Capability](#_new_spir_v_capability_5)
- [Issues](#_issues_103)
- [Version History](#_version_history_239)
- [VK_NV_optical_flow](#VK_NV_optical_flow)
- [Other Extension Metadata](#_other_extension_metadata_239)
- [Other_Extension_Metadata](#_other_extension_metadata_239)
- [Description](#_description_239)
- [New Object Types](#_new_object_types_17)
- [New_Object_Types](#_new_object_types_17)
- [New Commands](#_new_commands_105)
- [New Structures](#_new_structures_213)
- [New Enums](#_new_enums_69)
- [New Bitmasks](#_new_bitmasks_55)
- [New Enum Constants](#_new_enum_constants_240)
- [New_Enum_Constants](#_new_enum_constants_240)
- [Examples](#_examples_30)
- [Version History](#_version_history_240)
- [VK_NV_partitioned_acceleration_structure](#VK_NV_partitioned_acceleration_structure)
- [Other Extension Metadata](#_other_extension_metadata_240)
- [Other_Extension_Metadata](#_other_extension_metadata_240)
- [Description](#_description_240)
- [New Commands](#_new_commands_106)
- [New Structures](#_new_structures_214)
- [New Enums](#_new_enums_70)
- [New Bitmasks](#_new_bitmasks_56)
- [New Enum Constants](#_new_enum_constants_241)
- [New_Enum_Constants](#_new_enum_constants_241)
- [Version History](#_version_history_241)
- [VK_NV_per_stage_descriptor_set](#VK_NV_per_stage_descriptor_set)
- [Other Extension Metadata](#_other_extension_metadata_241)
- [Other_Extension_Metadata](#_other_extension_metadata_241)
- [Description](#_description_241)
- [New Structures](#_new_structures_215)
- [New Enum Constants](#_new_enum_constants_242)
- [New_Enum_Constants](#_new_enum_constants_242)
- [Issues](#_issues_104)
- [Version History](#_version_history_242)
- [VK_NV_present_barrier](#VK_NV_present_barrier)
- [Other Extension Metadata](#_other_extension_metadata_242)
- [Other_Extension_Metadata](#_other_extension_metadata_242)
- [Description](#_description_242)
- [New Structures](#_new_structures_216)
- [New Enum Constants](#_new_enum_constants_243)
- [New_Enum_Constants](#_new_enum_constants_243)
- [Issues](#_issues_105)
- [Version History](#_version_history_243)
- [VK_NV_raw_access_chains](#VK_NV_raw_access_chains)
- [Other Extension Metadata](#_other_extension_metadata_243)
- [Other_Extension_Metadata](#_other_extension_metadata_243)
- [Description](#_description_243)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_27)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_27)
- [Version History](#_version_history_244)
- [VK_NV_ray_tracing_invocation_reorder](#VK_NV_ray_tracing_invocation_reorder)
- [Other Extension Metadata](#_other_extension_metadata_244)
- [Other_Extension_Metadata](#_other_extension_metadata_244)
- [Description](#_description_244)
- [New Structures](#_new_structures_217)
- [New Enums](#_new_enums_71)
- [New Enum Constants](#_new_enum_constants_244)
- [New_Enum_Constants](#_new_enum_constants_244)
- [HLSL Mapping](#_hlsl_mapping)
- [Version History](#_version_history_245)
- [VK_NV_ray_tracing_linear_swept_spheres](#VK_NV_ray_tracing_linear_swept_spheres)
- [Other Extension Metadata](#_other_extension_metadata_245)
- [Other_Extension_Metadata](#_other_extension_metadata_245)
- [Description](#_description_245)
- [New Structures](#_new_structures_218)
- [New Enums](#_new_enums_72)
- [New Enum Constants](#_new_enum_constants_245)
- [New_Enum_Constants](#_new_enum_constants_245)
- [New or Modified Built-In Variables](#_new_or_modified_built_in_variables_8)
- [New_or_Modified_Built-In_Variables](#_new_or_modified_built_in_variables_8)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_28)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_28)
- [Version History](#_version_history_246)
- [VK_NV_ray_tracing_motion_blur](#VK_NV_ray_tracing_motion_blur)
- [Other Extension Metadata](#_other_extension_metadata_246)
- [Other_Extension_Metadata](#_other_extension_metadata_246)
- [Description](#_description_246)
- [New Structures](#_new_structures_219)
- [New Unions](#_new_unions_9)
- [New Enums](#_new_enums_73)
- [New Bitmasks](#_new_bitmasks_57)
- [New Enum Constants](#_new_enum_constants_246)
- [New_Enum_Constants](#_new_enum_constants_246)
- [Issues](#_issues_106)
- [Version History](#_version_history_247)
- [VK_NV_ray_tracing_validation](#VK_NV_ray_tracing_validation)
- [Other Extension Metadata](#_other_extension_metadata_247)
- [Other_Extension_Metadata](#_other_extension_metadata_247)
- [Description](#_description_247)
- [New Structures](#_new_structures_220)
- [New Enum Constants](#_new_enum_constants_247)
- [New_Enum_Constants](#_new_enum_constants_247)
- [Version History](#_version_history_248)
- [VK_NV_representative_fragment_test](#VK_NV_representative_fragment_test)
- [Other Extension Metadata](#_other_extension_metadata_248)
- [Other_Extension_Metadata](#_other_extension_metadata_248)
- [Description](#_description_248)
- [New Structures](#_new_structures_221)
- [New Enum Constants](#_new_enum_constants_248)
- [New_Enum_Constants](#_new_enum_constants_248)
- [Issues](#_issues_107)
- [Version History](#_version_history_249)
- [VK_NV_sample_mask_override_coverage](#VK_NV_sample_mask_override_coverage)
- [Other Extension Metadata](#_other_extension_metadata_249)
- [Other_Extension_Metadata](#_other_extension_metadata_249)
- [Description](#_description_249)
- [New Enum Constants](#_new_enum_constants_249)
- [New_Enum_Constants](#_new_enum_constants_249)
- [New Variable Decoration](#_new_variable_decoration_2)
- [New_Variable_Decoration](#_new_variable_decoration_2)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_29)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_29)
- [Version History](#_version_history_250)
- [VK_NV_scissor_exclusive](#VK_NV_scissor_exclusive)
- [Other Extension Metadata](#_other_extension_metadata_250)
- [Other_Extension_Metadata](#_other_extension_metadata_250)
- [Description](#_description_250)
- [New Commands](#_new_commands_107)
- [New Structures](#_new_structures_222)
- [New Enum Constants](#_new_enum_constants_250)
- [New_Enum_Constants](#_new_enum_constants_250)
- [Issues](#_issues_108)
- [Version History](#_version_history_251)
- [VK_NV_shader_atomic_float16_vector](#VK_NV_shader_atomic_float16_vector)
- [Other Extension Metadata](#_other_extension_metadata_251)
- [Other_Extension_Metadata](#_other_extension_metadata_251)
- [Description](#_description_251)
- [New Structures](#_new_structures_223)
- [New Enum Constants](#_new_enum_constants_251)
- [New_Enum_Constants](#_new_enum_constants_251)
- [Issues](#_issues_109)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_30)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_30)
- [Version History](#_version_history_252)
- [VK_NV_shader_image_footprint](#VK_NV_shader_image_footprint)
- [Other Extension Metadata](#_other_extension_metadata_252)
- [Other_Extension_Metadata](#_other_extension_metadata_252)
- [Description](#_description_252)
- [New Structures](#_new_structures_224)
- [New Enum Constants](#_new_enum_constants_252)
- [New_Enum_Constants](#_new_enum_constants_252)
- [New SPIR-V Capability](#_new_spir_v_capability_6)
- [New_SPIR-V_Capability](#_new_spir_v_capability_6)
- [Issues](#_issues_110)
- [Examples](#_examples_31)
- [Version History](#_version_history_253)
- [VK_NV_shader_sm_builtins](#VK_NV_shader_sm_builtins)
- [Other Extension Metadata](#_other_extension_metadata_253)
- [Other_Extension_Metadata](#_other_extension_metadata_253)
- [Description](#_description_253)
- [New Structures](#_new_structures_225)
- [New Enum Constants](#_new_enum_constants_253)
- [New_Enum_Constants](#_new_enum_constants_253)
- [New or Modified Built-In Variables](#_new_or_modified_built_in_variables_9)
- [New_or_Modified_Built-In_Variables](#_new_or_modified_built_in_variables_9)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_31)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_31)
- [Issues](#_issues_111)
- [Version History](#_version_history_254)
- [VK_NV_shader_subgroup_partitioned](#VK_NV_shader_subgroup_partitioned)
- [Other Extension Metadata](#_other_extension_metadata_254)
- [Other_Extension_Metadata](#_other_extension_metadata_254)
- [Description](#_description_254)
- [New Enum Constants](#_new_enum_constants_254)
- [New_Enum_Constants](#_new_enum_constants_254)
- [Version History](#_version_history_255)
- [VK_NV_shading_rate_image](#VK_NV_shading_rate_image)
- [Other Extension Metadata](#_other_extension_metadata_255)
- [Other_Extension_Metadata](#_other_extension_metadata_255)
- [Description](#_description_255)
- [New Commands](#_new_commands_108)
- [New Structures](#_new_structures_226)
- [New Enums](#_new_enums_74)
- [New Enum Constants](#_new_enum_constants_255)
- [New_Enum_Constants](#_new_enum_constants_255)
- [Issues](#_issues_112)
- [Version History](#_version_history_256)
- [VK_NV_viewport_array2](#VK_NV_viewport_array2)
- [Other Extension Metadata](#_other_extension_metadata_256)
- [Other_Extension_Metadata](#_other_extension_metadata_256)
- [Description](#_description_256)
- [New Enum Constants](#_new_enum_constants_256)
- [New_Enum_Constants](#_new_enum_constants_256)
- [New or Modified Built-In Variables](#_new_or_modified_built_in_variables_10)
- [New_or_Modified_Built-In_Variables](#_new_or_modified_built_in_variables_10)
- [New Variable Decoration](#_new_variable_decoration_3)
- [New_Variable_Decoration](#_new_variable_decoration_3)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_32)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_32)
- [Version History](#_version_history_257)
- [VK_NV_viewport_swizzle](#VK_NV_viewport_swizzle)
- [Other Extension Metadata](#_other_extension_metadata_257)
- [Other_Extension_Metadata](#_other_extension_metadata_257)
- [Description](#_description_257)
- [New Structures](#_new_structures_227)
- [New Enums](#_new_enums_75)
- [New Bitmasks](#_new_bitmasks_58)
- [New Enum Constants](#_new_enum_constants_257)
- [New_Enum_Constants](#_new_enum_constants_257)
- [Issues](#_issues_113)
- [Version History](#_version_history_258)
- [VK_NVX_binary_import](#VK_NVX_binary_import)
- [Other Extension Metadata](#_other_extension_metadata_258)
- [Other_Extension_Metadata](#_other_extension_metadata_258)
- [Description](#_description_258)
- [New Object Types](#_new_object_types_18)
- [New_Object_Types](#_new_object_types_18)
- [New Commands](#_new_commands_109)
- [New Structures](#_new_structures_228)
- [New Enum Constants](#_new_enum_constants_258)
- [New_Enum_Constants](#_new_enum_constants_258)
- [Stub API References](#_stub_api_references)
- [Stub_API_References](#_stub_api_references)
- [Version History](#_version_history_259)
- [VK_NVX_image_view_handle](#VK_NVX_image_view_handle)
- [Other Extension Metadata](#_other_extension_metadata_259)
- [Other_Extension_Metadata](#_other_extension_metadata_259)
- [Description](#_description_259)
- [New Commands](#_new_commands_110)
- [New Structures](#_new_structures_229)
- [New Enum Constants](#_new_enum_constants_259)
- [New_Enum_Constants](#_new_enum_constants_259)
- [Version History](#_version_history_260)
- [VK_NVX_multiview_per_view_attributes](#VK_NVX_multiview_per_view_attributes)
- [Other Extension Metadata](#_other_extension_metadata_260)
- [Other_Extension_Metadata](#_other_extension_metadata_260)
- [Description](#_description_260)
- [New Structures](#_new_structures_230)
- [New Enum Constants](#_new_enum_constants_260)
- [New_Enum_Constants](#_new_enum_constants_260)
- [New Built-In Variables](#_new_built_in_variables_6)
- [New_Built-In_Variables](#_new_built_in_variables_6)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_33)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_33)
- [Examples](#_examples_32)
- [Version History](#_version_history_261)
- [VK_QCOM_filter_cubic_clamp](#VK_QCOM_filter_cubic_clamp)
- [Other Extension Metadata](#_other_extension_metadata_261)
- [Other_Extension_Metadata](#_other_extension_metadata_261)
- [Description](#_description_261)
- [New Structures](#_new_structures_231)
- [New Enum Constants](#_new_enum_constants_261)
- [New_Enum_Constants](#_new_enum_constants_261)
- [Version History](#_version_history_262)
- [VK_QCOM_filter_cubic_weights](#VK_QCOM_filter_cubic_weights)
- [Other Extension Metadata](#_other_extension_metadata_262)
- [Other_Extension_Metadata](#_other_extension_metadata_262)
- [Description](#_description_262)
- [New Structures](#_new_structures_232)
- [New Enums](#_new_enums_76)
- [New Enum Constants](#_new_enum_constants_262)
- [New_Enum_Constants](#_new_enum_constants_262)
- [Version History](#_version_history_263)
- [VK_QCOM_image_processing](#VK_QCOM_image_processing)
- [Other Extension Metadata](#_other_extension_metadata_263)
- [Other_Extension_Metadata](#_other_extension_metadata_263)
- [Description](#_description_263)
- [New Structures](#_new_structures_233)
- [New Enum Constants](#_new_enum_constants_263)
- [New_Enum_Constants](#_new_enum_constants_263)
- [Version History](#_version_history_264)
- [VK_QCOM_image_processing2](#VK_QCOM_image_processing2)
- [Other Extension Metadata](#_other_extension_metadata_264)
- [Other_Extension_Metadata](#_other_extension_metadata_264)
- [Description](#_description_264)
- [New Structures](#_new_structures_234)
- [New Enums](#_new_enums_77)
- [New Enum Constants](#_new_enum_constants_264)
- [New_Enum_Constants](#_new_enum_constants_264)
- [Issues](#_issues_114)
- [Version History](#_version_history_265)
- [VK_QCOM_multiview_per_view_render_areas](#VK_QCOM_multiview_per_view_render_areas)
- [Other Extension Metadata](#_other_extension_metadata_265)
- [Other_Extension_Metadata](#_other_extension_metadata_265)
- [Description](#_description_265)
- [New Structures](#_new_structures_235)
- [New Enum Constants](#_new_enum_constants_265)
- [New_Enum_Constants](#_new_enum_constants_265)
- [Issues](#_issues_115)
- [Version History](#_version_history_266)
- [VK_QCOM_multiview_per_view_viewports](#VK_QCOM_multiview_per_view_viewports)
- [Other Extension Metadata](#_other_extension_metadata_266)
- [Other_Extension_Metadata](#_other_extension_metadata_266)
- [Description](#_description_266)
- [New Structures](#_new_structures_236)
- [New Enum Constants](#_new_enum_constants_266)
- [New_Enum_Constants](#_new_enum_constants_266)
- [Issues](#_issues_116)
- [Version History](#_version_history_267)
- [VK_QCOM_render_pass_shader_resolve](#VK_QCOM_render_pass_shader_resolve)
- [Other Extension Metadata](#_other_extension_metadata_267)
- [Other_Extension_Metadata](#_other_extension_metadata_267)
- [Description](#_description_267)
- [New Enum Constants](#_new_enum_constants_267)
- [New_Enum_Constants](#_new_enum_constants_267)
- [Issues](#_issues_117)
- [Version History](#_version_history_268)
- [VK_QCOM_render_pass_store_ops](#VK_QCOM_render_pass_store_ops)
- [Other Extension Metadata](#_other_extension_metadata_268)
- [Other_Extension_Metadata](#_other_extension_metadata_268)
- [Description](#_description_268)
- [New Enum Constants](#_new_enum_constants_268)
- [New_Enum_Constants](#_new_enum_constants_268)
- [Version History](#_version_history_269)
- [VK_QCOM_render_pass_transform](#VK_QCOM_render_pass_transform)
- [Other Extension Metadata](#_other_extension_metadata_269)
- [Other_Extension_Metadata](#_other_extension_metadata_269)
- [Description](#_description_269)
- [New Structures](#_new_structures_237)
- [New Enum Constants](#_new_enum_constants_269)
- [New_Enum_Constants](#_new_enum_constants_269)
- [Issues](#_issues_118)
- [Version History](#_version_history_270)
- [VK_QCOM_rotated_copy_commands](#VK_QCOM_rotated_copy_commands)
- [Other Extension Metadata](#_other_extension_metadata_270)
- [Other_Extension_Metadata](#_other_extension_metadata_270)
- [Description](#_description_270)
- [Issues](#_issues_119)
- [New Structures](#_new_structures_238)
- [New Enum Constants](#_new_enum_constants_270)
- [New_Enum_Constants](#_new_enum_constants_270)
- [Version History](#_version_history_271)
- [VK_QCOM_tile_memory_heap](#VK_QCOM_tile_memory_heap)
- [Other Extension Metadata](#_other_extension_metadata_271)
- [Other_Extension_Metadata](#_other_extension_metadata_271)
- [Description](#_description_271)
- [Issues](#_issues_120)
- [New Commands](#_new_commands_111)
- [New Structures](#_new_structures_239)
- [New Enum Constants](#_new_enum_constants_271)
- [New_Enum_Constants](#_new_enum_constants_271)
- [Version History](#_version_history_272)
- [VK_QCOM_tile_properties](#VK_QCOM_tile_properties)
- [Other Extension Metadata](#_other_extension_metadata_272)
- [Other_Extension_Metadata](#_other_extension_metadata_272)
- [Description](#_description_272)
- [New Commands](#_new_commands_112)
- [New Structures](#_new_structures_240)
- [New Enum Constants](#_new_enum_constants_272)
- [New_Enum_Constants](#_new_enum_constants_272)
- [Version History](#_version_history_273)
- [VK_QCOM_tile_shading](#VK_QCOM_tile_shading)
- [Other Extension Metadata](#_other_extension_metadata_273)
- [Other_Extension_Metadata](#_other_extension_metadata_273)
- [Description](#_description_273)
- [New Commands](#_new_commands_113)
- [New Structures](#_new_structures_241)
- [New Enums](#_new_enums_78)
- [New Bitmasks](#_new_bitmasks_59)
- [New Enum Constants](#_new_enum_constants_273)
- [New_Enum_Constants](#_new_enum_constants_273)
- [New or Modified Built-In Variables](#_new_or_modified_built_in_variables_11)
- [New_or_Modified_Built-In_Variables](#_new_or_modified_built_in_variables_11)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_34)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_34)
- [Issues](#_issues_121)
- [Version History](#_version_history_274)
- [VK_QCOM_ycbcr_degamma](#VK_QCOM_ycbcr_degamma)
- [Other Extension Metadata](#_other_extension_metadata_274)
- [Other_Extension_Metadata](#_other_extension_metadata_274)
- [Description](#_description_274)
- [New Structures](#_new_structures_242)
- [New Enum Constants](#_new_enum_constants_274)
- [New_Enum_Constants](#_new_enum_constants_274)
- [Issues](#_issues_122)
- [Version History](#_version_history_275)
- [VK_QNX_external_memory_screen_buffer](#VK_QNX_external_memory_screen_buffer)
- [Other Extension Metadata](#_other_extension_metadata_275)
- [Other_Extension_Metadata](#_other_extension_metadata_275)
- [Description](#_description_275)
- [New Commands](#_new_commands_114)
- [New Structures](#_new_structures_243)
- [New Enum Constants](#_new_enum_constants_275)
- [New_Enum_Constants](#_new_enum_constants_275)
- [Issues](#_issues_123)
- [Version History](#_version_history_276)
- [VK_QNX_screen_surface](#VK_QNX_screen_surface)
- [Other Extension Metadata](#_other_extension_metadata_276)
- [Other_Extension_Metadata](#_other_extension_metadata_276)
- [Description](#_description_276)
- [New Commands](#_new_commands_115)
- [New Structures](#_new_structures_244)
- [New Bitmasks](#_new_bitmasks_60)
- [New Enum Constants](#_new_enum_constants_276)
- [New_Enum_Constants](#_new_enum_constants_276)
- [Version History](#_version_history_277)
- [VK_SEC_amigo_profiling](#VK_SEC_amigo_profiling)
- [Other Extension Metadata](#_other_extension_metadata_277)
- [Other_Extension_Metadata](#_other_extension_metadata_277)
- [Description](#_description_277)
- [New Structures](#_new_structures_245)
- [New Enum Constants](#_new_enum_constants_277)
- [New_Enum_Constants](#_new_enum_constants_277)
- [Stub API References](#_stub_api_references_2)
- [Stub_API_References](#_stub_api_references_2)
- [Version History](#_version_history_278)
- [VK_VALVE_descriptor_set_host_mapping](#VK_VALVE_descriptor_set_host_mapping)
- [Other Extension Metadata](#_other_extension_metadata_278)
- [Other_Extension_Metadata](#_other_extension_metadata_278)
- [Description](#_description_278)
- [New Commands](#_new_commands_116)
- [New Structures](#_new_structures_246)
- [New Enum Constants](#_new_enum_constants_278)
- [New_Enum_Constants](#_new_enum_constants_278)
- [Stub API References](#_stub_api_references_3)
- [Stub_API_References](#_stub_api_references_3)
- [Version History](#_version_history_279)
- [List of Provisional Extensions](#provisional-extension-appendices-list)
- [List_of_Provisional_Extensions](#provisional-extension-appendices-list)
- [VK_KHR_portability_subset](#VK_KHR_portability_subset)
- [Other Extension Metadata](#_other_extension_metadata_279)
- [Other_Extension_Metadata](#_other_extension_metadata_279)
- [Description](#_description_279)
- [New Structures](#_new_structures_247)
- [New Enum Constants](#_new_enum_constants_279)
- [New_Enum_Constants](#_new_enum_constants_279)
- [Issues](#_issues_124)
- [Version History](#_version_history_280)
- [VK_AMDX_shader_enqueue](#VK_AMDX_shader_enqueue)
- [Other Extension Metadata](#_other_extension_metadata_280)
- [Other_Extension_Metadata](#_other_extension_metadata_280)
- [Description](#_description_280)
- [New Commands](#_new_commands_117)
- [New Structures](#_new_structures_248)
- [New Unions](#_new_unions_10)
- [New Enum Constants](#_new_enum_constants_280)
- [New_Enum_Constants](#_new_enum_constants_280)
- [Version History](#_version_history_281)
- [VK_NV_cuda_kernel_launch](#VK_NV_cuda_kernel_launch)
- [Other Extension Metadata](#_other_extension_metadata_281)
- [Other_Extension_Metadata](#_other_extension_metadata_281)
- [Description](#_description_281)
- [New Object Types](#_new_object_types_19)
- [New_Object_Types](#_new_object_types_19)
- [New Commands](#_new_commands_118)
- [New Structures](#_new_structures_249)
- [New Enum Constants](#_new_enum_constants_281)
- [New_Enum_Constants](#_new_enum_constants_281)
- [Issues](#_issues_125)
- [Version History](#_version_history_282)
- [VK_NV_present_metering](#VK_NV_present_metering)
- [Other Extension Metadata](#_other_extension_metadata_282)
- [Other_Extension_Metadata](#_other_extension_metadata_282)
- [Description](#_description_282)
- [New Structures](#_new_structures_250)
- [New Enum Constants](#_new_enum_constants_282)
- [New_Enum_Constants](#_new_enum_constants_282)
- [Issues](#_issues_126)
- [Version History](#_version_history_283)
- [List of Deprecated Extensions](#deprecated-extension-appendices-list)
- [List_of_Deprecated_Extensions](#deprecated-extension-appendices-list)
- [VK_KHR_16bit_storage](#VK_KHR_16bit_storage)
- [Other Extension Metadata](#_other_extension_metadata_283)
- [Other_Extension_Metadata](#_other_extension_metadata_283)
- [Description](#_description_283)
- [Promotion to Vulkan 1.1](#_promotion_to_vulkan_1_1)
- [Promotion_to_Vulkan_1.1](#_promotion_to_vulkan_1_1)
- [Promotion to Vulkan 1.4](#_promotion_to_vulkan_1_4)
- [Promotion_to_Vulkan_1.4](#_promotion_to_vulkan_1_4)
- [New Structures](#_new_structures_251)
- [New Enum Constants](#_new_enum_constants_283)
- [New_Enum_Constants](#_new_enum_constants_283)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_35)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_35)
- [Version History](#_version_history_284)
- [VK_KHR_8bit_storage](#VK_KHR_8bit_storage)
- [Other Extension Metadata](#_other_extension_metadata_284)
- [Other_Extension_Metadata](#_other_extension_metadata_284)
- [Description](#_description_284)
- [Promotion to Vulkan 1.2](#_promotion_to_vulkan_1_2)
- [Promotion_to_Vulkan_1.2](#_promotion_to_vulkan_1_2)
- [Promotion to Vulkan 1.4](#_promotion_to_vulkan_1_4_2)
- [Promotion_to_Vulkan_1.4](#_promotion_to_vulkan_1_4_2)
- [New Structures](#_new_structures_252)
- [New Enum Constants](#_new_enum_constants_284)
- [New_Enum_Constants](#_new_enum_constants_284)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_36)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_36)
- [Version History](#_version_history_285)
- [VK_KHR_bind_memory2](#VK_KHR_bind_memory2)
- [Other Extension Metadata](#_other_extension_metadata_285)
- [Other_Extension_Metadata](#_other_extension_metadata_285)
- [Description](#_description_285)
- [Promotion to Vulkan 1.1](#_promotion_to_vulkan_1_1_2)
- [Promotion_to_Vulkan_1.1](#_promotion_to_vulkan_1_1_2)
- [New Commands](#_new_commands_119)
- [New Structures](#_new_structures_253)
- [New Enum Constants](#_new_enum_constants_285)
- [New_Enum_Constants](#_new_enum_constants_285)
- [Version History](#_version_history_286)
- [VK_KHR_buffer_device_address](#VK_KHR_buffer_device_address)
- [Other Extension Metadata](#_other_extension_metadata_286)
- [Other_Extension_Metadata](#_other_extension_metadata_286)
- [Description](#_description_286)
- [Promotion to Vulkan 1.2](#_promotion_to_vulkan_1_2_2)
- [Promotion_to_Vulkan_1.2](#_promotion_to_vulkan_1_2_2)
- [Promotion to Vulkan 1.3](#_promotion_to_vulkan_1_3)
- [Promotion_to_Vulkan_1.3](#_promotion_to_vulkan_1_3)
- [New Commands](#_new_commands_120)
- [New Structures](#_new_structures_254)
- [New Enum Constants](#_new_enum_constants_286)
- [New_Enum_Constants](#_new_enum_constants_286)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_37)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_37)
- [Version History](#_version_history_287)
- [VK_KHR_copy_commands2](#VK_KHR_copy_commands2)
- [Other Extension Metadata](#_other_extension_metadata_287)
- [Other_Extension_Metadata](#_other_extension_metadata_287)
- [Description](#_description_287)
- [New Commands](#_new_commands_121)
- [New Structures](#_new_structures_255)
- [New Enum Constants](#_new_enum_constants_287)
- [New_Enum_Constants](#_new_enum_constants_287)
- [Promotion to Vulkan 1.3](#_promotion_to_vulkan_1_3_2)
- [Promotion_to_Vulkan_1.3](#_promotion_to_vulkan_1_3_2)
- [Version History](#_version_history_288)
- [VK_KHR_create_renderpass2](#VK_KHR_create_renderpass2)
- [Other Extension Metadata](#_other_extension_metadata_288)
- [Other_Extension_Metadata](#_other_extension_metadata_288)
- [Description](#_description_288)
- [Promotion to Vulkan 1.2](#_promotion_to_vulkan_1_2_3)
- [Promotion_to_Vulkan_1.2](#_promotion_to_vulkan_1_2_3)
- [New Commands](#_new_commands_122)
- [New Structures](#_new_structures_256)
- [New Enum Constants](#_new_enum_constants_288)
- [New_Enum_Constants](#_new_enum_constants_288)
- [Version History](#_version_history_289)
- [VK_KHR_dedicated_allocation](#VK_KHR_dedicated_allocation)
- [Other Extension Metadata](#_other_extension_metadata_289)
- [Other_Extension_Metadata](#_other_extension_metadata_289)
- [Description](#_description_289)
- [Promotion to Vulkan 1.1](#_promotion_to_vulkan_1_1_3)
- [Promotion_to_Vulkan_1.1](#_promotion_to_vulkan_1_1_3)
- [New Structures](#_new_structures_257)
- [New Enum Constants](#_new_enum_constants_289)
- [New_Enum_Constants](#_new_enum_constants_289)
- [Examples](#_examples_33)
- [Version History](#_version_history_290)
- [VK_KHR_depth_stencil_resolve](#VK_KHR_depth_stencil_resolve)
- [Other Extension Metadata](#_other_extension_metadata_290)
- [Other_Extension_Metadata](#_other_extension_metadata_290)
- [Description](#_description_290)
- [Promotion to Vulkan 1.2](#_promotion_to_vulkan_1_2_4)
- [Promotion_to_Vulkan_1.2](#_promotion_to_vulkan_1_2_4)
- [New Structures](#_new_structures_258)
- [New Enums](#_new_enums_79)
- [New Bitmasks](#_new_bitmasks_61)
- [New Enum Constants](#_new_enum_constants_290)
- [New_Enum_Constants](#_new_enum_constants_290)
- [Version History](#_version_history_291)
- [VK_KHR_descriptor_update_template](#VK_KHR_descriptor_update_template)
- [Other Extension Metadata](#_other_extension_metadata_291)
- [Other_Extension_Metadata](#_other_extension_metadata_291)
- [Description](#_description_291)
- [Promotion to Vulkan 1.1](#_promotion_to_vulkan_1_1_4)
- [Promotion_to_Vulkan_1.1](#_promotion_to_vulkan_1_1_4)
- [New Object Types](#_new_object_types_20)
- [New_Object_Types](#_new_object_types_20)
- [New Commands](#_new_commands_123)
- [New Structures](#_new_structures_259)
- [New Enums](#_new_enums_80)
- [New Bitmasks](#_new_bitmasks_62)
- [New Enum Constants](#_new_enum_constants_291)
- [New_Enum_Constants](#_new_enum_constants_291)
- [Version History](#_version_history_292)
- [VK_KHR_device_group](#VK_KHR_device_group)
- [Other Extension Metadata](#_other_extension_metadata_292)
- [Other_Extension_Metadata](#_other_extension_metadata_292)
- [Description](#_description_292)
- [Promotion to Vulkan 1.1](#_promotion_to_vulkan_1_1_5)
- [Promotion_to_Vulkan_1.1](#_promotion_to_vulkan_1_1_5)
- [New Commands](#_new_commands_124)
- [New Structures](#_new_structures_260)
- [New Enums](#_new_enums_81)
- [New Bitmasks](#_new_bitmasks_63)
- [New Enum Constants](#_new_enum_constants_292)
- [New_Enum_Constants](#_new_enum_constants_292)
- [New Built-in Variables](#_new_built_in_variables_7)
- [New_Built-in_Variables](#_new_built_in_variables_7)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_38)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_38)
- [Version History](#_version_history_293)
- [VK_KHR_device_group_creation](#VK_KHR_device_group_creation)
- [Other Extension Metadata](#_other_extension_metadata_293)
- [Other_Extension_Metadata](#_other_extension_metadata_293)
- [Description](#_description_293)
- [Promotion to Vulkan 1.1](#_promotion_to_vulkan_1_1_6)
- [Promotion_to_Vulkan_1.1](#_promotion_to_vulkan_1_1_6)
- [New Commands](#_new_commands_125)
- [New Structures](#_new_structures_261)
- [New Enum Constants](#_new_enum_constants_293)
- [New_Enum_Constants](#_new_enum_constants_293)
- [Examples](#_examples_34)
- [Version History](#_version_history_294)
- [VK_KHR_draw_indirect_count](#VK_KHR_draw_indirect_count)
- [Other Extension Metadata](#_other_extension_metadata_294)
- [Other_Extension_Metadata](#_other_extension_metadata_294)
- [Description](#_description_294)
- [Promotion to Vulkan 1.2](#_promotion_to_vulkan_1_2_5)
- [Promotion_to_Vulkan_1.2](#_promotion_to_vulkan_1_2_5)
- [New Commands](#_new_commands_126)
- [New Enum Constants](#_new_enum_constants_294)
- [New_Enum_Constants](#_new_enum_constants_294)
- [Version History](#_version_history_295)
- [VK_KHR_driver_properties](#VK_KHR_driver_properties)
- [Other Extension Metadata](#_other_extension_metadata_295)
- [Other_Extension_Metadata](#_other_extension_metadata_295)
- [Description](#_description_295)
- [Promotion to Vulkan 1.2](#_promotion_to_vulkan_1_2_6)
- [Promotion_to_Vulkan_1.2](#_promotion_to_vulkan_1_2_6)
- [New Structures](#_new_structures_262)
- [New Enums](#_new_enums_82)
- [New Enum Constants](#_new_enum_constants_295)
- [New_Enum_Constants](#_new_enum_constants_295)
- [Version History](#_version_history_296)
- [VK_KHR_dynamic_rendering](#VK_KHR_dynamic_rendering)
- [Other Extension Metadata](#_other_extension_metadata_296)
- [Other_Extension_Metadata](#_other_extension_metadata_296)
- [Description](#_description_296)
- [New Commands](#_new_commands_127)
- [New Structures](#_new_structures_263)
- [New Enums](#_new_enums_83)
- [New Bitmasks](#_new_bitmasks_64)
- [New Enum Constants](#_new_enum_constants_296)
- [New_Enum_Constants](#_new_enum_constants_296)
- [Promotion to Vulkan 1.3](#_promotion_to_vulkan_1_3_3)
- [Promotion_to_Vulkan_1.3](#_promotion_to_vulkan_1_3_3)
- [Version History](#_version_history_297)
- [VK_KHR_dynamic_rendering_local_read](#VK_KHR_dynamic_rendering_local_read)
- [Other Extension Metadata](#_other_extension_metadata_297)
- [Other_Extension_Metadata](#_other_extension_metadata_297)
- [Description](#_description_297)
- [New Commands](#_new_commands_128)
- [New Structures](#_new_structures_264)
- [New Enum Constants](#_new_enum_constants_297)
- [New_Enum_Constants](#_new_enum_constants_297)
- [Promotion to Vulkan 1.4](#_promotion_to_vulkan_1_4_3)
- [Promotion_to_Vulkan_1.4](#_promotion_to_vulkan_1_4_3)
- [Version History](#_version_history_298)
- [VK_KHR_external_fence](#VK_KHR_external_fence)
- [Other Extension Metadata](#_other_extension_metadata_298)
- [Other_Extension_Metadata](#_other_extension_metadata_298)
- [Description](#_description_298)
- [Promotion to Vulkan 1.1](#_promotion_to_vulkan_1_1_7)
- [Promotion_to_Vulkan_1.1](#_promotion_to_vulkan_1_1_7)
- [New Structures](#_new_structures_265)
- [New Enums](#_new_enums_84)
- [New Bitmasks](#_new_bitmasks_65)
- [New Enum Constants](#_new_enum_constants_298)
- [New_Enum_Constants](#_new_enum_constants_298)
- [Issues](#_issues_127)
- [Version History](#_version_history_299)
- [VK_KHR_external_fence_capabilities](#VK_KHR_external_fence_capabilities)
- [Other Extension Metadata](#_other_extension_metadata_299)
- [Other_Extension_Metadata](#_other_extension_metadata_299)
- [Description](#_description_299)
- [Promotion to Vulkan 1.1](#_promotion_to_vulkan_1_1_8)
- [Promotion_to_Vulkan_1.1](#_promotion_to_vulkan_1_1_8)
- [New Commands](#_new_commands_129)
- [New Structures](#_new_structures_266)
- [New Enums](#_new_enums_85)
- [New Bitmasks](#_new_bitmasks_66)
- [New Enum Constants](#_new_enum_constants_299)
- [New_Enum_Constants](#_new_enum_constants_299)
- [Version History](#_version_history_300)
- [VK_KHR_external_memory](#VK_KHR_external_memory)
- [Other Extension Metadata](#_other_extension_metadata_300)
- [Other_Extension_Metadata](#_other_extension_metadata_300)
- [Description](#_description_300)
- [Promotion to Vulkan 1.1](#_promotion_to_vulkan_1_1_9)
- [Promotion_to_Vulkan_1.1](#_promotion_to_vulkan_1_1_9)
- [New Structures](#_new_structures_267)
- [New Enum Constants](#_new_enum_constants_300)
- [New_Enum_Constants](#_new_enum_constants_300)
- [Issues](#_issues_128)
- [Version History](#_version_history_301)
- [VK_KHR_external_memory_capabilities](#VK_KHR_external_memory_capabilities)
- [Other Extension Metadata](#_other_extension_metadata_301)
- [Other_Extension_Metadata](#_other_extension_metadata_301)
- [Description](#_description_301)
- [Promotion to Vulkan 1.1](#_promotion_to_vulkan_1_1_10)
- [Promotion_to_Vulkan_1.1](#_promotion_to_vulkan_1_1_10)
- [New Commands](#_new_commands_130)
- [New Structures](#_new_structures_268)
- [New Enums](#_new_enums_86)
- [New Bitmasks](#_new_bitmasks_67)
- [New Enum Constants](#_new_enum_constants_301)
- [New_Enum_Constants](#_new_enum_constants_301)
- [Issues](#_issues_129)
- [Version History](#_version_history_302)
- [VK_KHR_external_semaphore](#VK_KHR_external_semaphore)
- [Other Extension Metadata](#_other_extension_metadata_302)
- [Other_Extension_Metadata](#_other_extension_metadata_302)
- [Description](#_description_302)
- [Promotion to Vulkan 1.1](#_promotion_to_vulkan_1_1_11)
- [Promotion_to_Vulkan_1.1](#_promotion_to_vulkan_1_1_11)
- [New Structures](#_new_structures_269)
- [New Enums](#_new_enums_87)
- [New Bitmasks](#_new_bitmasks_68)
- [New Enum Constants](#_new_enum_constants_302)
- [New_Enum_Constants](#_new_enum_constants_302)
- [Issues](#_issues_130)
- [Version History](#_version_history_303)
- [VK_KHR_external_semaphore_capabilities](#VK_KHR_external_semaphore_capabilities)
- [Other Extension Metadata](#_other_extension_metadata_303)
- [Other_Extension_Metadata](#_other_extension_metadata_303)
- [Description](#_description_303)
- [Promotion to Vulkan 1.1](#_promotion_to_vulkan_1_1_12)
- [Promotion_to_Vulkan_1.1](#_promotion_to_vulkan_1_1_12)
- [New Commands](#_new_commands_131)
- [New Structures](#_new_structures_270)
- [New Enums](#_new_enums_88)
- [New Bitmasks](#_new_bitmasks_69)
- [New Enum Constants](#_new_enum_constants_303)
- [New_Enum_Constants](#_new_enum_constants_303)
- [Version History](#_version_history_304)
- [VK_KHR_format_feature_flags2](#VK_KHR_format_feature_flags2)
- [Other Extension Metadata](#_other_extension_metadata_304)
- [Other_Extension_Metadata](#_other_extension_metadata_304)
- [Description](#_description_304)
- [New Structures](#_new_structures_271)
- [New Enums](#_new_enums_89)
- [New Bitmasks](#_new_bitmasks_70)
- [New Enum Constants](#_new_enum_constants_304)
- [New_Enum_Constants](#_new_enum_constants_304)
- [Promotion to Vulkan 1.3](#_promotion_to_vulkan_1_3_4)
- [Promotion_to_Vulkan_1.3](#_promotion_to_vulkan_1_3_4)
- [Version History](#_version_history_305)
- [VK_KHR_get_memory_requirements2](#VK_KHR_get_memory_requirements2)
- [Other Extension Metadata](#_other_extension_metadata_305)
- [Other_Extension_Metadata](#_other_extension_metadata_305)
- [Description](#_description_305)
- [Promotion to Vulkan 1.1](#_promotion_to_vulkan_1_1_13)
- [Promotion_to_Vulkan_1.1](#_promotion_to_vulkan_1_1_13)
- [New Commands](#_new_commands_132)
- [New Structures](#_new_structures_272)
- [New Enum Constants](#_new_enum_constants_305)
- [New_Enum_Constants](#_new_enum_constants_305)
- [Version History](#_version_history_306)
- [VK_KHR_get_physical_device_properties2](#VK_KHR_get_physical_device_properties2)
- [Other Extension Metadata](#_other_extension_metadata_306)
- [Other_Extension_Metadata](#_other_extension_metadata_306)
- [Description](#_description_306)
- [Promotion to Vulkan 1.1](#_promotion_to_vulkan_1_1_14)
- [Promotion_to_Vulkan_1.1](#_promotion_to_vulkan_1_1_14)
- [New Commands](#_new_commands_133)
- [New Structures](#_new_structures_273)
- [New Enum Constants](#_new_enum_constants_306)
- [New_Enum_Constants](#_new_enum_constants_306)
- [Examples](#_examples_35)
- [Version History](#_version_history_307)
- [VK_KHR_global_priority](#VK_KHR_global_priority)
- [Other Extension Metadata](#_other_extension_metadata_307)
- [Other_Extension_Metadata](#_other_extension_metadata_307)
- [Description](#_description_307)
- [New Structures](#_new_structures_274)
- [New Enums](#_new_enums_90)
- [New Enum Constants](#_new_enum_constants_307)
- [New_Enum_Constants](#_new_enum_constants_307)
- [Promotion to Vulkan 1.4](#_promotion_to_vulkan_1_4_4)
- [Promotion_to_Vulkan_1.4](#_promotion_to_vulkan_1_4_4)
- [Issues](#_issues_131)
- [Version History](#_version_history_308)
- [VK_KHR_image_format_list](#VK_KHR_image_format_list)
- [Other Extension Metadata](#_other_extension_metadata_308)
- [Other_Extension_Metadata](#_other_extension_metadata_308)
- [Description](#_description_308)
- [Promotion to Vulkan 1.2](#_promotion_to_vulkan_1_2_7)
- [Promotion_to_Vulkan_1.2](#_promotion_to_vulkan_1_2_7)
- [New Structures](#_new_structures_275)
- [New Enum Constants](#_new_enum_constants_308)
- [New_Enum_Constants](#_new_enum_constants_308)
- [Version History](#_version_history_309)
- [VK_KHR_imageless_framebuffer](#VK_KHR_imageless_framebuffer)
- [Other Extension Metadata](#_other_extension_metadata_309)
- [Other_Extension_Metadata](#_other_extension_metadata_309)
- [Description](#_description_309)
- [Promotion to Vulkan 1.2](#_promotion_to_vulkan_1_2_8)
- [Promotion_to_Vulkan_1.2](#_promotion_to_vulkan_1_2_8)
- [New Structures](#_new_structures_276)
- [New Enum Constants](#_new_enum_constants_309)
- [New_Enum_Constants](#_new_enum_constants_309)
- [Version History](#_version_history_310)
- [VK_KHR_index_type_uint8](#VK_KHR_index_type_uint8)
- [Other Extension Metadata](#_other_extension_metadata_310)
- [Other_Extension_Metadata](#_other_extension_metadata_310)
- [Description](#_description_310)
- [New Structures](#_new_structures_277)
- [New Enum Constants](#_new_enum_constants_310)
- [New_Enum_Constants](#_new_enum_constants_310)
- [Promotion to Vulkan 1.4](#_promotion_to_vulkan_1_4_5)
- [Promotion_to_Vulkan_1.4](#_promotion_to_vulkan_1_4_5)
- [Version History](#_version_history_311)
- [VK_KHR_line_rasterization](#VK_KHR_line_rasterization)
- [Other Extension Metadata](#_other_extension_metadata_311)
- [Other_Extension_Metadata](#_other_extension_metadata_311)
- [Description](#_description_311)
- [New Commands](#_new_commands_134)
- [New Structures](#_new_structures_278)
- [New Enums](#_new_enums_91)
- [New Enum Constants](#_new_enum_constants_311)
- [New_Enum_Constants](#_new_enum_constants_311)
- [Promotion to Vulkan 1.4](#_promotion_to_vulkan_1_4_6)
- [Promotion_to_Vulkan_1.4](#_promotion_to_vulkan_1_4_6)
- [Issues](#_issues_132)
- [Version History](#_version_history_312)
- [VK_KHR_load_store_op_none](#VK_KHR_load_store_op_none)
- [Other Extension Metadata](#_other_extension_metadata_312)
- [Other_Extension_Metadata](#_other_extension_metadata_312)
- [Description](#_description_312)
- [New Enum Constants](#_new_enum_constants_312)
- [New_Enum_Constants](#_new_enum_constants_312)
- [Promotion to Vulkan 1.4](#_promotion_to_vulkan_1_4_7)
- [Promotion_to_Vulkan_1.4](#_promotion_to_vulkan_1_4_7)
- [Version History](#_version_history_313)
- [VK_KHR_maintenance1](#VK_KHR_maintenance1)
- [Other Extension Metadata](#_other_extension_metadata_313)
- [Other_Extension_Metadata](#_other_extension_metadata_313)
- [Description](#_description_313)
- [Promotion to Vulkan 1.1](#_promotion_to_vulkan_1_1_15)
- [Promotion_to_Vulkan_1.1](#_promotion_to_vulkan_1_1_15)
- [New Commands](#_new_commands_135)
- [New Bitmasks](#_new_bitmasks_71)
- [New Enum Constants](#_new_enum_constants_313)
- [New_Enum_Constants](#_new_enum_constants_313)
- [Issues](#_issues_133)
- [Version History](#_version_history_314)
- [VK_KHR_maintenance2](#VK_KHR_maintenance2)
- [Other Extension Metadata](#_other_extension_metadata_314)
- [Other_Extension_Metadata](#_other_extension_metadata_314)
- [Description](#_description_314)
- [Input Attachment Specification](#_input_attachment_specification)
- [Input_Attachment_Specification](#_input_attachment_specification)
- [Promotion to Vulkan 1.1](#_promotion_to_vulkan_1_1_16)
- [Promotion_to_Vulkan_1.1](#_promotion_to_vulkan_1_1_16)
- [New Structures](#_new_structures_279)
- [New Enums](#_new_enums_92)
- [New Enum Constants](#_new_enum_constants_314)
- [New_Enum_Constants](#_new_enum_constants_314)
- [Input Attachment Specification Example](#_input_attachment_specification_example)
- [Input_Attachment_Specification_Example](#_input_attachment_specification_example)
- [Issues](#_issues_134)
- [Version History](#_version_history_315)
- [VK_KHR_maintenance3](#VK_KHR_maintenance3)
- [Other Extension Metadata](#_other_extension_metadata_315)
- [Other_Extension_Metadata](#_other_extension_metadata_315)
- [Description](#_description_315)
- [Promotion to Vulkan 1.1](#_promotion_to_vulkan_1_1_17)
- [Promotion_to_Vulkan_1.1](#_promotion_to_vulkan_1_1_17)
- [New Commands](#_new_commands_136)
- [New Structures](#_new_structures_280)
- [New Enum Constants](#_new_enum_constants_315)
- [New_Enum_Constants](#_new_enum_constants_315)
- [Version History](#_version_history_316)
- [VK_KHR_maintenance4](#VK_KHR_maintenance4)
- [Other Extension Metadata](#_other_extension_metadata_316)
- [Other_Extension_Metadata](#_other_extension_metadata_316)
- [Description](#_description_316)
- [New Commands](#_new_commands_137)
- [New Structures](#_new_structures_281)
- [New Enum Constants](#_new_enum_constants_316)
- [New_Enum_Constants](#_new_enum_constants_316)
- [Promotion to Vulkan 1.3](#_promotion_to_vulkan_1_3_5)
- [Promotion_to_Vulkan_1.3](#_promotion_to_vulkan_1_3_5)
- [Issues](#_issues_135)
- [Version History](#_version_history_317)
- [VK_KHR_maintenance5](#VK_KHR_maintenance5)
- [Other Extension Metadata](#_other_extension_metadata_317)
- [Other_Extension_Metadata](#_other_extension_metadata_317)
- [Description](#_description_317)
- [New Commands](#_new_commands_138)
- [New Structures](#_new_structures_282)
- [New Enums](#_new_enums_93)
- [New Bitmasks](#_new_bitmasks_72)
- [New Enum Constants](#_new_enum_constants_317)
- [New_Enum_Constants](#_new_enum_constants_317)
- [Promotion to Vulkan 1.4](#_promotion_to_vulkan_1_4_8)
- [Promotion_to_Vulkan_1.4](#_promotion_to_vulkan_1_4_8)
- [Version History](#_version_history_318)
- [VK_KHR_maintenance6](#VK_KHR_maintenance6)
- [Other Extension Metadata](#_other_extension_metadata_318)
- [Other_Extension_Metadata](#_other_extension_metadata_318)
- [Description](#_description_318)
- [New Commands](#_new_commands_139)
- [New Structures](#_new_structures_283)
- [New Enum Constants](#_new_enum_constants_318)
- [New_Enum_Constants](#_new_enum_constants_318)
- [Promotion to Vulkan 1.4](#_promotion_to_vulkan_1_4_9)
- [Promotion_to_Vulkan_1.4](#_promotion_to_vulkan_1_4_9)
- [Version History](#_version_history_319)
- [VK_KHR_map_memory2](#VK_KHR_map_memory2)
- [Other Extension Metadata](#_other_extension_metadata_319)
- [Other_Extension_Metadata](#_other_extension_metadata_319)
- [Description](#_description_319)
- [New Commands](#_new_commands_140)
- [New Structures](#_new_structures_284)
- [New Enums](#_new_enums_94)
- [New Bitmasks](#_new_bitmasks_73)
- [New Enum Constants](#_new_enum_constants_319)
- [New_Enum_Constants](#_new_enum_constants_319)
- [Promotion to Vulkan 1.4](#_promotion_to_vulkan_1_4_10)
- [Promotion_to_Vulkan_1.4](#_promotion_to_vulkan_1_4_10)
- [Version History](#_version_history_320)
- [VK_KHR_multiview](#VK_KHR_multiview)
- [Other Extension Metadata](#_other_extension_metadata_320)
- [Other_Extension_Metadata](#_other_extension_metadata_320)
- [Description](#_description_320)
- [Promotion to Vulkan 1.1](#_promotion_to_vulkan_1_1_18)
- [Promotion_to_Vulkan_1.1](#_promotion_to_vulkan_1_1_18)
- [New Structures](#_new_structures_285)
- [New Enum Constants](#_new_enum_constants_320)
- [New_Enum_Constants](#_new_enum_constants_320)
- [New Built-In Variables](#_new_built_in_variables_8)
- [New_Built-In_Variables](#_new_built_in_variables_8)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_39)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_39)
- [Version History](#_version_history_321)
- [VK_KHR_push_descriptor](#VK_KHR_push_descriptor)
- [Other Extension Metadata](#_other_extension_metadata_321)
- [Other_Extension_Metadata](#_other_extension_metadata_321)
- [Description](#_description_321)
- [New Commands](#_new_commands_141)
- [New Structures](#_new_structures_286)
- [New Enum Constants](#_new_enum_constants_321)
- [New_Enum_Constants](#_new_enum_constants_321)
- [Promotion to Vulkan 1.4](#_promotion_to_vulkan_1_4_11)
- [Promotion_to_Vulkan_1.4](#_promotion_to_vulkan_1_4_11)
- [Version History](#_version_history_322)
- [VK_KHR_relaxed_block_layout](#VK_KHR_relaxed_block_layout)
- [Other Extension Metadata](#_other_extension_metadata_322)
- [Other_Extension_Metadata](#_other_extension_metadata_322)
- [Description](#_description_322)
- [Promotion to Vulkan 1.1](#_promotion_to_vulkan_1_1_19)
- [Promotion_to_Vulkan_1.1](#_promotion_to_vulkan_1_1_19)
- [New Enum Constants](#_new_enum_constants_322)
- [New_Enum_Constants](#_new_enum_constants_322)
- [Version History](#_version_history_323)
- [VK_KHR_sampler_mirror_clamp_to_edge](#VK_KHR_sampler_mirror_clamp_to_edge)
- [Other Extension Metadata](#_other_extension_metadata_323)
- [Other_Extension_Metadata](#_other_extension_metadata_323)
- [Description](#_description_323)
- [Promotion to Vulkan 1.2](#_promotion_to_vulkan_1_2_9)
- [Promotion_to_Vulkan_1.2](#_promotion_to_vulkan_1_2_9)
- [New Enum Constants](#_new_enum_constants_323)
- [New_Enum_Constants](#_new_enum_constants_323)
- [Example](#_example_4)
- [Issues](#_issues_136)
- [Version History](#_version_history_324)
- [VK_KHR_sampler_ycbcr_conversion](#VK_KHR_sampler_ycbcr_conversion)
- [Other Extension Metadata](#_other_extension_metadata_324)
- [Other_Extension_Metadata](#_other_extension_metadata_324)
- [Description](#_description_324)
- [Promotion to Vulkan 1.1](#_promotion_to_vulkan_1_1_20)
- [Promotion_to_Vulkan_1.1](#_promotion_to_vulkan_1_1_20)
- [Promotion to Vulkan 1.4](#_promotion_to_vulkan_1_4_12)
- [Promotion_to_Vulkan_1.4](#_promotion_to_vulkan_1_4_12)
- [New Object Types](#_new_object_types_21)
- [New_Object_Types](#_new_object_types_21)
- [New Commands](#_new_commands_142)
- [New Structures](#_new_structures_287)
- [New Enums](#_new_enums_95)
- [New Enum Constants](#_new_enum_constants_324)
- [New_Enum_Constants](#_new_enum_constants_324)
- [Version History](#_version_history_325)
- [VK_KHR_separate_depth_stencil_layouts](#VK_KHR_separate_depth_stencil_layouts)
- [Other Extension Metadata](#_other_extension_metadata_325)
- [Other_Extension_Metadata](#_other_extension_metadata_325)
- [Description](#_description_325)
- [Promotion to Vulkan 1.2](#_promotion_to_vulkan_1_2_10)
- [Promotion_to_Vulkan_1.2](#_promotion_to_vulkan_1_2_10)
- [New Structures](#_new_structures_288)
- [New Enum Constants](#_new_enum_constants_325)
- [New_Enum_Constants](#_new_enum_constants_325)
- [Version History](#_version_history_326)
- [VK_KHR_shader_atomic_int64](#VK_KHR_shader_atomic_int64)
- [Other Extension Metadata](#_other_extension_metadata_326)
- [Other_Extension_Metadata](#_other_extension_metadata_326)
- [Description](#_description_326)
- [Promotion to Vulkan 1.2](#_promotion_to_vulkan_1_2_11)
- [Promotion_to_Vulkan_1.2](#_promotion_to_vulkan_1_2_11)
- [New Structures](#_new_structures_289)
- [New Enum Constants](#_new_enum_constants_326)
- [New_Enum_Constants](#_new_enum_constants_326)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_40)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_40)
- [Version History](#_version_history_327)
- [VK_KHR_shader_draw_parameters](#VK_KHR_shader_draw_parameters)
- [Other Extension Metadata](#_other_extension_metadata_327)
- [Other_Extension_Metadata](#_other_extension_metadata_327)
- [Description](#_description_327)
- [Promotion to Vulkan 1.1](#_promotion_to_vulkan_1_1_21)
- [Promotion_to_Vulkan_1.1](#_promotion_to_vulkan_1_1_21)
- [New Enum Constants](#_new_enum_constants_327)
- [New_Enum_Constants](#_new_enum_constants_327)
- [New Built-In Variables](#_new_built_in_variables_9)
- [New_Built-In_Variables](#_new_built_in_variables_9)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_41)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_41)
- [Issues](#_issues_137)
- [Version History](#_version_history_328)
- [VK_KHR_shader_expect_assume](#VK_KHR_shader_expect_assume)
- [Other Extension Metadata](#_other_extension_metadata_328)
- [Other_Extension_Metadata](#_other_extension_metadata_328)
- [Description](#_description_328)
- [New Structures](#_new_structures_290)
- [New Enum Constants](#_new_enum_constants_328)
- [New_Enum_Constants](#_new_enum_constants_328)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_42)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_42)
- [Promotion to Vulkan 1.4](#_promotion_to_vulkan_1_4_13)
- [Promotion_to_Vulkan_1.4](#_promotion_to_vulkan_1_4_13)
- [Version History](#_version_history_329)
- [VK_KHR_shader_float16_int8](#VK_KHR_shader_float16_int8)
- [Other Extension Metadata](#_other_extension_metadata_329)
- [Other_Extension_Metadata](#_other_extension_metadata_329)
- [Description](#_description_329)
- [Promotion to Vulkan 1.2](#_promotion_to_vulkan_1_2_12)
- [Promotion_to_Vulkan_1.2](#_promotion_to_vulkan_1_2_12)
- [Promotion to Vulkan 1.4](#_promotion_to_vulkan_1_4_14)
- [Promotion_to_Vulkan_1.4](#_promotion_to_vulkan_1_4_14)
- [New Structures](#_new_structures_291)
- [New Enum Constants](#_new_enum_constants_329)
- [New_Enum_Constants](#_new_enum_constants_329)
- [Version History](#_version_history_330)
- [VK_KHR_shader_float_controls](#VK_KHR_shader_float_controls)
- [Other Extension Metadata](#_other_extension_metadata_330)
- [Other_Extension_Metadata](#_other_extension_metadata_330)
- [Description](#_description_330)
- [Promotion to Vulkan 1.2](#_promotion_to_vulkan_1_2_13)
- [Promotion_to_Vulkan_1.2](#_promotion_to_vulkan_1_2_13)
- [New Structures](#_new_structures_292)
- [New Enums](#_new_enums_96)
- [New Enum Constants](#_new_enum_constants_330)
- [New_Enum_Constants](#_new_enum_constants_330)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_43)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_43)
- [Issues](#_issues_138)
- [Version 4 API Incompatibility](#VK_KHR_shader_controls_v4_incompatibility)
- [Version_4_API_Incompatibility](#VK_KHR_shader_controls_v4_incompatibility)
- [Version History](#_version_history_331)
- [VK_KHR_shader_float_controls2](#VK_KHR_shader_float_controls2)
- [Other Extension Metadata](#_other_extension_metadata_331)
- [Other_Extension_Metadata](#_other_extension_metadata_331)
- [Description](#_description_331)
- [New Structures](#_new_structures_293)
- [New Enum Constants](#_new_enum_constants_331)
- [New_Enum_Constants](#_new_enum_constants_331)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_44)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_44)
- [Promotion to Vulkan 1.4](#_promotion_to_vulkan_1_4_15)
- [Promotion_to_Vulkan_1.4](#_promotion_to_vulkan_1_4_15)
- [Version History](#_version_history_332)
- [VK_KHR_shader_integer_dot_product](#VK_KHR_shader_integer_dot_product)
- [Other Extension Metadata](#_other_extension_metadata_332)
- [Other_Extension_Metadata](#_other_extension_metadata_332)
- [Description](#_description_332)
- [New Structures](#_new_structures_294)
- [New Enum Constants](#_new_enum_constants_332)
- [New_Enum_Constants](#_new_enum_constants_332)
- [Promotion to Vulkan 1.3](#_promotion_to_vulkan_1_3_6)
- [Promotion_to_Vulkan_1.3](#_promotion_to_vulkan_1_3_6)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_45)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_45)
- [Version History](#_version_history_333)
- [VK_KHR_shader_non_semantic_info](#VK_KHR_shader_non_semantic_info)
- [Other Extension Metadata](#_other_extension_metadata_333)
- [Other_Extension_Metadata](#_other_extension_metadata_333)
- [Description](#_description_333)
- [New Enum Constants](#_new_enum_constants_333)
- [New_Enum_Constants](#_new_enum_constants_333)
- [Promotion to Vulkan 1.3](#_promotion_to_vulkan_1_3_7)
- [Promotion_to_Vulkan_1.3](#_promotion_to_vulkan_1_3_7)
- [Version History](#_version_history_334)
- [VK_KHR_shader_subgroup_extended_types](#VK_KHR_shader_subgroup_extended_types)
- [Other Extension Metadata](#_other_extension_metadata_334)
- [Other_Extension_Metadata](#_other_extension_metadata_334)
- [Description](#_description_334)
- [Promotion to Vulkan 1.2](#_promotion_to_vulkan_1_2_14)
- [Promotion_to_Vulkan_1.2](#_promotion_to_vulkan_1_2_14)
- [New Structures](#_new_structures_295)
- [New Enum Constants](#_new_enum_constants_334)
- [New_Enum_Constants](#_new_enum_constants_334)
- [Version History](#_version_history_335)
- [VK_KHR_shader_subgroup_rotate](#VK_KHR_shader_subgroup_rotate)
- [New Structures](#_new_structures_296)
- [New Enum Constants](#_new_enum_constants_335)
- [New_Enum_Constants](#_new_enum_constants_335)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_46)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_46)
- [Promotion to Vulkan 1.4](#_promotion_to_vulkan_1_4_16)
- [Promotion_to_Vulkan_1.4](#_promotion_to_vulkan_1_4_16)
- [Version History](#_version_history_336)
- [VK_KHR_shader_terminate_invocation](#VK_KHR_shader_terminate_invocation)
- [Other Extension Metadata](#_other_extension_metadata_335)
- [Other_Extension_Metadata](#_other_extension_metadata_335)
- [Description](#_description_335)
- [New Structures](#_new_structures_297)
- [New Enum Constants](#_new_enum_constants_336)
- [New_Enum_Constants](#_new_enum_constants_336)
- [Promotion to Vulkan 1.3](#_promotion_to_vulkan_1_3_8)
- [Promotion_to_Vulkan_1.3](#_promotion_to_vulkan_1_3_8)
- [Version History](#_version_history_337)
- [VK_KHR_spirv_1_4](#VK_KHR_spirv_1_4)
- [Other Extension Metadata](#_other_extension_metadata_336)
- [Other_Extension_Metadata](#_other_extension_metadata_336)
- [Description](#_description_336)
- [Promotion to Vulkan 1.2](#_promotion_to_vulkan_1_2_15)
- [Promotion_to_Vulkan_1.2](#_promotion_to_vulkan_1_2_15)
- [New Enum Constants](#_new_enum_constants_337)
- [New_Enum_Constants](#_new_enum_constants_337)
- [Issues](#_issues_139)
- [Version History](#_version_history_338)
- [VK_KHR_storage_buffer_storage_class](#VK_KHR_storage_buffer_storage_class)
- [Other Extension Metadata](#_other_extension_metadata_337)
- [Other_Extension_Metadata](#_other_extension_metadata_337)
- [Description](#_description_337)
- [Promotion to Vulkan 1.1](#_promotion_to_vulkan_1_1_22)
- [Promotion_to_Vulkan_1.1](#_promotion_to_vulkan_1_1_22)
- [New Enum Constants](#_new_enum_constants_338)
- [New_Enum_Constants](#_new_enum_constants_338)
- [Version History](#_version_history_339)
- [VK_KHR_synchronization2](#VK_KHR_synchronization2)
- [Other Extension Metadata](#_other_extension_metadata_338)
- [Other_Extension_Metadata](#_other_extension_metadata_338)
- [Description](#_description_338)
- [New Base Types](#_new_base_types_6)
- [New_Base_Types](#_new_base_types_6)
- [New Commands](#_new_commands_143)
- [New Structures](#_new_structures_298)
- [New Enums](#_new_enums_97)
- [New Bitmasks](#_new_bitmasks_74)
- [New Enum Constants](#_new_enum_constants_339)
- [New_Enum_Constants](#_new_enum_constants_339)
- [Promotion to Vulkan 1.3](#_promotion_to_vulkan_1_3_9)
- [Promotion_to_Vulkan_1.3](#_promotion_to_vulkan_1_3_9)
- [Examples](#_examples_36)
- [Version History](#_version_history_340)
- [VK_KHR_timeline_semaphore](#VK_KHR_timeline_semaphore)
- [Other Extension Metadata](#_other_extension_metadata_339)
- [Other_Extension_Metadata](#_other_extension_metadata_339)
- [Description](#_description_339)
- [Promotion to Vulkan 1.2](#_promotion_to_vulkan_1_2_16)
- [Promotion_to_Vulkan_1.2](#_promotion_to_vulkan_1_2_16)
- [New Commands](#_new_commands_144)
- [New Structures](#_new_structures_299)
- [New Enums](#_new_enums_98)
- [New Bitmasks](#_new_bitmasks_75)
- [New Enum Constants](#_new_enum_constants_340)
- [New_Enum_Constants](#_new_enum_constants_340)
- [Issues](#_issues_140)
- [Version History](#_version_history_341)
- [VK_KHR_uniform_buffer_standard_layout](#VK_KHR_uniform_buffer_standard_layout)
- [Other Extension Metadata](#_other_extension_metadata_340)
- [Other_Extension_Metadata](#_other_extension_metadata_340)
- [Description](#_description_340)
- [Promotion to Vulkan 1.2](#_promotion_to_vulkan_1_2_17)
- [Promotion_to_Vulkan_1.2](#_promotion_to_vulkan_1_2_17)
- [New Structures](#_new_structures_300)
- [New Enum Constants](#_new_enum_constants_341)
- [New_Enum_Constants](#_new_enum_constants_341)
- [Version History](#_version_history_342)
- [VK_KHR_variable_pointers](#VK_KHR_variable_pointers)
- [Other Extension Metadata](#_other_extension_metadata_341)
- [Other_Extension_Metadata](#_other_extension_metadata_341)
- [Description](#_description_341)
- [Promotion to Vulkan 1.1](#_promotion_to_vulkan_1_1_23)
- [Promotion_to_Vulkan_1.1](#_promotion_to_vulkan_1_1_23)
- [Promotion to Vulkan 1.4](#_promotion_to_vulkan_1_4_17)
- [Promotion_to_Vulkan_1.4](#_promotion_to_vulkan_1_4_17)
- [New Structures](#_new_structures_301)
- [New Enum Constants](#_new_enum_constants_342)
- [New_Enum_Constants](#_new_enum_constants_342)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_47)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_47)
- [Issues](#_issues_141)
- [Version History](#_version_history_343)
- [VK_KHR_vertex_attribute_divisor](#VK_KHR_vertex_attribute_divisor)
- [Other Extension Metadata](#_other_extension_metadata_342)
- [Other_Extension_Metadata](#_other_extension_metadata_342)
- [Description](#_description_342)
- [New Structures](#_new_structures_302)
- [New Enum Constants](#_new_enum_constants_343)
- [New_Enum_Constants](#_new_enum_constants_343)
- [Promotion to Vulkan 1.4](#_promotion_to_vulkan_1_4_18)
- [Promotion_to_Vulkan_1.4](#_promotion_to_vulkan_1_4_18)
- [Version History](#_version_history_344)
- [VK_KHR_vulkan_memory_model](#VK_KHR_vulkan_memory_model)
- [Other Extension Metadata](#_other_extension_metadata_343)
- [Other_Extension_Metadata](#_other_extension_metadata_343)
- [Description](#_description_343)
- [Promotion to Vulkan 1.2](#_promotion_to_vulkan_1_2_18)
- [Promotion_to_Vulkan_1.2](#_promotion_to_vulkan_1_2_18)
- [Promotion to Vulkan 1.3](#_promotion_to_vulkan_1_3_10)
- [Promotion_to_Vulkan_1.3](#_promotion_to_vulkan_1_3_10)
- [New Structures](#_new_structures_303)
- [New Enum Constants](#_new_enum_constants_344)
- [New_Enum_Constants](#_new_enum_constants_344)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_48)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_48)
- [Version History](#_version_history_345)
- [VK_KHR_zero_initialize_workgroup_memory](#VK_KHR_zero_initialize_workgroup_memory)
- [Other Extension Metadata](#_other_extension_metadata_344)
- [Other_Extension_Metadata](#_other_extension_metadata_344)
- [Description](#_description_344)
- [New Structures](#_new_structures_304)
- [New Enum Constants](#_new_enum_constants_345)
- [New_Enum_Constants](#_new_enum_constants_345)
- [Promotion to Vulkan 1.3](#_promotion_to_vulkan_1_3_11)
- [Promotion_to_Vulkan_1.3](#_promotion_to_vulkan_1_3_11)
- [Version History](#_version_history_346)
- [VK_EXT_4444_formats](#VK_EXT_4444_formats)
- [Other Extension Metadata](#_other_extension_metadata_345)
- [Other_Extension_Metadata](#_other_extension_metadata_345)
- [Description](#_description_345)
- [New Structures](#_new_structures_305)
- [New Enum Constants](#_new_enum_constants_346)
- [New_Enum_Constants](#_new_enum_constants_346)
- [Promotion to Vulkan 1.3](#_promotion_to_vulkan_1_3_12)
- [Promotion_to_Vulkan_1.3](#_promotion_to_vulkan_1_3_12)
- [Version History](#_version_history_347)
- [VK_EXT_buffer_device_address](#VK_EXT_buffer_device_address)
- [Other Extension Metadata](#_other_extension_metadata_346)
- [Other_Extension_Metadata](#_other_extension_metadata_346)
- [Description](#_description_346)
- [New Commands](#_new_commands_145)
- [New Structures](#_new_structures_306)
- [New Enum Constants](#_new_enum_constants_347)
- [New_Enum_Constants](#_new_enum_constants_347)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_49)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_49)
- [Issues](#_issues_142)
- [Version History](#_version_history_348)
- [VK_EXT_calibrated_timestamps](#VK_EXT_calibrated_timestamps)
- [Other Extension Metadata](#_other_extension_metadata_347)
- [Other_Extension_Metadata](#_other_extension_metadata_347)
- [Description](#_description_347)
- [Promotion to VK_KHR_calibrated_timestamps](#_promotion_to_vk_khr_calibrated_timestamps)
- [Promotion_to_VK_KHR_calibrated_timestamps](#_promotion_to_vk_khr_calibrated_timestamps)
- [New Commands](#_new_commands_146)
- [New Structures](#_new_structures_307)
- [New Enums](#_new_enums_99)
- [New Enum Constants](#_new_enum_constants_348)
- [New_Enum_Constants](#_new_enum_constants_348)
- [Version History](#_version_history_349)
- [VK_EXT_debug_marker](#VK_EXT_debug_marker)
- [Other Extension Metadata](#_other_extension_metadata_348)
- [Other_Extension_Metadata](#_other_extension_metadata_348)
- [Description](#_description_348)
- [New Commands](#_new_commands_147)
- [New Structures](#_new_structures_308)
- [New Enums](#_new_enums_100)
- [New Enum Constants](#_new_enum_constants_349)
- [New_Enum_Constants](#_new_enum_constants_349)
- [Examples](#_examples_37)
- [Issues](#_issues_143)
- [Version History](#_version_history_350)
- [VK_EXT_debug_report](#VK_EXT_debug_report)
- [Other Extension Metadata](#_other_extension_metadata_349)
- [Other_Extension_Metadata](#_other_extension_metadata_349)
- [Description](#_description_349)
- [New Object Types](#_new_object_types_22)
- [New_Object_Types](#_new_object_types_22)
- [New Commands](#_new_commands_148)
- [New Structures](#_new_structures_309)
- [New Function Pointers](#_new_function_pointers_4)
- [New_Function_Pointers](#_new_function_pointers_4)
- [New Enums](#_new_enums_101)
- [New Bitmasks](#_new_bitmasks_76)
- [New Enum Constants](#_new_enum_constants_350)
- [New_Enum_Constants](#_new_enum_constants_350)
- [Examples](#_examples_38)
- [Issues](#_issues_144)
- [Version History](#_version_history_351)
- [VK_EXT_depth_clamp_zero_one](#VK_EXT_depth_clamp_zero_one)
- [Other Extension Metadata](#_other_extension_metadata_350)
- [Other_Extension_Metadata](#_other_extension_metadata_350)
- [Description](#_description_350)
- [Promotion to VK_KHR_depth_clamp_zero_one](#_promotion_to_vk_khr_depth_clamp_zero_one)
- [Promotion_to_VK_KHR_depth_clamp_zero_one](#_promotion_to_vk_khr_depth_clamp_zero_one)
- [New Structures](#_new_structures_310)
- [New Enum Constants](#_new_enum_constants_351)
- [New_Enum_Constants](#_new_enum_constants_351)
- [Version History](#_version_history_352)
- [VK_EXT_descriptor_indexing](#VK_EXT_descriptor_indexing)
- [Other Extension Metadata](#_other_extension_metadata_351)
- [Other_Extension_Metadata](#_other_extension_metadata_351)
- [Description](#_description_351)
- [Promotion to Vulkan 1.2](#_promotion_to_vulkan_1_2_19)
- [Promotion_to_Vulkan_1.2](#_promotion_to_vulkan_1_2_19)
- [Promotion to Vulkan 1.4](#_promotion_to_vulkan_1_4_19)
- [Promotion_to_Vulkan_1.4](#_promotion_to_vulkan_1_4_19)
- [New Structures](#_new_structures_311)
- [New Enums](#_new_enums_102)
- [New Bitmasks](#_new_bitmasks_77)
- [New Enum Constants](#_new_enum_constants_352)
- [New_Enum_Constants](#_new_enum_constants_352)
- [Version History](#_version_history_353)
- [VK_EXT_extended_dynamic_state](#VK_EXT_extended_dynamic_state)
- [Other Extension Metadata](#_other_extension_metadata_352)
- [Other_Extension_Metadata](#_other_extension_metadata_352)
- [Description](#_description_352)
- [New Commands](#_new_commands_149)
- [New Structures](#_new_structures_312)
- [New Enum Constants](#_new_enum_constants_353)
- [New_Enum_Constants](#_new_enum_constants_353)
- [Promotion to Vulkan 1.3](#_promotion_to_vulkan_1_3_13)
- [Promotion_to_Vulkan_1.3](#_promotion_to_vulkan_1_3_13)
- [Issues](#_issues_145)
- [Version History](#_version_history_354)
- [VK_EXT_extended_dynamic_state2](#VK_EXT_extended_dynamic_state2)
- [Other Extension Metadata](#_other_extension_metadata_353)
- [Other_Extension_Metadata](#_other_extension_metadata_353)
- [Description](#_description_353)
- [New Commands](#_new_commands_150)
- [New Structures](#_new_structures_313)
- [New Enum Constants](#_new_enum_constants_354)
- [New_Enum_Constants](#_new_enum_constants_354)
- [Promotion to Vulkan 1.3](#_promotion_to_vulkan_1_3_14)
- [Promotion_to_Vulkan_1.3](#_promotion_to_vulkan_1_3_14)
- [Version History](#_version_history_355)
- [VK_EXT_global_priority](#VK_EXT_global_priority)
- [Other Extension Metadata](#_other_extension_metadata_354)
- [Other_Extension_Metadata](#_other_extension_metadata_354)
- [Description](#_description_354)
- [New Structures](#_new_structures_314)
- [New Enums](#_new_enums_103)
- [New Enum Constants](#_new_enum_constants_355)
- [New_Enum_Constants](#_new_enum_constants_355)
- [Version History](#_version_history_356)
- [VK_EXT_global_priority_query](#VK_EXT_global_priority_query)
- [Other Extension Metadata](#_other_extension_metadata_355)
- [Other_Extension_Metadata](#_other_extension_metadata_355)
- [Description](#_description_355)
- [New Structures](#_new_structures_315)
- [New Enum Constants](#_new_enum_constants_356)
- [New_Enum_Constants](#_new_enum_constants_356)
- [Issues](#_issues_146)
- [Version History](#_version_history_357)
- [VK_EXT_host_image_copy](#VK_EXT_host_image_copy)
- [Other Extension Metadata](#_other_extension_metadata_356)
- [Other_Extension_Metadata](#_other_extension_metadata_356)
- [Description](#_description_356)
- [New Commands](#_new_commands_151)
- [New Structures](#_new_structures_316)
- [New Enums](#_new_enums_104)
- [New Bitmasks](#_new_bitmasks_78)
- [New Enum Constants](#_new_enum_constants_357)
- [New_Enum_Constants](#_new_enum_constants_357)
- [Promotion to Vulkan 1.4](#_promotion_to_vulkan_1_4_20)
- [Promotion_to_Vulkan_1.4](#_promotion_to_vulkan_1_4_20)
- [Issues](#_issues_147)
- [Version History](#_version_history_358)
- [VK_EXT_host_query_reset](#VK_EXT_host_query_reset)
- [Other Extension Metadata](#_other_extension_metadata_357)
- [Other_Extension_Metadata](#_other_extension_metadata_357)
- [Description](#_description_357)
- [Promotion to Vulkan 1.2](#_promotion_to_vulkan_1_2_20)
- [Promotion_to_Vulkan_1.2](#_promotion_to_vulkan_1_2_20)
- [New Commands](#_new_commands_152)
- [New Structures](#_new_structures_317)
- [New Enum Constants](#_new_enum_constants_358)
- [New_Enum_Constants](#_new_enum_constants_358)
- [Version History](#_version_history_359)
- [VK_EXT_image_robustness](#VK_EXT_image_robustness)
- [Other Extension Metadata](#_other_extension_metadata_358)
- [Other_Extension_Metadata](#_other_extension_metadata_358)
- [Description](#_description_358)
- [New Structures](#_new_structures_318)
- [New Enum Constants](#_new_enum_constants_359)
- [New_Enum_Constants](#_new_enum_constants_359)
- [Promotion to Vulkan 1.3](#_promotion_to_vulkan_1_3_15)
- [Promotion_to_Vulkan_1.3](#_promotion_to_vulkan_1_3_15)
- [Issues](#_issues_148)
- [Examples](#_examples_39)
- [Version History](#_version_history_360)
- [VK_EXT_index_type_uint8](#VK_EXT_index_type_uint8)
- [Other Extension Metadata](#_other_extension_metadata_359)
- [Other_Extension_Metadata](#_other_extension_metadata_359)
- [Description](#_description_359)
- [Promotion to VK_KHR_index_type_uint8](#_promotion_to_vk_khr_index_type_uint8)
- [Promotion_to_VK_KHR_index_type_uint8](#_promotion_to_vk_khr_index_type_uint8)
- [New Structures](#_new_structures_319)
- [New Enum Constants](#_new_enum_constants_360)
- [New_Enum_Constants](#_new_enum_constants_360)
- [Version History](#_version_history_361)
- [VK_EXT_inline_uniform_block](#VK_EXT_inline_uniform_block)
- [Other Extension Metadata](#_other_extension_metadata_360)
- [Other_Extension_Metadata](#_other_extension_metadata_360)
- [Description](#_description_360)
- [New Structures](#_new_structures_320)
- [New Enum Constants](#_new_enum_constants_361)
- [New_Enum_Constants](#_new_enum_constants_361)
- [Promotion to Vulkan 1.3](#_promotion_to_vulkan_1_3_16)
- [Promotion_to_Vulkan_1.3](#_promotion_to_vulkan_1_3_16)
- [Issues](#_issues_149)
- [Version History](#_version_history_362)
- [VK_EXT_line_rasterization](#VK_EXT_line_rasterization)
- [Other Extension Metadata](#_other_extension_metadata_361)
- [Other_Extension_Metadata](#_other_extension_metadata_361)
- [Description](#_description_361)
- [Promotion to VK_KHR_line_rasterization](#_promotion_to_vk_khr_line_rasterization)
- [Promotion_to_VK_KHR_line_rasterization](#_promotion_to_vk_khr_line_rasterization)
- [New Commands](#_new_commands_153)
- [New Structures](#_new_structures_321)
- [New Enums](#_new_enums_105)
- [New Enum Constants](#_new_enum_constants_362)
- [New_Enum_Constants](#_new_enum_constants_362)
- [Issues](#_issues_150)
- [Version History](#_version_history_363)
- [VK_EXT_load_store_op_none](#VK_EXT_load_store_op_none)
- [Other Extension Metadata](#_other_extension_metadata_362)
- [Other_Extension_Metadata](#_other_extension_metadata_362)
- [Description](#_description_362)
- [Promotion to VK_KHR_load_store_op_none](#_promotion_to_vk_khr_load_store_op_none)
- [Promotion_to_VK_KHR_load_store_op_none](#_promotion_to_vk_khr_load_store_op_none)
- [New Enum Constants](#_new_enum_constants_363)
- [New_Enum_Constants](#_new_enum_constants_363)
- [Version History](#_version_history_364)
- [VK_EXT_pipeline_creation_cache_control](#VK_EXT_pipeline_creation_cache_control)
- [Other Extension Metadata](#_other_extension_metadata_363)
- [Other_Extension_Metadata](#_other_extension_metadata_363)
- [Description](#_description_363)
- [Background](#_background)
- [New Structures](#_new_structures_322)
- [New Enums](#_new_enums_106)
- [New Enum Constants](#_new_enum_constants_364)
- [New_Enum_Constants](#_new_enum_constants_364)
- [Promotion to Vulkan 1.3](#_promotion_to_vulkan_1_3_17)
- [Promotion_to_Vulkan_1.3](#_promotion_to_vulkan_1_3_17)
- [Version History](#_version_history_365)
- [VK_EXT_pipeline_creation_feedback](#VK_EXT_pipeline_creation_feedback)
- [Other Extension Metadata](#_other_extension_metadata_364)
- [Other_Extension_Metadata](#_other_extension_metadata_364)
- [Description](#_description_364)
- [New Structures](#_new_structures_323)
- [New Enums](#_new_enums_107)
- [New Bitmasks](#_new_bitmasks_79)
- [New Enum Constants](#_new_enum_constants_365)
- [New_Enum_Constants](#_new_enum_constants_365)
- [Promotion to Vulkan 1.3](#_promotion_to_vulkan_1_3_18)
- [Promotion_to_Vulkan_1.3](#_promotion_to_vulkan_1_3_18)
- [Version History](#_version_history_366)
- [VK_EXT_pipeline_protected_access](#VK_EXT_pipeline_protected_access)
- [Other Extension Metadata](#_other_extension_metadata_365)
- [Other_Extension_Metadata](#_other_extension_metadata_365)
- [Description](#_description_365)
- [New Structures](#_new_structures_324)
- [New Enum Constants](#_new_enum_constants_366)
- [New_Enum_Constants](#_new_enum_constants_366)
- [Promotion to Vulkan 1.4](#_promotion_to_vulkan_1_4_21)
- [Promotion_to_Vulkan_1.4](#_promotion_to_vulkan_1_4_21)
- [Version History](#_version_history_367)
- [VK_EXT_pipeline_robustness](#VK_EXT_pipeline_robustness)
- [Other Extension Metadata](#_other_extension_metadata_366)
- [Other_Extension_Metadata](#_other_extension_metadata_366)
- [Description](#_description_366)
- [New Structures](#_new_structures_325)
- [New Enums](#_new_enums_108)
- [New Enum Constants](#_new_enum_constants_367)
- [New_Enum_Constants](#_new_enum_constants_367)
- [Promotion to Vulkan 1.4](#_promotion_to_vulkan_1_4_22)
- [Promotion_to_Vulkan_1.4](#_promotion_to_vulkan_1_4_22)
- [Version History](#_version_history_368)
- [VK_EXT_private_data](#VK_EXT_private_data)
- [Other Extension Metadata](#_other_extension_metadata_367)
- [Other_Extension_Metadata](#_other_extension_metadata_367)
- [Description](#_description_367)
- [New Object Types](#_new_object_types_23)
- [New_Object_Types](#_new_object_types_23)
- [New Commands](#_new_commands_154)
- [New Structures](#_new_structures_326)
- [New Bitmasks](#_new_bitmasks_80)
- [New Enum Constants](#_new_enum_constants_368)
- [New_Enum_Constants](#_new_enum_constants_368)
- [Promotion to Vulkan 1.3](#_promotion_to_vulkan_1_3_19)
- [Promotion_to_Vulkan_1.3](#_promotion_to_vulkan_1_3_19)
- [Examples](#_examples_40)
- [Issues](#_issues_151)
- [Version History](#_version_history_369)
- [VK_EXT_robustness2](#VK_EXT_robustness2)
- [Other Extension Metadata](#_other_extension_metadata_368)
- [Other_Extension_Metadata](#_other_extension_metadata_368)
- [Description](#_description_368)
- [Promotion to VK_KHR_robustness2](#_promotion_to_vk_khr_robustness2)
- [Promotion_to_VK_KHR_robustness2](#_promotion_to_vk_khr_robustness2)
- [New Structures](#_new_structures_327)
- [New Enum Constants](#_new_enum_constants_369)
- [New_Enum_Constants](#_new_enum_constants_369)
- [Issues](#_issues_152)
- [Examples](#_examples_41)
- [Version History](#_version_history_370)
- [VK_EXT_sampler_filter_minmax](#VK_EXT_sampler_filter_minmax)
- [Other Extension Metadata](#_other_extension_metadata_369)
- [Other_Extension_Metadata](#_other_extension_metadata_369)
- [Description](#_description_369)
- [Promotion to Vulkan 1.2](#_promotion_to_vulkan_1_2_21)
- [Promotion_to_Vulkan_1.2](#_promotion_to_vulkan_1_2_21)
- [New Structures](#_new_structures_328)
- [New Enums](#_new_enums_109)
- [New Enum Constants](#_new_enum_constants_370)
- [New_Enum_Constants](#_new_enum_constants_370)
- [Version History](#_version_history_371)
- [VK_EXT_scalar_block_layout](#VK_EXT_scalar_block_layout)
- [Other Extension Metadata](#_other_extension_metadata_370)
- [Other_Extension_Metadata](#_other_extension_metadata_370)
- [Description](#_description_370)
- [Promotion to Vulkan 1.2](#_promotion_to_vulkan_1_2_22)
- [Promotion_to_Vulkan_1.2](#_promotion_to_vulkan_1_2_22)
- [Promotion to Vulkan 1.4](#_promotion_to_vulkan_1_4_23)
- [Promotion_to_Vulkan_1.4](#_promotion_to_vulkan_1_4_23)
- [New Structures](#_new_structures_329)
- [New Enum Constants](#_new_enum_constants_371)
- [New_Enum_Constants](#_new_enum_constants_371)
- [Version History](#_version_history_372)
- [VK_EXT_separate_stencil_usage](#VK_EXT_separate_stencil_usage)
- [Other Extension Metadata](#_other_extension_metadata_371)
- [Other_Extension_Metadata](#_other_extension_metadata_371)
- [Description](#_description_371)
- [Promotion to Vulkan 1.2](#_promotion_to_vulkan_1_2_23)
- [Promotion_to_Vulkan_1.2](#_promotion_to_vulkan_1_2_23)
- [New Structures](#_new_structures_330)
- [New Enum Constants](#_new_enum_constants_372)
- [New_Enum_Constants](#_new_enum_constants_372)
- [Version History](#_version_history_373)
- [VK_EXT_shader_demote_to_helper_invocation](#VK_EXT_shader_demote_to_helper_invocation)
- [Other Extension Metadata](#_other_extension_metadata_372)
- [Other_Extension_Metadata](#_other_extension_metadata_372)
- [Description](#_description_372)
- [New Structures](#_new_structures_331)
- [New Enum Constants](#_new_enum_constants_373)
- [New_Enum_Constants](#_new_enum_constants_373)
- [New SPIR-V Capability](#_new_spir_v_capability_7)
- [New_SPIR-V_Capability](#_new_spir_v_capability_7)
- [Promotion to Vulkan 1.3](#_promotion_to_vulkan_1_3_20)
- [Promotion_to_Vulkan_1.3](#_promotion_to_vulkan_1_3_20)
- [Version History](#_version_history_374)
- [VK_EXT_shader_subgroup_ballot](#VK_EXT_shader_subgroup_ballot)
- [Other Extension Metadata](#_other_extension_metadata_373)
- [Other_Extension_Metadata](#_other_extension_metadata_373)
- [Description](#_description_373)
- [Deprecated by Vulkan 1.2](#_deprecated_by_vulkan_1_2)
- [Deprecated_by_Vulkan_1.2](#_deprecated_by_vulkan_1_2)
- [New Enum Constants](#_new_enum_constants_374)
- [New_Enum_Constants](#_new_enum_constants_374)
- [New Built-In Variables](#_new_built_in_variables_10)
- [New_Built-In_Variables](#_new_built_in_variables_10)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_50)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_50)
- [Version History](#_version_history_375)
- [VK_EXT_shader_subgroup_vote](#VK_EXT_shader_subgroup_vote)
- [Other Extension Metadata](#_other_extension_metadata_374)
- [Other_Extension_Metadata](#_other_extension_metadata_374)
- [Description](#_description_374)
- [Deprecated by Vulkan 1.1](#_deprecated_by_vulkan_1_1)
- [Deprecated_by_Vulkan_1.1](#_deprecated_by_vulkan_1_1)
- [New Enum Constants](#_new_enum_constants_375)
- [New_Enum_Constants](#_new_enum_constants_375)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_51)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_51)
- [Version History](#_version_history_376)
- [VK_EXT_shader_viewport_index_layer](#VK_EXT_shader_viewport_index_layer)
- [Other Extension Metadata](#_other_extension_metadata_375)
- [Other_Extension_Metadata](#_other_extension_metadata_375)
- [Description](#_description_375)
- [Promotion to Vulkan 1.2](#_promotion_to_vulkan_1_2_24)
- [Promotion_to_Vulkan_1.2](#_promotion_to_vulkan_1_2_24)
- [New Enum Constants](#_new_enum_constants_376)
- [New_Enum_Constants](#_new_enum_constants_376)
- [New or Modified Built-In Variables](#_new_or_modified_built_in_variables_12)
- [New_or_Modified_Built-In_Variables](#_new_or_modified_built_in_variables_12)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_52)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_52)
- [Version History](#_version_history_377)
- [VK_EXT_subgroup_size_control](#VK_EXT_subgroup_size_control)
- [Other Extension Metadata](#_other_extension_metadata_376)
- [Other_Extension_Metadata](#_other_extension_metadata_376)
- [Description](#_description_376)
- [New Structures](#_new_structures_332)
- [New Enum Constants](#_new_enum_constants_377)
- [New_Enum_Constants](#_new_enum_constants_377)
- [Promotion to Vulkan 1.3](#_promotion_to_vulkan_1_3_21)
- [Promotion_to_Vulkan_1.3](#_promotion_to_vulkan_1_3_21)
- [Version History](#_version_history_378)
- [VK_EXT_texel_buffer_alignment](#VK_EXT_texel_buffer_alignment)
- [Other Extension Metadata](#_other_extension_metadata_377)
- [Other_Extension_Metadata](#_other_extension_metadata_377)
- [Description](#_description_377)
- [New Structures](#_new_structures_333)
- [New Enum Constants](#_new_enum_constants_378)
- [New_Enum_Constants](#_new_enum_constants_378)
- [Promotion to Vulkan 1.3](#_promotion_to_vulkan_1_3_22)
- [Promotion_to_Vulkan_1.3](#_promotion_to_vulkan_1_3_22)
- [Version History](#_version_history_379)
- [VK_EXT_texture_compression_astc_hdr](#VK_EXT_texture_compression_astc_hdr)
- [Other Extension Metadata](#_other_extension_metadata_378)
- [Other_Extension_Metadata](#_other_extension_metadata_378)
- [Description](#_description_378)
- [New Structures](#_new_structures_334)
- [New Enum Constants](#_new_enum_constants_379)
- [New_Enum_Constants](#_new_enum_constants_379)
- [Promotion to Vulkan 1.3](#_promotion_to_vulkan_1_3_23)
- [Promotion_to_Vulkan_1.3](#_promotion_to_vulkan_1_3_23)
- [Issues](#_issues_153)
- [Version History](#_version_history_380)
- [VK_EXT_tooling_info](#VK_EXT_tooling_info)
- [Other Extension Metadata](#_other_extension_metadata_379)
- [Other_Extension_Metadata](#_other_extension_metadata_379)
- [Description](#_description_379)
- [New Commands](#_new_commands_155)
- [New Structures](#_new_structures_335)
- [New Enums](#_new_enums_110)
- [New Bitmasks](#_new_bitmasks_81)
- [New Enum Constants](#_new_enum_constants_380)
- [New_Enum_Constants](#_new_enum_constants_380)
- [Promotion to Vulkan 1.3](#_promotion_to_vulkan_1_3_24)
- [Promotion_to_Vulkan_1.3](#_promotion_to_vulkan_1_3_24)
- [Examples](#_examples_42)
- [Issues](#_issues_154)
- [Version History](#_version_history_381)
- [VK_EXT_validation_features](#VK_EXT_validation_features)
- [Other Extension Metadata](#_other_extension_metadata_380)
- [Other_Extension_Metadata](#_other_extension_metadata_380)
- [Description](#_description_380)
- [Deprecation by VK_EXT_layer_settings](#_deprecation_by_vk_ext_layer_settings)
- [Deprecation_by_VK_EXT_layer_settings](#_deprecation_by_vk_ext_layer_settings)
- [New Structures](#_new_structures_336)
- [New Enums](#_new_enums_111)
- [New Enum Constants](#_new_enum_constants_381)
- [New_Enum_Constants](#_new_enum_constants_381)
- [Version History](#_version_history_382)
- [VK_EXT_validation_flags](#VK_EXT_validation_flags)
- [Other Extension Metadata](#_other_extension_metadata_381)
- [Other_Extension_Metadata](#_other_extension_metadata_381)
- [Description](#_description_381)
- [Deprecation by VK_EXT_layer_settings](#_deprecation_by_vk_ext_layer_settings_2)
- [Deprecation_by_VK_EXT_layer_settings](#_deprecation_by_vk_ext_layer_settings_2)
- [New Structures](#_new_structures_337)
- [New Enums](#_new_enums_112)
- [New Enum Constants](#_new_enum_constants_382)
- [New_Enum_Constants](#_new_enum_constants_382)
- [Version History](#_version_history_383)
- [VK_EXT_vertex_attribute_divisor](#VK_EXT_vertex_attribute_divisor)
- [Other Extension Metadata](#_other_extension_metadata_382)
- [Other_Extension_Metadata](#_other_extension_metadata_382)
- [Description](#_description_382)
- [New Structures](#_new_structures_338)
- [New Enum Constants](#_new_enum_constants_383)
- [New_Enum_Constants](#_new_enum_constants_383)
- [Issues](#_issues_155)
- [Examples](#_examples_43)
- [Version History](#_version_history_384)
- [VK_EXT_ycbcr_2plane_444_formats](#VK_EXT_ycbcr_2plane_444_formats)
- [Other Extension Metadata](#_other_extension_metadata_383)
- [Other_Extension_Metadata](#_other_extension_metadata_383)
- [Description](#_description_383)
- [New Structures](#_new_structures_339)
- [New Enum Constants](#_new_enum_constants_384)
- [New_Enum_Constants](#_new_enum_constants_384)
- [Promotion to Vulkan 1.3](#_promotion_to_vulkan_1_3_25)
- [Promotion_to_Vulkan_1.3](#_promotion_to_vulkan_1_3_25)
- [Version History](#_version_history_385)
- [VK_AMD_draw_indirect_count](#VK_AMD_draw_indirect_count)
- [Other Extension Metadata](#_other_extension_metadata_384)
- [Other_Extension_Metadata](#_other_extension_metadata_384)
- [Description](#_description_384)
- [Promotion to VK_KHR_draw_indirect_count](#_promotion_to_vk_khr_draw_indirect_count)
- [Promotion_to_VK_KHR_draw_indirect_count](#_promotion_to_vk_khr_draw_indirect_count)
- [New Commands](#_new_commands_156)
- [New Enum Constants](#_new_enum_constants_385)
- [New_Enum_Constants](#_new_enum_constants_385)
- [Version History](#_version_history_386)
- [VK_AMD_gpu_shader_half_float](#VK_AMD_gpu_shader_half_float)
- [Other Extension Metadata](#_other_extension_metadata_385)
- [Other_Extension_Metadata](#_other_extension_metadata_385)
- [Description](#_description_385)
- [Deprecation by VK_KHR_shader_float16_int8](#_deprecation_by_vk_khr_shader_float16_int8)
- [Deprecation_by_VK_KHR_shader_float16_int8](#_deprecation_by_vk_khr_shader_float16_int8)
- [New Enum Constants](#_new_enum_constants_386)
- [New_Enum_Constants](#_new_enum_constants_386)
- [Version History](#_version_history_387)
- [VK_AMD_gpu_shader_int16](#VK_AMD_gpu_shader_int16)
- [Other Extension Metadata](#_other_extension_metadata_386)
- [Other_Extension_Metadata](#_other_extension_metadata_386)
- [Description](#_description_386)
- [Deprecation by VK_KHR_shader_float16_int8](#_deprecation_by_vk_khr_shader_float16_int8_2)
- [Deprecation_by_VK_KHR_shader_float16_int8](#_deprecation_by_vk_khr_shader_float16_int8_2)
- [New Enum Constants](#_new_enum_constants_387)
- [New_Enum_Constants](#_new_enum_constants_387)
- [Version History](#_version_history_388)
- [VK_AMD_negative_viewport_height](#VK_AMD_negative_viewport_height)
- [Other Extension Metadata](#_other_extension_metadata_387)
- [Other_Extension_Metadata](#_other_extension_metadata_387)
- [Description](#_description_387)
- [Obsoletion by VK_KHR_maintenance1 and Vulkan 1.1](#_obsoletion_by_vk_khr_maintenance1_and_vulkan_1_1)
- [Obsoletion_by_VK_KHR_maintenance1_and_Vulkan_1.1](#_obsoletion_by_vk_khr_maintenance1_and_vulkan_1_1)
- [New Enum Constants](#_new_enum_constants_388)
- [New_Enum_Constants](#_new_enum_constants_388)
- [Version History](#_version_history_389)
- [VK_ARM_rasterization_order_attachment_access](#VK_ARM_rasterization_order_attachment_access)
- [Other Extension Metadata](#_other_extension_metadata_388)
- [Other_Extension_Metadata](#_other_extension_metadata_388)
- [Description](#_description_388)
- [New Structures](#_new_structures_340)
- [New Enum Constants](#_new_enum_constants_389)
- [New_Enum_Constants](#_new_enum_constants_389)
- [Issues](#_issues_156)
- [Examples](#_examples_44)
- [Version History](#_version_history_390)
- [VK_IMG_format_pvrtc](#VK_IMG_format_pvrtc)
- [Other Extension Metadata](#_other_extension_metadata_389)
- [Other_Extension_Metadata](#_other_extension_metadata_389)
- [Description](#_description_389)
- [Deprecation](#_deprecation)
- [New Enum Constants](#_new_enum_constants_390)
- [New_Enum_Constants](#_new_enum_constants_390)
- [Version History](#_version_history_391)
- [VK_MVK_ios_surface](#VK_MVK_ios_surface)
- [Other Extension Metadata](#_other_extension_metadata_390)
- [Other_Extension_Metadata](#_other_extension_metadata_390)
- [Description](#_description_390)
- [Deprecation by VK_EXT_metal_surface](#_deprecation_by_vk_ext_metal_surface)
- [Deprecation_by_VK_EXT_metal_surface](#_deprecation_by_vk_ext_metal_surface)
- [New Commands](#_new_commands_157)
- [New Structures](#_new_structures_341)
- [New Bitmasks](#_new_bitmasks_82)
- [New Enum Constants](#_new_enum_constants_391)
- [New_Enum_Constants](#_new_enum_constants_391)
- [Version History](#_version_history_392)
- [VK_MVK_macos_surface](#VK_MVK_macos_surface)
- [Other Extension Metadata](#_other_extension_metadata_391)
- [Other_Extension_Metadata](#_other_extension_metadata_391)
- [Description](#_description_391)
- [Deprecation by VK_EXT_metal_surface](#_deprecation_by_vk_ext_metal_surface_2)
- [Deprecation_by_VK_EXT_metal_surface](#_deprecation_by_vk_ext_metal_surface_2)
- [New Commands](#_new_commands_158)
- [New Structures](#_new_structures_342)
- [New Bitmasks](#_new_bitmasks_83)
- [New Enum Constants](#_new_enum_constants_392)
- [New_Enum_Constants](#_new_enum_constants_392)
- [Version History](#_version_history_393)
- [VK_NV_compute_shader_derivatives](#VK_NV_compute_shader_derivatives)
- [Other Extension Metadata](#_other_extension_metadata_392)
- [Other_Extension_Metadata](#_other_extension_metadata_392)
- [Description](#_description_392)
- [New Structures](#_new_structures_343)
- [New Enum Constants](#_new_enum_constants_393)
- [New_Enum_Constants](#_new_enum_constants_393)
- [New SPIR-V Capability](#_new_spir_v_capability_8)
- [New_SPIR-V_Capability](#_new_spir_v_capability_8)
- [Issues](#_issues_157)
- [Examples](#_examples_45)
- [Version History](#_version_history_394)
- [VK_NV_dedicated_allocation](#VK_NV_dedicated_allocation)
- [Other Extension Metadata](#_other_extension_metadata_393)
- [Other_Extension_Metadata](#_other_extension_metadata_393)
- [Description](#_description_393)
- [New Structures](#_new_structures_344)
- [New Enum Constants](#_new_enum_constants_394)
- [New_Enum_Constants](#_new_enum_constants_394)
- [Examples](#_examples_46)
- [Version History](#_version_history_395)
- [VK_NV_displacement_micromap](#VK_NV_displacement_micromap)
- [Other Extension Metadata](#_other_extension_metadata_394)
- [Other_Extension_Metadata](#_other_extension_metadata_394)
- [Description](#_description_394)
- [New Structures](#_new_structures_345)
- [New Enums](#_new_enums_113)
- [New Enum Constants](#_new_enum_constants_395)
- [New_Enum_Constants](#_new_enum_constants_395)
- [Issues](#_issues_158)
- [Version History](#_version_history_396)
- [VK_NV_external_memory](#VK_NV_external_memory)
- [Other Extension Metadata](#_other_extension_metadata_395)
- [Other_Extension_Metadata](#_other_extension_metadata_395)
- [Description](#_description_395)
- [New Structures](#_new_structures_346)
- [New Enum Constants](#_new_enum_constants_396)
- [New_Enum_Constants](#_new_enum_constants_396)
- [Issues](#_issues_159)
- [Examples](#_examples_47)
- [Version History](#_version_history_397)
- [VK_NV_external_memory_capabilities](#VK_NV_external_memory_capabilities)
- [Other Extension Metadata](#_other_extension_metadata_396)
- [Other_Extension_Metadata](#_other_extension_metadata_396)
- [Description](#_description_396)
- [New Commands](#_new_commands_159)
- [New Structures](#_new_structures_347)
- [New Enums](#_new_enums_114)
- [New Bitmasks](#_new_bitmasks_84)
- [New Enum Constants](#_new_enum_constants_397)
- [New_Enum_Constants](#_new_enum_constants_397)
- [Issues](#_issues_160)
- [Version History](#_version_history_398)
- [VK_NV_external_memory_win32](#VK_NV_external_memory_win32)
- [Other Extension Metadata](#_other_extension_metadata_397)
- [Other_Extension_Metadata](#_other_extension_metadata_397)
- [Description](#_description_397)
- [New Commands](#_new_commands_160)
- [New Structures](#_new_structures_348)
- [New Enum Constants](#_new_enum_constants_398)
- [New_Enum_Constants](#_new_enum_constants_398)
- [Issues](#_issues_161)
- [Examples](#_examples_48)
- [Version History](#_version_history_399)
- [VK_NV_fragment_shader_barycentric](#VK_NV_fragment_shader_barycentric)
- [Other Extension Metadata](#_other_extension_metadata_398)
- [Other_Extension_Metadata](#_other_extension_metadata_398)
- [Description](#_description_398)
- [Promotion to VK_KHR_fragment_shader_barycentric](#_promotion_to_vk_khr_fragment_shader_barycentric)
- [Promotion_to_VK_KHR_fragment_shader_barycentric](#_promotion_to_vk_khr_fragment_shader_barycentric)
- [New Structures](#_new_structures_349)
- [New Enum Constants](#_new_enum_constants_399)
- [New_Enum_Constants](#_new_enum_constants_399)
- [New Built-In Variables](#_new_built_in_variables_11)
- [New_Built-In_Variables](#_new_built_in_variables_11)
- [New SPIR-V Decorations](#_new_spir_v_decorations_2)
- [New_SPIR-V_Decorations](#_new_spir_v_decorations_2)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_53)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_53)
- [Issues](#_issues_162)
- [Version History](#_version_history_400)
- [VK_NV_glsl_shader](#VK_NV_glsl_shader)
- [Other Extension Metadata](#_other_extension_metadata_399)
- [Other_Extension_Metadata](#_other_extension_metadata_399)
- [Description](#_description_399)
- [Deprecation](#_deprecation_2)
- [New Enum Constants](#_new_enum_constants_400)
- [New_Enum_Constants](#_new_enum_constants_400)
- [Examples](#_examples_49)
- [Version History](#_version_history_401)
- [VK_NV_ray_tracing](#VK_NV_ray_tracing)
- [Other Extension Metadata](#_other_extension_metadata_400)
- [Other_Extension_Metadata](#_other_extension_metadata_400)
- [Description](#_description_400)
- [New Object Types](#_new_object_types_24)
- [New_Object_Types](#_new_object_types_24)
- [New Commands](#_new_commands_161)
- [New Structures](#_new_structures_350)
- [New Enums](#_new_enums_115)
- [New Bitmasks](#_new_bitmasks_85)
- [New Enum Constants](#_new_enum_constants_401)
- [New_Enum_Constants](#_new_enum_constants_401)
- [New or Modified Built-In Variables](#_new_or_modified_built_in_variables_13)
- [New_or_Modified_Built-In_Variables](#_new_or_modified_built_in_variables_13)
- [New SPIR-V Capabilities](#_new_spir_v_capabilities_54)
- [New_SPIR-V_Capabilities](#_new_spir_v_capabilities_54)
- [Issues](#_issues_163)
- [Sample Code](#_sample_code_6)
- [Version History](#_version_history_402)
- [VK_NV_win32_keyed_mutex](#VK_NV_win32_keyed_mutex)
- [Other Extension Metadata](#_other_extension_metadata_401)
- [Other_Extension_Metadata](#_other_extension_metadata_401)
- [Description](#_description_401)
- [New Structures](#_new_structures_351)
- [New Enum Constants](#_new_enum_constants_402)
- [New_Enum_Constants](#_new_enum_constants_402)
- [Examples](#_examples_50)
- [Version History](#_version_history_403)
- [VK_QCOM_fragment_density_map_offset](#VK_QCOM_fragment_density_map_offset)
- [Other Extension Metadata](#_other_extension_metadata_402)
- [Other_Extension_Metadata](#_other_extension_metadata_402)
- [Description](#_description_402)
- [New Structures](#_new_structures_352)
- [New Enum Constants](#_new_enum_constants_403)
- [New_Enum_Constants](#_new_enum_constants_403)
- [Version History](#_version_history_404)
- [VK_VALVE_mutable_descriptor_type](#VK_VALVE_mutable_descriptor_type)
- [Other Extension Metadata](#_other_extension_metadata_403)
- [Other_Extension_Metadata](#_other_extension_metadata_403)
- [Description](#_description_403)
- [New Structures](#_new_structures_353)
- [New Enum Constants](#_new_enum_constants_404)
- [New_Enum_Constants](#_new_enum_constants_404)
- [Version History](#_version_history_405)

## Content

Extensions to the Vulkan API can be defined by authors, groups of authors, and the Khronos Vulkan Working Group. The online Registry of extensions is available at URL https://registry.khronos.org/vulkan/ Authors creating extensions and layers must follow the mandatory procedures described in the Vulkan Documentation and Extensions document when creating extensions and layers. The version of the Vulkan specification published on the Vulkan Documentation site and in the Registry includes all registered and published extensions. It is also possible to build the specification with an arbitrary set of extensions included, and the specification you are viewing may not include all extensions. In the remainder of this appendix, extensions are grouped as Khronos KHR, multivendor EXT, and then alphabetically by author ID. Within each group, extensions are listed in alphabetical order by their name. Extensions which have dependencies on specific core versions or on other extensions will list such dependencies. For core versions, the specified version must be supported at runtime. All extensions implicitly require support for Vulkan 1.0. For a device extension, use of any device-level functionality defined by that extension requires that any extensions that extension depends on be enabled. For any extension, use of any instance-level functionality defined by that extension requires only that any extensions that extension depends on be supported at runtime. Some extensions define APIs which are only supported when other extensions or core versions are supported at runtime. Such interactions are noted as API Interactions. Name String VK_KHR_acceleration_structure Extension Type Device extension Registered Extension Number 151 Revision 13 Ratification Status Ratified Extension and Version Dependencies Vulkan Version 1.1 and VK_EXT_descriptor_indexing and VK_KHR_buffer_device_address or Vulkan Version 1.2 and VK_KHR_deferred_host_operations API Interactions Interacts with VK_VERSION_1_2 Interacts with VK_VERSION_1_3 Interacts with VK_EXT_debug_report Interacts with VK_KHR_format_feature_flags2 Contact Daniel Koch dgkoch Last Modified Date 2021-09-30 Contributors Samuel Bourasseau, Adobe Matthus Chajdas, AMD Greg Grebe, AMD Nicolai Hhnle, AMD Tobias Hector, AMD Dave Oldcorn, AMD Skyler Saleh, AMD Mathieu Robart, Arm Marius Bjorge, Arm Tom Olson, Arm Sebastian Tafuri, EA Henrik Rydgard, Embark Juan Caada, Epic Games Patrick Kelly, Epic Games Yuriy ODonnell, Epic Games Michael Doggett, Facebook/Oculus Ricardo Garcia, Igalia Andrew Garrard, Imagination Don Scorgie, Imagination Dae Kim, Imagination Joshua Barczak, Intel Slawek Grajewski, Intel Jeff Bolz, NVIDIA Pascal Gautron, NVIDIA Daniel Koch, NVIDIA Christoph Kubisch, NVIDIA Ashwin Lele, NVIDIA Robert Stepinski, NVIDIA Martin Stich, NVIDIA Nuno Subtil, NVIDIA Eric Werness, NVIDIA Jon Leech, Khronos Jeroen van Schijndel, OTOY Juul Joosten, OTOY Alex Bourd, Qualcomm Roman Larionov, Qualcomm David McAllister, Qualcomm Lewis Gordon, Samsung Ralph Potter, Samsung Jasper Bekkers, Traverse Research Jesse Barker, Unity Baldur Karlsson, Valve In order to be efficient, rendering techniques such as ray tracing need a quick way to identify which primitives may be intersected by a ray traversing the geometries. Acceleration structures are the most common way to represent the geometry spatially sorted, in order to quickly identify such potential intersections. This extension adds new functionalities: Acceleration structure objects and build commands Structures to describe geometry inputs to acceleration structure builds Acceleration structure copy commands VkAccelerationStructureKHR vkBuildAccelerationStructuresKHR vkCmdBuildAccelerationStructuresIndirectKHR vkCmdBuildAccelerationStructuresKHR vkCmdCopyAccelerationStructureKHR vkCmdCopyAccelerationStructureToMemoryKHR vkCmdCopyMemoryToAccelerationStructureKHR vkCmdWriteAccelerationStructuresPropertiesKHR vkCopyAccelerationStructureKHR vkCopyAccelerationStructureToMemoryKHR vkCopyMemoryToAccelerationStructureKHR vkCreateAccelerationStructureKHR vkDestroyAccelerationStructureKHR vkGetAccelerationStructureBuildSizesKHR vkGetAccelerationStructureDeviceAddressKHR vkGetDeviceAccelerationStructureCompatibilityKHR vkWriteAccelerationStructuresPropertiesKHR VkAabbPositionsKHR VkAccelerationStructureBuildGeometryInfoKHR VkAccelerationStructureBuildRangeInfoKHR VkAccelerationStructureBuildSizesInfoKHR VkAccelerationStructureCreateInfoKHR VkAccelerationStructureDeviceAddressInfoKHR VkAccelerationStructureGeometryAabbsDataKHR VkAccelerationStructureGeometryInstancesDataKHR VkAccelerationStructureGeometryKHR VkAccelerationStructureGeometryTrianglesDataKHR VkAccelerationStructureInstanceKHR VkAccelerationStructureVersionInfoKHR VkCopyAccelerationStructureInfoKHR VkCopyAccelerationStructureToMemoryInfoKHR VkCopyMemoryToAccelerationStructureInfoKHR VkTransformMatrixKHR Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceAccelerationStructureFeaturesKHR Extending VkPhysicalDeviceProperties2: VkPhysicalDeviceAccelerationStructurePropertiesKHR Extending VkWriteDescriptorSet: VkWriteDescriptorSetAccelerationStructureKHR VkAccelerationStructureGeometryDataKHR VkDeviceOrHostAddressConstKHR VkDeviceOrHostAddressKHR VkAccelerationStructureBuildTypeKHR VkAccelerationStructureCompatibilityKHR VkAccelerationStructureCreateFlagBitsKHR VkAccelerationStructureTypeKHR VkBuildAccelerationStructureFlagBitsKHR VkBuildAccelerationStructureModeKHR VkCopyAccelerationStructureModeKHR VkGeometryFlagBitsKHR VkGeometryInstanceFlagBitsKHR VkGeometryTypeKHR VkAccelerationStructureCreateFlagsKHR VkBuildAccelerationStructureFlagsKHR VkGeometryFlagsKHR VkGeometryInstanceFlagsKHR VK_KHR_ACCELERATION_STRUCTURE_EXTENSION_NAME VK_KHR_ACCELERATION_STRUCTURE_SPEC_VERSION Extending VkAccessFlagBits: VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR Extending VkBufferUsageFlagBits: VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR Extending VkCopyAccelerationStructureModeKHR: VK_COPY_ACCELERATION_STRUCTURE_MODE_DESERIALIZE_KHR VK_COPY_ACCELERATION_STRUCTURE_MODE_SERIALIZE_KHR Extending VkDescriptorType: VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR Extending VkFormatFeatureFlagBits: VK_FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR Extending VkIndexType: VK_INDEX_TYPE_NONE_KHR Extending VkObjectType: VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR Extending VkPipelineStageFlagBits: VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR Extending VkQueryType: VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR Extending VkStructureType: VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR If VK_EXT_debug_report is supported: Extending VkDebugReportObjectTypeEXT: VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR_EXT If VK_KHR_format_feature_flags2 or Vulkan Version 1.3 is supported: Extending VkFormatFeatureFlagBits2: VK_FORMAT_FEATURE_2_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR (1) How does this extension differ from VK_NV_ray_tracing? DISCUSSION: The following is a summary of the main functional differences between VK_KHR_acceleration_structure and VK_NV_ray_tracing: added acceleration structure serialization / deserialization (VK_COPY_ACCELERATION_STRUCTURE_MODE_SERIALIZE_KHR, VK_COPY_ACCELERATION_STRUCTURE_MODE_DESERIALIZE_KHR, vkCmdCopyAccelerationStructureToMemoryKHR, vkCmdCopyMemoryToAccelerationStructureKHR) document inactive primitives and instances added VkPhysicalDeviceAccelerationStructureFeaturesKHR structure added indirect and batched acceleration structure builds (vkCmdBuildAccelerationStructuresIndirectKHR) added host acceleration structure commands reworked geometry structures so they could be better shared between device, host, and indirect builds explicitly made VkAccelerationStructureKHR use device addresses added acceleration structure compatibility check function (vkGetDeviceAccelerationStructureCompatibilityKHR) add parameter for requesting memory requirements for host and/or device build added format feature for acceleration structure build vertex formats (VK_FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR) (2) Can you give a more detailed comparison of differences and similarities between VK_NV_ray_tracing and VK_KHR_acceleration_structure? DISCUSSION: The following is a more detailed comparison of which commands, structures, and enums are aliased, changed, or removed. Aliased functionality  enums, structures, and commands that are considered equivalent: VkGeometryTypeNV  VkGeometryTypeKHR VkAccelerationStructureTypeNV  VkAccelerationStructureTypeKHR VkCopyAccelerationStructureModeNV  VkCopyAccelerationStructureModeKHR VkGeometryFlagsNV  VkGeometryFlagsKHR VkGeometryFlagBitsNV  VkGeometryFlagBitsKHR VkGeometryInstanceFlagsNV  VkGeometryInstanceFlagsKHR VkGeometryInstanceFlagBitsNV  VkGeometryInstanceFlagBitsKHR VkBuildAccelerationStructureFlagsNV  VkBuildAccelerationStructureFlagsKHR VkBuildAccelerationStructureFlagBitsNV  VkBuildAccelerationStructureFlagBitsKHR VkTransformMatrixNV  VkTransformMatrixKHR (added to VK_NV_ray_tracing for descriptive purposes) VkAabbPositionsNV  VkAabbPositionsKHR (added to VK_NV_ray_tracing for descriptive purposes) VkAccelerationStructureInstanceNV  VkAccelerationStructureInstanceKHR (added to VK_NV_ray_tracing for descriptive purposes) Changed enums, structures, and commands: renamed VK_GEOMETRY_INSTANCE_TRIANGLE_CULL_DISABLE_BIT_NV  VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR in VkGeometryInstanceFlagBitsKHR VkGeometryTrianglesNV  VkAccelerationStructureGeometryTrianglesDataKHR (device or host address instead of buffer+offset) VkGeometryAABBNV  VkAccelerationStructureGeometryAabbsDataKHR (device or host address instead of buffer+offset) VkGeometryDataNV  VkAccelerationStructureGeometryDataKHR (union of triangle/aabbs/instances) VkGeometryNV  VkAccelerationStructureGeometryKHR (changed type of geometry) VkAccelerationStructureCreateInfoNV  VkAccelerationStructureCreateInfoKHR (reshuffle geometry layout/information) VkPhysicalDeviceRayTracingPropertiesNV  VkPhysicalDeviceAccelerationStructurePropertiesKHR (for acceleration structure properties, renamed maxTriangleCount to maxPrimitiveCount, added per stage and update after bind limits) and VkPhysicalDeviceRayTracingPipelinePropertiesKHR (for ray tracing pipeline properties) VkAccelerationStructureMemoryRequirementsInfoNV (deleted - replaced by allocating on top of VkBuffer) VkWriteDescriptorSetAccelerationStructureNV  VkWriteDescriptorSetAccelerationStructureKHR (different acceleration structure type) vkCreateAccelerationStructureNV  vkCreateAccelerationStructureKHR (device address, different geometry layout/information) vkGetAccelerationStructureMemoryRequirementsNV (deleted - replaced by allocating on top of VkBuffer) vkCmdBuildAccelerationStructureNV  vkCmdBuildAccelerationStructuresKHR (params moved to structs, layout differences) vkCmdCopyAccelerationStructureNV  vkCmdCopyAccelerationStructureKHR (params to struct, extendable) vkGetAccelerationStructureHandleNV  vkGetAccelerationStructureDeviceAddressKHR (device address instead of handle) VkAccelerationStructureMemoryRequirementsTypeNV  size queries for scratch space moved to vkGetAccelerationStructureBuildSizesKHR vkDestroyAccelerationStructureNV  vkDestroyAccelerationStructureKHR (different acceleration structure types) vkCmdWriteAccelerationStructuresPropertiesNV  vkCmdWriteAccelerationStructuresPropertiesKHR (different acceleration structure types) Added enums, structures and commands: VK_GEOMETRY_TYPE_INSTANCES_KHR to VkGeometryTypeKHR enum VK_COPY_ACCELERATION_STRUCTURE_MODE_SERIALIZE_KHR, VK_COPY_ACCELERATION_STRUCTURE_MODE_DESERIALIZE_KHR to VkCopyAccelerationStructureModeKHR enum VkPhysicalDeviceAccelerationStructureFeaturesKHR structure VkAccelerationStructureBuildTypeKHR enum VkBuildAccelerationStructureModeKHR enum VkDeviceOrHostAddressKHR and VkDeviceOrHostAddressConstKHR unions VkAccelerationStructureBuildRangeInfoKHR struct VkAccelerationStructureGeometryInstancesDataKHR struct VkAccelerationStructureDeviceAddressInfoKHR struct VkAccelerationStructureVersionInfoKHR struct VkStridedDeviceAddressRegionKHR struct VkCopyAccelerationStructureToMemoryInfoKHR struct VkCopyMemoryToAccelerationStructureInfoKHR struct VkCopyAccelerationStructureInfoKHR struct vkBuildAccelerationStructuresKHR command (host build) vkCopyAccelerationStructureKHR command (host copy) vkCopyAccelerationStructureToMemoryKHR (host serialize) vkCopyMemoryToAccelerationStructureKHR (host deserialize) vkWriteAccelerationStructuresPropertiesKHR (host properties) vkCmdCopyAccelerationStructureToMemoryKHR (device serialize) vkCmdCopyMemoryToAccelerationStructureKHR (device deserialize) vkGetDeviceAccelerationStructureCompatibilityKHR (serialization) (3) What are the changes between the public provisional (VK_KHR_ray_tracing v8) release and the internal provisional (VK_KHR_ray_tracing v9) release? added geometryFlags to VkAccelerationStructureCreateGeometryTypeInfoKHR (later reworked to obsolete this) added minAccelerationStructureScratchOffsetAlignment property to VkPhysicalDeviceRayTracingPropertiesKHR fix naming and return enum from vkGetDeviceAccelerationStructureCompatibilityKHR renamed VkAccelerationStructureVersionKHR to VkAccelerationStructureVersionInfoKHR renamed VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_KHR to VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR removed VK_ERROR_INCOMPATIBLE_VERSION_KHR added VkAccelerationStructureCompatibilityKHR enum remove return value from vkGetDeviceAccelerationStructureCompatibilityKHR and added return enum parameter Require Vulkan 1.1 added creation time capture and replay flags added VkAccelerationStructureCreateFlagBitsKHR and VkAccelerationStructureCreateFlagsKHR renamed the flags member of VkAccelerationStructureCreateInfoKHR to buildFlags (later removed) and added the createFlags member change vkCmdBuildAccelerationStructuresIndirectKHR to use buffer device address for indirect parameter make VK_KHR_deferred_host_operations an interaction instead of a required extension (later went back on this) renamed VkAccelerationStructureBuildOffsetInfoKHR to VkAccelerationStructureBuildRangeInfoKHR renamed the ppOffsetInfos parameter of vkCmdBuildAccelerationStructuresKHR to ppBuildRangeInfos Re-unify geometry description between build and create remove VkAccelerationStructureCreateGeometryTypeInfoKHR and VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_GEOMETRY_TYPE_INFO_KHR added VkAccelerationStructureCreateSizeInfoKHR structure (later removed) change type of the pGeometryInfos member of VkAccelerationStructureCreateInfoKHR from VkAccelerationStructureCreateGeometryTypeInfoKHR to VkAccelerationStructureGeometryKHR (later removed) added pCreateSizeInfos member to VkAccelerationStructureCreateInfoKHR (later removed) Fix ppGeometries ambiguity, add pGeometries remove geometryArrayOfPointers member of VkAccelerationStructureBuildGeometryInfoKHR disambiguate two meanings of ppGeometries by explicitly adding pGeometries to the VkAccelerationStructureBuildGeometryInfoKHR structure and require one of them be NULL added nullDescriptor support for acceleration structures changed the update member of VkAccelerationStructureBuildGeometryInfoKHR from a bool to the mode VkBuildAccelerationStructureModeKHR enum which allows future extensibility in update types Clarify deferred host ops for pipeline creation VkDeferredOperationKHR is now a top-level parameter for vkBuildAccelerationStructuresKHR, vkCreateRayTracingPipelinesKHR, vkCopyAccelerationStructureToMemoryKHR, vkCopyAccelerationStructureKHR, and vkCopyMemoryToAccelerationStructureKHR removed VkDeferredOperationInfoKHR structure change deferred host creation/return parameter behavior such that the implementation can modify such parameters until the deferred host operation completes VK_KHR_deferred_host_operations is required again Change acceleration structure build to always be sized de-alias VkAccelerationStructureMemoryRequirementsTypeNV and VkAccelerationStructureMemoryRequirementsTypeKHR, and remove VkAccelerationStructureMemoryRequirementsTypeKHR add vkGetAccelerationStructureBuildSizesKHR command and VkAccelerationStructureBuildSizesInfoKHR structure and VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR enum to query sizes for acceleration structures and scratch storage move size queries for scratch space to vkGetAccelerationStructureBuildSizesKHR remove compactedSize, buildFlags, maxGeometryCount, pGeometryInfos, pCreateSizeInfos members of VkAccelerationStructureCreateInfoKHR and add the size member add maxVertex member to VkAccelerationStructureGeometryTrianglesDataKHR structure remove VkAccelerationStructureCreateSizeInfoKHR structure (4) What are the changes between the internal provisional (VK_KHR_ray_tracing v9) release and the final (VK_KHR_acceleration_structure v11) release? refactor VK_KHR_ray_tracing into 3 extensions, enabling implementation flexibility and decoupling ray query support from ray pipelines: VK_KHR_acceleration_structure (for acceleration structure operations) VK_KHR_ray_tracing_pipeline (for ray tracing pipeline and shader stages) VK_KHR_ray_query (for ray queries in existing shader stages) clarify buffer usage flags for ray tracing VK_BUFFER_USAGE_RAY_TRACING_BIT_NV is left alone in VK_NV_ray_tracing (required on scratch and instanceData) VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR is added as an alias of VK_BUFFER_USAGE_RAY_TRACING_BIT_NV in VK_KHR_ray_tracing_pipeline and is required on shader binding table buffers VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR is added in VK_KHR_acceleration_structure for all vertex, index, transform, aabb, and instance buffer data referenced by device build commands VK_BUFFER_USAGE_STORAGE_BUFFER_BIT is used for scratchData add max primitive counts (ppMaxPrimitiveCounts) to vkCmdBuildAccelerationStructuresIndirectKHR Allocate acceleration structures from VkBuffers and add a mode to constrain the device address de-alias VkBindAccelerationStructureMemoryInfoNV and vkBindAccelerationStructureMemoryNV, and remove VkBindAccelerationStructureMemoryInfoKHR, VkAccelerationStructureMemoryRequirementsInfoKHR, and vkGetAccelerationStructureMemoryRequirementsKHR acceleration structures now take a VkBuffer and offset at creation time for memory placement add a new VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR buffer usage for such buffers add a new VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR acceleration structure type for layering move VK_GEOMETRY_TYPE_INSTANCES_KHR to main enum instead of being added via extension make build commands more consistent - all now build multiple acceleration structures and are named plurally (vkCmdBuildAccelerationStructuresIndirectKHR, vkCmdBuildAccelerationStructuresKHR, vkBuildAccelerationStructuresKHR) add interactions with VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT for acceleration structures, including a new feature (descriptorBindingAccelerationStructureUpdateAfterBind) and 3 new properties (maxPerStageDescriptorAccelerationStructures, maxPerStageDescriptorUpdateAfterBindAccelerationStructures, maxDescriptorSetUpdateAfterBindAccelerationStructures) extension is no longer provisional define synchronization requirements for builds, traces, and copies define synchronization requirements for AS build inputs and indirect build buffer (5) What is VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR for? RESOLVED: It is primarily intended for API layering. In DXR, the acceleration structure is basically just a buffer in a special layout, and you do not know at creation time whether it will be used as a top or bottom level acceleration structure. We thus added a generic acceleration structure type whose type is unknown at creation time, but is specified at build time instead. Applications which are written directly for Vulkan should not use it. Revision 1, 2019-12-05 (Members of the Vulkan Ray Tracing TSG) Internal revisions (forked from VK_NV_ray_tracing) Revision 2, 2019-12-20 (Daniel Koch, Eric Werness) Add const version of DeviceOrHostAddress (!3515) Add VU to clarify that only handles in the current pipeline are valid (!3518) Restore some missing VUs and add in-place update language (#1902, !3522) rename VkAccelerationStructureInstanceKHR member from accelerationStructure to accelerationStructureReference to better match its type (!3523) Allow VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS for pipeline creation if shader group handles cannot be reused (!3523) update documentation for the VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS error code and add missing documentation for new return codes from VK_KHR_deferred_host_operations (!3523) list new query types for VK_KHR_ray_tracing (!3523) Fix VU statements for VkAccelerationStructureGeometryKHR referring to correct union members and update to use more current wording (!3523) Revision 3, 2020-01-10 (Daniel Koch, Jon Leech, Christoph Kubisch) Fix 'instance of' and 'that/which contains/defines' markup issues (!3528) factor out VK_KHR_pipeline_library as stand-alone extension (!3540) Resolve Vulkan-hpp issues (!3543) add missing require for VkGeometryInstanceFlagsKHR de-alias VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV since the KHR structure is no longer equivalent add len to pDataSize attribute for vkWriteAccelerationStructuresPropertiesKHR Revision 4, 2020-01-23 (Daniel Koch, Eric Werness) Improve vkWriteAccelerationStructuresPropertiesKHR, add return value and VUs (#1947) Clarify language to allow multiple raygen shaders (#1959) Various editorial feedback (!3556) Add language to help deal with looped self-intersecting fans (#1901) Change vkCmdTraceRays{,Indirect}KHR args to pointers (!3559) Add scratch address validation language (#1941, !3551) Fix definition and add hierarchy information for shader call scope (#1977, !3571) Revision 5, 2020-02-04 (Eric Werness, Jeff Bolz, Daniel Koch) remove vestigial accelerationStructureUUID (!3582) update definition of repack instructions and improve memory model interactions (#1910, #1913, !3584) Fix wrong sType for VkPhysicalDeviceRayTracingFeaturesKHR (#1988) Use provisional SPIR-V capabilities (#1987) require rayTraversalPrimitiveCulling if rayQuery is supported (#1927) Miss shaders do not have object parameters (!3592) Fix missing required types in XML (!3592) clarify matching conditions for update (!3592) add goal that host and device builds be similar (!3592) clarify that maxPrimitiveCount limit should apply to triangles and AABBs (!3592) Require alignment for instance arrayOfPointers (!3592) Zero is a valid value for instance flags (!3592) Add some alignment VUs that got lost in refactoring (!3592) Recommend TMin epsilon rather than culling (!3592) Get angle from dot product not cross product (!3592) Clarify that AH can access the payload and attributes (!3592) Match DXR behavior for inactive primitive definition (!3592) Use a more generic term than degenerate for inactive to avoid confusion (!3592) Revision 6, 2020-02-20 (Daniel Koch) fix some dangling NV references (#1996) rename VkCmdTraceRaysIndirectCommandKHR to VkTraceRaysIndirectCommandKHR (!3607) update contributor list (!3611) use uint64_t instead of VkAccelerationStructureReferenceKHR in VkAccelerationStructureInstanceKHR (#2004) Revision 7, 2020-02-28 (Tobias Hector) remove HitTKHR SPIR-V builtin (spirv/spirv-extensions#7) Revision 8, 2020-03-06 (Tobias Hector, Dae Kim, Daniel Koch, Jeff Bolz, Eric Werness) explicitly state that Tmax is updated when new closest intersection is accepted (#2020,!3536) Made references to min and max t values consistent (!3644) finish enumerating differences relative to VK_NV_ray_tracing in issues (1) and (2) (#1974,!3642) fix formatting in some math equations (!3642) Restrict the Hit Kind operand of OpReportIntersectionKHR to 7-bits (spirv/spirv-extensions#8,!3646) Say ray tracing 'should' be watertight (#2008,!3631) Clarify memory requirements for ray tracing buffers (#2005,!3649) Add callable size limits (#1997,!3652) Revision 9, 2020-04-15 (Eric Werness, Daniel Koch, Tobias Hector, Joshua Barczak) Add geometry flags to acceleration structure creation (!3672) add build scratch memory alignment (minAccelerationStructureScratchOffsetAlignment) (#2065,!3725) fix naming and return enum from vkGetDeviceAccelerationStructureCompatibilityKHR (#2051,!3726) require SPIR-V 1.4 (#2096,!3777) added creation time capture/replay flags (#2104,!3774) require Vulkan 1.1 (#2133,!3806) use device addresses instead of VkBuffers for ray tracing commands (#2074,!3815) add interactions with Vulkan 1.2 and VK_KHR_vulkan_memory_model (#2133,!3830) make VK_KHR_pipeline_library an interaction instead of required (#2045,#2108,!3830) make VK_KHR_deferred_host_operations an interaction instead of required (#2045,!3830) removed maxCallableSize and added explicit stack size management for ray pipelines (#1997,!3817,!3772,!3844) improved documentation for VkAccelerationStructureVersionInfoKHR (#2135,3835) rename VkAccelerationStructureBuildOffsetInfoKHR to VkAccelerationStructureBuildRangeInfoKHR (#2058,!3754) Re-unify geometry description between build and create (!3754) Fix ppGeometries ambiguity, add pGeometries (#2032,!3811) add interactions with VK_EXT_robustness2 and allow nullDescriptor support for acceleration structures (#1920,!3848) added future extensibility for AS updates (#2114,!3849) Fix VU for dispatchrays and add a limit on the size of the full grid (#2160,!3851) Add shaderGroupHandleAlignment property (#2180,!3875) Clarify deferred host ops for pipeline creation (#2067,!3813) Change acceleration structure build to always be sized (#2131,#2197,#2198,!3854,!3883,!3880) Revision 10, 2020-07-03 (Mathieu Robart, Daniel Koch, Eric Werness, Tobias Hector) Decomposition of the specification, from VK_KHR_ray_tracing to VK_KHR_acceleration_structure (#1918,!3912) clarify buffer usage flags for ray tracing (#2181,!3939) add max primitive counts to build indirect command (#2233,!3944) Allocate acceleration structures from VkBuffers and add a mode to constrain the device address (#2131,!3936) Move VK_GEOMETRY_TYPE_INSTANCES_KHR to main enum (#2243,!3952) make build commands more consistent (#2247,!3958) add interactions with UPDATE_AFTER_BIND (#2128,!3986) correct and expand build command VUs (!4020) fix copy command VUs (!4018) added various alignment requirements (#2229,!3943) fix valid usage for arrays of geometryCount items (#2198,!4010) define what is allowed to change on RTAS updates and relevant VUs (#2177,!3961) Revision 11, 2020-11-12 (Eric Werness, Josh Barczak, Daniel Koch, Tobias Hector) de-alias NV and KHR acceleration structure types and associated commands (#2271,!4035) specify alignment for host copy commands (#2273,!4037) document VK_FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR specify that acceleration structures are non-linear (#2289,!4068) add several missing VUs for strides, vertexFormat, and indexType (#2315,!4069) restore VUs for VkAccelerationStructureBuildGeometryInfoKHR (#2337,!4098) ban multi-instance memory for host operations (#2324,!4102) allow dstAccelerationStructure to be null for vkGetAccelerationStructureBuildSizesKHR (#2330,!4111) more build VU cleanup (#2138,#4130) specify host endianness for AS serialization (#2261,!4136) add invertible transform matrix VU (#1710,!4140) require geometryCount to be 1 for TLAS builds (!4145) improved validity conditions for build addresses (#4142) add single statement SPIR-V VUs, build limit VUs (!4158) document limits for vertex and aabb strides (#2390,!4184) specify that VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR applies to AS copies (#2382,#4173) define sync for AS build inputs and indirect buffer (#2407,!4208) Revision 12, 2021-08-06 (Samuel Bourasseau) rename VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_KHR to VK_GEOMETRY_INSTANCE_TRIANGLE_FLIP_FACING_BIT_KHR (keep previous as alias). Clarify description and add note. Revision 13, 2021-09-30 (Jon Leech) Add interaction with VK_KHR_format_feature_flags2 to vk.xml Name String VK_KHR_android_surface Extension Type Instance extension Registered Extension Number 9 Revision 6 Ratification Status Ratified Extension and Version Dependencies VK_KHR_surface Contact Jesse Hall critsec Last Modified Date 2016-01-14 IP Status No known IP claims. Contributors Patrick Doane, Blizzard Faith Ekstrand, Intel Ian Elliott, LunarG Courtney Goeltzenleuchter, LunarG Jesse Hall, Google James Jones, NVIDIA Antoine Labour, Google Jon Leech, Khronos David Mao, AMD Norbert Nopper, Freescale Alon Or-bach, Samsung Daniel Rakos, AMD Graham Sellers, AMD Ray Smith, ARM Jeff Vigil, Qualcomm Chia-I Wu, LunarG The VK_KHR_android_surface extension is an instance extension. It provides a mechanism to create a VkSurfaceKHR object (defined by the VK_KHR_surface extension) that refers to an ANativeWindow, Androids native surface type. The ANativeWindow represents the producer endpoint of any buffer queue, regardless of consumer endpoint. Common consumer endpoints for ANativeWindows are the system window compositor, video encoders, and application-specific compositors importing the images through a SurfaceTexture. ANativeWindow vkCreateAndroidSurfaceKHR VkAndroidSurfaceCreateInfoKHR VkAndroidSurfaceCreateFlagsKHR VK_KHR_ANDROID_SURFACE_EXTENSION_NAME VK_KHR_ANDROID_SURFACE_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR 1) Does Android need a way to query for compatibility between a particular physical device (and queue family?) and a specific Android display? RESOLVED: No. Currently on Android, any physical device is expected to be able to present to the system compositor, and all queue families must support the necessary image layout transitions and synchronization operations. Revision 1, 2015-09-23 (Jesse Hall) Initial draft. Revision 2, 2015-10-26 (Ian Elliott) Renamed from VK_EXT_KHR_android_surface to VK_KHR_android_surface. Revision 3, 2015-11-03 (Daniel Rakos) Added allocation callbacks to surface creation function. Revision 4, 2015-11-10 (Jesse Hall) Removed VK_ERROR_INVALID_ANDROID_WINDOW_KHR. Revision 5, 2015-11-28 (Daniel Rakos) Updated the surface create function to take a pCreateInfo structure. Revision 6, 2016-01-14 (James Jones) Moved VK_ERROR_NATIVE_WINDOW_IN_USE_KHR from the VK_KHR_android_surface to the VK_KHR_surface extension. Name String VK_KHR_calibrated_timestamps Extension Type Device extension Registered Extension Number 544 Revision 1 Ratification Status Ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 Contact Daniel Rakos aqnuep Extension Proposal VK_EXT_calibrated_timestamps Last Modified Date 2023-07-12 IP Status No known IP claims. Contributors Matthaeus G. Chajdas, AMD Alan Harrison, AMD Derrick Owens, AMD Daniel Rakos, RasterGrid Faith Ekstrand, Intel Keith Packard, Valve This extension provides an interface to query calibrated timestamps obtained quasi simultaneously from two time domains. vkGetCalibratedTimestampsKHR vkGetPhysicalDeviceCalibrateableTimeDomainsKHR VkCalibratedTimestampInfoKHR VkTimeDomainKHR VK_KHR_CALIBRATED_TIMESTAMPS_EXTENSION_NAME VK_KHR_CALIBRATED_TIMESTAMPS_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_KHR Revision 1, 2023-07-12 (Daniel Rakos) Initial draft. Name String VK_KHR_compute_shader_derivatives Extension Type Device extension Registered Extension Number 512 Revision 1 Ratification Status Ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 SPIR-V Dependencies SPV_KHR_compute_shader_derivatives Contact Jean-Noe Morissette MagicPoncho Extension Proposal VK_KHR_compute_shader_derivatives Last Modified Date 2024-06-26 IP Status No known IP claims. Interactions and External Dependencies This extension requires SPV_KHR_compute_shader_derivatives This extension provides API support for GL_KHR_compute_shader_derivatives Contributors Jean-Noe Morissette, Epic Games Daniel Koch, NVIDIA Pat Brown, NVIDIA Stu Smith, AMD Jan-Harald Fredriksen, Arm Tobias Hector, AMD Ralph Potter, Samsung Pan Gao, Huawei Samuel (Sheng-Wen) Huang, MediaTek Graeme Leese, Broadcom Hans-Kristian Arntzen, Valve Matthew Netsh, Qualcomm This extension adds Vulkan support for the SPV_KHR_compute_shader_derivatives SPIR-V extension. The SPIR-V extension provides two new execution modes, both of which allow execution models with defined workgroups to use built-ins that evaluate derivatives explicitly or implicitly. Derivatives will be computed via differencing over a 2x2 group of shader invocations. The DerivativeGroupQuadsKHR execution mode assembles shader invocations into 2x2 groups, where each group has x and y coordinates of the local invocation ID of the form (2m+{0,1}, 2n+{0,1}). The DerivativeGroupLinearKHR execution mode assembles shader invocations into 2x2 groups, where each group has local invocation index values of the form 4m+{0,1,2,3}. The new execution modes are supported in compute shaders and optionally (see meshAndTaskShaderDerivatives) in mesh and task shaders. Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR Extending VkPhysicalDeviceProperties2: VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR VK_KHR_COMPUTE_SHADER_DERIVATIVES_EXTENSION_NAME VK_KHR_COMPUTE_SHADER_DERIVATIVES_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_PROPERTIES_KHR ComputeDerivativeGroupQuadsKHR ComputeDerivativeGroupLinearKHR None. Revision 1, 2023-02-27 (Jean-Noe Morissette) Initial draft Add properties and clarify mesh and task support (Daniel Koch) Name String VK_KHR_cooperative_matrix Extension Type Device extension Registered Extension Number 507 Revision 2 Ratification Status Ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 SPIR-V Dependencies SPV_KHR_cooperative_matrix Contact Kevin Petit kpet Extension Proposal VK_KHR_cooperative_matrix Last Modified Date 2023-05-03 Interactions and External Dependencies This extension provides API support for GLSL_KHR_cooperative_matrix Contributors Jeff Bolz, NVIDIA Markus Tavenrath, NVIDIA Daniel Koch, NVIDIA Kevin Petit, Arm Ltd. Boris Zanin, AMD This extension adds support for using cooperative matrix types in SPIR-V. Cooperative matrix types are medium-sized matrices that are primarily supported in compute shaders, where the storage for the matrix is spread across all invocations in some scope (usually a subgroup) and those invocations cooperate to efficiently perform matrix multiplies. Cooperative matrix types are defined by the SPV_KHR_cooperative_matrix SPIR-V extension and can be used with the GLSL_KHR_cooperative_matrix GLSL extension. This extension includes support for enumerating the matrix types and dimensions that are supported by the implementation. vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR VkCooperativeMatrixPropertiesKHR Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceCooperativeMatrixFeaturesKHR Extending VkPhysicalDeviceProperties2: VkPhysicalDeviceCooperativeMatrixPropertiesKHR VkComponentTypeKHR VkScopeKHR VK_KHR_COOPERATIVE_MATRIX_EXTENSION_NAME VK_KHR_COOPERATIVE_MATRIX_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_KHR VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR CooperativeMatrixKHR Revision 2, 2023-05-03 (Kevin Petit) First KHR revision Revision 1, 2019-02-05 (Jeff Bolz) NVIDIA vendor extension Name String VK_KHR_deferred_host_operations Extension Type Device extension Registered Extension Number 269 Revision 4 Ratification Status Ratified Extension and Version Dependencies None Contact Josh Barczak jbarczak Last Modified Date 2020-11-12 IP Status No known IP claims. Contributors Joshua Barczak, Intel Jeff Bolz, NVIDIA Daniel Koch, NVIDIA Slawek Grajewski, Intel Tobias Hector, AMD Yuriy ODonnell, Epic Eric Werness, NVIDIA Baldur Karlsson, Valve Jesse Barker, Unity Contributors to VK_KHR_acceleration_structure, VK_KHR_ray_tracing_pipeline The VK_KHR_deferred_host_operations extension defines the infrastructure and usage patterns for deferrable commands, but does not specify any commands as deferrable. This is left to additional dependent extensions. Commands must not be deferred unless the deferral is specifically allowed by another extension which depends on VK_KHR_deferred_host_operations. VkDeferredOperationKHR vkCreateDeferredOperationKHR vkDeferredOperationJoinKHR vkDestroyDeferredOperationKHR vkGetDeferredOperationMaxConcurrencyKHR vkGetDeferredOperationResultKHR VK_KHR_DEFERRED_HOST_OPERATIONS_EXTENSION_NAME VK_KHR_DEFERRED_HOST_OPERATIONS_SPEC_VERSION Extending VkObjectType: VK_OBJECT_TYPE_DEFERRED_OPERATION_KHR Extending VkResult: VK_OPERATION_DEFERRED_KHR VK_OPERATION_NOT_DEFERRED_KHR VK_THREAD_DONE_KHR VK_THREAD_IDLE_KHR The following examples will illustrate the concept of deferrable operations using a hypothetical example. The command vkDoSomethingExpensive denotes a deferrable command. The following example illustrates how a vulkan application might request deferral of an expensive operation: // create a deferred operation VkDeferredOperationKHR hOp; VkResult result = vkCreateDeferredOperationKHR(device, pCallbacks, &hOp); assert(result == VK_SUCCESS); result = vkDoSomethingExpensive(device, hOp, ...); assert( result == VK_OPERATION_DEFERRED_KHR ); // operation was deferred. Execute it asynchronously std::async::launch( [ hOp ] ( ) { vkDeferredOperationJoinKHR(device, hOp); result = vkGetDeferredOperationResultKHR(device, hOp); // deferred operation is now complete. 'result' indicates success or failure vkDestroyDeferredOperationKHR(device, hOp, pCallbacks); } ); The following example illustrates extracting concurrency from a single deferred operation: // create a deferred operation VkDeferredOperationKHR hOp; VkResult result = vkCreateDeferredOperationKHR(device, pCallbacks, &hOp); assert(result == VK_SUCCESS); result = vkDoSomethingExpensive(device, hOp, ...); assert( result == VK_OPERATION_DEFERRED_KHR ); // Query the maximum amount of concurrency and clamp to the desired maximum uint32_t numLaunches = std::min(vkGetDeferredOperationMaxConcurrencyKHR(device, hOp), maxThreads); std::vector > joins; for (uint32_t i = 0; i 1 be usable for performance queries? RESOLVED Yes. Some vendors will have costly performance counter query pool creation, and would rather if a certain set of counters were to be used multiple times that a queryCount > 1 can be used to amortize the instantiation cost. 10) Should we introduce an indirect mechanism to set the counter pass index? RESOLVED Specify the counter pass index at submit time instead, to avoid requiring re-recording of command buffers when multiple counter passes are needed. The following example shows how to find what performance counters a queue family supports, setup a query pool to record these performance counters, how to add the query pool to the command buffer to record information, and how to get the results from the query pool. // A previously created physical device VkPhysicalDevice physicalDevice; // One of the queue families our device supports uint32_t queueFamilyIndex; uint32_t counterCount; // Get the count of counters supported vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR( physicalDevice, queueFamilyIndex, &counterCount, NULL, NULL); VkPerformanceCounterKHR* counters = malloc(sizeof(VkPerformanceCounterKHR) * counterCount); VkPerformanceCounterDescriptionKHR* counterDescriptions = malloc(sizeof(VkPerformanceCounterDescriptionKHR) * counterCount); // Get the counters supported vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR( physicalDevice, queueFamilyIndex, &counterCount, counters, counterDescriptions); // Try to enable the first 8 counters uint32_t enabledCounters[8]; const uint32_t enabledCounterCount = min(counterCount, 8)); for (uint32_t i = 0; i size must be 0. DISCUSSION: Prior art, such as EGL_EXT_image_dma_buf_import_modifiers2, struct drm_mode_fb_cmd24, and struct gbm_import_fd_modifier_data5, omits from the API the size of each plane. Instead, the APIs infer each planes size from the import parameters, which include the images pixel format and a dma_buf, offset, and row pitch for each plane. However, Vulkan differs from EGL and GBM with regards to image creation in the following ways: Differences in Image Creation Undedicated allocation by default. When importing or exporting a set of dma_bufs as an EGLImage or gbm_bo, common practice mandates that each dma_bufs memory be dedicated (in the sense of VK_KHR_dedicated_allocation) to the image (though not necessarily dedicated to a single plane). In particular, neither the GBM documentation nor the EGL extension specifications explicitly state this requirement, but in light of common practice this is likely due to under-specification rather than intentional omission. In contrast, VK_EXT_image_drm_format_modifier permits, but does not require, the implementation to require dedicated allocations for images created with VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT. Separation of image creation and memory allocation. When importing a set of dma_bufs as an EGLImage or gbm_bo, EGL and GBM create the image resource and bind it to memory (the dma_bufs) simultaneously. This allows EGL and GBM to query each dma_bufs size during image creation. In Vulkan, image creation and memory allocation are independent unless a dedicated allocation is used (as in VK_KHR_dedicated_allocation). Therefore, without requiring dedicated allocation, Vulkan cannot query the size of each dma_buf (or other external handle) when calculating the images memory layout. Even if dedication allocation were required, Vulkan cannot calculate the images memory layout until after the image is bound to its dma_ufs. The above differences complicate the potential inference of plane size in Vulkan. Consider the following problematic cases: Problematic Plane Size Calculations Padding. Some plane of the image may require implementation-dependent padding. Metadata. For some modifiers, the image may have a metadata plane which requires a non-trivial calculation to determine its size. Mipmapped, array, and 3D images. The implementation may support VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT for images whose mipLevels, arrayLayers, or depth is greater than 1. For such images with certain modifiers, the calculation of each planes size may be non-trivial. However, an application-provided plane size solves none of the above problems. For simplicity, consider an external image with a single memory plane. The implementation is obviously capable calculating the images size when its tiling is VK_IMAGE_TILING_OPTIMAL. Likewise, any reasonable implementation is capable of calculating the images size when its tiling uses a supported modifier. Suppose that the external images size is smaller than the implementation-calculated size. If the application provided the external images size to vkCreateImage, the implementation would observe the mismatched size and recognize its inability to comprehend the external images layout (unless the implementation used the application-provided size to select a refinement of the tiling layout indicated by the modifier, which is strongly discouraged). The implementation would observe the conflict, and reject image creation with VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT. On the other hand, if the application did not provide the external images size to vkCreateImage, then the application would observe after calling vkGetImageMemoryRequirements that the external images size is less than the size required by the implementation. The application would observe the conflict and refuse to bind the VkImage to the external memory. In both cases, the result is explicit failure. Suppose that the external images size is larger than the implementation-calculated size. If the application provided the external images size to vkCreateImage, for reasons similar to above the implementation would observe the mismatched size and recognize its inability to comprehend the image data residing in the extra size. The implementation, however, must assume that image data resides in the entire size provided by the application. The implementation would observe the conflict and reject image creation with VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT. On the other hand, if the application did not provide the external images size to vkCreateImage, then the application would observe after calling vkGetImageMemoryRequirements that the external images size is larger than the implementation-usable size. The application would observe the conflict and refuse to bind the VkImage to the external memory. In both cases, the result is explicit failure. Therefore, an application-provided size provides no benefit, and this extension should not require it. This decision renders VkSubresourceLayout::size an unused field during image creation, and thus introduces a risk that implementations may require applications to submit sideband creation parameters in the unused field. To prevent implementations from relying on sideband data, this extension requires the application to set size to 0. EGL_EXT_image_dma_buf_import EGL_EXT_image_dma_buf_import_modifiers EGL_MESA_image_dma_buf_export struct drm_mode_fb_cmd2 gbm.h Revision 1, 2018-08-29 (Lina Versace) First stable revision Revision 2, 2021-09-30 (Jon Leech) Add interaction with VK_KHR_format_feature_flags2 to vk.xml Name String VK_EXT_image_sliced_view_of_3d Extension Type Device extension Registered Extension Number 419 Revision 1 Ratification Status Not ratified Extension and Version Dependencies VK_KHR_maintenance1 and VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 Special Use D3D support Contact Mike Blumenkrantz zmike Extension Proposal VK_EXT_image_sliced_view_of_3d Last Modified Date 2023-01-24 IP Status No known IP claims. Contributors Mike Blumenkrantz, Valve Hans-Kristian Arntzen, Valve Ricardo Garcia, Igalia Shahbaz Youssefi, Google Piers Daniell, NVIDIA This extension allows creating 3D views of 3D images such that the views contain a subset of the slices in the image, using a Z offset and range, for the purpose of using the views as storage image descriptors. This matches functionality in D3D12 and is primarily intended to support D3D12 emulation. Extending VkImageViewCreateInfo: VkImageViewSlicedCreateInfoEXT Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT VK_EXT_IMAGE_SLICED_VIEW_OF_3D_EXTENSION_NAME VK_EXT_IMAGE_SLICED_VIEW_OF_3D_SPEC_VERSION VK_REMAINING_3D_SLICES_EXT Extending VkStructureType: VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT Revision 1, 2022-10-21 (Mike Blumenkrantz) Initial revision Name String VK_EXT_image_view_min_lod Extension Type Device extension Registered Extension Number 392 Revision 1 Ratification Status Ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 Contact Joshua Ashton Joshua-Ashton Last Modified Date 2021-11-09 IP Status No known IP claims. Contributors Joshua Ashton, Valve Hans-Kristian Arntzen, Valve Samuel Iglesias Gonsalvez, Igalia Tobias Hector, AMD Faith Ekstrand, Intel Tom Olson, ARM This extension allows applications to clamp the minimum LOD value during Image Level(s) Selection, Texel Gathering and Integer Texel Coordinate Operations with a given VkImageView by VkImageViewMinLodCreateInfoEXT::minLod. This extension may be useful to restrict a VkImageView to only mips which have been uploaded, and the use of fractional minLod can be useful for smoothly introducing new mip levels when using linear mipmap filtering. Extending VkImageViewCreateInfo: VkImageViewMinLodCreateInfoEXT Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceImageViewMinLodFeaturesEXT VK_EXT_IMAGE_VIEW_MIN_LOD_EXTENSION_NAME VK_EXT_IMAGE_VIEW_MIN_LOD_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT Revision 1, 2021-07-06 (Joshua Ashton) Initial version Name String VK_EXT_layer_settings Extension Type Instance extension Registered Extension Number 497 Revision 2 Ratification Status Ratified Extension and Version Dependencies None Contact Christophe Riccio christophe Extension Proposal VK_EXT_layer_settings Last Modified Date 2023-09-23 IP Status No known IP claims. Contributors Christophe Riccio, LunarG Mark Lobodzinski, LunarG Charles Giessen, LunarG Spencer Fricke, LunarG Juan Ramos, LunarG Daniel Rakos, RasterGrid Shahbaz Youssefi, Google Lina Versace, Google Bill Hollings, The Brenwill Workshop Jon Leech, Khronos Tom Olson, Arm This extension provides a mechanism for configuring programmatically through the Vulkan API the behavior of layers. This extension provides the VkLayerSettingsCreateInfoEXT structure that can be included in the pNext chain of the VkInstanceCreateInfo structure passed as the pCreateInfo parameter of vkCreateInstance. The structure contains an array of VkLayerSettingEXT structure values that configure specific features of layers. The VK_EXT_layer_settings extension subsumes all the functionality provided in the VK_EXT_validation_flags extension and the VK_EXT_validation_features extension. VkLayerSettingEXT Extending VkInstanceCreateInfo: VkLayerSettingsCreateInfoEXT VkLayerSettingTypeEXT VK_EXT_LAYER_SETTINGS_EXTENSION_NAME VK_EXT_LAYER_SETTINGS_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT One example usage of VK_EXT_layer_settings is as implemented by the Vulkan Profiles layer. It allows the profiles layer tests used by the profiles layer C.I. to programmatically configure the layer for each test without affecting the C.I. environment, allowing to run multiple tests concurrently. const char* profile_file_data = JSON_TEST_FILES_PATH "VP_KHR_roadmap_2022.json"; const char* profile_name_data = "VP_KHR_roadmap_2022"; VkBool32 emulate_portability_data = VK_TRUE; const char* simulate_capabilities[] = { "SIMULATE_API_VERSION_BIT", "SIMULATE_FEATURES_BIT", "SIMULATE_PROPERTIES_BIT", "SIMULATE_EXTENSIONS_BIT", "SIMULATE_FORMATS_BIT", "SIMULATE_QUEUE_FAMILY_PROPERTIES_BIT" }; const char* debug_reports[] = { "DEBUG_REPORT_ERROR_BIT", "DEBUG_REPORT_WARNING_BIT", "DEBUG_REPORT_NOTIFICATION_BIT", "DEBUG_REPORT_DEBUG_BIT" }; const VkLayerSettingEXT settings[] = { {kLayerName, kLayerSettingsProfileFile, VK_LAYER_SETTING_TYPE_STRING_EXT, 1, &profile_file_data}, {kLayerName, kLayerSettingsProfileName, VK_LAYER_SETTING_TYPE_STRING_EXT, 1, &profile_name_data}, {kLayerName, kLayerSettingsEmulatePortability, VK_LAYER_SETTING_TYPE_BOOL32_EXT, 1, &emulate_portability_data}, {kLayerName, kLayerSettingsSimulateCapabilities, VK_LAYER_SETTING_TYPE_STRING_EXT, static_cast(std::size(simulate_capabilities)), simulate_capabilities}, {kLayerName, kLayerSettingsDebugReports, VK_LAYER_SETTING_TYPE_STRING_EXT, static_cast(std::size(debug_reports)), debug_reports} }; const VkLayerSettingsCreateInfoEXT layer_settings_create_info{ VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT, nullptr, static_cast(std::size(settings)), settings}; VkInstanceCreateInfo inst_create_info = {}; ... inst_create_info.pNext = &layer_settings_create_info; vkCreateInstance(&inst_create_info, nullptr, &_instances); How should application developers figure out the list of available settings? This extension does not provide a reflection API for layer settings. Layer settings are described in each layer JSON manifest and the documentation of each layer which implements this extension. Revision 1, 2020-06-17 (Mark Lobodzinski) Initial revision for Validation layer internal usages Revision 2, 2023-09-26 (Christophe Riccio) Refactor APIs for any layer usages and public release Name String VK_EXT_legacy_dithering Extension Type Device extension Registered Extension Number 466 Revision 2 Ratification Status Ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 API Interactions Interacts with VK_VERSION_1_3 Interacts with VK_VERSION_1_4 Interacts with VK_KHR_dynamic_rendering Interacts with VK_KHR_maintenance5 Special Use OpenGL / ES support Contact Shahbaz Youssefi syoussefi Extension Proposal VK_EXT_legacy_dithering Last Modified Date 2024-02-22 Contributors Shahbaz Youssefi, Google Graeme Leese, Broadcom Jan-Harald Fredriksen, Arm This extension exposes a hardware feature used by some vendors to implement OpenGLs dithering. The purpose of this extension is to support layering OpenGL over Vulkan, by allowing the layer to take advantage of the same hardware feature and provide equivalent dithering to OpenGL applications. Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceLegacyDitheringFeaturesEXT VK_EXT_LEGACY_DITHERING_EXTENSION_NAME VK_EXT_LEGACY_DITHERING_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT Extending VkSubpassDescriptionFlagBits: VK_SUBPASS_DESCRIPTION_ENABLE_LEGACY_DITHERING_BIT_EXT If VK_KHR_dynamic_rendering or Vulkan Version 1.3 and VK_KHR_maintenance5 or Vulkan Version 1.4 is supported: Extending VkPipelineCreateFlagBits2: VK_PIPELINE_CREATE_2_ENABLE_LEGACY_DITHERING_BIT_EXT Extending VkRenderingFlagBits: VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT Revision 1, 2022-03-31 (Shahbaz Youssefi) Internal revisions Revision 2, 2024-02-22 (Shahbaz Youssefi) Added pipeline create flag to support dynamic rendering 1) In OpenGL, the dither state can change dynamically. Should this extension add a pipeline state for dither? RESOLVED: No. Changing dither state is rarely, if ever, done during rendering. Every surveyed Android application either entirely disables dither, explicitly enables it, or uses the default state (which is enabled). Additionally, on some hardware dither can only be specified in a render pass granularity, so a change in dither state would necessarily need to cause a render pass break. This extension considers dynamic changes in OpenGL dither state a theoretical situation, and expects the layer to break the render pass in such a situation without any practical downsides. Name String VK_EXT_legacy_vertex_attributes Extension Type Device extension Registered Extension Number 496 Revision 1 Ratification Status Ratified Extension and Version Dependencies VK_EXT_vertex_input_dynamic_state Special Use OpenGL / ES support Contact Mike Blumenkrantz zmike Extension Proposal VK_EXT_legacy_vertex_attributes Last Modified Date 2024-02-23 IP Status No known IP claims. Contributors Mike Blumenkrantz, Valve Piers Daniell, NVIDIA Spencer Fricke, LunarG Alyssa Rosenzweig, Valve This extension adds support for legacy features of (non-64-bit) vertex attributes as found in OpenGL: Vertex attributes loaded from arbitrary buffer alignments Vertex attributes using arbitrary strides Vertex attributes where the component data type of the binding does not match the component numeric type of the shader input These features are only usable with dynamic vertex input. Unaligned loads of vertex attributes may incur performance penalties, indicated with a property. Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT Extending VkPhysicalDeviceProperties2: VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT VK_EXT_LEGACY_VERTEX_ATTRIBUTES_EXTENSION_NAME VK_EXT_LEGACY_VERTEX_ATTRIBUTES_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_FEATURES_EXT VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_PROPERTIES_EXT 1.) Should implementations convert float/integer values? RESOLVED: No. When fetching an integer data type from float values or float data types from integer values, the resulting shader values are implementation-dependent. Revision 1, 2024-02-16 (Mike Blumenkrantz) Initial revision Name String VK_EXT_map_memory_placed Extension Type Device extension Registered Extension Number 273 Revision 1 Ratification Status Ratified Extension and Version Dependencies VK_KHR_map_memory2 or Vulkan Version 1.4 Contact Faith Ekstrand gfxstrand Extension Proposal VK_EXT_map_memory_placed Last Modified Date 2023-03-21 IP Status No known IP claims. Interactions and External Dependencies Depends on apitext:VK_KHR_map_memory2 Interacts with apitext:VK_EXT_external_memory_host Contributors Faith Ekstrand, Collabora Tobias Hector, AMD James Jones, NVIDIA Georg Lehmann, Valve Derek Lesho, Codeweavers This extension allows an application to request that vkMapMemory2KHR attempt to place the memory map at a particular virtual address. Extending VkMemoryMapInfo: VkMemoryMapPlacedInfoEXT Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceMapMemoryPlacedFeaturesEXT Extending VkPhysicalDeviceProperties2: VkPhysicalDeviceMapMemoryPlacedPropertiesEXT VK_EXT_MAP_MEMORY_PLACED_EXTENSION_NAME VK_EXT_MAP_MEMORY_PLACED_SPEC_VERSION Extending VkMemoryMapFlagBits: VK_MEMORY_MAP_PLACED_BIT_EXT Extending VkMemoryUnmapFlagBits: VK_MEMORY_UNMAP_RESERVE_BIT_EXT Extending VkStructureType: VK_STRUCTURE_TYPE_MEMORY_MAP_PLACED_INFO_EXT VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_FEATURES_EXT VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_PROPERTIES_EXT Revision 1, 2024-01-14 (Faith Ekstrand) Internal revisions Name String VK_EXT_memory_budget Extension Type Device extension Registered Extension Number 238 Revision 1 Ratification Status Ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 Contact Jeff Bolz jeffbolznv Last Modified Date 2018-10-08 Contributors Jeff Bolz, NVIDIA Jeff Juliano, NVIDIA While running a Vulkan application, other processes on the machine might also be attempting to use the same device memory, which can pose problems. This extension adds support for querying the amount of memory used and the total memory budget for a memory heap. The values returned by this query are implementation-dependent and can depend on a variety of factors including operating system and system load. The VkPhysicalDeviceMemoryBudgetPropertiesEXT::heapBudget values can be used as a guideline for how much total memory from each heap the current process can use at any given time, before allocations may start failing or causing performance degradation. The values may change based on other activity in the system that is outside the scope and control of the Vulkan implementation. The VkPhysicalDeviceMemoryBudgetPropertiesEXT::heapUsage will display the current process estimated heap usage. With this information, the idea is for an application at some interval (once per frame, per few seconds, etc) to query heapBudget and heapUsage. From here the application can notice if it is over budget and decide how it wants to handle the memory situation (free it, move to host memory, changing mipmap levels, etc). This extension is designed to be used in concert with VK_EXT_memory_priority to help with this part of memory management. Extending VkPhysicalDeviceMemoryProperties2: VkPhysicalDeviceMemoryBudgetPropertiesEXT VK_EXT_MEMORY_BUDGET_EXTENSION_NAME VK_EXT_MEMORY_BUDGET_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT Revision 1, 2018-10-08 (Jeff Bolz) Initial revision Name String VK_EXT_memory_priority Extension Type Device extension Registered Extension Number 239 Revision 1 Ratification Status Ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 Contact Jeff Bolz jeffbolznv Last Modified Date 2018-10-08 Contributors Jeff Bolz, NVIDIA Jeff Juliano, NVIDIA This extension adds a priority value specified at memory allocation time. On some systems with both device-local and non-device-local memory heaps, the implementation may transparently move memory from one heap to another when a heap becomes full (for example, when the total memory used across all processes exceeds the size of the heap). In such a case, this priority value may be used to determine which allocations are more likely to remain in device-local memory. Extending VkMemoryAllocateInfo: VkMemoryPriorityAllocateInfoEXT Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceMemoryPriorityFeaturesEXT VK_EXT_MEMORY_PRIORITY_EXTENSION_NAME VK_EXT_MEMORY_PRIORITY_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT Revision 1, 2018-10-08 (Jeff Bolz) Initial revision Name String VK_EXT_mesh_shader Extension Type Device extension Registered Extension Number 329 Revision 1 Ratification Status Ratified Extension and Version Dependencies VK_KHR_spirv_1_4 or Vulkan Version 1.2 API Interactions Interacts with VK_VERSION_1_2 Interacts with VK_EXT_device_generated_commands Interacts with VK_KHR_draw_indirect_count Interacts with VK_KHR_fragment_shading_rate Interacts with VK_NV_device_generated_commands Interacts with VkPhysicalDeviceMeshShaderFeaturesEXT::primitiveFragmentShadingRateMeshShader SPIR-V Dependencies SPV_EXT_mesh_shader Contact Christoph Kubisch pixeljetstream Extension Proposal VK_EXT_mesh_shader Last Modified Date 2022-01-20 Interactions and External Dependencies This extension provides API support for GLSL_EXT_mesh_shader Interacts with Vulkan 1.1 Interacts with VK_KHR_multiview Interacts with VK_KHR_fragment_shading_rate Contributors Christoph Kubisch, NVIDIA Pat Brown, NVIDIA Jeff Bolz, NVIDIA Daniel Koch, NVIDIA Piers Daniell, NVIDIA Pierre Boudier, NVIDIA Patrick Mours, NVIDIA David Zhao Akeley, NVIDIA Kedarnath Thangudu, NVIDIA Timur Kristf, Valve Hans-Kristian Arntzen, Valve Philip Rebohle, Valve Mike Blumenkrantz, Valve Slawomir Grajewski, Intel Michal Pietrasiuk, Intel Mariusz Merecki, Intel Tom Olson, ARM Jan-Harald Fredriksen, ARM Sandeep Kakarlapudi, ARM Ruihao Zhang, QUALCOMM Ricardo Garcia, Igalia, S.L. Tobias Hector, AMD Stu Smith, AMD This extension provides a new mechanism allowing applications to generate collections of geometric primitives via programmable mesh shading. It is an alternative to the existing programmable primitive shading pipeline, which relied on generating input primitives by a fixed function assembler as well as fixed function vertex fetch. This extension also adds support for the following SPIR-V extension in Vulkan: SPV_EXT_mesh_shader vkCmdDrawMeshTasksEXT vkCmdDrawMeshTasksIndirectEXT If VK_KHR_draw_indirect_count or Vulkan Version 1.2 is supported: vkCmdDrawMeshTasksIndirectCountEXT VkDrawMeshTasksIndirectCommandEXT Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceMeshShaderFeaturesEXT Extending VkPhysicalDeviceProperties2: VkPhysicalDeviceMeshShaderPropertiesEXT VK_EXT_MESH_SHADER_EXTENSION_NAME VK_EXT_MESH_SHADER_SPEC_VERSION Extending VkPipelineStageFlagBits: VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT Extending VkQueryPipelineStatisticFlagBits: VK_QUERY_PIPELINE_STATISTIC_MESH_SHADER_INVOCATIONS_BIT_EXT VK_QUERY_PIPELINE_STATISTIC_TASK_SHADER_INVOCATIONS_BIT_EXT Extending VkQueryType: VK_QUERY_TYPE_MESH_PRIMITIVES_GENERATED_EXT Extending VkShaderStageFlagBits: VK_SHADER_STAGE_MESH_BIT_EXT VK_SHADER_STAGE_TASK_BIT_EXT Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT If VK_EXT_device_generated_commands is supported: Extending VkIndirectCommandsTokenTypeEXT: VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_COUNT_EXT VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_EXT If VK_NV_device_generated_commands is supported: Extending VkIndirectCommandsTokenTypeNV: VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV CullPrimitiveEXT PrimitivePointIndicesEXT PrimitiveLineIndicesEXT PrimitiveTriangleIndicesEXT (modified)Position (modified)PointSize (modified)ClipDistance (modified)CullDistance (modified)PrimitiveId (modified)Layer (modified)ViewportIndex (modified)NumWorkgroups (modified)WorkgroupSize (modified)WorkgroupId (modified)LocalInvocationId (modified)GlobalInvocationId (modified)LocalInvocationIndex (modified)NumSubgroups (modified)SubgroupId (modified)DrawIndex (modified)PrimitiveShadingRateKHR (modified)ViewIndex MeshShadingEXT Revision 1, 2022-03-08 (Christoph Kubisch, Daniel Koch, Patrick Mours) Initial revision Name String VK_EXT_metal_objects Extension Type Device extension Registered Extension Number 312 Revision 2 Ratification Status Ratified Extension and Version Dependencies None Contact Bill Hollings billhollings Extension Proposal VK_EXT_metal_objects Last Modified Date 2024-04-04 IP Status No known IP claims. Contributors Bill Hollings, The Brenwill Workshop Ltd. Dzmitry Malyshau, Mozilla Corp. In a Vulkan implementation that is layered on top of Metal on Apple device platforms, this extension provides the ability to import and export the underlying Metal objects associated with specific Vulkan objects. As detailed in the extension proposal document, this extension adds one new Vulkan command, vkExportMetalObjectsEXT, to export underlying Metal objects from Vulkan objects, and supports importing the appropriate existing Metal objects when creating Vulkan objects of types VkDeviceMemory, VkImage, VkSemaphore, and VkEvent, The intent is that this extension will be advertised and supported only on implementations that are layered on top of Metal on Apple device platforms. IOSurfaceRef MTLBuffer_id MTLCommandQueue_id MTLDevice_id MTLSharedEvent_id MTLTexture_id vkExportMetalObjectsEXT VkExportMetalObjectsInfoEXT Extending VkExportMetalObjectsInfoEXT: VkExportMetalBufferInfoEXT VkExportMetalCommandQueueInfoEXT VkExportMetalDeviceInfoEXT VkExportMetalIOSurfaceInfoEXT VkExportMetalSharedEventInfoEXT VkExportMetalTextureInfoEXT Extending VkImageCreateInfo: VkImportMetalIOSurfaceInfoEXT VkImportMetalTextureInfoEXT Extending VkInstanceCreateInfo, VkMemoryAllocateInfo, VkImageCreateInfo, VkImageViewCreateInfo, VkBufferViewCreateInfo, VkSemaphoreCreateInfo, VkEventCreateInfo: VkExportMetalObjectCreateInfoEXT Extending VkMemoryAllocateInfo: VkImportMetalBufferInfoEXT Extending VkSemaphoreCreateInfo, VkEventCreateInfo: VkImportMetalSharedEventInfoEXT VkExportMetalObjectTypeFlagBitsEXT VkExportMetalObjectTypeFlagsEXT VK_EXT_METAL_OBJECTS_EXTENSION_NAME VK_EXT_METAL_OBJECTS_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_EXPORT_METAL_BUFFER_INFO_EXT VK_STRUCTURE_TYPE_EXPORT_METAL_COMMAND_QUEUE_INFO_EXT VK_STRUCTURE_TYPE_EXPORT_METAL_DEVICE_INFO_EXT VK_STRUCTURE_TYPE_EXPORT_METAL_IO_SURFACE_INFO_EXT VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECTS_INFO_EXT VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT VK_STRUCTURE_TYPE_EXPORT_METAL_SHARED_EVENT_INFO_EXT VK_STRUCTURE_TYPE_EXPORT_METAL_TEXTURE_INFO_EXT VK_STRUCTURE_TYPE_IMPORT_METAL_BUFFER_INFO_EXT VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT None. Revision 1, 2022-05-28 (Bill Hollings) Initial draft. Incorporated feedback from review by the Vulkan Working Group. Renamed many structures, moved import/export of MTLBuffer to VkDeviceMemory, added export of MTLSharedEvent, added import of MTLSharedEvent for VkSemaphore and VkEvent, and changed used bit mask fields to individual bit fields to simplify Valid Usage rules. Revision 2, 2024-04-04 (Bill Hollings) Add an __unsafe_unretained ownership qualifier to all Metal object declarations, to support Automatic Reference Counting (ARC) on Apple devices. Name String VK_EXT_metal_surface Extension Type Instance extension Registered Extension Number 218 Revision 1 Ratification Status Ratified Extension and Version Dependencies VK_KHR_surface Contact Dzmitry Malyshau kvark Last Modified Date 2018-10-01 IP Status No known IP claims. Contributors Dzmitry Malyshau, Mozilla Corp. The VK_EXT_metal_surface extension is an instance extension. It provides a mechanism to create a VkSurfaceKHR object (defined by the VK_KHR_surface extension) from CAMetalLayer, which is the native rendering surface of Apples Metal framework. CAMetalLayer vkCreateMetalSurfaceEXT VkMetalSurfaceCreateInfoEXT VkMetalSurfaceCreateFlagsEXT VK_EXT_METAL_SURFACE_EXTENSION_NAME VK_EXT_METAL_SURFACE_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT Revision 1, 2018-10-01 (Dzmitry Malyshau) Initial version Name String VK_EXT_multi_draw Extension Type Device extension Registered Extension Number 393 Revision 1 Ratification Status Ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 Contact Mike Blumenkrantz zmike Last Modified Date 2021-05-19 Interactions and External Dependencies Interacts with Vulkan 1.1. Interacts with VK_KHR_shader_draw_parameters. IP Status No known IP claims. Contributors Mike Blumenkrantz, VALVE Piers Daniell, NVIDIA Faith Ekstrand, INTEL Spencer Fricke, SAMSUNG Ricardo Garcia, IGALIA Jon Leech, KHRONOS Stu Smith, AMD Processing multiple draw commands in sequence incurs measurable overhead within drivers due to repeated state checks and updates during dispatch. This extension enables passing the entire sequence of draws directly to the driver in order to avoid any such overhead, using an array of VkMultiDrawInfoEXT or VkMultiDrawIndexedInfoEXT structs with vkCmdDrawMultiEXT or vkCmdDrawMultiIndexedEXT, respectively. These functions could be used any time multiple draw commands are being recorded without any state changes between them in order to maximize performance. vkCmdDrawMultiEXT vkCmdDrawMultiIndexedEXT VkMultiDrawIndexedInfoEXT VkMultiDrawInfoEXT Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceMultiDrawFeaturesEXT Extending VkPhysicalDeviceProperties2: VkPhysicalDeviceMultiDrawPropertiesEXT VK_EXT_MULTI_DRAW_EXTENSION_NAME VK_EXT_MULTI_DRAW_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT (modified)DrawIndex Revision 1, 2021-01-20 (Mike Blumenkrantz) Initial version Name String VK_EXT_multisampled_render_to_single_sampled Extension Type Device extension Registered Extension Number 377 Revision 1 Ratification Status Ratified Extension and Version Dependencies VK_KHR_create_renderpass2 and VK_KHR_depth_stencil_resolve or Vulkan Version 1.2 Contact Shahbaz Youssefi syoussefi Extension Proposal VK_EXT_multisampled_render_to_single_sampled Last Modified Date 2021-04-16 IP Status No known IP claims. Contributors Shahbaz Youssefi, Google Jan-Harald Fredriksen, Arm Jrg Wagner, Arm Matthew Netsch, Qualcomm Technologies, Inc. Jarred Davies, Imagination Technologies With careful usage of resolve attachments, multisampled image memory allocated with VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT, loadOp not equal to VK_ATTACHMENT_LOAD_OP_LOAD and storeOp not equal to VK_ATTACHMENT_STORE_OP_STORE, a Vulkan application is able to efficiently perform multisampled rendering without incurring any additional memory penalty on some implementations. Under certain circumstances however, the application may not be able to complete its multisampled rendering within a single render pass; for example if it does partial rasterization from frame to frame, blending on an image from a previous frame, or in emulation of GL_EXT_multisampled_render_to_texture. In such cases, the application can use an initial subpass to effectively load single-sampled data from the next subpasss resolve attachment and fill in the multisampled attachment which otherwise uses loadOp equal to VK_ATTACHMENT_LOAD_OP_DONT_CARE. However, this is not always possible (for example for stencil in the absence of VK_EXT_shader_stencil_export) and has multiple drawbacks. Some implementations are able to perform said operation efficiently in hardware, effectively loading a multisampled attachment from the contents of a single sampled one. Together with the ability to perform a resolve operation at the end of a subpass, these implementations are able to perform multisampled rendering on single-sampled attachments with no extra memory or bandwidth overhead. This extension exposes this capability by allowing a framebuffer and render pass to include single-sampled attachments while rendering is done with a specified number of samples. Extending VkFormatProperties2: VkSubpassResolvePerformanceQueryEXT Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT Extending VkSubpassDescription2, VkRenderingInfo: VkMultisampledRenderToSingleSampledInfoEXT VK_EXT_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_EXTENSION_NAME VK_EXT_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_SPEC_VERSION Extending VkImageCreateFlagBits: VK_IMAGE_CREATE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_BIT_EXT Extending VkStructureType: VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT 1) Could the multisampled attachment be initialized through some form of copy? RESOLVED: No. Some implementations do not support copying between attachments in general, and find expressing this operation through a copy unnatural. 2) Another way to achieve this is by introducing a new loadOp to load the contents of the multisampled image from a single-sampled one. Why is this extension preferred? RESOLVED: Using this extension simplifies the application, as it does not need to manage a secondary lazily-allocated image. Additionally, using this extension leaves less room for error; for example a single mistake in loadOp or storeOp would result in the lazily-allocated image to actually take up memory, and remain so until destruction. 3) There is no guarantee that multisampled data between two subpasses with the same number of samples will be retained as the implementation may be forced to split the render pass implicitly for various reasons. Should this extension require that every subpass that uses multisampled-render-to-single-sampled end in an implicit render pass split (which results in a resolve operation)? RESOLVED: No. Not requiring this allows render passes with multiple multisampled-render-to-single-sampled subpasses to potentially execute more efficiently (though there is no guarantee). Revision 1, 2021-04-12 (Shahbaz Youssefi) Name String VK_EXT_mutable_descriptor_type Extension Type Device extension Registered Extension Number 495 Revision 1 Ratification Status Ratified Extension and Version Dependencies VK_KHR_maintenance3 or Vulkan Version 1.1 Special Use D3D support Contact Joshua Ashton Joshua-Ashton Hans-Kristian Arntzen HansKristian-Work Extension Proposal VK_EXT_mutable_descriptor_type Last Modified Date 2022-08-22 IP Status No known IP claims. Contributors Joshua Ashton, Valve Hans-Kristian Arntzen, Valve This extension allows applications to reduce descriptor memory footprint by allowing a descriptor to be able to mutate to a given list of descriptor types depending on which descriptor types are written into, or copied into a descriptor set. The main use case this extension intends to address is descriptor indexing with VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT where the descriptor types are completely generic, as this means applications can allocate one large descriptor set, rather than having one large descriptor set per descriptor type, which significantly bloats descriptor memory usage and causes performance issues. This extension also adds a mechanism to declare that a descriptor pool, and therefore the descriptor sets that are allocated from it, reside only in host memory; as such these descriptors can only be updated/copied, but not bound. These features together allow much more efficient emulation of the raw D3D12 binding model. This extension is primarily intended to be useful for API layering efforts. VkMutableDescriptorTypeListEXT Extending VkDescriptorSetLayoutCreateInfo, VkDescriptorPoolCreateInfo: VkMutableDescriptorTypeCreateInfoEXT Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT VK_EXT_MUTABLE_DESCRIPTOR_TYPE_EXTENSION_NAME VK_EXT_MUTABLE_DESCRIPTOR_TYPE_SPEC_VERSION Extending VkDescriptorPoolCreateFlagBits: VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_EXT Extending VkDescriptorSetLayoutCreateFlagBits: VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_EXT Extending VkDescriptorType: VK_DESCRIPTOR_TYPE_MUTABLE_EXT Extending VkStructureType: VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT Revision 1, 2022-08-22 (Jon Leech) Initial version, promoted from VK_VALVE_mutable_descriptor_type. Name String VK_EXT_nested_command_buffer Extension Type Device extension Registered Extension Number 452 Revision 1 Ratification Status Ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 Contact Piers Daniell pdaniell-nv Last Modified Date 2023-09-18 Contributors Daniel Story, Nintendo Peter Kohaut, NVIDIA Shahbaz Youssefi, Google Slawomir Grajewski, Intel Stu Smith, AMD With core Vulkan it is not legal to call vkCmdExecuteCommands when recording a secondary command buffer. This extension relaxes that restriction, allowing secondary command buffers to execute other secondary command buffers. Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceNestedCommandBufferFeaturesEXT Extending VkPhysicalDeviceProperties2: VkPhysicalDeviceNestedCommandBufferPropertiesEXT VK_EXT_NESTED_COMMAND_BUFFER_EXTENSION_NAME VK_EXT_NESTED_COMMAND_BUFFER_SPEC_VERSION Extending VkRenderingFlagBits: VK_RENDERING_CONTENTS_INLINE_BIT_EXT Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_PROPERTIES_EXT Extending VkSubpassContents: VK_SUBPASS_CONTENTS_INLINE_AND_SECONDARY_COMMAND_BUFFERS_EXT 1) The Command Buffer Levels property for the Vulkan commands comes from the cmdbufferlevel attribute in vk.xml for the command, and it is currently not possible to modify this attribute based on whether an extension is enabled. For this extension we want the cmdbufferlevel attribute for vkCmdExecuteCommands to be primary,secondary when this extension is enabled and primary otherwise. RESOLVED: The cmdbufferlevel attribute for vkCmdExecuteCommands has been changed to primary,secondary and a new VUID added to prohibit recording this command in a secondary command buffer unless this extension is enabled. Revision 1, 2023-09-18 (Piers Daniell) Internal revisions Name String VK_EXT_non_seamless_cube_map Extension Type Device extension Registered Extension Number 423 Revision 1 Ratification Status Ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 Special Uses D3D support OpenGL / ES support Contact Georg Lehmann DadSchoorse Extension Proposal VK_EXT_non_seamless_cube_map Last Modified Date 2021-09-04 IP Status No known IP claims. Contributors Georg Lehmann This extension provides functionality to disable cube map edge handling on a per sampler level which matches the behavior of other graphics APIs. This extension may be useful for building translation layers for those APIs or for porting applications that rely on this cube map behavior. Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT VK_EXT_NON_SEAMLESS_CUBE_MAP_EXTENSION_NAME VK_EXT_NON_SEAMLESS_CUBE_MAP_SPEC_VERSION Extending VkSamplerCreateFlagBits: VK_SAMPLER_CREATE_NON_SEAMLESS_CUBE_MAP_BIT_EXT Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT Revision 1, 2021-09-04 (Georg Lehmann) First Version Name String VK_EXT_opacity_micromap Extension Type Device extension Registered Extension Number 397 Revision 2 Ratification Status Ratified Extension and Version Dependencies VK_KHR_acceleration_structure and VK_KHR_synchronization2 or Vulkan Version 1.3 SPIR-V Dependencies SPV_EXT_opacity_micromap Contact Christoph Kubisch pixeljetstream Eric Werness Extension Proposal VK_EXT_opacity_micromap Last Modified Date 2022-08-24 Interactions and External Dependencies This extension provides API support for GLSL_EXT_opacity_micromap Contributors Christoph Kubisch, NVIDIA Eric Werness, NVIDIA Josh Barczak, Intel Stu Smith, AMD When adding transparency to a ray traced scene, an application can choose between further tessellating the geometry or using an any-hit shader to allow the ray through specific parts of the geometry. These options have the downside of either significantly increasing memory consumption or adding runtime overhead to run shader code in the middle of traversal, respectively. This extension adds the ability to add an opacity micromap to geometry when building an acceleration structure. The opacity micromap compactly encodes opacity information which can be read by the implementation to mark parts of triangles as opaque or transparent. The format is externally visible to allow the application to compress its internal geometry and surface representations into the compressed format ahead of time. The compressed format subdivides each triangle into a set of subtriangles, each of which can be assigned either two or four opacity values. These opacity values can control if a ray hitting that subtriangle is treated as an opaque hit, complete miss, or possible hit, depending on the controls described in Ray Opacity Micromap. This extension provides: a VkMicromapEXT structure to store the micromap, functions similar to acceleration structure build functions to build the opacity micromap array, and a structure to extend VkAccelerationStructureGeometryTrianglesDataKHR to attach a micromap to the geometry of the acceleration structure. VkMicromapEXT vkBuildMicromapsEXT vkCmdBuildMicromapsEXT vkCmdCopyMemoryToMicromapEXT vkCmdCopyMicromapEXT vkCmdCopyMicromapToMemoryEXT vkCmdWriteMicromapsPropertiesEXT vkCopyMemoryToMicromapEXT vkCopyMicromapEXT vkCopyMicromapToMemoryEXT vkCreateMicromapEXT vkDestroyMicromapEXT vkGetDeviceMicromapCompatibilityEXT vkGetMicromapBuildSizesEXT vkWriteMicromapsPropertiesEXT VkCopyMemoryToMicromapInfoEXT VkCopyMicromapInfoEXT VkCopyMicromapToMemoryInfoEXT VkMicromapBuildInfoEXT VkMicromapBuildSizesInfoEXT VkMicromapCreateInfoEXT VkMicromapTriangleEXT VkMicromapUsageEXT VkMicromapVersionInfoEXT Extending VkAccelerationStructureGeometryTrianglesDataKHR: VkAccelerationStructureTrianglesOpacityMicromapEXT Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceOpacityMicromapFeaturesEXT Extending VkPhysicalDeviceProperties2: VkPhysicalDeviceOpacityMicromapPropertiesEXT VkBuildMicromapFlagBitsEXT VkBuildMicromapModeEXT VkCopyMicromapModeEXT VkMicromapCreateFlagBitsEXT VkMicromapTypeEXT VkOpacityMicromapFormatEXT VkOpacityMicromapSpecialIndexEXT VkBuildMicromapFlagsEXT VkMicromapCreateFlagsEXT VK_EXT_OPACITY_MICROMAP_EXTENSION_NAME VK_EXT_OPACITY_MICROMAP_SPEC_VERSION Extending VkAccessFlagBits2: VK_ACCESS_2_MICROMAP_READ_BIT_EXT VK_ACCESS_2_MICROMAP_WRITE_BIT_EXT Extending VkBufferUsageFlagBits: VK_BUFFER_USAGE_MICROMAP_BUILD_INPUT_READ_ONLY_BIT_EXT VK_BUFFER_USAGE_MICROMAP_STORAGE_BIT_EXT Extending VkBuildAccelerationStructureFlagBitsKHR: VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISABLE_OPACITY_MICROMAPS_EXT VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_DATA_UPDATE_EXT VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_UPDATE_EXT Extending VkGeometryInstanceFlagBitsKHR: VK_GEOMETRY_INSTANCE_DISABLE_OPACITY_MICROMAPS_EXT VK_GEOMETRY_INSTANCE_FORCE_OPACITY_MICROMAP_2_STATE_EXT Extending VkObjectType: VK_OBJECT_TYPE_MICROMAP_EXT Extending VkPipelineCreateFlagBits: VK_PIPELINE_CREATE_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT Extending VkPipelineStageFlagBits2: VK_PIPELINE_STAGE_2_MICROMAP_BUILD_BIT_EXT Extending VkQueryType: VK_QUERY_TYPE_MICROMAP_COMPACTED_SIZE_EXT VK_QUERY_TYPE_MICROMAP_SERIALIZATION_SIZE_EXT Extending VkStructureType: VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT VK_STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT VK_STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT VK_STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT VK_STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT VK_STRUCTURE_TYPE_MICROMAP_CREATE_INFO_EXT VK_STRUCTURE_TYPE_MICROMAP_VERSION_INFO_EXT VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT uint32_t BarycentricsToSpaceFillingCurveIndex(float u, float v, uint32_t level) { u = clamp(u, 0.0f, 1.0f); v = clamp(v, 0.0f, 1.0f); uint32_t iu, iv, iw; // Quantize barycentric coordinates float fu = u * (1u = (1u = (1u = (1u = 1.0f && iuv > 1u; f ^= f >> 2u; f ^= f >> 4u; f ^= f >> 8u; uint32_t b1 = ((f ^ iu) & ~b0) | t; // Interleave bits b0 = (b0 | (b0 (vkGetInstanceProcAddr(instance, "vkGetPhysicalDeviceProperties2") ); VkPhysicalDeviceProperties2 general_props; VkPhysicalDeviceShaderCorePropertiesAMD shader_core_properties; shader_core_properties.pNext = nullptr; shader_core_properties.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD; general_props.pNext = &shader_core_properties; general_props.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2; // After this call, shader_core_properties has been populated pfnVkGetPhysicalDeviceProperties2(device, &general_props); printf("Number of shader engines: %d\n", m_shader_core_properties.shader_engine_count = shader_core_properties.shaderEngineCount; printf("Number of shader arrays: %d\n", m_shader_core_properties.shader_arrays_per_engine_count = shader_core_properties.shaderArraysPerEngineCount; printf("Number of CUs per shader array: %d\n", m_shader_core_properties.compute_units_per_shader_array = shader_core_properties.computeUnitsPerShaderArray; printf("Number of SIMDs per compute unit: %d\n", m_shader_core_properties.simd_per_compute_unit = shader_core_properties.simdPerComputeUnit; printf("Number of wavefront slots in each SIMD: %d\n", m_shader_core_properties.wavefronts_per_simd = shader_core_properties.wavefrontsPerSimd; printf("Number of threads per wavefront: %d\n", m_shader_core_properties.wavefront_size = shader_core_properties.wavefrontSize; printf("Number of physical SGPRs per SIMD: %d\n", m_shader_core_properties.sgprs_per_simd = shader_core_properties.sgprsPerSimd; printf("Minimum number of SGPRs that can be allocated by a wave: %d\n", m_shader_core_properties.min_sgpr_allocation = shader_core_properties.minSgprAllocation; printf("Number of available SGPRs: %d\n", m_shader_core_properties.max_sgpr_allocation = shader_core_properties.maxSgprAllocation; printf("SGPRs are allocated in groups of this size: %d\n", m_shader_core_properties.sgpr_allocation_granularity = shader_core_properties.sgprAllocationGranularity; printf("Number of physical VGPRs per SIMD: %d\n", m_shader_core_properties.vgprs_per_simd = shader_core_properties.vgprsPerSimd; printf("Minimum number of VGPRs that can be allocated by a wave: %d\n", m_shader_core_properties.min_vgpr_allocation = shader_core_properties.minVgprAllocation; printf("Number of available VGPRs: %d\n", m_shader_core_properties.max_vgpr_allocation = shader_core_properties.maxVgprAllocation; printf("VGPRs are allocated in groups of this size: %d\n", m_shader_core_properties.vgpr_allocation_granularity = shader_core_properties.vgprAllocationGranularity; Revision 2, 2019-06-25 (Matthaeus G. Chajdas) Clarified the meaning of a few fields. Revision 1, 2018-02-15 (Martin Dinkov) Initial draft. Name String VK_AMD_shader_core_properties2 Extension Type Device extension Registered Extension Number 228 Revision 1 Ratification Status Not ratified Extension and Version Dependencies VK_AMD_shader_core_properties Contact Matthaeus G. Chajdas anteru Last Modified Date 2019-07-26 IP Status No known IP claims. Contributors Matthaeus G. Chajdas, AMD Tobias Hector, AMD This extension exposes additional shader core properties for a target physical device through the VK_KHR_get_physical_device_properties2 extension. Extending VkPhysicalDeviceProperties2: VkPhysicalDeviceShaderCoreProperties2AMD VkShaderCorePropertiesFlagBitsAMD VkShaderCorePropertiesFlagsAMD VK_AMD_SHADER_CORE_PROPERTIES_2_EXTENSION_NAME VK_AMD_SHADER_CORE_PROPERTIES_2_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD None. Revision 1, 2019-07-26 (Matthaeus G. Chajdas) Initial draft. Name String VK_AMD_shader_early_and_late_fragment_tests Extension Type Device extension Registered Extension Number 322 Revision 1 Ratification Status Not ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 SPIR-V Dependencies SPV_AMD_shader_early_and_late_fragment_tests Contact Tobias Hector tobski Extension Proposal VK_AMD_shader_early_and_late_fragment_tests Last Modified Date 2021-09-14 Interactions and External Dependencies This extension interacts with VK_EXT_shader_stencil_export Contributors Tobias Hector, AMD This extension adds support for the SPV_AMD_shader_early_and_late_fragment_tests extension, allowing shaders to explicitly opt in to allowing both early and late fragment tests with the EarlyAndLateFragmentTestsAMD execution mode. If the VK_EXT_shader_stencil_export extension is supported, additional execution modes allowing early depth tests similar to DepthUnchanged, DepthLess, and DepthGreater are provided. Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD VK_AMD_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_EXTENSION_NAME VK_AMD_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD Revision 1, 2021-09-14 (Tobias Hector) Initial draft Name String VK_AMD_shader_explicit_vertex_parameter Extension Type Device extension Registered Extension Number 22 Revision 1 Ratification Status Not ratified Extension and Version Dependencies None SPIR-V Dependencies SPV_AMD_shader_explicit_vertex_parameter Contact Qun Lin linqun Last Modified Date 2016-05-10 IP Status No known IP claims. Interactions and External Dependencies This extension provides API support for GL_AMD_shader_explicit_vertex_parameter Contributors Matthaeus G. Chajdas, AMD Qun Lin, AMD Daniel Rakos, AMD Graham Sellers, AMD Rex Xu, AMD This extension adds support for the following SPIR-V extension in Vulkan: SPV_AMD_shader_explicit_vertex_parameter VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_EXTENSION_NAME VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_SPEC_VERSION Revision 1, 2016-05-10 (Daniel Rakos) Initial draft Name String VK_AMD_shader_fragment_mask Extension Type Device extension Registered Extension Number 138 Revision 1 Ratification Status Not ratified Extension and Version Dependencies None SPIR-V Dependencies SPV_AMD_shader_fragment_mask Contact Aaron Hagan AaronHaganAMD Last Modified Date 2017-08-16 IP Status No known IP claims. Interactions and External Dependencies This extension provides API support for GL_AMD_shader_fragment_mask Contributors Aaron Hagan, AMD Daniel Rakos, AMD Timothy Lottes, AMD This extension provides efficient read access to the fragment mask in compressed multisampled color surfaces. The fragment mask is a lookup table that associates color samples with color fragment values. From a shader, the fragment mask can be fetched with a call to fragmentMaskFetchAMD, which returns a single uint where each subsequent four bits specify the color fragment index corresponding to the color sample, starting from the least significant bit. For example, when eight color samples are used, the color fragment index for color sample 0 will be in bits 0-3 of the fragment mask, for color sample 7 the index will be in bits 28-31. The color fragment for a particular color sample may then be fetched with the corresponding fragment mask value using the fragmentFetchAMD shader function. VK_AMD_SHADER_FRAGMENT_MASK_EXTENSION_NAME VK_AMD_SHADER_FRAGMENT_MASK_SPEC_VERSION FragmentMaskAMD This example shows a shader that queries the fragment mask from a multisampled compressed surface and uses it to query fragment values. #version 450 core #extension GL_AMD_shader_fragment_mask: enable layout(binding = 0) uniform sampler2DMS s2DMS; layout(binding = 1) uniform isampler2DMSArray is2DMSArray; layout(binding = 2, input_attachment_index = 0) uniform usubpassInputMS usubpassMS; layout(location = 0) out vec4 fragColor; void main() { vec4 fragOne = vec4(0.0); uint fragMask = fragmentMaskFetchAMD(s2DMS, ivec2(2, 3)); uint fragIndex = (fragMask & 0xF0) >> 4; fragOne += fragmentFetchAMD(s2DMS, ivec2(2, 3), 1); fragMask = fragmentMaskFetchAMD(is2DMSArray, ivec3(2, 3, 1)); fragIndex = (fragMask & 0xF0) >> 4; fragOne += fragmentFetchAMD(is2DMSArray, ivec3(2, 3, 1), fragIndex); fragMask = fragmentMaskFetchAMD(usubpassMS); fragIndex = (fragMask & 0xF0) >> 4; fragOne += fragmentFetchAMD(usubpassMS, fragIndex); fragColor = fragOne; } Revision 1, 2017-08-16 (Aaron Hagan) Initial draft Name String VK_AMD_shader_image_load_store_lod Extension Type Device extension Registered Extension Number 47 Revision 1 Ratification Status Not ratified Extension and Version Dependencies None SPIR-V Dependencies SPV_AMD_shader_image_load_store_lod Contact Dominik Witczak dominikwitczakamd Last Modified Date 2017-08-21 Interactions and External Dependencies This extension provides API support for GL_AMD_shader_image_load_store_lod IP Status No known IP claims. Contributors Dominik Witczak, AMD Qun Lin, AMD Rex Xu, AMD This extension adds support for the following SPIR-V extension in Vulkan: SPV_AMD_shader_image_load_store_lod VK_AMD_SHADER_IMAGE_LOAD_STORE_LOD_EXTENSION_NAME VK_AMD_SHADER_IMAGE_LOAD_STORE_LOD_SPEC_VERSION Revision 1, 2017-08-21 (Dominik Witczak) Initial draft Name String VK_AMD_shader_info Extension Type Device extension Registered Extension Number 43 Revision 1 Ratification Status Not ratified Extension and Version Dependencies None Special Use Developer tools Contact Jaakko Konttinen jaakkoamd Last Modified Date 2017-10-09 IP Status No known IP claims. Contributors Jaakko Konttinen, AMD This extension adds a way to query certain information about a compiled shader which is part of a pipeline. This information may include shader disassembly, shader binary and various statistics about a shaders resource usage. While this extension provides a mechanism for extracting this information, the details regarding the contents or format of this information are not specified by this extension and may be provided by the vendor externally. Furthermore, all information types are optionally supported, and users should not assume every implementation supports querying every type of information. vkGetShaderInfoAMD VkShaderResourceUsageAMD VkShaderStatisticsInfoAMD VkShaderInfoTypeAMD VK_AMD_SHADER_INFO_EXTENSION_NAME VK_AMD_SHADER_INFO_SPEC_VERSION This example extracts the register usage of a fragment shader within a particular graphics pipeline: extern VkDevice device; extern VkPipeline gfxPipeline; PFN_vkGetShaderInfoAMD pfnGetShaderInfoAMD = (PFN_vkGetShaderInfoAMD)vkGetDeviceProcAddr( device, "vkGetShaderInfoAMD"); VkShaderStatisticsInfoAMD statistics = {}; size_t dataSize = sizeof(statistics); if (pfnGetShaderInfoAMD(device, gfxPipeline, VK_SHADER_STAGE_FRAGMENT_BIT, VK_SHADER_INFO_TYPE_STATISTICS_AMD, &dataSize, &statistics) == VK_SUCCESS) { printf("VGPR usage: %d\n", statistics.resourceUsage.numUsedVgprs); printf("SGPR usage: %d\n", statistics.resourceUsage.numUsedSgprs); } The following example continues the previous example by subsequently attempting to query and print shader disassembly about the fragment shader: // Query disassembly size (if available) if (pfnGetShaderInfoAMD(device, gfxPipeline, VK_SHADER_STAGE_FRAGMENT_BIT, VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD, &dataSize, nullptr) == VK_SUCCESS) { printf("Fragment shader disassembly:\n"); void* disassembly = malloc(dataSize); // Query disassembly and print if (pfnGetShaderInfoAMD(device, gfxPipeline, VK_SHADER_STAGE_FRAGMENT_BIT, VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD, &dataSize, disassembly) == VK_SUCCESS) { printf((char*)disassembly); } free(disassembly); } Revision 1, 2017-10-09 (Jaakko Konttinen) Initial revision Name String VK_AMD_shader_trinary_minmax Extension Type Device extension Registered Extension Number 21 Revision 1 Ratification Status Not ratified Extension and Version Dependencies None SPIR-V Dependencies SPV_AMD_shader_trinary_minmax Contact Qun Lin linqun Last Modified Date 2016-05-10 IP Status No known IP claims. Interactions and External Dependencies This extension provides API support for GL_AMD_shader_trinary_minmax Contributors Matthaeus G. Chajdas, AMD Qun Lin, AMD Daniel Rakos, AMD Graham Sellers, AMD Rex Xu, AMD This extension adds support for the following SPIR-V extension in Vulkan: SPV_AMD_shader_trinary_minmax VK_AMD_SHADER_TRINARY_MINMAX_EXTENSION_NAME VK_AMD_SHADER_TRINARY_MINMAX_SPEC_VERSION Revision 1, 2016-05-10 (Daniel Rakos) Initial draft Name String VK_AMD_texture_gather_bias_lod Extension Type Device extension Registered Extension Number 42 Revision 1 Ratification Status Not ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 SPIR-V Dependencies SPV_AMD_texture_gather_bias_lod Contact Rex Xu amdrexu Last Modified Date 2017-03-21 IP Status No known IP claims. Interactions and External Dependencies This extension provides API support for GL_AMD_texture_gather_bias_lod Contributors Dominik Witczak, AMD Daniel Rakos, AMD Graham Sellers, AMD Matthaeus G. Chajdas, AMD Qun Lin, AMD Rex Xu, AMD Timothy Lottes, AMD This extension adds two related features. Firstly, support for the following SPIR-V extension in Vulkan is added: SPV_AMD_texture_gather_bias_lod Secondly, the extension allows the application to query which formats can be used together with the new function prototypes introduced by the SPIR-V extension. Extending VkImageFormatProperties2: VkTextureLODGatherFormatPropertiesAMD VK_AMD_TEXTURE_GATHER_BIAS_LOD_EXTENSION_NAME VK_AMD_TEXTURE_GATHER_BIAS_LOD_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD ImageGatherBiasLodAMD struct VkTextureLODGatherFormatPropertiesAMD { VkStructureType sType; const void* pNext; VkBool32 supportsTextureGatherLODBiasAMD; }; // ---------------------------------------------------------------------------------------- // How to detect if an image format can be used with the new function prototypes. VkPhysicalDeviceImageFormatInfo2 formatInfo; VkImageFormatProperties2 formatProps; VkTextureLODGatherFormatPropertiesAMD textureLODGatherSupport; textureLODGatherSupport.sType = VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD; textureLODGatherSupport.pNext = nullptr; formatInfo.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2; formatInfo.pNext = nullptr; formatInfo.format = ...; formatInfo.type = ...; formatInfo.tiling = ...; formatInfo.usage = ...; formatInfo.flags = ...; formatProps.sType = VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2; formatProps.pNext = &textureLODGatherSupport; vkGetPhysicalDeviceImageFormatProperties2(physical_device, &formatInfo, &formatProps); if (textureLODGatherSupport.supportsTextureGatherLODBiasAMD == VK_TRUE) { // physical device supports SPV_AMD_texture_gather_bias_lod for the specified // format configuration. } else { // physical device does not support SPV_AMD_texture_gather_bias_lod for the // specified format configuration. } Revision 1, 2017-03-21 (Dominik Witczak) Initial draft Name String VK_ANDROID_external_format_resolve Extension Type Device extension Registered Extension Number 469 Revision 1 Ratification Status Not ratified Extension and Version Dependencies VK_ANDROID_external_memory_android_hardware_buffer API Interactions Interacts with VK_VERSION_1_3 Interacts with VK_KHR_dynamic_rendering Special Use OpenGL / ES support Contact Chris Forbes chrisforbes Extension Proposal VK_ANDROID_external_format_resolve Last Modified Date 2023-05-03 IP Status No known IP claims. Contributors Tobias Hector, AMD Chris Forbes, Google Jan-Harald Fredriksen, Arm Shahbaz Youssefi, Google Matthew Netsch, Qualcomm Tony Zlatsinki, Nvidia Daniel Koch, Nvidia Jeff Leger, Qualcomm Alex Walters, Imagination Andrew Garrard, Imagination Ralph Potter, Samsung Ian Elliott, Google This extension enables rendering to Android Hardware Buffers with external formats which cannot be directly represented as renderable in Vulkan, including YCBCR formats. Extending VkAndroidHardwareBufferPropertiesANDROID: VkAndroidHardwareBufferFormatResolvePropertiesANDROID Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceExternalFormatResolveFeaturesANDROID Extending VkPhysicalDeviceProperties2: VkPhysicalDeviceExternalFormatResolvePropertiesANDROID VK_ANDROID_EXTERNAL_FORMAT_RESOLVE_EXTENSION_NAME VK_ANDROID_EXTERNAL_FORMAT_RESOLVE_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_RESOLVE_PROPERTIES_ANDROID VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_FEATURES_ANDROID VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_PROPERTIES_ANDROID If VK_KHR_dynamic_rendering or Vulkan Version 1.3 is supported: Extending VkResolveModeFlagBits: VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID Revision 1, 2023-05-34 (Tobias Hector) Initial version Name String VK_ANDROID_external_memory_android_hardware_buffer Extension Type Device extension Registered Extension Number 130 Revision 5 Ratification Status Not ratified Extension and Version Dependencies VK_KHR_sampler_ycbcr_conversion and VK_KHR_external_memory and VK_KHR_dedicated_allocation or Vulkan Version 1.1 and VK_EXT_queue_family_foreign API Interactions Interacts with VK_VERSION_1_3 Interacts with VK_KHR_format_feature_flags2 Contact Jesse Hall critsec Last Modified Date 2021-09-30 IP Status No known IP claims. Contributors Ray Smith, ARM Lina Versace, Google Jesse Hall, Google Tobias Hector, Imagination James Jones, NVIDIA Tony Zlatinski, NVIDIA Matthew Netsch, Qualcomm Andrew Garrard, Samsung This extension enables an application to import Android AHardwareBuffer objects created outside of the Vulkan device into Vulkan memory objects, where they can be bound to images and buffers. It also allows exporting an AHardwareBuffer from a Vulkan memory object for symmetry with other operating systems. But since not all AHardwareBuffer usages and formats have Vulkan equivalents, exporting from Vulkan provides strictly less functionality than creating the AHardwareBuffer externally and importing it. Some AHardwareBuffer images have implementation-defined external formats that may not correspond to Vulkan formats. Sampler YCBCR conversion can be used to sample from these images and convert them to a known color space. AHardwareBuffer vkGetAndroidHardwareBufferPropertiesANDROID vkGetMemoryAndroidHardwareBufferANDROID VkAndroidHardwareBufferPropertiesANDROID VkMemoryGetAndroidHardwareBufferInfoANDROID Extending VkAndroidHardwareBufferPropertiesANDROID: VkAndroidHardwareBufferFormatPropertiesANDROID Extending VkImageCreateInfo, VkSamplerYcbcrConversionCreateInfo, VkAttachmentDescription2, VkGraphicsPipelineCreateInfo, VkCommandBufferInheritanceInfo: VkExternalFormatANDROID Extending VkImageFormatProperties2: VkAndroidHardwareBufferUsageANDROID Extending VkMemoryAllocateInfo: VkImportAndroidHardwareBufferInfoANDROID If VK_KHR_format_feature_flags2 or Vulkan Version 1.3 is supported: Extending VkAndroidHardwareBufferPropertiesANDROID: VkAndroidHardwareBufferFormatProperties2ANDROID VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_EXTENSION_NAME VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_SPEC_VERSION Extending VkExternalMemoryHandleTypeFlagBits: VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID Extending VkStructureType: VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID If VK_KHR_format_feature_flags2 or Vulkan Version 1.3 is supported: Extending VkStructureType: VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID 1) Other external memory objects are represented as weakly-typed handles (e.g. Win32 HANDLE or POSIX file descriptor), and require a handle type parameter along with handles. AHardwareBuffer is strongly typed, so naming the handle type is redundant. Does symmetry justify adding handle type parameters/fields anyway? RESOLVED: No. The handle type is already provided in places that treat external memory objects generically. In the places we would add it, the application code that would have to provide the handle type value is already dealing with AHardwareBuffer-specific commands/structures; the extra symmetry would not be enough to make that code generic. 2) The internal layout and therefore size of a AHardwareBuffer image may depend on native usage flags that do not have corresponding Vulkan counterparts. Do we provide this information to vkCreateImage somehow, or allow the allocation size reported by vkGetImageMemoryRequirements to be approximate? RESOLVED: Allow the allocation size to be unspecified when allocating the memory. It has to work this way for exported image memory anyway, since AHardwareBuffer allocation happens in vkAllocateMemory, and internally is performed by a separate HAL, not the Vulkan implementation itself. There is a similar issue with vkGetImageSubresourceLayout: the layout is determined by the allocator HAL, so it is not known until the image is bound to memory. 3) Should the result of sampling an external-format image with the suggested YCBCR conversion parameters yield the same results as using a samplerExternalOES in OpenGL ES? RESOLVED: This would be desirable, so that apps converting from OpenGL ES to Vulkan could get the same output given the same input. But since sampling and conversion from YCBCR images is so loosely defined in OpenGL ES, multiple implementations do it in a way that does not conform to Vulkans requirements. Modifying the OpenGL ES implementation would be difficult, and would change the output of existing unmodified applications. Changing the output only for applications that are being modified gives developers the chance to notice and mitigate any problems. Implementations are encouraged to minimize differences as much as possible without causing compatibility problems for existing OpenGL ES applications or violating Vulkan requirements. 4) Should an AHardwareBuffer with AHARDWAREBUFFER_USAGE_CPU_* usage be mappable in Vulkan? Should it be possible to export an AHardwareBuffers with such usage? RESOLVED: Optional, and mapping in Vulkan is not the same as AHardwareBuffer_lock. The semantics of these are different: mapping in memory is persistent, just gives a raw view of the memory contents, and does not involve ownership. AHardwareBuffer_lock gives the host exclusive access to the buffer, is temporary, and allows for reformatting copy-in/copy-out. Implementations are not required to support host-visible memory types for imported Android hardware buffers or resources backed by them. If a host-visible memory type is supported and used, the memory can be mapped in Vulkan, but doing so follows Vulkan semantics: it is just a raw view of the data and does not imply ownership (this means implementations must not internally call AHardwareBuffer_lock to implement vkMapMemory, or assume the application has done so). Implementations are not required to support linear-tiled images backed by Android hardware buffers, even if the AHardwareBuffer has CPU usage. There is no reliable way to allocate memory in Vulkan that can be exported to a AHardwareBuffer with CPU usage. 5) Android may add new AHardwareBuffer formats and usage flags over time. Can reference to them be added to this extension, or do they need a new extension? RESOLVED: This extension can document the interaction between the new AHB formats/usages and existing Vulkan features. No new Vulkan features or implementation requirements can be added. The extension version number will be incremented when this additional documentation is added, but the version number does not indicate that an implementation supports Vulkan memory or resources that map to the new AHardwareBuffer features: support for that must be queried with vkGetPhysicalDeviceImageFormatProperties2 or is implied by successfully allocating a AHardwareBuffer outside of Vulkan that uses the new feature and has a GPU usage flag. In essence, these are new features added to a new Android API level, rather than new Vulkan features. The extension will only document how existing Vulkan features map to that new Android feature. Revision 5, 2022-02-04 (Chris Forbes) Describe mapping of flags for storage image support Revision 4, 2021-09-30 (Jon Leech) Add interaction with VK_KHR_format_feature_flags2 to vk.xml Revision 3, 2019-08-27 (Jon Leech) Update revision history to correspond to XML version number Revision 2, 2018-04-09 (Petr Kraus) Markup fixes and remove incorrect Draft status Revision 1, 2018-03-04 (Jesse Hall) Initial version Name String VK_ARM_pipeline_opacity_micromap Extension Type Device extension Registered Extension Number 597 Revision 1 Ratification Status Not ratified Extension and Version Dependencies VK_EXT_opacity_micromap Contact Mathieu Robart mathieurobart-arm Extension Proposal VK_ARM_pipeline_opacity_micromap Last Modified Date 2025-01-07 IP Status No known IP claims. Contributors Mathieu Robart, Arm Marius Bjorge, Arm Yaozhong Zhang, Arm Jan-Harald Fredriksen, Arm The Opacity Micromap extension VK_EXT_opacity_micromap supports the new pipeline creation flag VK_PIPELINE_CREATE_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT, indicating that the ray tracing pipeline may be used with acceleration structures referencing micromaps. This allows for possible optimizations, knowing beforehand that opacity micromaps may be used with the pipeline. An equivalent flag does not exist for pipelines supporting Ray Query with opacity micromaps, such as graphics and compute. Consequently, it is currently not possible to optimize such pipelines for no-opacity, e.g. when opacity micromaps are supported by an application but not used by the pipeline. This may lead to performance degradation. This extension adds a new flag, VK_PIPELINE_CREATE_2_DISALLOW_OPACITY_MICROMAP_BIT_ARM, indicating that a pipeline will NOT be used with an acceleration structure referencing an opacity micromap, therefore allowing possible pipeline optimizations. Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDevicePipelineOpacityMicromapFeaturesARM VK_ARM_PIPELINE_OPACITY_MICROMAP_EXTENSION_NAME VK_ARM_PIPELINE_OPACITY_MICROMAP_SPEC_VERSION Extending VkPipelineCreateFlagBits2: VK_PIPELINE_CREATE_2_DISALLOW_OPACITY_MICROMAP_BIT_ARM Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_OPACITY_MICROMAP_FEATURES_ARM None. None. Revision 1, 2025-01-07 (Mathieu Robart) Initial draft Name String VK_ARM_render_pass_striped Extension Type Device extension Registered Extension Number 425 Revision 1 Ratification Status Not ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 and VK_KHR_synchronization2 or Vulkan Version 1.3 Contact Jan-Harald Fredriksen janharaldfredriksen-arm Extension Proposal VK_ARM_render_pass_striped Last Modified Date 2023-11-21 IP Status No known IP claims. Contributors Jan-Harald Fredriksen, Arm Lisa Wu, Arm Torbjorn Nilsson, Arm Ying-Chieh Chen, Mediatek Jim Chiu, Mediatek This extension adds the ability to split a render pass instance into stripes, and to get a notification when rendering has completed for each stripe. VkRenderPassStripeInfoARM Extending VkCommandBufferSubmitInfo: VkRenderPassStripeSubmitInfoARM Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceRenderPassStripedFeaturesARM Extending VkPhysicalDeviceProperties2: VkPhysicalDeviceRenderPassStripedPropertiesARM Extending VkRenderingInfo, VkRenderPassBeginInfo: VkRenderPassStripeBeginInfoARM VK_ARM_RENDER_PASS_STRIPED_EXTENSION_NAME VK_ARM_RENDER_PASS_STRIPED_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_FEATURES_ARM VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_PROPERTIES_ARM VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_BEGIN_INFO_ARM VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_INFO_ARM VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_SUBMIT_INFO_ARM None. Revision 1, 2023-11-21 Initial revision Name String VK_ARM_scheduling_controls Extension Type Device extension Registered Extension Number 418 Revision 1 Ratification Status Not ratified Extension and Version Dependencies VK_ARM_shader_core_builtins Contact Kevin Petit kpet Last Modified Date 2023-08-23 Interactions and External Dependencies None IP Status No known IP claims. Contributors Kvin Petit, Arm Ltd. Jan-Harald Fredriksen, Arm Ltd. Mikel Garai, Arm Ltd. This extension exposes a collection of controls to modify the scheduling behavior of Arm Mali devices. Extending VkDeviceQueueCreateInfo, VkDeviceCreateInfo: VkDeviceQueueShaderCoreControlCreateInfoARM Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceSchedulingControlsFeaturesARM Extending VkPhysicalDeviceProperties2: VkPhysicalDeviceSchedulingControlsPropertiesARM VkPhysicalDeviceSchedulingControlsFlagBitsARM VkPhysicalDeviceSchedulingControlsFlagsARM VK_ARM_SCHEDULING_CONTROLS_EXTENSION_NAME VK_ARM_SCHEDULING_CONTROLS_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_DEVICE_QUEUE_SHADER_CORE_CONTROL_CREATE_INFO_ARM VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_FEATURES_ARM VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_PROPERTIES_ARM None. None. Revision 1, 2023-08-23 (Kvin Petit) Initial revision Name String VK_ARM_shader_core_builtins Extension Type Device extension Registered Extension Number 498 Revision 2 Ratification Status Not ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 SPIR-V Dependencies SPV_ARM_core_builtins Contact Kevin Petit kpet Last Modified Date 2022-10-05 Interactions and External Dependencies This extension provides API support for GL_ARM_shader_core_builtins Contributors Kevin Petit, Arm Ltd. Jan-Harald Fredriksen, Arm Ltd. This extension provides the ability to determine device-specific properties on Arm GPUs. It exposes properties for the number of shader cores, the maximum number of warps that can run on a shader core, and shader builtins to enable invocations to identify which core and warp a shader invocation is executing on. This extension enables support for the SPIR-V CoreBuiltinsARM capability. These properties and built-ins can be used for debugging or performance optimization purposes. A typical optimization example would be to use CoreIDARM to select a per-shader-core instance of a data structure in algorithms that use atomics so as to reduce contention. Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM Extending VkPhysicalDeviceProperties2: VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM VK_ARM_SHADER_CORE_BUILTINS_EXTENSION_NAME VK_ARM_SHADER_CORE_BUILTINS_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM CoreCountARM CoreMaxIDARM CoreIDARM WarpsMaxIDARM WarpIDARM CoreBuiltinsARM None. Revision 1, 2022-10-05 (Kevin Petit) Initial revision Revision 2, 2022-10-26 (Kevin Petit) Add shaderCoreMask property Name String VK_ARM_shader_core_properties Extension Type Device extension Registered Extension Number 416 Revision 1 Ratification Status Not ratified Extension and Version Dependencies Vulkan Version 1.1 Contact Jan-Harald Fredriksen janharaldfredriksen-arm Last Modified Date 2023-02-07 IP Status No known IP claims. Contributors Jan-Harald Fredriksen, Arm Ltd. This extension provides the ability to determine device-specific performance properties of Arm GPUs. It exposes properties for the number of texel, pixel, and fused multiply-add operations per clock per shader core. This can be used in combination with the VK_ARM_shader_core_builtins extension that provides the ability to query the number of shader cores on the physical device. Extending VkPhysicalDeviceProperties2: VkPhysicalDeviceShaderCorePropertiesARM VK_ARM_SHADER_CORE_PROPERTIES_EXTENSION_NAME VK_ARM_SHADER_CORE_PROPERTIES_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM Revision 1, 2023-02-07 (Jan-Harald Fredriksen) Initial draft. Name String VK_FUCHSIA_buffer_collection Extension Type Device extension Registered Extension Number 367 Revision 2 Ratification Status Not ratified Extension and Version Dependencies VK_FUCHSIA_external_memory and VK_KHR_sampler_ycbcr_conversion or Vulkan Version 1.1 API Interactions Interacts with VK_EXT_debug_report Contact John Rosasco rosasco Last Modified Date 2021-09-23 IP Status No known IP claims. Contributors Craig Stout, Google John Bauman, Google John Rosasco, Google A buffer collection is a collection of one or more buffers which were allocated together as a group and which all have the same properties. These properties describe the buffers' internal representation such as its dimensions and memory layout. This ensures that all of the buffers can be used interchangeably by tasks that require swapping among multiple buffers, such as double-buffered graphics rendering. By sharing such a collection of buffers between components, communication about buffer lifecycle can be made much simpler and more efficient. For example, when a content producer finishes writing to a buffer, it can message the consumer of the buffer with the buffer index, rather than passing a handle to the shared memory. On Fuchsia, the Sysmem service uses buffer collections as a core construct in its design. VK_FUCHSIA_buffer_collection is the Vulkan extension that allows Vulkan applications to interoperate with the Sysmem service on Fuchsia. VkBufferCollectionFUCHSIA vkCreateBufferCollectionFUCHSIA vkDestroyBufferCollectionFUCHSIA vkGetBufferCollectionPropertiesFUCHSIA vkSetBufferCollectionBufferConstraintsFUCHSIA vkSetBufferCollectionImageConstraintsFUCHSIA VkBufferCollectionConstraintsInfoFUCHSIA VkBufferCollectionCreateInfoFUCHSIA VkBufferCollectionPropertiesFUCHSIA VkBufferConstraintsInfoFUCHSIA VkImageConstraintsInfoFUCHSIA VkImageFormatConstraintsInfoFUCHSIA VkSysmemColorSpaceFUCHSIA Extending VkBufferCreateInfo: VkBufferCollectionBufferCreateInfoFUCHSIA Extending VkImageCreateInfo: VkBufferCollectionImageCreateInfoFUCHSIA Extending VkMemoryAllocateInfo: VkImportMemoryBufferCollectionFUCHSIA VkImageConstraintsInfoFlagBitsFUCHSIA VkImageConstraintsInfoFlagsFUCHSIA VkImageFormatConstraintsFlagsFUCHSIA VK_FUCHSIA_BUFFER_COLLECTION_EXTENSION_NAME VK_FUCHSIA_BUFFER_COLLECTION_SPEC_VERSION Extending VkObjectType: VK_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA Extending VkStructureType: VK_STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CREATE_INFO_FUCHSIA VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA VK_STRUCTURE_TYPE_BUFFER_COLLECTION_PROPERTIES_FUCHSIA VK_STRUCTURE_TYPE_BUFFER_CONSTRAINTS_INFO_FUCHSIA VK_STRUCTURE_TYPE_IMAGE_CONSTRAINTS_INFO_FUCHSIA VK_STRUCTURE_TYPE_IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA VK_STRUCTURE_TYPE_IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA VK_STRUCTURE_TYPE_SYSMEM_COLOR_SPACE_FUCHSIA If VK_EXT_debug_report is supported: Extending VkDebugReportObjectTypeEXT: VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA_EXT 1) When configuring a VkImageConstraintsInfoFUCHSIA structure for constraint setting, should a NULL pFormatConstraints parameter be allowed ? RESOLVED: No. Specifying a NULL pFormatConstraints results in logical complexity of interpreting the relationship between the VkImageCreateInfo::usage settings of the elements of the pImageCreateInfos array and the implied or desired VkFormatFeatureFlags. The explicit requirement for pFormatConstraints to be non-NULL simplifies the implied logic of the implementation and expectations for the Vulkan application. Revision 2, 2021-09-23 (John Rosasco) Review passes Revision 1, 2021-03-09 (John Rosasco) Initial revision Name String VK_FUCHSIA_external_memory Extension Type Device extension Registered Extension Number 365 Revision 1 Ratification Status Not ratified Extension and Version Dependencies VK_KHR_external_memory_capabilities and VK_KHR_external_memory or Vulkan Version 1.1 Contact John Rosasco rosasco Last Modified Date 2021-03-01 IP Status No known IP claims. Contributors Craig Stout, Google John Bauman, Google John Rosasco, Google Vulkan apps may wish to export or import device memory handles to or from other logical devices, instances or APIs. This memory sharing can eliminate copies of memory buffers when different subsystems need to interoperate on them. Sharing memory buffers may also facilitate a better distribution of processing workload for more complex memory manipulation pipelines. vkGetMemoryZirconHandleFUCHSIA vkGetMemoryZirconHandlePropertiesFUCHSIA VkMemoryGetZirconHandleInfoFUCHSIA VkMemoryZirconHandlePropertiesFUCHSIA Extending VkMemoryAllocateInfo: VkImportMemoryZirconHandleInfoFUCHSIA VK_FUCHSIA_EXTERNAL_MEMORY_EXTENSION_NAME VK_FUCHSIA_EXTERNAL_MEMORY_SPEC_VERSION Extending VkExternalMemoryHandleTypeFlagBits: VK_EXTERNAL_MEMORY_HANDLE_TYPE_ZIRCON_VMO_BIT_FUCHSIA Extending VkStructureType: VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA VK_STRUCTURE_TYPE_MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA VK_STRUCTURE_TYPE_MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA See VK_KHR_external_memory issues list for further information. Revision 1, 2021-03-01 (John Rosasco) Initial draft Name String VK_FUCHSIA_external_semaphore Extension Type Device extension Registered Extension Number 366 Revision 1 Ratification Status Not ratified Extension and Version Dependencies VK_KHR_external_semaphore_capabilities and VK_KHR_external_semaphore Contact John Rosasco rosasco Last Modified Date 2021-03-08 IP Status No known IP claims. Contributors Craig Stout, Google John Bauman, Google John Rosasco, Google An application using external memory may wish to synchronize access to that memory using semaphores. This extension enables an application to export semaphore payload to and import semaphore payload from Zircon event handles. vkGetSemaphoreZirconHandleFUCHSIA vkImportSemaphoreZirconHandleFUCHSIA VkImportSemaphoreZirconHandleInfoFUCHSIA VkSemaphoreGetZirconHandleInfoFUCHSIA VK_FUCHSIA_EXTERNAL_SEMAPHORE_EXTENSION_NAME VK_FUCHSIA_EXTERNAL_SEMAPHORE_SPEC_VERSION Extending VkExternalSemaphoreHandleTypeFlagBits: VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_ZIRCON_EVENT_BIT_FUCHSIA Extending VkStructureType: VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA VK_STRUCTURE_TYPE_SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA 1) Does the application need to close the Zircon event handle returned by vkGetSemaphoreZirconHandleFUCHSIA? RESOLVED: Yes, unless it is passed back in to a driver instance to import the semaphore. A successful get call transfers ownership of the Zircon event handle to the application, and a successful import transfers it back to the driver. Destroying the original semaphore object will not close the Zircon event handle nor remove its reference to the underlying semaphore resource associated with it. Revision 1, 2021-03-08 (John Rosasco) Initial revision Name String VK_FUCHSIA_imagepipe_surface Extension Type Instance extension Registered Extension Number 215 Revision 1 Ratification Status Not ratified Extension and Version Dependencies VK_KHR_surface Contact Craig Stout cdotstout Last Modified Date 2018-07-27 IP Status No known IP claims. Contributors Craig Stout, Google Ian Elliott, Google Jesse Hall, Google The VK_FUCHSIA_imagepipe_surface extension is an instance extension. It provides a mechanism to create a VkSurfaceKHR object (defined by the VK_KHR_surface extension) that refers to a Fuchsia imagePipeHandle. vkCreateImagePipeSurfaceFUCHSIA VkImagePipeSurfaceCreateInfoFUCHSIA VkImagePipeSurfaceCreateFlagsFUCHSIA VK_FUCHSIA_IMAGEPIPE_SURFACE_EXTENSION_NAME VK_FUCHSIA_IMAGEPIPE_SURFACE_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA Revision 1, 2018-07-27 (Craig Stout) Initial draft. Name String VK_GGP_frame_token Extension Type Device extension Registered Extension Number 192 Revision 1 Ratification Status Not ratified Extension and Version Dependencies VK_KHR_swapchain and VK_GGP_stream_descriptor_surface Contact Jean-Francois Roy jfroy Last Modified Date 2019-01-28 IP Status No known IP claims. Contributors Jean-Francois Roy, Google Richard OGrady, Google This extension allows an application that uses the VK_KHR_swapchain extension in combination with a Google Games Platform surface provided by the VK_GGP_stream_descriptor_surface extension to associate a Google Games Platform frame token with a present operation. Extending VkPresentInfoKHR: VkPresentFrameTokenGGP VK_GGP_FRAME_TOKEN_EXTENSION_NAME VK_GGP_FRAME_TOKEN_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP Revision 1, 2018-11-26 (Jean-Francois Roy) Initial revision. Name String VK_GGP_stream_descriptor_surface Extension Type Instance extension Registered Extension Number 50 Revision 1 Ratification Status Not ratified Extension and Version Dependencies VK_KHR_surface Contact Jean-Francois Roy jfroy Last Modified Date 2019-01-28 IP Status No known IP claims. Contributors Jean-Francois Roy, Google Brad Grantham, Google Connor Smith, Google Cort Stratton, Google Hai Nguyen, Google Ian Elliott, Google Jesse Hall, Google Jim Ray, Google Katherine Wu, Google Kaye Mason, Google Kuangye Guo, Google Mark Segal, Google Nicholas Vining, Google Paul Lalonde, Google Richard OGrady, Google The VK_GGP_stream_descriptor_surface extension is an instance extension. It provides a mechanism to create a VkSurfaceKHR object (defined by the VK_KHR_surface extension) that refers to a Google Games Platform GgpStreamDescriptor. vkCreateStreamDescriptorSurfaceGGP VkStreamDescriptorSurfaceCreateInfoGGP VkStreamDescriptorSurfaceCreateFlagsGGP VK_GGP_STREAM_DESCRIPTOR_SURFACE_EXTENSION_NAME VK_GGP_STREAM_DESCRIPTOR_SURFACE_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP Revision 1, 2018-11-26 (Jean-Francois Roy) Initial revision. Name String VK_GOOGLE_decorate_string Extension Type Device extension Registered Extension Number 225 Revision 1 Ratification Status Not ratified Extension and Version Dependencies None SPIR-V Dependencies SPV_GOOGLE_decorate_string Contact Hai Nguyen chaoticbob Last Modified Date 2018-07-09 IP Status No known IP claims. Contributors Hai Nguyen, Google Neil Henning, AMD The VK_GOOGLE_decorate_string extension allows use of the SPV_GOOGLE_decorate_string extension in SPIR-V shader modules. VK_GOOGLE_DECORATE_STRING_EXTENSION_NAME VK_GOOGLE_DECORATE_STRING_SPEC_VERSION Revision 1, 2018-07-09 (Neil Henning) Initial draft Name String VK_GOOGLE_display_timing Extension Type Device extension Registered Extension Number 93 Revision 1 Ratification Status Not ratified Extension and Version Dependencies VK_KHR_swapchain Contact Ian Elliott ianelliottus Last Modified Date 2017-02-14 IP Status No known IP claims. Contributors Ian Elliott, Google Jesse Hall, Google This device extension allows an application that uses the VK_KHR_swapchain extension to obtain information about the presentation engines display, to obtain timing information about each present, and to schedule a present to happen no earlier than a desired time. An application can use this to minimize various visual anomalies (e.g. stuttering). Traditional game and real-time animation applications need to correctly position their geometry for when the presentable image will be presented to the user. To accomplish this, applications need various timing information about the presentation engines display. They need to know when presentable images were actually presented, and when they could have been presented. Applications also need to tell the presentation engine to display an image no sooner than a given time. This allows the application to avoid stuttering, so the animation looks smooth to the user. This extension treats variable-refresh-rate (VRR) displays as if they are fixed-refresh-rate (FRR) displays. vkGetPastPresentationTimingGOOGLE vkGetRefreshCycleDurationGOOGLE VkPastPresentationTimingGOOGLE VkPresentTimeGOOGLE VkRefreshCycleDurationGOOGLE Extending VkPresentInfoKHR: VkPresentTimesInfoGOOGLE VK_GOOGLE_DISPLAY_TIMING_EXTENSION_NAME VK_GOOGLE_DISPLAY_TIMING_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE The example code for the this extension (like the VK_KHR_surface and VK_GOOGLE_display_timing extensions) is contained in the cube demo that is shipped with the official Khronos SDK, and is being kept up-to-date in that location (see: https://github.com/KhronosGroup/Vulkan-Tools/blob/main/cube/cube.c ). Revision 1, 2017-02-14 (Ian Elliott) Internal revisions Name String VK_GOOGLE_hlsl_functionality1 Extension Type Device extension Registered Extension Number 224 Revision 1 Ratification Status Not ratified Extension and Version Dependencies None SPIR-V Dependencies SPV_GOOGLE_hlsl_functionality1 Contact Hai Nguyen chaoticbob Last Modified Date 2018-07-09 IP Status No known IP claims. Contributors Hai Nguyen, Google Neil Henning, AMD The VK_GOOGLE_hlsl_functionality1 extension allows use of the SPV_GOOGLE_hlsl_functionality1 extension in SPIR-V shader modules. VK_GOOGLE_HLSL_FUNCTIONALITY1_EXTENSION_NAME VK_GOOGLE_HLSL_FUNCTIONALITY1_SPEC_VERSION VK_GOOGLE_HLSL_FUNCTIONALITY_1_EXTENSION_NAME VK_GOOGLE_HLSL_FUNCTIONALITY_1_SPEC_VERSION Revision 1, 2018-07-09 (Neil Henning) Initial draft Name String VK_GOOGLE_surfaceless_query Extension Type Instance extension Registered Extension Number 434 Revision 2 Ratification Status Not ratified Extension and Version Dependencies VK_KHR_surface Special Use OpenGL / ES support Contact Shahbaz Youssefi syoussefi Extension Proposal VK_GOOGLE_surfaceless_query Last Modified Date 2022-08-03 IP Status No known IP claims. Contributors Ian Elliott, Google Shahbaz Youssefi, Google James Jones, NVIDIA This extension allows the vkGetPhysicalDeviceSurfaceFormatsKHR and vkGetPhysicalDeviceSurfacePresentModesKHR functions to accept VK_NULL_HANDLE as their surface parameter, allowing potential surface formats, color spaces and present modes to be queried without providing a surface. Identically, vkGetPhysicalDeviceSurfaceFormats2KHR, vkGetPhysicalDeviceSurfacePresentModes2EXT, and vkGetPhysicalDeviceSurfaceCapabilities2KHR would accept VK_NULL_HANDLE in VkPhysicalDeviceSurfaceInfo2KHR::surface. This can only be supported on platforms where the results of these queries are surface-agnostic and a single presentation engine is the implicit target of all present operations. VK_GOOGLE_SURFACELESS_QUERY_EXTENSION_NAME VK_GOOGLE_SURFACELESS_QUERY_SPEC_VERSION Revision 1, 2021-12-14 (Shahbaz Youssefi) Internal revisions Revision 2, 2022-08-03 (Shahbaz Youssefi) Precisions to which parts of the query responses are defined when surfaceless Name String VK_GOOGLE_user_type Extension Type Device extension Registered Extension Number 290 Revision 1 Ratification Status Not ratified Extension and Version Dependencies None SPIR-V Dependencies SPV_GOOGLE_user_type Contact Kaye Mason chaleur Last Modified Date 2019-07-09 IP Status No known IP claims. Contributors Kaye Mason, Google Hai Nguyen, Google The VK_GOOGLE_user_type extension allows use of the SPV_GOOGLE_user_type extension in SPIR-V shader modules. VK_GOOGLE_USER_TYPE_EXTENSION_NAME VK_GOOGLE_USER_TYPE_SPEC_VERSION Revision 1, 2019-09-07 (Kaye Mason) Initial draft Name String VK_HUAWEI_cluster_culling_shader Extension Type Device extension Registered Extension Number 405 Revision 3 Ratification Status Not ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 SPIR-V Dependencies SPV_HUAWEI_cluster_culling_shader Contact Yuchang Wang richard_Wang2 Extension Proposal VK_HUAWEI_cluster_culling_shader Last Modified Date 2023-08-16 Interactions and External Dependencies This extension provides API support for GL_HUAWEI_cluster_culling_shader. Contributors Yuchang Wang, Huawei Juntao Li, Huawei Pan Gao, Huawei Jie Cao, Huawei Yunjin Zhang, Huawei Shujie Zhou, Huawei Chaojun Wang, Huawei Jiajun Hu, Huawei Cong Zhang, Huawei Cluster Culling Shaders (CCS) are similar to the existing compute shaders. Their main purpose is to provide an execution environment in order to perform coarse-level geometry culling and LOD selection more efficiently on the GPU. The traditional 2-pass GPU culling solution using a compute shader sometimes needs a pipeline barrier between compute and graphics pipeline to optimize performance. An additional compaction process may also be required. This extension addresses these shortcomings, allowing compute shaders to directly emit visible clusters to the following graphics pipeline. A set of new built-in output variables are used to express a visible cluster, including per-cluster shading rate. In addition, a new built-in function is used to emit these variables from CCS to the IA stage. The IA stage can use these variables to fetch vertices of a visible cluster and drive vertex shaders to shading these vertices. Note that CCS do not work with geometry or tessellation shaders, but both IA and vertex shaders are preserved. Vertex shaders are still used for vertex position shading, instead of directly outputting transformed vertices from the compute shader. This makes CCS more suitable for mobile GPUs. vkCmdDrawClusterHUAWEI vkCmdDrawClusterIndirectHUAWEI Extending VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI: VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI Extending VkPhysicalDeviceProperties2: VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI VK_HUAWEI_CLUSTER_CULLING_SHADER_EXTENSION_NAME VK_HUAWEI_CLUSTER_CULLING_SHADER_SPEC_VERSION Extending VkPipelineStageFlagBits2: VK_PIPELINE_STAGE_2_CLUSTER_CULLING_SHADER_BIT_HUAWEI Extending VkQueryPipelineStatisticFlagBits: VK_QUERY_PIPELINE_STATISTIC_CLUSTER_CULLING_SHADER_INVOCATIONS_BIT_HUAWEI Extending VkShaderStageFlagBits: VK_SHADER_STAGE_CLUSTER_CULLING_BIT_HUAWEI Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_VRS_FEATURES_HUAWEI IndexCountHUAWEI VertexCountHUAWEI InstanceCountHUAWEI FirstIndexHUAWEI FirstVertexHUAWEI VertexOffsetHUAWEI FirstInstanceHUAWEI ClusterIDHUAWEI ClusterShadingRateHUAWEI ClusterCullingShadingHUAWEI Example of cluster culling in a GLSL shader #extension GL_HUAWEI_cluster_culling_shader: enable #define GPU_WARP_SIZE 32 #define GPU_GROUP_SIZE GPU_WARP_SIZE #define GPU_CLUSTER_PER_INVOCATION 1 #define GPU_CLUSTER_PER_WORKGROUP (GPU_GROUP_SIZE * GPU_CLUSTER_PER_INVOCATION) // Number of threads per workgroup // - 1D only // - warpsize = 32 layout(local_size_x=GPU_GROUP_SIZE, local_size_y=1, local_size_z=1) in; #define GPU_DRAW_BUFFER_BINDING 0 #define GPU_INSTANCE_DESCRIPTOR_BINDING 1 struct BoundingSphere { vec3 center; float radius; }; struct InstanceData { mat4 mvp_matrix; // mvp matrix. vec4 frustum_planes[6]; // six frustum planes mat4 model_matrix_transpose_inverse; // inverse transpose of model matrix. vec3 view_origin; // view original }; struct InstanceDescriptor { uint begin; uint end; uint cluster_count; uint debug; BoundingSphere sphere; InstanceData instance_data; }; struct DrawElementsCommand{ uint indexcount; uint instanceCount; uint firstIndex; int vertexoffset; uint firstInstance; uint cluster_id; }; // indexed mode out gl_PerClusterHUAWEI{ uint gl_IndexCountHUAWEI; uint gl_InstanceCountHUAWEI; uint gl_FirstIndexHUAWEI; int gl_VertexOffsetHUAWEI; uint gl_FirstInstanceHUAWEI; uint gl_ClusterIDHUAWEI; uint gl_ClusterShadingRateHUAWEI; }; layout(binding = GPU_DRAW_BUFFER_BINDING, std430) buffer draw_indirect_ssbo { DrawElementsCommand draw_commands[]; }; layout(binding = GPU_INSTANCE_DESCRIPTOR_BINDING, std430) buffer instance_descriptor_ssbo { InstanceDescriptor instance_descriptors[]; }; float Distance(uint instance_id) { vec3 v = normalize(instance_descriptor[instance_id].sphere.center - instance_descriptor[instance_id].instance_data.view_origin); float dist = sqrt(dot(v,v)); return dist; } bool isSphereOutsideFrustum( vec3 sphere_center, float sphere_radius ) { bool isInside = false; for(int i = 0; i 0.7) gl_ClusterShadingRateHUAWEI = gl_ShadingRateFlag4VerticalPixelsEXT | gl_ShadingRateFlag4HorizontalPixelsEXT; else if(distance > 0.3) gl_ClusterShadingRateHUAWEI = gl_ShadingRateFlag2VerticalPixelsEXT | gl_ShadingRateFlag2HorizontalPixelsEXT; else gl_ClusterShadingRateHUAWEI = 0; // this is a visible cluster, update built-in output variable. // in case of indexed mode: gl_IndexCountHUAWEI = draw_commands[cluster_id].indexcount; gl_InstanceCountHUAWEI = draw_commands[cluster_id].instanceCount; gl_FirstIndexHUAWEI = draw_commands[cluster_id].firstIndex; gl_VertexOffsetHUAWEI = draw_commands[cluster_id].vertexoffset; gl_FirstInstanceHUAWEI = draw_commands[cluster_id].firstInstance; gl_ClusterIDHUAWEI = draw_commands[cluster_id].cluster_id; // emit built-in output variables as a drawing command to subsequent // rendering pipeline. dispatchClusterHUAWEI(); } } Example of graphics pipeline creation with cluster culling shader // create a cluster culling shader stage info structure. VkPipelineShaderStageCreateInfo ccsStageInfo{}; ccsStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO; ccsStageInfo.stage = VK_SHADER_STAGE_CLUSTER_CULLING_BIT_HUAWEI; ccsStageInfo.module = clustercullingshaderModule; ccsStageInfo.pName = "main"; // pipeline shader stage creation VkPipelineShaderStageCreateInfo shaderStages[] = { ccsStageInfo, vertexShaderStageInfo, fragmentShaderStageInfo }; // create graphics pipeline VkGraphicsPipelineCreateInfo pipelineInfo{}; pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO; pipelineInfo.stageCount = 3; pipelineInfo.pStage = shaderStages; pipelineInfo.pVertexInputState = &vertexInputInfo; // ... VkPipeline graphicsPipeline; VkCreateGraphicsPipelines(device, VK_NULL_HANDLE, 1, &pipelineInfo, nullptr, &graphicsPipeline); Example of launching the execution of cluster culling shader vkCmdBindPipeline(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, graphicsPipeline); vkCmdDrawClusterHUAWEI(commandBuffer, groupCountX, 1, 1); vkCmdEndRenderPass(commandBuffer); Revision 1, 2022-11-18 (YuChang Wang) Internal revisions Revision 2, 2023-04-02 (Jon Leech) Grammar edits. Revision 3, 2023-08-21 (YuChang Wang) Add per-cluster shading rate. Name String VK_HUAWEI_hdr_vivid Extension Type Device extension Registered Extension Number 591 Revision 1 Ratification Status Not ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 and VK_KHR_swapchain and VK_EXT_hdr_metadata Contact Zehui Lin bactlink Last Modified Date 2024-10-08 IP Status No known IP claims. Contributors Juntao Li, Huawei Pan Gao, Huawei Xiufeng Zhang, Huawei Zehui Lin, Huawei This extension allows applications to assign HDR Vivid (T/UWA 005.1-2022) metadata to swapchains. HDR Vivid is an HDR standard released by UWA (UHD World Association). It defines tone mapping from the metadata to better preserve the creators intentions and achieve better consistency across devices with different display capabilities. Extending VkHdrMetadataEXT: VkHdrVividDynamicMetadataHUAWEI Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceHdrVividFeaturesHUAWEI VK_HUAWEI_HDR_VIVID_EXTENSION_NAME VK_HUAWEI_HDR_VIVID_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_HDR_VIVID_DYNAMIC_METADATA_HUAWEI VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HDR_VIVID_FEATURES_HUAWEI Revision 1, 2024-10-08 (Zehui Lin) Initial version Name String VK_HUAWEI_invocation_mask Extension Type Device extension Registered Extension Number 371 Revision 1 Ratification Status Not ratified Extension and Version Dependencies VK_KHR_ray_tracing_pipeline and VK_KHR_synchronization2 or Vulkan Version 1.3 Contact Pan Gao PanGao-h Extension Proposal VK_HUAWEI_invocation_mask Last Modified Date 2021-05-27 Interactions and External Dependencies This extension requires VK_KHR_ray_tracing_pipeline, which allow to bind an invocation mask image before the ray tracing command This extension requires VK_KHR_synchronization2, which allows new pipeline stage for the invocation mask image Contributors Yunpeng Zhu Juntao Li, Huawei Liang Chen, Huawei Shaozhuang Shi, Huawei Hailong Chu, Huawei The rays to trace may be sparse in some use cases. For example, the scene only have a few regions to reflect. Providing an invocation mask image to the ray tracing commands could potentially give the hardware the hint to do certain optimization without invoking an additional pass to compact the ray buffer. vkCmdBindInvocationMaskHUAWEI Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceInvocationMaskFeaturesHUAWEI VK_HUAWEI_INVOCATION_MASK_EXTENSION_NAME VK_HUAWEI_INVOCATION_MASK_SPEC_VERSION Extending VkAccessFlagBits2: VK_ACCESS_2_INVOCATION_MASK_READ_BIT_HUAWEI Extending VkImageUsageFlagBits: VK_IMAGE_USAGE_INVOCATION_MASK_BIT_HUAWEI Extending VkPipelineStageFlagBits2: VK_PIPELINE_STAGE_2_INVOCATION_MASK_BIT_HUAWEI Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI RT mask is updated before each traceRay. Step 1. Generate InvocationMask. //the rt mask image bind as color attachment in the fragment shader Layout(location = 2) out vec4 outRTmask vec4 mask = vec4(x,x,x,x); outRTmask = mask; Step 2. traceRay with InvocationMask vkCmdBindPipeline( commandBuffers[imageIndex], VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR, m_rtPipeline); vkCmdBindDescriptorSets(commandBuffers[imageIndex], VK_PIPELINE_BIND_POINT_RAY_TRACING_NV, m_rtPipelineLayout, 0, 1, &m_rtDescriptorSet, 0, nullptr); vkCmdBindInvocationMaskHUAWEI( commandBuffers[imageIndex], InvocationMaskimageView, InvocationMaskimageLayout); vkCmdTraceRaysKHR(commandBuffers[imageIndex], pRaygenShaderBindingTable, pMissShaderBindingTable, swapChainExtent.width, swapChainExtent.height, 1); Revision 1, 2021-05-27 (Yunpeng Zhu) Initial draft. Name String VK_HUAWEI_subpass_shading Extension Type Device extension Registered Extension Number 370 Revision 3 Ratification Status Not ratified Extension and Version Dependencies VK_KHR_create_renderpass2 or Vulkan Version 1.2 and VK_KHR_synchronization2 or Vulkan Version 1.3 SPIR-V Dependencies SPV_HUAWEI_subpass_shading Contact Pan Gao PanGao-h Last Modified Date 2021-06-01 Interactions and External Dependencies This extension provides API support for GL_HUAWEI_subpass_shading. Contributors Hueilong Wang Juntao Li, Huawei Renmiao Lu, Huawei Pan Gao, Huawei This extension allows applications to execute a subpass shading pipeline in a subpass of a render pass in order to save memory bandwidth for algorithms like tile-based deferred rendering and forward plus. A subpass shading pipeline is a pipeline with the compute pipeline ability, allowed to read values from input attachments, and only allowed to be dispatched inside a stand-alone subpass. Its work dimension is defined by the render passs render area size. Its workgroup size (width, height) shall be a power-of-two number in width or height, with minimum value from 8, and maximum value shall be decided from the render pass attachments and sample counts but depends on implementation. The GlobalInvocationId.xy of a subpass shading pipeline is equal to the FragCoord.xy of a graphic pipeline in the same render pass subtracted the offset of the VkRenderPassBeginInfo::renderArea. GlobalInvocationId.z is mapped to the Layer if VK_EXT_shader_viewport_index_layer is supported. The GlobalInvocationId.xy is equal to the index of the local workgroup multiplied by the size of the local workgroup plus the LocalInvocationId and the offset of the VkRenderPassBeginInfo::renderArea. This extension allows a subpasss pipeline bind point to be VK_PIPELINE_BIND_POINT_SUBPASS_SHADING_HUAWEI. vkCmdSubpassShadingHUAWEI vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI Extending VkComputePipelineCreateInfo: VkSubpassShadingPipelineCreateInfoHUAWEI Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceSubpassShadingFeaturesHUAWEI Extending VkPhysicalDeviceProperties2: VkPhysicalDeviceSubpassShadingPropertiesHUAWEI VK_HUAWEI_SUBPASS_SHADING_EXTENSION_NAME VK_HUAWEI_SUBPASS_SHADING_SPEC_VERSION Extending VkPipelineBindPoint: VK_PIPELINE_BIND_POINT_SUBPASS_SHADING_HUAWEI Extending VkPipelineStageFlagBits2: VK_PIPELINE_STAGE_2_SUBPASS_SHADER_BIT_HUAWEI VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI Extending VkShaderStageFlagBits: VK_SHADER_STAGE_SUBPASS_SHADING_BIT_HUAWEI Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI Example of subpass shading in a GLSL shader #extension GL_HUAWEI_subpass_shading: enable #extension GL_KHR_shader_subgroup_arithmetic: enable layout(constant_id = 0) const uint tileWidth = 8; layout(constant_id = 1) const uint tileHeight = 8; layout(local_size_x_id = 0, local_size_y_id = 1, local_size_z = 1) in; layout(set=0, binding=0, input_attachment_index=0) uniform subpassInput depth; void main() { float d = subpassLoad(depth).x; float minD = subgroupMin(d); float maxD = subgroupMax(d); } Example of subpass shading dispatching in a subpass vkCmdNextSubpass(commandBuffer, VK_SUBPASS_CONTENTS_INLINE); vkCmdBindPipeline(commandBuffer, VK_PIPELINE_BIND_POINT_SUBPASS_SHADING_HUAWEI, subpassShadingPipeline); vkCmdBindDescriptorSets(commandBuffer, VK_PIPELINE_BIND_POINT_SUBPASS_SHADING_HUAWEI, subpassShadingPipelineLayout, firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount, pDynamicOffsets); vkCmdSubpassShadingHUAWEI(commandBuffer) vkCmdEndRenderPass(commandBuffer); Example of subpass shading render pass creation VkAttachmentDescription2 attachments[] = { { VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2, NULL, 0, VK_FORMAT_R8G8B8A8_UNORM, VK_SAMPLE_COUNT_1_BIT, VK_ATTACHMENT_LOAD_OP_CLEAR, VK_ATTACHMENT_STORE_OP_DONT_CARE, VK_ATTACHMENT_LOAD_OP_DONT_CARE, VK_ATTACHMENT_LOAD_OP_DONT_CARE, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL }, { VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2, NULL, 0, VK_FORMAT_R8G8B8A8_UNORM, VK_SAMPLE_COUNT_1_BIT, VK_ATTACHMENT_LOAD_OP_CLEAR, VK_ATTACHMENT_STORE_OP_DONT_CARE, VK_ATTACHMENT_LOAD_OP_DONT_CARE, VK_ATTACHMENT_LOAD_OP_DONT_CARE, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL }, { VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2, NULL, 0, VK_FORMAT_R8G8B8A8_UNORM, VK_SAMPLE_COUNT_1_BIT, VK_ATTACHMENT_LOAD_OP_CLEAR, VK_ATTACHMENT_STORE_OP_DONT_CARE, VK_ATTACHMENT_LOAD_OP_DONT_CARE, VK_ATTACHMENT_LOAD_OP_DONT_CARE, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL }, { VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2, NULL, 0, VK_FORMAT_D24_UNORM_S8_UINT, VK_SAMPLE_COUNT_1_BIT, VK_ATTACHMENT_LOAD_OP_CLEAR, VK_ATTACHMENT_STORE_OP_DONT_CARE, VK_ATTACHMENT_LOAD_OP_CLEAR, VK_ATTACHMENT_LOAD_OP_DONT_CARE, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL }, { VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2, NULL, 0, VK_FORMAT_R8G8B8A8_UNORM, VK_SAMPLE_COUNT_1_BIT, VK_ATTACHMENT_LOAD_OP_CLEAR, VK_ATTACHMENT_STORE_OP_STORE, VK_ATTACHMENT_LOAD_OP_DONT_CARE, VK_ATTACHMENT_LOAD_OP_DONT_CARE, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL } }; VkAttachmentReference2 gBufferAttachmentReferences[] = { { VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2, NULL, 0, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, VK_IMAGE_ASPECT_COLOR_BIT }, { VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2, NULL, 1, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, VK_IMAGE_ASPECT_COLOR_BIT }, { VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2, NULL, 2, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, VK_IMAGE_ASPECT_COLOR_BIT } }; VkAttachmentReference2 gBufferDepthStencilAttachmentReferences = { VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2, NULL, 3, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, VK_IMAGE_ASPECT_DEPTH_BIT|VK_IMAGE_ASPECT_STENCIL_BIT }; VkAttachmentReference2 depthInputAttachmentReferences[] = { { VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2, NULL, 3, VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL, VK_IMAGE_ASPECT_DEPTH_BIT|VK_IMAGE_ASPECT_STENCIL_BIT }; }; VkAttachmentReference2 preserveAttachmentReferences[] = { { VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2, NULL, 0, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, VK_IMAGE_ASPECT_COLOR_BIT }, { VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2, NULL, 1, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, VK_IMAGE_ASPECT_COLOR_BIT }, { VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2, NULL, 2, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, VK_IMAGE_ASPECT_COLOR_BIT }, { VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2, NULL, 3, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, VK_IMAGE_ASPECT_DEPTH_BIT|VK_IMAGE_ASPECT_STENCIL_BIT } }; // G buffer including depth/stencil VkAttachmentReference2 colorAttachmentReferences[] = { { VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2, NULL, 4, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, VK_IMAGE_ASPECT_COLOR_BIT } }; VkAttachmentReference2 resolveAttachmentReference = { VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2, NULL, 4, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, VK_IMAGE_ASPECT_COLOR_BIT }; VkSubpassDescription2 subpasses[] = { { VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2, NULL, 0, VK_PIPELINE_BIND_POINT_GRAPHICS, 0, 0, NULL, // input sizeof(gBufferAttachmentReferences)/sizeof(gBufferAttachmentReferences[0]), gBufferAttachmentReferences, // color NULL, &gBufferDepthStencilAttachmentReferences, // resolve & DS 0, NULL }, { VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2, NULL, 0, VK_PIPELINE_BIND_POINT_SUBPASS_SHADING_HUAWEI , 0, sizeof(depthInputAttachmentReferences)/sizeof(depthInputAttachmentReferences[0]), depthInputAttachmentReferences, // input 0, NULL, // color NULL, NULL, // resolve & DS sizeof(preserveAttachmentReferences)/sizeof(preserveAttachmentReferences[0]), preserveAttachmentReferences, }, { VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2, NULL, 0, VK_PIPELINE_BIND_POINT_GRAPHICS, 0, sizeof(gBufferAttachmentReferences)/sizeof(gBufferAttachmentReferences[0]), gBufferAttachmentReferences, // input sizeof(colorAttachmentReferences)/sizeof(colorAttachmentReferences[0]), colorAttachmentReferences, // color &resolveAttachmentReference, &gBufferDepthStencilAttachmentReferences, // resolve & DS 0, NULL }, }; VkMemoryBarrier2KHR fragmentToSubpassShading = { VK_STRUCTURE_TYPE_MEMORY_BARRIER_2_KHR, NULL, VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT_KHR, VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT|VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT, VK_PIPELINE_STAGE_2_SUBPASS_SHADER_BIT_HUAWEI, VK_ACCESS_INPUT_ATTACHMENT_READ_BIT }; VkMemoryBarrier2KHR subpassShadingToFragment = { VK_STRUCTURE_TYPE_MEMORY_BARRIER_2_KHR, NULL, VK_PIPELINE_STAGE_2_SUBPASS_SHADER_BIT_HUAWEI, VK_ACCESS_SHADER_WRITE_BIT, VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT_KHR, VK_ACCESS_SHADER_READ_BIT }; VkSubpassDependency2 dependencies[] = { { VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2, &fragmentToSubpassShading, 0, 1, 0, 0, 0, 0, 0, 0 }, { VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2, &subpassShadingToFragment, 1, 2, 0, 0, 0, 0, 0, 0 }, }; VkRenderPassCreateInfo2 renderPassCreateInfo = { VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2, NULL, 0, sizeof(attachments)/sizeof(attachments[0]), attachments, sizeof(subpasses)/sizeof(subpasses[0]), subpasses, sizeof(dependencies)/sizeof(dependencies[0]), dependencies, 0, NULL }; VKRenderPass renderPass; vkCreateRenderPass2(device, &renderPassCreateInfo, NULL, &renderPass); Example of subpass shading pipeline creation VkExtent2D maxWorkgroupSize; VkSpecializationMapEntry subpassShadingConstantMapEntries[] = { { 0, 0 * sizeof(uint32_t), sizeof(uint32_t) }, { 1, 1 * sizeof(uint32_t), sizeof(uint32_t) } }; VkSpecializationInfo subpassShadingConstants = { 2, subpassShadingConstantMapEntries, sizeof(VkExtent2D), &maxWorkgroupSize }; VkSubpassShadingPipelineCreateInfoHUAWEI subpassShadingPipelineCreateInfo { VK_STRUCTURE_TYPE_SUBPASSS_SHADING_PIPELINE_CREATE_INFO_HUAWEI, NULL, renderPass, 1 }; VkPipelineShaderStageCreateInfo subpassShadingPipelineStageCreateInfo { VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO, NULL, 0, VK_SHADER_STAGE_SUBPASS_SHADING_BIT_HUAWEI, shaderModule, "main", &subpassShadingConstants }; VkComputePipelineCreateInfo subpassShadingComputePipelineCreateInfo = { VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO, &subpassShadingPipelineCreateInfo, 0, &subpassShadingPipelineStageCreateInfo, pipelineLayout, basePipelineHandle, basePipelineIndex }; VKPipeline pipeline; vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(device, renderPass, &maxWorkgroupSize); vkCreateComputePipelines(device, pipelineCache, 1, &subpassShadingComputePipelineCreateInfo, NULL, &pipeline); Revision 3, 2023-06-19 (Pan Gao) Rename VK_PIPELINE_STAGE_2_SUBPASS_SHADING_BIT_HUAWEI to VK_PIPELINE_STAGE_2_SUBPASS_SHADER_BIT_HUAWEI to better aligned with naming of other pipeline stages Revision 2, 2021-06-28 (Hueilong Wang) Change vkGetSubpassShadingMaxWorkgroupSizeHUAWEI to vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI to resolve issue pub1564 Revision 1, 2020-12-15 (Hueilong Wang) Initial draft. Name String VK_IMG_filter_cubic Extension Type Device extension Registered Extension Number 16 Revision 1 Ratification Status Not ratified Extension and Version Dependencies None Contact Tobias Hector tobski Last Modified Date 2016-02-23 Contributors Tobias Hector, Imagination Technologies VK_IMG_filter_cubic adds an additional, high quality cubic filtering mode to Vulkan, using a Catmull-Rom bicubic filter. Performing this kind of filtering can be done in a shader by using 16 samples and a number of instructions, but this can be inefficient. The cubic filter mode exposes an optimized high quality texture sampling using fixed texture sampling functionality. VK_IMG_FILTER_CUBIC_EXTENSION_NAME VK_IMG_FILTER_CUBIC_SPEC_VERSION Extending VkFilter: VK_FILTER_CUBIC_IMG Extending VkFormatFeatureFlagBits: VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG Creating a sampler with the new filter for both magnification and minification VkSamplerCreateInfo createInfo = { .sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO, // Other members set to application-desired values }; createInfo.magFilter = VK_FILTER_CUBIC_IMG; createInfo.minFilter = VK_FILTER_CUBIC_IMG; VkSampler sampler; VkResult result = vkCreateSampler( device, &createInfo, &sampler); Revision 1, 2016-02-23 (Tobias Hector) Initial version Name String VK_IMG_relaxed_line_rasterization Extension Type Device extension Registered Extension Number 111 Revision 1 Ratification Status Not ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 Special Use OpenGL / ES support Contact James Fitzpatrick jamesfitzpatrick Last Modified Date 2023-10-22 IP Status No known IP claims. Contributors James Fitzpatrick, Imagination Andrew Garrard, Imagination Alex Walters, Imagination OpenGL specifies that implementations should rasterize lines using the diamond exit rule (a slightly modified version of Bresenhams algorithm). To implement OpenGL some implementations have a device-level compatibility mode to rasterize lines according to the OpenGL specification. This extension allows OpenGL emulation layers to enable the OpenGL compatible line rasterization mode of such implementations. Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG VK_IMG_RELAXED_LINE_RASTERIZATION_EXTENSION_NAME VK_IMG_RELAXED_LINE_RASTERIZATION_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG None. Revision 1, 2023-10-22 (James Fitzpatrick) Initial version Name String VK_INTEL_performance_query Extension Type Device extension Registered Extension Number 211 Revision 2 Ratification Status Not ratified Extension and Version Dependencies None Special Use Developer tools Contact Lionel Landwerlin llandwerlin Last Modified Date 2018-05-16 IP Status No known IP claims. Contributors Lionel Landwerlin, Intel Piotr Maciejewski, Intel This extension allows an application to capture performance data to be interpreted by an external application or library. Such a library is available at : https://github.com/intel/metrics-discovery Performance analysis tools such as Graphics Performance Analyzers make use of this extension and the metrics-discovery library to present the data in a human readable way. VkPerformanceConfigurationINTEL vkAcquirePerformanceConfigurationINTEL vkCmdSetPerformanceMarkerINTEL vkCmdSetPerformanceOverrideINTEL vkCmdSetPerformanceStreamMarkerINTEL vkGetPerformanceParameterINTEL vkInitializePerformanceApiINTEL vkQueueSetPerformanceConfigurationINTEL vkReleasePerformanceConfigurationINTEL vkUninitializePerformanceApiINTEL VkInitializePerformanceApiInfoINTEL VkPerformanceConfigurationAcquireInfoINTEL VkPerformanceMarkerInfoINTEL VkPerformanceOverrideInfoINTEL VkPerformanceStreamMarkerInfoINTEL VkPerformanceValueINTEL Extending VkQueryPoolCreateInfo: VkQueryPoolCreateInfoINTEL VkQueryPoolPerformanceQueryCreateInfoINTEL VkPerformanceValueDataINTEL VkPerformanceConfigurationTypeINTEL VkPerformanceOverrideTypeINTEL VkPerformanceParameterTypeINTEL VkPerformanceValueTypeINTEL VkQueryPoolSamplingModeINTEL VK_INTEL_PERFORMANCE_QUERY_EXTENSION_NAME VK_INTEL_PERFORMANCE_QUERY_SPEC_VERSION Extending VkObjectType: VK_OBJECT_TYPE_PERFORMANCE_CONFIGURATION_INTEL Extending VkQueryType: VK_QUERY_TYPE_PERFORMANCE_QUERY_INTEL Extending VkStructureType: VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO_INTEL VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL // A previously created device VkDevice device; // A queue derived from the device VkQueue queue; VkInitializePerformanceApiInfoINTEL performanceApiInfoIntel = { VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL, NULL, NULL }; vkInitializePerformanceApiINTEL( device, &performanceApiInfoIntel); VkQueryPoolPerformanceQueryCreateInfoINTEL queryPoolIntel = { VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO_INTEL, NULL, VK_QUERY_POOL_SAMPLING_MODE_MANUAL_INTEL, }; VkQueryPoolCreateInfo queryPoolCreateInfo = { VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO, &queryPoolIntel, 0, VK_QUERY_TYPE_PERFORMANCE_QUERY_INTEL, 1, 0 }; VkQueryPool queryPool; VkResult result = vkCreateQueryPool( device, &queryPoolCreateInfo, NULL, &queryPool); assert(VK_SUCCESS == result); // A command buffer we want to record counters on VkCommandBuffer commandBuffer; VkCommandBufferBeginInfo commandBufferBeginInfo = { VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO, NULL, VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT, NULL }; result = vkBeginCommandBuffer(commandBuffer, &commandBufferBeginInfo); assert(VK_SUCCESS == result); vkCmdResetQueryPool( commandBuffer, queryPool, 0, 1); vkCmdBeginQuery( commandBuffer, queryPool, 0, 0); // Perform the commands you want to get performance information on // ... // Perform a barrier to ensure all previous commands were complete before // ending the query vkCmdPipelineBarrier(commandBuffer, VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT, VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT, 0, 0, NULL, 0, NULL, 0, NULL); vkCmdEndQuery( commandBuffer, queryPool, 0); result = vkEndCommandBuffer(commandBuffer); assert(VK_SUCCESS == result); VkPerformanceConfigurationAcquireInfoINTEL performanceConfigurationAcquireInfo = { VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL, NULL, VK_PERFORMANCE_CONFIGURATION_TYPE_COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED_INTEL }; VkPerformanceConfigurationINTEL performanceConfigurationIntel; result = vkAcquirePerformanceConfigurationINTEL( device, &performanceConfigurationAcquireInfo, &performanceConfigurationIntel); vkQueueSetPerformanceConfigurationINTEL(queue, performanceConfigurationIntel); assert(VK_SUCCESS == result); // Submit the command buffer and wait for its completion // ... result = vkReleasePerformanceConfigurationINTEL( device, performanceConfigurationIntel); assert(VK_SUCCESS == result); // Get the report size from metrics-discovery's QueryReportSize result = vkGetQueryPoolResults( device, queryPool, 0, 1, QueryReportSize, data, QueryReportSize, 0); assert(VK_SUCCESS == result); // The data can then be passed back to metrics-discovery from which // human readable values can be queried. Revision 2, 2020-03-06 (Lionel Landwerlin) Rename VkQueryPoolCreateInfoINTEL in VkQueryPoolPerformanceQueryCreateInfoINTEL Revision 1, 2018-05-16 (Lionel Landwerlin) Initial revision Name String VK_INTEL_shader_integer_functions2 Extension Type Device extension Registered Extension Number 210 Revision 1 Ratification Status Not ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 SPIR-V Dependencies SPV_INTEL_shader_integer_functions2 Contact Ian Romanick ianromanick Last Modified Date 2019-04-30 IP Status No known IP claims. Interactions and External Dependencies This extension provides API support for GL_INTEL_shader_integer_functions2. Contributors Ian Romanick, Intel Ben Ashbaugh, Intel This extension adds support for several new integer instructions in SPIR-V for use in graphics shaders. Many of these instructions have pre-existing counterparts in the Kernel environment. The added integer functions are defined by the SPV_INTEL_shader_integer_functions2 SPIR-V extension and can be used with the GL_INTEL_shader_integer_functions2 GLSL extension. Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL VK_INTEL_SHADER_INTEGER_FUNCTIONS_2_EXTENSION_NAME VK_INTEL_SHADER_INTEGER_FUNCTIONS_2_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL IntegerFunctions2INTEL Revision 1, 2019-04-30 (Ian Romanick) Initial draft Name String VK_LUNARG_direct_driver_loading Extension Type Instance extension Registered Extension Number 460 Revision 1 Ratification Status Not ratified Extension and Version Dependencies None Contact Charles Giessen charles-lunarg Extension Proposal VK_LUNARG_direct_driver_loading Last Modified Date 2022-11-29 Contributors Charles Giessen, LunarG This extension provides a mechanism for applications to add drivers to the implementation. This allows drivers to be included with an application without requiring installation and is capable of being used in any execution environment, such as a process running with elevated privileges. VkDirectDriverLoadingInfoLUNARG Extending VkInstanceCreateInfo: VkDirectDriverLoadingListLUNARG PFN_vkGetInstanceProcAddrLUNARG VkDirectDriverLoadingModeLUNARG VkDirectDriverLoadingFlagsLUNARG VK_LUNARG_DIRECT_DRIVER_LOADING_EXTENSION_NAME VK_LUNARG_DIRECT_DRIVER_LOADING_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_INFO_LUNARG VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_LIST_LUNARG Revision 1, 2022-11-29 (Charles Giessen) Initial version Name String VK_MESA_image_alignment_control Extension Type Device extension Registered Extension Number 576 Revision 1 Ratification Status Not ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 Special Use D3D support Contact Hans-Kristian Arntzen HansKristian-Work Last Modified Date 2024-05-03 IP Status No known IP claims. Contributors Hans-Kristian Arntzen, Valve This extension allows applications to request a narrower alignment for images than an implementation would otherwise require. Some implementations internally support multiple image layouts in VK_IMAGE_TILING_OPTIMAL, each with different alignment requirements and performance trade-offs. In some API layering use cases such as D3D12, it is beneficial to be able to control the alignment, since certain alignments for placed resources are guaranteed to be supported, and emulating that expectation requires unnecessary padding of allocations. VkImageAlignmentControlCreateInfoMESA can be chained to VkImageCreateInfo, requesting that the alignment is no more than the provided alignment. If the requested alignment is not supported for a given VkImageCreateInfo, a larger alignment may be returned. While something similar could be achieved with VK_EXT_image_drm_format_modifier in theory, this is not the intended way to use that extension. Format modifiers are generally used for externally shareable images, and would not be platform portable. It is also a cumbersome API to use just to lower the alignment. Extending VkImageCreateInfo: VkImageAlignmentControlCreateInfoMESA Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceImageAlignmentControlFeaturesMESA Extending VkPhysicalDeviceProperties2: VkPhysicalDeviceImageAlignmentControlPropertiesMESA VK_MESA_IMAGE_ALIGNMENT_CONTROL_EXTENSION_NAME VK_MESA_IMAGE_ALIGNMENT_CONTROL_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_FEATURES_MESA VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_PROPERTIES_MESA Revision 1, 2024-04-05 (Hans-Kristian Arntzen) Initial specification Name String VK_MSFT_layered_driver Extension Type Device extension Registered Extension Number 531 Revision 1 Ratification Status Not ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 Contact Jesse Natalie jenatali Extension Proposal VK_MSFT_layered_driver Last Modified Date 2023-06-21 IP Status No known IP claims. Contributors Jesse Natalie, Microsoft This extension adds new physical device properties to allow applications and the Vulkan ICD loader to understand when a physical device is implemented as a layered driver on top of another underlying API. Extending VkPhysicalDeviceProperties2: VkPhysicalDeviceLayeredDriverPropertiesMSFT VkLayeredDriverUnderlyingApiMSFT VK_MSFT_LAYERED_DRIVER_EXTENSION_NAME VK_MSFT_LAYERED_DRIVER_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT None. Revision 1, 2023-06-21 (Jesse Natalie) Initial revision Name String VK_NN_vi_surface Extension Type Instance extension Registered Extension Number 63 Revision 1 Ratification Status Not ratified Extension and Version Dependencies VK_KHR_surface Contact Mathias Heyer mheyer Last Modified Date 2016-12-02 IP Status No known IP claims. Contributors Mathias Heyer, NVIDIA Michael Chock, NVIDIA Yasuhiro Yoshioka, Nintendo Daniel Koch, NVIDIA The VK_NN_vi_surface extension is an instance extension. It provides a mechanism to create a VkSurfaceKHR object (defined by the VK_KHR_surface extension) associated with an nn::vi::Layer. vkCreateViSurfaceNN VkViSurfaceCreateInfoNN VkViSurfaceCreateFlagsNN VK_NN_VI_SURFACE_EXTENSION_NAME VK_NN_VI_SURFACE_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN 1) Does VI need a way to query for compatibility between a particular physical device (and queue family?) and a specific VI display? RESOLVED: No. It is currently always assumed that the device and display will always be compatible. 2) VkViSurfaceCreateInfoNN::window is intended to store an nn::vi::NativeWindowHandle, but its declared type is a bare void* to store the window handle. Why the discrepancy? RESOLVED: It is for C compatibility. The definition for the VI native window handle type is defined inside the nn::vi C++ namespace. This prevents its use in C source files. nn::vi::NativeWindowHandle is always defined to be void*, so this extension uses void* to match. Revision 1, 2016-12-2 (Michael Chock) Initial draft. Name String VK_NV_acquire_winrt_display Extension Type Device extension Registered Extension Number 346 Revision 1 Ratification Status Not ratified Extension and Version Dependencies VK_EXT_direct_mode_display Contact Jeff Juliano jjuliano Last Modified Date 2020-09-29 IP Status No known IP claims. Contributors Jeff Juliano, NVIDIA This extension allows an application to take exclusive control of a display on Windows 10 provided that the display is not already controlled by a compositor. Examples of compositors include the Windows desktop compositor, other applications using this Vulkan extension, and applications that Acquire a DisplayTarget using a WinRT command such as winrt::Windows::Devices::Display::Core::DisplayManager.TryAcquireTarget(). When control is acquired the application has exclusive access to the display until control is released or the application terminates. An applications attempt to acquire is denied if a different application has already acquired the display. vkAcquireWinrtDisplayNV vkGetWinrtDisplayNV VK_NV_ACQUIRE_WINRT_DISPLAY_EXTENSION_NAME VK_NV_ACQUIRE_WINRT_DISPLAY_SPEC_VERSION 1) What should the platform substring be for this extension: RESOLVED: The platform substring is Winrt. The substring Winrt matches the fact that the OS API exposing the acquire and release functionality is called WinRT. The substring Win32 is wrong because the related WinRT API is explicitly not a Win32 API. WinRT is a competing API family to the Win32 API family. The substring Windows is suboptimal because there could be more than one relevant API on the Windows platform. There is preference to use the more-specific substring Winrt. 2) Should vkAcquireWinrtDisplayNV take a winRT DisplayTarget, or a Vulkan display handle as input? RESOLVED: A Vulkan display handle. This matches the design of vkAcquireXlibDisplayEXT. 3) Should the acquire command be platform-independent named vkAcquireDisplayNV, or platform-specific named vkAcquireWinrtDisplayNV? RESOLVED: Add a platform-specific command. The inputs to the Acquire command are all Vulkan types. None are WinRT types. This opens the possibility of the winrt extension defining a platform-independent acquire command. The X11 acquire command does need to accept a platform-specific parameter. This could be handled by adding to a platform-independent acquire command a params structure to which platform-dependent types can be chained by pNext pointer. The prevailing opinion is that it would be odd to create a second platform-independent function that is used on the Windows 10 platform, but that is not used for the X11 platform. Since a Windows 10 platform-specific command is needed anyway for converting between vkDisplayKHR and platform-native handles, opinion was to create a platform-specific acquire function. 4) Should the vkGetWinrtDisplayNV parameter identifying a display be named deviceRelativeId or adapterRelativeId? RESOLVED: The WinRT name is AdapterRelativeId. The name adapter is the Windows analog to a Vulkan physical device. Vulkan already has precedent to use the name deviceLUID for the concept that Windows APIs call AdapterLuid. Keeping form with this precedent, the name deviceRelativeId is chosen. 5) Does vkAcquireWinrtDisplayNV cause the Windows desktop compositor to release a display? RESOLVED: No. vkAcquireWinrtDisplayNV does not itself cause the Windows desktop compositor to release a display. This action must be performed outside of Vulkan. Beginning with Windows 10 version 2004 it is possible to cause the Windows desktop compositor to release a display by using the Advanced display settings sub-page of the Display settings control panel. See https://docs.microsoft.com/en-us/windows-hardware/drivers/display/specialized-monitors 6) Where can one find additional information about custom compositors for Windows 10? RESOLVED: Relevant references are as follows. According to Microsofts documentation on "building a custom compositor", the ability to write a custom compositor is not a replacement for a fullscreen desktop window. The feature is for writing compositor apps that drive specialized hardware. Only certain editions of Windows 10 support custom compositors, "documented here". The product type can be queried from Windows 10. See https://docs.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-getproductinfo Revision 1, 2020-09-29 (Jeff Juliano) Initial draft Name String VK_NV_clip_space_w_scaling Extension Type Device extension Registered Extension Number 88 Revision 1 Ratification Status Not ratified Extension and Version Dependencies None Contact Eric Werness ewerness-nv Last Modified Date 2017-02-15 Contributors Eric Werness, NVIDIA Kedarnath Thangudu, NVIDIA Virtual Reality (VR) applications often involve a post-processing step to apply a barrel distortion to the rendered image to correct the pincushion distortion introduced by the optics in a VR device. The barrel distorted image has lower resolution along the edges compared to the center. Since the original image is rendered at high resolution, which is uniform across the complete image, a lot of pixels towards the edges do not make it to the final post-processed image. This extension provides a mechanism to render VR scenes at a non-uniform resolution, in particular a resolution that falls linearly from the center towards the edges. This is achieved by scaling the w coordinate of the vertices in the clip space before perspective divide. The clip space w coordinate of the vertices can be offset as of a function of x and y coordinates as follows: w' = w + Ax + By In the intended use case for viewport position scaling, an application should use a set of four viewports, one for each of the four quadrants of a Cartesian coordinate system. Each viewport is set to the dimension of the image, but is scissored to the quadrant it represents. The application should specify A and B coefficients of the w-scaling equation above, that have the same value, but different signs, for each of the viewports. The signs of A and B should match the signs of x and y for the quadrant that they represent such that the value of w' will always be greater than or equal to the original w value for the entire image. Since the offset to w, (Ax + By), is always positive, and increases with the absolute values of x and y, the effective resolution will fall off linearly from the center of the image to its edges. vkCmdSetViewportWScalingNV VkViewportWScalingNV Extending VkPipelineViewportStateCreateInfo: VkPipelineViewportWScalingStateCreateInfoNV VK_NV_CLIP_SPACE_W_SCALING_EXTENSION_NAME VK_NV_CLIP_SPACE_W_SCALING_SPEC_VERSION Extending VkDynamicState: VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV Extending VkStructureType: VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV 1) Is the pipeline structure name too long? RESOLVED: It fits with the naming convention. 2) Separate W scaling section or fold into coordinate transformations? RESOLVED: Leaving it as its own section for now. VkViewport viewports[4]; VkRect2D scissors[4]; VkViewportWScalingNV scalings[4]; for (int i = 0; i The payload: must be global needs the RayPayloadKHR attribute as an extra storage class struct [raypayload] HitPayload { float hitT : write(closesthit, miss) : read(caller); int instanceIndex : write(closesthit) : read(caller); float3 pos : write(closesthit) : read(caller); float3 nrm : write(closesthit) : read(caller); }; #define RayPayloadKHR 5338 [[vk::ext_storage_class(RayPayloadKHR)]] static HitPayload payload; Here is the declaration of a few invocation reordering functions: [[vk::ext_instruction(OpHitObjectRecordEmptyNV)]] void hitObjectRecordEmptyNV([[vk::ext_reference]] HitObjectNV hitObject); [[vk::ext_instruction(OpHitObjectTraceRayNV)]] void hitObjectTraceRayNV( [[vk::ext_reference]] HitObjectNV hitObject, RaytracingAccelerationStructure as, uint RayFlags, uint CullMask, uint SBTOffset, uint SBTStride, uint MissIndex, float3 RayOrigin, float RayTmin, float3 RayDirection, float RayTMax, [[vk::ext_reference]] [[vk::ext_storage_class(RayPayloadKHR)]] HitPayload payload ); [[vk::ext_instruction(OpReorderThreadWithHintNV)]] void reorderThreadWithHintNV(int Hint, int Bits); [[vk::ext_instruction(OpReorderThreadWithHitObjectNV)]] void reorderThreadWithHitObjectNV([[vk::ext_reference]] HitObjectNV hitObject); [[vk::ext_instruction(OpHitObjectExecuteShaderNV)]] void hitObjectExecuteShaderNV([[vk::ext_reference]] HitObjectNV hitObject, [[vk::ext_reference]] [[vk::ext_storage_class(RayPayloadKHR)]] HitPayload payload); [[vk::ext_instruction(OpHitObjectIsHitNV)]] bool hitObjectIsHitNV([[vk::ext_reference]] HitObjectNV hitObject); Using the function in the code, can be done like this if (USE_SER == 1) { createHitObjectNV(); HitObjectNV hObj; // hitObjectNV hObj; hitObjectRecordEmptyNV(hObj); //Initialize to an empty hit object hitObjectTraceRayNV(hObj, topLevelAS, rayFlags, 0xFF, 0, 0, 0, r.Origin, 0.0, r.Direction, INFINITE, payload); reorderThreadWithHitObjectNV(hObj); hitObjectExecuteShaderNV(hObj, payload); } Note: createHitObjectNV() needs to be call at least once. This can be also done in the main entry of the shader. Function with a payload parameter, needs to have the payload struct defined before. There are no templated declaration of the function. Revision 1, 2020-09-12 (Eric Werness, Ashwin Lele) Initial external release Name String VK_NV_ray_tracing_linear_swept_spheres Extension Type Device extension Registered Extension Number 430 Revision 1 Ratification Status Not ratified Extension and Version Dependencies VK_KHR_ray_tracing_pipeline SPIR-V Dependencies SPV_NV_linear_swept_spheres Contact Vikram Kushwaha vkushwaha Extension Proposal VK_NV_ray_tracing_linear_swept_spheres Last Modified Date 2025-01-03 Interactions and External Dependencies This extension requires SPV_NV_linear_swept_spheres This extension provides API support for GL_NV_linear_swept_spheres Contributors Vikram Kushwaha, NVIDIA Eric Werness, NVIDIA Daniel Koch, NVIDIA Ashwin Lele, NVIDIA Nathan Morrical, NVIDIA This extension adds two new primitives for ray tracing: a sphere primitive and a linear swept sphere (LSS) primitive. The purpose of the LSS primitive is to enable rendering of high quality hair and fur using a compact primitive representation encoded in the acceleration structure. Sphere primitives are defined by a position and a radius and are a subset of LSS, but are useful in their own right, for example for particle systems. This extension adds support for the following SPIR-V extension in Vulkan: SPV_NV_linear_swept_spheres Extending VkAccelerationStructureGeometryKHR: VkAccelerationStructureGeometryLinearSweptSpheresDataNV VkAccelerationStructureGeometrySpheresDataNV Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV VkRayTracingLssIndexingModeNV VkRayTracingLssPrimitiveEndCapsModeNV VK_NV_RAY_TRACING_LINEAR_SWEPT_SPHERES_EXTENSION_NAME VK_NV_RAY_TRACING_LINEAR_SWEPT_SPHERES_SPEC_VERSION Extending VkFormatFeatureFlagBits2: VK_FORMAT_FEATURE_2_ACCELERATION_STRUCTURE_RADIUS_BUFFER_BIT_NV Extending VkGeometryTypeKHR: VK_GEOMETRY_TYPE_LINEAR_SWEPT_SPHERES_NV VK_GEOMETRY_TYPE_SPHERES_NV Extending VkPipelineCreateFlagBits2: VK_PIPELINE_CREATE_2_RAY_TRACING_ALLOW_SPHERES_AND_LINEAR_SWEPT_SPHERES_BIT_NV Extending VkStructureType: VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_LINEAR_SWEPT_SPHERES_DATA_NV VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_SPHERES_DATA_NV VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_LINEAR_SWEPT_SPHERES_FEATURES_NV HitIsSphereNV HitIsLSSNV HitSpherePositionNV HitSphereRadiusNV HitLSSPositionsNV HitLSSRadiiNV RayTracingSpheresGeometryNV RayTracingLinearSweptSpheresGeometryNV Revision 1, 2025-01-03 (Vikram Kushwaha) Initial draft Name String VK_NV_ray_tracing_motion_blur Extension Type Device extension Registered Extension Number 328 Revision 1 Ratification Status Not ratified Extension and Version Dependencies VK_KHR_ray_tracing_pipeline SPIR-V Dependencies SPV_NV_ray_tracing_motion_blur Contact Eric Werness Last Modified Date 2021-06-16 Interactions and External Dependencies This extension provides API support for GL_NV_ray_tracing_motion_blur Contributors Eric Werness, NVIDIA Ashwin Lele, NVIDIA Ray tracing support in the API provides an efficient mechanism to intersect rays against static geometry, but rendering algorithms often want to support motion, which is more efficiently supported with motion-specific algorithms. This extension adds a set of mechanisms to support fast tracing of moving geometry: A ray pipeline trace call which takes a time parameter Flags to enable motion support in an acceleration structure Support for time-varying vertex positions in a geometry Motion instances to move existing instances over time The motion represented here is parameterized across a normalized timestep between 0.0 and 1.0. A motion trace using OpTraceRayMotionNV provides a time within that normalized range to be used when intersecting that ray with geometry. The geometry can be provided with motion by a combination of adding a second vertex position for time of 1.0 using VkAccelerationStructureGeometryMotionTrianglesDataNV and providing multiple transforms in the instance using VkAccelerationStructureMotionInstanceNV. VkAccelerationStructureMatrixMotionInstanceNV VkAccelerationStructureMotionInstanceNV VkAccelerationStructureSRTMotionInstanceNV VkSRTDataNV Extending VkAccelerationStructureCreateInfoKHR: VkAccelerationStructureMotionInfoNV Extending VkAccelerationStructureGeometryTrianglesDataKHR: VkAccelerationStructureGeometryMotionTrianglesDataNV Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceRayTracingMotionBlurFeaturesNV VkAccelerationStructureMotionInstanceDataNV VkAccelerationStructureMotionInstanceTypeNV VkAccelerationStructureMotionInfoFlagsNV VkAccelerationStructureMotionInstanceFlagsNV VK_NV_RAY_TRACING_MOTION_BLUR_EXTENSION_NAME VK_NV_RAY_TRACING_MOTION_BLUR_SPEC_VERSION Extending VkAccelerationStructureCreateFlagBitsKHR: VK_ACCELERATION_STRUCTURE_CREATE_MOTION_BIT_NV Extending VkBuildAccelerationStructureFlagBitsKHR: VK_BUILD_ACCELERATION_STRUCTURE_MOTION_BIT_NV Extending VkPipelineCreateFlagBits: VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV Extending VkStructureType: VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV (1) What size is VkAccelerationStructureMotionInstanceNV? Added a note on the structure size and made the stride explicit in the language. (2) Allow arrayOfPointers for motion TLAS? Yes, with a packed encoding to minimize the amount of data sent for metadata. Revision 1, 2020-06-16 (Eric Werness, Ashwin Lele) Initial external release Name String VK_NV_ray_tracing_validation Extension Type Device extension Registered Extension Number 569 Revision 1 Ratification Status Not ratified Extension and Version Dependencies None Contact Vikram Kushwaha vkushwaha-nv Extension Proposal VK_NV_ray_tracing_validation Last Modified Date 2024-03-04 Contributors Vikram Kushwaha, NVIDIA Eric Werness, NVIDIA Piers Daniell, NVIDIA This extension adds support for performing ray tracing validation at an implementation level. Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceRayTracingValidationFeaturesNV VK_NV_RAY_TRACING_VALIDATION_EXTENSION_NAME VK_NV_RAY_TRACING_VALIDATION_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_VALIDATION_FEATURES_NV Revision 1, 2024-03-04 (Vikram Kushwaha) Initial draft Name String VK_NV_representative_fragment_test Extension Type Device extension Registered Extension Number 167 Revision 2 Ratification Status Not ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 Contact Kedarnath Thangudu kthangudu Last Modified Date 2018-09-13 Contributors Kedarnath Thangudu, NVIDIA Christoph Kubisch, NVIDIA Pierre Boudier, NVIDIA Pat Brown, NVIDIA Jeff Bolz, NVIDIA Eric Werness, NVIDIA This extension provides a new representative fragment test that allows implementations to reduce the amount of rasterization and fragment processing work performed for each point, line, or triangle primitive. For any primitive that produces one or more fragments that pass all other early fragment tests, the implementation is permitted to choose one or more representative fragments for processing and discard all other fragments. For draw calls rendering multiple points, lines, or triangles arranged in lists, strips, or fans, the representative fragment test is performed independently for each of those primitives. This extension is useful for applications that use an early render pass to determine the full set of primitives that would be visible in the final scene. In this render pass, such applications would set up a fragment shader that enables early fragment tests and writes to an image or shader storage buffer to record the ID of the primitive that generated the fragment. Without this extension, the shader would record the ID separately for each visible fragment of each primitive. With this extension, fewer stores will be performed, particularly for large primitives. The representative fragment test has no effect if early fragment tests are not enabled via the fragment shader. The set of fragments discarded by the representative fragment test is implementation-dependent and may vary from frame to frame. In some cases, the representative fragment test may not discard any fragments for a given primitive. Extending VkGraphicsPipelineCreateInfo: VkPipelineRepresentativeFragmentTestStateCreateInfoNV Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV VK_NV_REPRESENTATIVE_FRAGMENT_TEST_EXTENSION_NAME VK_NV_REPRESENTATIVE_FRAGMENT_TEST_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV (1) Is the representative fragment test guaranteed to have any effect? RESOLVED: No. As specified, we only guarantee that each primitive with at least one fragment that passes prior tests will have one fragment passing the representative fragment tests. We do not guarantee that any particular fragment will fail the test. In the initial implementation of this extension, the representative fragment test is treated as an optimization that may be completely disabled for some pipeline states. This feature was designed for a use case where the fragment shader records information on individual primitives using shader storage buffers or storage images, with no writes to color or depth buffers. (2) Will the set of fragments that pass the representative fragment test be repeatable if you draw the same scene over and over again? RESOLVED: No. The set of fragments that pass the representative fragment test is implementation-dependent and may vary due to the timing of operations performed by the GPU. (3) What happens if you enable the representative fragment test with writes to color and/or depth render targets enabled? RESOLVED: If writes to the color or depth buffer are enabled, they will be performed for any fragments that survive the relevant tests. Any fragments that fail the representative fragment test will not update color buffers. For the use cases intended for this feature, we do not expect color or depth writes to be enabled. (4) How do derivatives and automatic texture LOD computations work with the representative fragment test enabled? RESOLVED: If a fragment shader uses derivative functions or texture lookups using automatic LOD computation, derivatives will be computed identically whether or not the representative fragment test is enabled. For the use cases intended for this feature, we do not expect the use of derivatives in the fragment shader. Revision 2, 2018-09-13 (pbrown) Add issues. Revision 1, 2018-08-22 (Kedarnath Thangudu) Internal Revisions Name String VK_NV_sample_mask_override_coverage Extension Type Device extension Registered Extension Number 95 Revision 1 Ratification Status Not ratified Extension and Version Dependencies None SPIR-V Dependencies SPV_NV_sample_mask_override_coverage Contact Piers Daniell pdaniell-nv Last Modified Date 2016-12-08 IP Status No known IP claims. Interactions and External Dependencies This extension provides API support for GL_NV_sample_mask_override_coverage Contributors Daniel Koch, NVIDIA Jeff Bolz, NVIDIA This extension adds support for the following SPIR-V extension in Vulkan: SPV_NV_sample_mask_override_coverage The extension provides access to the OverrideCoverageNV decoration under the SampleMaskOverrideCoverageNV capability. Adding this decoration to a variable with the SampleMask builtin decoration allows the shader to modify the coverage mask and affect which samples are used to process the fragment. When using GLSL source-based shader languages, the override_coverage layout qualifier from GL_NV_sample_mask_override_coverage maps to the OverrideCoverageNV decoration. To use the override_coverage layout qualifier in GLSL the GL_NV_sample_mask_override_coverage extension must be enabled. Behavior is described in the GL_NV_sample_mask_override_coverage extension spec. VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_EXTENSION_NAME VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_SPEC_VERSION OverrideCoverageNV in SampleMask SampleMaskOverrideCoverageNV Revision 1, 2016-12-08 (Piers Daniell) Internal revisions Name String VK_NV_scissor_exclusive Extension Type Device extension Registered Extension Number 206 Revision 2 Ratification Status Not ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 Contact Pat Brown nvpbrown Last Modified Date 2023-01-18 IP Status No known IP claims. Interactions and External Dependencies None Contributors Pat Brown, NVIDIA Jeff Bolz, NVIDIA Piers Daniell, NVIDIA Daniel Koch, NVIDIA This extension adds support for an exclusive scissor test to Vulkan. The exclusive scissor test behaves like the scissor test, except that the exclusive scissor test fails for pixels inside the corresponding rectangle and passes for pixels outside the rectangle. If the same rectangle is used for both the scissor and exclusive scissor tests, the exclusive scissor test will pass if and only if the scissor test fails. Version 2 of this extension introduces VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_ENABLE_NV and vkCmdSetExclusiveScissorEnableNV. Applications that use this dynamic state must ensure the implementation advertises at least specVersion 2 of this extension. vkCmdSetExclusiveScissorEnableNV vkCmdSetExclusiveScissorNV Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceExclusiveScissorFeaturesNV Extending VkPipelineViewportStateCreateInfo: VkPipelineViewportExclusiveScissorStateCreateInfoNV VK_NV_SCISSOR_EXCLUSIVE_EXTENSION_NAME VK_NV_SCISSOR_EXCLUSIVE_SPEC_VERSION Extending VkDynamicState: VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_ENABLE_NV VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV 1) For the scissor test, the viewport state must be created with a matching number of scissor and viewport rectangles. Should we have the same requirement for exclusive scissors? RESOLVED: For exclusive scissors, we relax this requirement and allow an exclusive scissor rectangle count that is either zero or equal to the number of viewport rectangles. If you pass in an exclusive scissor count of zero, the exclusive scissor test is treated as disabled. Revision 2, 2023-01-18 (Piers Daniell) Add dynamic state for explicit exclusive scissor enables Revision 1, 2018-07-31 (Pat Brown) Internal revisions Name String VK_NV_shader_atomic_float16_vector Extension Type Device extension Registered Extension Number 564 Revision 1 Ratification Status Not ratified Extension and Version Dependencies None SPIR-V Dependencies SPV_NV_shader_atomic_fp16_vector Contact Jeff Bolz jeffbolznv Last Modified Date 2024-02-03 IP Status No known IP claims. Interactions and External Dependencies This extension provides API support for GL_NV_shader_atomic_fp16_vector Contributors Jeff Bolz, NVIDIA This extension allows a shader to perform atomic add, min, max, and exchange operations on 2- and 4-component vectors of float16. Buffer, workgroup, and image storage classes are all supported. Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV VK_NV_SHADER_ATOMIC_FLOAT16_VECTOR_EXTENSION_NAME VK_NV_SHADER_ATOMIC_FLOAT16_VECTOR_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT16_VECTOR_FEATURES_NV None. AtomicFloat16VectorNV Revision 1, 2024-02-03 (Jeff Bolz) Internal revisions Name String VK_NV_shader_image_footprint Extension Type Device extension Registered Extension Number 205 Revision 2 Ratification Status Not ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 SPIR-V Dependencies SPV_NV_shader_image_footprint Contact Pat Brown nvpbrown Last Modified Date 2018-09-13 IP Status No known IP claims. Interactions and External Dependencies This extension provides API support for GL_NV_shader_texture_footprint Contributors Pat Brown, NVIDIA Chris Lentini, NVIDIA Daniel Koch, NVIDIA Jeff Bolz, NVIDIA This extension adds Vulkan support for the SPV_NV_shader_image_footprint SPIR-V extension. That SPIR-V extension provides a new instruction OpImageSampleFootprintNV allowing shaders to determine the set of texels that would be accessed by an equivalent filtered texture lookup. Instead of returning a filtered texture value, the instruction returns a structure that can be interpreted by shader code to determine the footprint of a filtered texture lookup. This structure includes integer values that identify a small neighborhood of texels in the image being accessed and a bitfield that indicates which texels in that neighborhood would be used. The structure also includes a bitfield where each bit identifies whether any texel in a small aligned block of texels would be fetched by the texture lookup. The size of each block is specified by an access granularity provided by the shader. The minimum granularity supported by this extension is 2x2 (for 2D textures) and 2x2x2 (for 3D textures); the maximum granularity is 256x256 (for 2D textures) or 64x32x32 (for 3D textures). Each footprint query returns the footprint from a single texture level. When using minification filters that combine accesses from multiple mipmap levels, shaders must perform separate queries for the two levels accessed (fine and coarse). The footprint query also returns a flag indicating if the texture lookup would access texels from only one mipmap level or from two neighboring levels. This extension should be useful for multi-pass rendering operations that do an initial expensive rendering pass to produce a first image that is then used as a texture for a second pass. If the second pass ends up accessing only portions of the first image (e.g., due to visibility), the work spent rendering the non-accessed portion of the first image was wasted. With this feature, an application can limit this waste using an initial pass over the geometry in the second image that performs a footprint query for each visible pixel to determine the set of pixels that it needs from the first image. This pass would accumulate an aggregate footprint of all visible pixels into a separate footprint image using shader atomics. Then, when rendering the first image, the application can kill all shading work for pixels not in this aggregate footprint. This extension has a number of limitations. The OpImageSampleFootprintNV instruction only supports for two- and three-dimensional textures. Footprint evaluation only supports the CLAMP_TO_EDGE wrap mode; results are undefined for all other wrap modes. Only a limited set of granularity values and that set does not support separate coverage information for each texel in the original image. When using SPIR-V generated from the OpenGL Shading Language, the new instruction will be generated from code using the new textureFootprint*NV built-in functions from the GL_NV_shader_texture_footprint shading language extension. Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceShaderImageFootprintFeaturesNV VK_NV_SHADER_IMAGE_FOOTPRINT_EXTENSION_NAME VK_NV_SHADER_IMAGE_FOOTPRINT_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV ImageFootprintNV (1) The footprint returned by the SPIR-V instruction is a structure that includes an anchor, an offset, and a mask that represents a 8x8 or 4x4x4 neighborhood of texel groups. But the bits of the mask are not stored in simple pitch order. Why is the footprint built this way? RESOLVED: We expect that applications using this feature will want to use a fixed granularity and accumulate coverage information from the returned footprints into an aggregate footprint image that tracks the portions of an image that would be needed by regular texture filtering. If an application is using a two-dimensional image with 4x4 pixel granularity, we expect that the footprint image will use 64-bit texels where each bit in an 8x8 array of bits corresponds to coverage for a 4x4 block in the original image. Texel (0,0) in the footprint image would correspond to texels (0,0) through (31,31) in the original image. In the usual case, the footprint for a single access will fully contained in a 32x32 aligned region of the original texture, which corresponds to a single 64-bit texel in the footprint image. In that case, the implementation will return an anchor coordinate pointing at the single footprint image texel, an offset vector of (0,0), and a mask whose bits are aligned with the bits in the footprint texel. For this case, the shader can simply atomically OR the mask bits into the contents of the footprint texel to accumulate footprint coverage. In the worst case, the footprint for a single access spans multiple 32x32 aligned regions and may require updates to four separate footprint image texels. In this case, the implementation will return an anchor coordinate pointing at the lower right footprint image texel and an offset will identify how many columns and rows of the returned 8x8 mask correspond to footprint texels to the left and above the anchor texel. If the anchor is (2,3), the 64 bits of the returned mask are arranged spatially as follows, where each 4x4 block is assigned a bit number that matches its bit number in the footprint image texels: +-------------------------+-------------------------+ | -- -- -- -- -- -- -- -- | -- -- -- -- -- -- -- -- | | -- -- -- -- -- -- -- -- | -- -- -- -- -- -- -- -- | | -- -- -- -- -- -- -- -- | -- -- -- -- -- -- -- -- | | -- -- -- -- -- -- -- -- | -- -- -- -- -- -- -- -- | | -- -- -- -- -- -- -- -- | -- -- -- -- -- -- -- -- | | -- -- -- -- -- -- 46 47 | 40 41 42 43 44 45 -- -- | | -- -- -- -- -- -- 54 55 | 48 49 50 51 52 53 -- -- | | -- -- -- -- -- -- 62 63 | 56 57 58 59 60 61 -- -- | +-------------------------+-------------------------+ | -- -- -- -- -- -- 06 07 | 00 01 02 03 04 05 -- -- | | -- -- -- -- -- -- 14 15 | 08 09 10 11 12 13 -- -- | | -- -- -- -- -- -- 22 23 | 16 17 18 19 20 21 -- -- | | -- -- -- -- -- -- 30 31 | 24 25 26 27 28 29 -- -- | | -- -- -- -- -- -- 38 39 | 32 33 34 35 36 37 -- -- | | -- -- -- -- -- -- -- -- | -- -- -- -- -- -- -- -- | | -- -- -- -- -- -- -- -- | -- -- -- -- -- -- -- -- | | -- -- -- -- -- -- -- -- | -- -- -- -- -- -- -- -- | +-------------------------+-------------------------+ To accumulate coverage for each of the four footprint image texels, a shader can AND the returned mask with simple masks derived from the x and y offset values and then atomically OR the updated mask bits into the contents of the corresponding footprint texel. uint64_t returnedMask = (uint64_t(footprint.mask.x) | (uint64_t(footprint.mask.y) > footprint.offset.x) * 0x0101010101010101UL); uint64_t bottomMask = 0xFFFFFFFFFFFFFFFFUL >> (8 * footprint.offset.y); uint64_t bottomRight = returnedMask & bottomMask & rightMask; uint64_t bottomLeft = returnedMask & bottomMask & (~rightMask); uint64_t topRight = returnedMask & (~bottomMask) & rightMask; uint64_t topLeft = returnedMask & (~bottomMask) & (~rightMask); (2) What should an application do to ensure maximum performance when accumulating footprints into an aggregate footprint image? RESOLVED: We expect that the most common usage of this feature will be to accumulate aggregate footprint coverage, as described in the previous issue. Even if you ignore the anisotropic filtering case where the implementation may return a granularity larger than that requested by the caller, each shader invocation will need to use atomic functions to update up to four footprint image texels for each LOD accessed. Having each active shader invocation perform multiple atomic operations can be expensive, particularly when neighboring invocations will want to update the same footprint image texels. Techniques can be used to reduce the number of atomic operations performed when accumulating coverage include: Have logic that detects returned footprints where all components of the returned offset vector are zero. In that case, the mask returned by the footprint function is guaranteed to be aligned with the footprint image texels and affects only a single footprint image texel. Have fragment shaders communicate using built-in functions from the VK_NV_shader_subgroup_partitioned extension or other shader subgroup extensions. If you have multiple invocations in a subgroup that need to update the same texel (x,y) in the footprint image, compute an aggregate footprint mask across all invocations in the subgroup updating that texel and have a single invocation perform an atomic operation using that aggregate mask. When the returned footprint spans multiple texels in the footprint image, each invocation need to perform four atomic operations. In the previous issue, we had an example that computed separate masks for topLeft, topRight, bottomLeft, and bottomRight. When the invocations in a subgroup have good locality, it might be the case the top left for some invocations might refer to footprint image texel (10,10), while neighbors might have their top left texels at (11,10), (10,11), and (11,11). If you compute separate masks for even/odd x and y values instead of left/right or top/bottom, the odd/odd mask for all invocations in the subgroup hold coverage for footprint image texel (11,11), which can be updated by a single atomic operation for the entire subgroup. TBD Revision 2, 2018-09-13 (Pat Brown) Add issue (2) with performance tips. Revision 1, 2018-08-12 (Pat Brown) Initial draft Name String VK_NV_shader_sm_builtins Extension Type Device extension Registered Extension Number 155 Revision 1 Ratification Status Not ratified Extension and Version Dependencies Vulkan Version 1.1 SPIR-V Dependencies SPV_NV_shader_sm_builtins Contact Daniel Koch dgkoch Last Modified Date 2019-05-28 Interactions and External Dependencies This extension provides API support for GL_NV_shader_sm_builtins Contributors Jeff Bolz, NVIDIA Eric Werness, NVIDIA This extension provides the ability to determine device-specific properties on NVIDIA GPUs. It provides the number of streaming multiprocessors (SMs), the maximum number of warps (subgroups) that can run on an SM, and shader builtins to enable invocations to identify which SM and warp a shader invocation is executing on. This extension enables support for the SPIR-V ShaderSMBuiltinsNV capability. These properties and built-ins should typically only be used for debugging purposes. Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceShaderSMBuiltinsFeaturesNV Extending VkPhysicalDeviceProperties2: VkPhysicalDeviceShaderSMBuiltinsPropertiesNV VK_NV_SHADER_SM_BUILTINS_EXTENSION_NAME VK_NV_SHADER_SM_BUILTINS_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV WarpsPerSMNV SMCountNV WarpIDNV SMIDNV ShaderSMBuiltinsNV What should we call this extension? RESOLVED: NV_shader_sm_builtins. Other options considered included: NV_shader_smid - but SMID is really easy to typo/confuse as SIMD. NV_shader_sm_info - but Info is typically reserved for input structures Revision 1, 2019-05-28 (Daniel Koch) Internal revisions Name String VK_NV_shader_subgroup_partitioned Extension Type Device extension Registered Extension Number 199 Revision 1 Ratification Status Not ratified Extension and Version Dependencies Vulkan Version 1.1 SPIR-V Dependencies SPV_NV_shader_subgroup_partitioned Contact Jeff Bolz jeffbolznv Last Modified Date 2018-03-17 Interactions and External Dependencies This extension provides API support for GL_NV_shader_subgroup_partitioned Contributors Jeff Bolz, NVIDIA This extension enables support for a new class of group operations on subgroups via the GL_NV_shader_subgroup_partitioned GLSL extension and SPV_NV_shader_subgroup_partitioned SPIR-V extension. Support for these new operations is advertised via the VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV bit. This extension requires Vulkan 1.1, for general subgroup support. VK_NV_SHADER_SUBGROUP_PARTITIONED_EXTENSION_NAME VK_NV_SHADER_SUBGROUP_PARTITIONED_SPEC_VERSION Extending VkSubgroupFeatureFlagBits: VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV Revision 1, 2018-03-17 (Jeff Bolz) Internal revisions Name String VK_NV_shading_rate_image Extension Type Device extension Registered Extension Number 165 Revision 3 Ratification Status Not ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 SPIR-V Dependencies SPV_NV_shading_rate Contact Pat Brown nvpbrown Last Modified Date 2019-07-18 Interactions and External Dependencies This extension provides API support for GL_NV_shading_rate_image Contributors Pat Brown, NVIDIA Carsten Rohde, NVIDIA Jeff Bolz, NVIDIA Daniel Koch, NVIDIA Mathias Schott, NVIDIA Matthew Netsch, Qualcomm Technologies, Inc. This extension allows applications to use a variable shading rate when processing fragments of rasterized primitives. By default, Vulkan will spawn one fragment shader for each pixel covered by a primitive. In this extension, applications can bind a shading rate image that can be used to vary the number of fragment shader invocations across the framebuffer. Some portions of the screen may be configured to spawn up to 16 fragment shaders for each pixel, while other portions may use a single fragment shader invocation for a 4x4 block of pixels. This can be useful for use cases like eye tracking, where the portion of the framebuffer that the user is looking at directly can be processed at high frequency, while distant corners of the image can be processed at lower frequency. Each texel in the shading rate image represents a fixed-size rectangle in the framebuffer, covering 16x16 pixels in the initial implementation of this extension. When rasterizing a primitive covering one of these rectangles, the Vulkan implementation reads a texel in the bound shading rate image and looks up the fetched value in a palette to determine a base shading rate. In addition to the API support controlling rasterization, this extension also adds Vulkan support for the SPV_NV_shading_rate extension to SPIR-V. That extension provides two fragment shader variable decorations that allow fragment shaders to determine the shading rate used for processing the fragment: FragmentSizeNV, which indicates the width and height of the set of pixels processed by the fragment shader. InvocationsPerPixel, which indicates the maximum number of fragment shader invocations that could be spawned for the pixel(s) covered by the fragment. When using SPIR-V in conjunction with the OpenGL Shading Language (GLSL), the fragment shader capabilities are provided by the GL_NV_shading_rate_image language extension and correspond to the built-in variables gl_FragmentSizeNV and gl_InvocationsPerPixelNV, respectively. vkCmdBindShadingRateImageNV vkCmdSetCoarseSampleOrderNV vkCmdSetViewportShadingRatePaletteNV VkCoarseSampleLocationNV VkCoarseSampleOrderCustomNV VkShadingRatePaletteNV Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceShadingRateImageFeaturesNV Extending VkPhysicalDeviceProperties2: VkPhysicalDeviceShadingRateImagePropertiesNV Extending VkPipelineViewportStateCreateInfo: VkPipelineViewportCoarseSampleOrderStateCreateInfoNV VkPipelineViewportShadingRateImageStateCreateInfoNV VkCoarseSampleOrderTypeNV VkShadingRatePaletteEntryNV VK_NV_SHADING_RATE_IMAGE_EXTENSION_NAME VK_NV_SHADING_RATE_IMAGE_SPEC_VERSION Extending VkAccessFlagBits: VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV Extending VkDynamicState: VK_DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV Extending VkImageLayout: VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV Extending VkImageUsageFlagBits: VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV Extending VkPipelineStageFlagBits: VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV (1) When using shading rates specifying coarse fragments covering multiple pixels, we will generate a combined coverage mask that combines the coverage masks of all pixels covered by the fragment. By default, these masks are combined in an implementation-dependent order. Should we provide a mechanism allowing applications to query or specify an exact order? RESOLVED: Yes, this feature is useful for cases where most of the fragment shader can be evaluated once for an entire coarse fragment, but where some per-pixel computations are also required. For example, a per-pixel alpha test may want to kill all the samples for some pixels in a coarse fragment. This sort of test can be implemented using an output sample mask, but such a shader would need to know which bit in the mask corresponds to each sample in the coarse fragment. We are including a mechanism to allow applications to specify the orders of coverage samples for each shading rate and sample count, either as static pipeline state or dynamically via a command buffer. This portion of the extension has its own feature bit. We will not be providing a query to determine the implementation-dependent default ordering. The thinking here is that if an application cares enough about the coarse fragment sample ordering to perform such a query, it could instead just set its own order, also using custom per-pixel sample locations if required. (2) For the pipeline stage VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV, should we specify a precise location in the pipeline the shading rate image is accessed (after geometry shading, but before the early fragment tests) or leave it under-specified in case there are other implementations that access the image in a different pipeline location? RESOLVED We are specifying the pipeline stage to be between the final pre-rasterization shader stage (VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT) and before the first stage used for fragment processing (VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT), which seems to be the natural place to access the shading rate image. (3) How do centroid-sampled variables work with fragments larger than one pixel? RESOLVED For single-pixel fragments, fragment shader inputs decorated with Centroid are sampled at an implementation-dependent location in the intersection of the area of the primitive being rasterized and the area of the pixel that corresponds to the fragment. With multi-pixel fragments, we follow a similar pattern, using the intersection of the primitive and the set of pixels corresponding to the fragment. One important thing to keep in mind when using such coarse shading rates is that fragment attributes are sampled at the center of the fragment by default, regardless of the set of pixels/samples covered by the fragment. For fragments with a size of 4x4 pixels, this center location will be more than two pixels (1.5 * sqrt(2)) away from the center of the pixels at the corners of the fragment. When rendering a primitive that covers only a small part of a coarse fragment, sampling a color outside the primitive can produce overly bright or dark color values if the color values have a large gradient. To deal with this, an application can use centroid sampling on attributes where extrapolation artifacts can lead to overly bright or dark pixels. Note that this same problem also exists for multisampling with single-pixel fragments, but is less severe because it only affects certain samples of a pixel and such bright/dark samples may be averaged with other samples that do not have a similar problem. Revision 3, 2019-07-18 (Mathias Schott) Fully list extension interfaces in this appendix. Revision 2, 2018-09-13 (Pat Brown) Miscellaneous edits preparing the specification for publication. Revision 1, 2018-08-08 (Pat Brown) Internal revisions Name String VK_NV_viewport_array2 Extension Type Device extension Registered Extension Number 97 Revision 1 Ratification Status Not ratified Extension and Version Dependencies None SPIR-V Dependencies SPV_NV_viewport_array2 Contact Daniel Koch dgkoch Last Modified Date 2017-02-15 Interactions and External Dependencies This extension provides API support for GL_NV_viewport_array2 This extension requires the geometryShader and multiViewport features. This extension interacts with the tessellationShader feature. Contributors Piers Daniell, NVIDIA Jeff Bolz, NVIDIA This extension adds support for the following SPIR-V extension in Vulkan: SPV_NV_viewport_array2 which allows a single primitive to be broadcast to multiple viewports and/or multiple layers. A new shader built-in output ViewportMaskNV is provided, which allows a single primitive to be output to multiple viewports simultaneously. Also, a new SPIR-V decoration is added to control whether the effective viewport index is added into the variable decorated with the Layer built-in decoration. These capabilities allow a single primitive to be output to multiple layers simultaneously. This extension allows variables decorated with the Layer and ViewportIndex built-ins to be exported from vertex or tessellation shaders, using the ShaderViewportIndexLayerNV capability. This extension adds a new ViewportMaskNV built-in decoration that is available for output variables in vertex, tessellation evaluation, and geometry shaders, and a new ViewportRelativeNV decoration that can be added on variables decorated with Layer when using the ShaderViewportMaskNV capability. When using GLSL source-based shading languages, the gl_ViewportMask[] built-in output variable and viewport_relative layout qualifier from GL_NV_viewport_array2 map to the ViewportMaskNV and ViewportRelativeNV decorations, respectively. Behavior is described in the GL_NV_viewport_array2 extension specification. The ShaderViewportIndexLayerNV capability is equivalent to the ShaderViewportIndexLayerEXT capability added by VK_EXT_shader_viewport_index_layer. VK_NV_VIEWPORT_ARRAY2_EXTENSION_NAME VK_NV_VIEWPORT_ARRAY2_SPEC_VERSION VK_NV_VIEWPORT_ARRAY_2_EXTENSION_NAME VK_NV_VIEWPORT_ARRAY_2_SPEC_VERSION (modified) Layer (modified) ViewportIndex ViewportMaskNV ViewportRelativeNV in Layer ShaderViewportIndexLayerNV ShaderViewportMaskNV Revision 1, 2017-02-15 (Daniel Koch) Internal revisions Name String VK_NV_viewport_swizzle Extension Type Device extension Registered Extension Number 99 Revision 1 Ratification Status Not ratified Extension and Version Dependencies None Contact Piers Daniell pdaniell-nv Last Modified Date 2016-12-22 Interactions and External Dependencies This extension requires multiViewport and geometryShader features to be useful. Contributors Daniel Koch, NVIDIA Jeff Bolz, NVIDIA This extension provides a new per-viewport swizzle that can modify the position of primitives sent to each viewport. New viewport swizzle state is added for each viewport, and a new position vector is computed for each vertex by selecting from and optionally negating any of the four components of the original position vector. This new viewport swizzle is useful for a number of algorithms, including single-pass cube map rendering (broadcasting a primitive to multiple faces and reorienting the vertex position for each face) and voxel rasterization. The per-viewport component remapping and negation provided by the swizzle allows application code to re-orient three-dimensional geometry with a view along any of the X, Y, or Z axes. If a perspective projection and depth buffering is required, 1/W buffering should be used, as described in the single-pass cube map rendering example in the Issues section below. VkViewportSwizzleNV Extending VkPipelineViewportStateCreateInfo: VkPipelineViewportSwizzleStateCreateInfoNV VkViewportCoordinateSwizzleNV VkPipelineViewportSwizzleStateCreateFlagsNV VK_NV_VIEWPORT_SWIZZLE_EXTENSION_NAME VK_NV_VIEWPORT_SWIZZLE_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV 1) Where does viewport swizzling occur in the pipeline? RESOLVED: Despite being associated with the viewport, viewport swizzling must happen prior to the viewport transform. In particular, it needs to be performed before clipping and perspective division. The viewport mask expansion (VK_NV_viewport_array2) and the viewport swizzle could potentially be performed before or after transform feedback, but feeding back several viewports worth of primitives with different swizzles does not seem particularly useful. This specification applies the viewport mask and swizzle after transform feedback, and makes primitive queries only count each primitive once. 2) Any interesting examples of how this extension, VK_NV_viewport_array2, and VK_NV_geometry_shader_passthrough can be used together in practice? RESOLVED: One interesting use case for this extension is for single-pass rendering to a cube map. In this example, the application would attach a cube map texture to a layered FBO where the six cube faces are treated as layers. Vertices are sent through the vertex shader without applying a projection matrix, where the gl_Position output is (x,y,z,1) and the center of the cube map is at (0,0,0). With unextended Vulkan, one could have a conventional instanced geometry shader that looks something like the following: layout(invocations = 6) in; // separate invocation per face layout(triangles) in; layout(triangle_strip) out; layout(max_vertices = 3) out; in Inputs { vec2 texcoord; vec3 normal; vec4 baseColor; } v[]; out Outputs { vec2 texcoord; vec3 normal; vec4 baseColor; }; void main() { int face = gl_InvocationID; // which face am I? // Project gl_Position for each vertex onto the cube map face. vec4 positions[3]; for (int i = 0; i maxSAD) { maxSAD = SAD; maxCoord = uvec2(x,y); } } } if (compareMode=MIN) { return vec4(minSAD, minCoord.x, minCoord.y, 0.0); } else { return vec4(maxSAD, maxCoord.x, maxCoord.y, 0.0); } } Below is the pseudocode for textureBlockMatchGatherSADQCOM. The pseudocode for textureBlockMatchGatherSSD follows an identical pattern. vec4 textureBlockMatchGatherSAD( sampler2D target, uvec2 targetCoord, samler2D reference, uvec2 refCoord, uvec2 blocksize) { vec4 out; for (uint x=0, x> 22); uint32_t minor = ((driverVersion) >> 12) & 0x3ff); uint32_t patch = ((driverVersion) & 0xfff); If the Adreno major.minor.patch version is greater than or equal to 512.469.0, then simply use the VK_STRUCTURE_TYPE values as defined in vulkan_core.h. If the version is less than or equal to 512.468.0, then use the alternate values for the two VK_STRUCTURE_TYPEs in the table below. Table 1. Adreno Driver Requirements Adreno Driver Version 512.468.0 and earlier 512.469.0 and later VK_STRUCTURE_TYPE_ RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM 1000282000 1000282001 VK_STRUCTURE_TYPE_ COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM 1000282001 1000282000 2) Should the extension support only rotations (e.g. 90, 180, 270-degrees), or also mirror transforms (e.g. vertical flips)? Mobile use cases only require rotation. Other display systems such as projectors might require a flipped transform. RESOLVED: In this version of the extension, the functionality is restricted to 90, 180, and 270-degree rotations to address mobile use cases. 3) How does this extension interact with VK_EXT_fragment_density_map? RESOLVED Some implementations may not be able to support a render pass that enables both render pass transform and fragment density maps. For simplicity, this extension disallows enabling both features within a single render pass. 4) What should this extension be named? We considered names such as rotated_rendering, pre_rotation and others. Since the functionality is limited to a render pass, it seemed the name should include render_pass. While the current extension is limited to rotations, it could be extended to other transforms (like mirror) in the future. RESOLVED The name render_pass_transform seems like the most accurate description of the introduced functionality. 5) How does this extension interact with VK_KHR_fragment_shading_rate? RESOLVED: For the same reasons as issue 3, this extension disallows enabling both pFragmentShadingRateAttachment and render pass transform within a single render pass. However, pipeline shading rate and primitive shading rate are supported, and their respective fragmentSize and PrimitiveShadingRateKHR are provided in the current (non-rotated) coordinate system. The implementation is responsible for transforming them to the rotated coordinate system. The set of supported shading rates may be different per transform. Supported rates queried from vkGetPhysicalDeviceFragmentShadingRatesKHR are in the native (rotated) coordinate system. This means that the application must swap the x/y of the reported rates to get the set of rates supported for 90 and 270 degree rotation. Revision 1, 2020-02-05 (Jeff Leger) Revision 2, 2021-03-09 (Matthew Netsch) Adds interactions with VK_KHR_fragment_shading_rate Revision 3, 2022-07-11 (Arpit Agarwal) Adds interactions with VK_QCOM_tile_properties Revision 4, 2023-12-13 (Matthew Netsch) Relax dependencies on VK_KHR_surface and VK_KHR_swapchain Name String VK_QCOM_rotated_copy_commands Extension Type Device extension Registered Extension Number 334 Revision 2 Ratification Status Not ratified Extension and Version Dependencies VK_KHR_copy_commands2 or Vulkan Version 1.3 Contact Matthew Netsch mnetsch Last Modified Date 2023-12-13 Interactions and External Dependencies This extension interacts with VK_KHR_swapchain This extension interacts with VK_KHR_surface Contributors Jeff Leger, Qualcomm Technologies, Inc. Matthew Netsch, Qualcomm Technologies, Inc. This extension extends adds an optional rotation transform to copy commands vkCmdBlitImage2KHR, vkCmdCopyImageToBuffer2KHR and vkCmdCopyBufferToImage2KHR. When copying between two resources, where one resource contains rotated content and the other does not, a rotated copy may be desired. This extension may be used in combination with VK_QCOM_render_pass_transform which adds rotated render passes. This extension adds an extension structure to the following commands: vkCmdBlitImage2KHR, vkCmdCopyImageToBuffer2KHR and vkCmdCopyBufferToImage2KHR 1) What is an appropriate name for the added extension structure? The style guide says Structures which extend other structures through the pNext chain should reflect the name of the base structure they extend., but in this case a single extension structure is used to extend three base structures (vkCmdBlitImage2KHR, vkCmdCopyImageToBuffer2KHR and vkCmdCopyBufferToImage2KHR). Creating three identical structures with unique names seemed undesirable. RESOLVED: Deviate from the style guide for extension structure naming. 2) Should this extension add a rotation capability to vkCmdCopyImage2KHR? RESOLVED: No. Use of rotated vkCmdBlitImage2KHR can fully address this use case. 3) Should this extension add a rotation capability to vkCmdResolveImage2KHR? RESOLVED No. Use of vkCmdResolveImage2KHR is very slow and extremely bandwidth intensive on Qualcomms GPU architecture and use of pResolveAttachments in vkRenderPass is the strongly preferred approach. Therefore, we choose not to introduce a rotation capability to vkCmdResolveImage2KHR. Extending VkBufferImageCopy2, VkImageBlit2: VkCopyCommandTransformInfoQCOM VK_QCOM_ROTATED_COPY_COMMANDS_EXTENSION_NAME VK_QCOM_ROTATED_COPY_COMMANDS_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM Revision 1, 2020-09-19 (Jeff Leger) Revision 2, 2023-12-13 (Matthew Netsch) Relax dependency on VK_KHR_swapchain Name String VK_QCOM_tile_memory_heap Extension Type Device extension Registered Extension Number 548 Revision 1 Ratification Status Not ratified Extension and Version Dependencies VK_KHR_get_memory_requirements2 and VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 API Interactions Interacts with VK_QCOM_tile_properties Contact Patrick Boyle pboyleQCOM Extension Proposal VK_QCOM_tile_memory_heap Last Modified Date 2025-05-05 Interactions and External Dependencies Interacts with VK_QCOM_tile_properties Interacts with VK_QCOM_tile_shading Contributors Patrick Boyle, Qualcomm Technologies, Inc. Matthew Netsch, Qualcomm Technologies, Inc. Srihari Babu Alla, Qualcomm Technologies, Inc. Kevin Matlage, Qualcomm Technologies, Inc. This extension adds a new memory heap which allows applications to allocate and manage tile memory. A tile memory heap is denoted by the new VK_MEMORY_HEAP_TILE_MEMORY_BIT_QCOM property. Memory contents within this heap behave differently than other heaps and only persist its memory contents within a command buffer submission batch boundary. This boundary may be extended to a queue submit boundary by querying queueSubmitBoundary in the new VkPhysicalDeviceTileMemoryHeapPropertiesQCOM structure. Tile memory from this heap can be bound to VkImages or VkBuffers. The following new usage flags VK_IMAGE_USAGE_TILE_MEMORY_BIT_QCOM, VK_BUFFER_USAGE_TILE_MEMORY_BIT_QCOM, VK_BUFFER_USAGE_2_TILE_MEMORY_BIT_QCOM were added for this. A new extended structure is added to get memory requirements for tile memory VkTileMemoryRequirementsQCOM. A new command is added to bind tile memory to a command buffer in order to access and persist tile memory contents while executing commands vkCmdBindTileMemoryQCOM. This extension can be used in combination with VK_QCOM_tile_properties with the new structure VkTileMemorySizeInfoQCOM. None. vkCmdBindTileMemoryQCOM Extending VkCommandBufferInheritanceInfo: VkTileMemoryBindInfoQCOM Extending VkMemoryRequirements2: VkTileMemoryRequirementsQCOM Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceTileMemoryHeapFeaturesQCOM Extending VkPhysicalDeviceProperties2: VkPhysicalDeviceTileMemoryHeapPropertiesQCOM If VK_QCOM_tile_properties is supported: Extending VkRenderPassCreateInfo, VkRenderPassCreateInfo2, VkRenderingInfo: VkTileMemorySizeInfoQCOM VK_QCOM_TILE_MEMORY_HEAP_EXTENSION_NAME VK_QCOM_TILE_MEMORY_HEAP_SPEC_VERSION Extending VkBufferUsageFlagBits: VK_BUFFER_USAGE_TILE_MEMORY_BIT_QCOM Extending VkBufferUsageFlagBits2: VK_BUFFER_USAGE_2_TILE_MEMORY_BIT_QCOM Extending VkImageUsageFlagBits: VK_IMAGE_USAGE_TILE_MEMORY_BIT_QCOM Extending VkMemoryHeapFlagBits: VK_MEMORY_HEAP_TILE_MEMORY_BIT_QCOM Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_FEATURES_QCOM VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_PROPERTIES_QCOM VK_STRUCTURE_TYPE_TILE_MEMORY_BIND_INFO_QCOM VK_STRUCTURE_TYPE_TILE_MEMORY_REQUIREMENTS_QCOM If VK_QCOM_tile_properties is supported: Extending VkStructureType: VK_STRUCTURE_TYPE_TILE_MEMORY_SIZE_INFO_QCOM Revision 1, 2025-03-26 (Patrick Boyle) Initial version Name String VK_QCOM_tile_properties Extension Type Device extension Registered Extension Number 485 Revision 1 Ratification Status Not ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 API Interactions Interacts with VK_VERSION_1_3 Interacts with VK_KHR_dynamic_rendering Contact Matthew Netsch mnetsch Extension Proposal VK_QCOM_tile_properties Last Modified Date 2022-07-11 Interactions and External Dependencies This extension interacts with VK_EXT_subpass_merge_feedback Contributors Jonathan Wicks, Qualcomm Technologies, Inc. Jonathan Tinkham, Qualcomm Technologies, Inc. Arpit Agarwal, Qualcomm Technologies, Inc. Jeff Leger, Qualcomm Technologies, Inc. This extension allows an application to query the tile properties. This extension supports both renderpasses and dynamic rendering. vkGetDynamicRenderingTilePropertiesQCOM vkGetFramebufferTilePropertiesQCOM VkTilePropertiesQCOM Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceTilePropertiesFeaturesQCOM If VK_KHR_dynamic_rendering or Vulkan Version 1.3 is supported: VkRenderingInfoKHR VK_QCOM_TILE_PROPERTIES_EXTENSION_NAME VK_QCOM_TILE_PROPERTIES_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM Revision 1, 2022-07-11 (Arpit Agarwal) Initial version Name String VK_QCOM_tile_shading Extension Type Device extension Registered Extension Number 310 Revision 1 Ratification Status Not ratified Extension and Version Dependencies VK_QCOM_tile_properties or VK_KHR_get_physical_device_properties2 SPIR-V Dependencies SPV_QCOM_tile_shading Contact Matthew Netsch mnetsch Extension Proposal VK_QCOM_tile_shading Last Modified Date 2023-10-12 IP Status No known IP claims. Interactions and External Dependencies This extension interacts with VK_KHR_dynamic_rendering This extension interacts with VK_EXT_transform_feedback This extension interacts with VK_EXT_debug_marker This extension interacts with VK_EXT_attachment_feedback_loop_layout This extension interacts with VK_KHR_dynamic_rendering_local_read This extension interacts with VK_QCOM_image_processing Contributors Jeff Leger, Qualcomm Matt Netsch, Qualcomm Srihari Babu Alla, Qualcomm Matthew Smith, Qualcomm Kevin Matlage, Qualcomm Alex Bourd, Qualcomm This extension exposes tile shading in Vulkan. Many mobile GPUs utilize Tile-Based Deferred Rendering (TBDR) to optimize for power and performance. Conversely, most desktop GPUs use immediate-mode rendering (IM). Adreno  GPUs uniquely have the ability to operate in either mode, and when this extension is not enabled, the Adreno driver will select the most optimal mode (TBDR or IM) based on the workload; this feature is called FlexRender . When this extension is in use, FlexRender is disabled and the GPU operates exclusively in TBDR wherever possible. The TBDR mode divides the color and depth/stencil buffer attachments into a regular grid of smaller regions called "tiles". When a render pass instance is submitted for execution on an Adreno GPU, the rendering is split into two phases: a single "visibility pass" followed by multiple "rendering passes" where a separate render pass is issued for each tile in the framebuffer. The "visibility pass" processes the geometry: identifies which tiles are covered by each primitive, eliminates occluded primitives and unneeded state changes, and performs other tile-specific optimizations. The primitive coverage information collected during the visibility pass is used in the subsequent "rendering pass" for each tile. During the rendering pass for each tile, any primitives that were determined not to cover the current tile are skipped. This deferred rasterization additionally utilizes a specialized high-bandwidth on-die memory, "tile memory". Tile memory is dramatically more efficient than other device memory. The tile memory temporarily stores the color and other attachments for each tile during rasterization. After each tile is fully rasterized, the resulting tile is typically copied to device memory backing the attachment as specified by the render pass STORE_OP. The per-tile rendering passes occur independently for each tile, with multiple tiles potentially being processed in parallel. This extension enables applications to leverage the power and performance of tile memory in new ways: Adds a mechanism for recording dispatches or draws that are guaranteed to be executed per-tile. Such draws bypass the above-mentioned visibility-based skipping and are guaranteed to be executed for every tile in the rendering pass. Shaders can declare "tile attachments" variables, providing shader access to color, depth/stencil, and input attachment pixels. Fragment and compute shaders can read these render pass attachments at any location within the tile. Compute shaders can also write to color attachments at any location within the tile. Shaders can use new built-in variables that provide the location, size, and apron region of the tile. A new tile dispatch command automatically scales workgroup sizes and counts to the tile size, given a desired shading rate. Framebuffer-local dependencies are expanded to tile-sized regions, rather than a single pixel or sample. A tile shading render pass can also enable tiling "aprons". This is a specialized rendering mode where the GPU renders overlapping tiles that enable specific use-cases. vkCmdBeginPerTileExecutionQCOM vkCmdDispatchTileQCOM vkCmdEndPerTileExecutionQCOM VkDispatchTileInfoQCOM VkPerTileBeginInfoQCOM VkPerTileEndInfoQCOM Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceTileShadingFeaturesQCOM Extending VkPhysicalDeviceProperties2: VkPhysicalDeviceTileShadingPropertiesQCOM Extending VkRenderPassCreateInfo, VkRenderPassCreateInfo2, VkRenderingInfo, VkCommandBufferInheritanceInfo: VkRenderPassTileShadingCreateInfoQCOM VkTileShadingRenderPassFlagBitsQCOM VkTileShadingRenderPassFlagsQCOM VK_QCOM_TILE_SHADING_EXTENSION_NAME VK_QCOM_TILE_SHADING_SPEC_VERSION Extending VkAccessFlagBits2: VK_ACCESS_2_SHADER_TILE_ATTACHMENT_READ_BIT_QCOM VK_ACCESS_2_SHADER_TILE_ATTACHMENT_WRITE_BIT_QCOM Extending VkStructureType: VK_STRUCTURE_TYPE_DISPATCH_TILE_INFO_QCOM VK_STRUCTURE_TYPE_PER_TILE_BEGIN_INFO_QCOM VK_STRUCTURE_TYPE_PER_TILE_END_INFO_QCOM VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_FEATURES_QCOM VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_PROPERTIES_QCOM VK_STRUCTURE_TYPE_RENDER_PASS_TILE_SHADING_CREATE_INFO_QCOM Extending VkSubpassDescriptionFlagBits: VK_SUBPASS_DESCRIPTION_TILE_SHADING_APRON_BIT_QCOM TileOffsetQCOM TileDimensionQCOM TileApronSizeQCOM TileShadingQCOM none Revision 1, 2023-10-12 (Jeff Leger) Name String VK_QCOM_ycbcr_degamma Extension Type Device extension Registered Extension Number 521 Revision 1 Ratification Status Not ratified Extension and Version Dependencies None Contact Matthew Netsch mnetsch Last Modified Date 2023-07-31 IP Status No known IP claims. Interactions and External Dependencies None Contributors Jeff Leger, Qualcomm Jonathan Wicks, Qualcomm This extension allows implementations to expose support for sRGB EOTF also known as sRGB degamma, used in combination with images using 8-bit YCBCR formats. In addition, the degamma can be selectively applied to the Y (luma) or CrCb (chroma). VK_KHR_sampler_ycbcr_conversion adds support for YCBCR conversion, but allows texture sampling in a non-linear space which can cause artifacts. This extension allows implementations to expose sRGB degamma for YCBCR formats, which is performed during texture filtering, allowing texture filtering to operate in a linear space. Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceYcbcrDegammaFeaturesQCOM Extending VkSamplerYcbcrConversionCreateInfo: VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM VK_QCOM_YCBCR_DEGAMMA_EXTENSION_NAME VK_QCOM_YCBCR_DEGAMMA_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM 1) Which YCBCR formats support the degamma feature? RESOLVED: For implementations that support the extension, each format that contains 8-bit R, G, and B components and supports either VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT or VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT must support degamma. Since non-compressed Vulkan sRGB formats are already limited to 8-bit components, and since Adreno supports degamma for all 8bit YCBCR formats, this extension does not introduce a new VK_FORMAT_FEATURE* bit for the degamma feature. 2) On which YCBCR components is the degamma applied? RESOLVED: While degamma is expected to be applied to only the Y (luma) component, the extension provides the ability to selectively enable degamma for both the Y (luma) and/or CbCr (chroma) components. 3) Should degamma be enabled for the sampler object or for the image view object? RESOLVED: Both. This extension extends VkSamplerYcbcrConversionCreateInfo and the specification already requires that both sampler and view objects must be created with an identical VkSamplerYcbcrConversionCreateInfo in their pNext chains. 4) Why apply the sRGB transfer function directly to YCBCR data when it would be more correct to use the ITU transfer function, and do so only after the values have been converted into non-linear RGB'? RESOLVED: YCBCR is frequently stored according to standards (e.g. BT.601 and BT.709) that specify that the conversion between linear and non-linear should use the ITU Transfer function. The ITU transfer function is mathematically different from the sRGB transfer function and while sRGB and ITU define similar curves, the difference is significant. Performing the sRGB degamma prior to range expansion can introduce artifacts if the content uses VK_SAMPLER_YCBCR_RANGE_ITU_NARROW encoding. Nevertheless, using sRGB can make sense for certain use cases where camera YCbCr images are known to be encoded with sRGB (or a pure gamma 2.2) transfer function and are known to use full-range encoding. For those use cases, this extension leverages the GPU ability to enable sRGB degamma at little cost, and can improve quality because texture filtering is able to occur in linear space. Revision 1, 2023-07-31 (Jeff Leger) Name String VK_QNX_external_memory_screen_buffer Extension Type Device extension Registered Extension Number 530 Revision 1 Ratification Status Not ratified Extension and Version Dependencies VK_KHR_sampler_ycbcr_conversion and VK_KHR_external_memory and VK_KHR_dedicated_allocation or Vulkan Version 1.1 and VK_EXT_queue_family_foreign Contact Mike Gorchak mgorchak-blackberry Aaron Ruby aruby-blackberry Last Modified Date 2023-05-17 IP Status No known IP claims. Contributors Mike Gorchak, QNX / Blackberry Limited Aaron Ruby, QNX / Blackberry Limited This extension enables an application to import QNX Screen _screen_buffer objects created outside of the Vulkan device into Vulkan memory objects, where they can be bound to images and buffers. Some _screen_buffer images have implementation-defined external formats that may not correspond to Vulkan formats. Sampler YCBCR conversion can be used to sample from these images and convert them to a known color space. _screen_buffer is strongly typed, so naming the handle type is redundant. The internal layout and therefore size of a _screen_buffer image may depend on native usage flags that do not have corresponding Vulkan counterparts. vkGetScreenBufferPropertiesQNX VkScreenBufferPropertiesQNX Extending VkImageCreateInfo, VkSamplerYcbcrConversionCreateInfo: VkExternalFormatQNX Extending VkMemoryAllocateInfo: VkImportScreenBufferInfoQNX Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX Extending VkScreenBufferPropertiesQNX: VkScreenBufferFormatPropertiesQNX VK_QNX_EXTERNAL_MEMORY_SCREEN_BUFFER_EXTENSION_NAME VK_QNX_EXTERNAL_MEMORY_SCREEN_BUFFER_SPEC_VERSION Extending VkExternalMemoryHandleTypeFlagBits: VK_EXTERNAL_MEMORY_HANDLE_TYPE_SCREEN_BUFFER_BIT_QNX Extending VkStructureType: VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX VK_STRUCTURE_TYPE_IMPORT_SCREEN_BUFFER_INFO_QNX VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCREEN_BUFFER_FEATURES_QNX VK_STRUCTURE_TYPE_SCREEN_BUFFER_FORMAT_PROPERTIES_QNX VK_STRUCTURE_TYPE_SCREEN_BUFFER_PROPERTIES_QNX Revision 1, 2023-05-17 (Mike Gorchak) Initial version Name String VK_QNX_screen_surface Extension Type Instance extension Registered Extension Number 379 Revision 1 Ratification Status Not ratified Extension and Version Dependencies VK_KHR_surface Contact Mike Gorchak mgorchak-blackberry Last Modified Date 2021-01-11 IP Status No known IP claims. Contributors Mike Gorchak, BlackBerry Limited The VK_QNX_screen_surface extension is an instance extension. It provides a mechanism to create a VkSurfaceKHR object (defined by the VK_KHR_surface extension) that refers to a QNX Screen window, as well as a query to determine support for rendering to a QNX Screen compositor. vkCreateScreenSurfaceQNX vkGetPhysicalDeviceScreenPresentationSupportQNX VkScreenSurfaceCreateInfoQNX VkScreenSurfaceCreateFlagsQNX VK_QNX_SCREEN_SURFACE_EXTENSION_NAME VK_QNX_SCREEN_SURFACE_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_SCREEN_SURFACE_CREATE_INFO_QNX Revision 1, 2021-01-11 (Mike Gorchak) Initial draft. Name String VK_SEC_amigo_profiling Extension Type Device extension Registered Extension Number 486 Revision 1 Ratification Status Not ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 Contact Ralph Potter r_potter Last Modified Date 2022-07-29 IP Status No known IP claims. Contributors Ralph Potter, Samsung Sangrak Oh, Samsung Jinku Kang, Samsung This extension is intended to communicate information from layered API implementations such as ANGLE to internal proprietary system schedulers. It has no behavioral implications beyond enabling more intelligent behavior from the system scheduler. Application developers should avoid using this extension. It is documented solely for the benefit of tools and layer developers, who may need to manipulate pNext chains that include these structures. There is currently no specification language written for this extension. The links to APIs defined by the extension are to stubs that only include generated content such as API declarations and implicit valid usage statements. This extension is only intended for use in specific embedded environments with known implementation details, and is therefore undocumented. Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceAmigoProfilingFeaturesSEC Extending VkSubmitInfo: VkAmigoProfilingSubmitInfoSEC VK_SEC_AMIGO_PROFILING_EXTENSION_NAME VK_SEC_AMIGO_PROFILING_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC There is currently no specification language written for this type. This section acts only as placeholder and to avoid dead links in the specification and reference pages. // Provided by VK_SEC_amigo_profiling typedef struct VkPhysicalDeviceAmigoProfilingFeaturesSEC { VkStructureType sType; void* pNext; VkBool32 amigoProfiling; } VkPhysicalDeviceAmigoProfilingFeaturesSEC; Valid Usage (Implicit) VUID-VkPhysicalDeviceAmigoProfilingFeaturesSEC-sType-sType sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC There is currently no specification language written for this type. This section acts only as placeholder and to avoid dead links in the specification and reference pages. // Provided by VK_SEC_amigo_profiling typedef struct VkAmigoProfilingSubmitInfoSEC { VkStructureType sType; const void* pNext; uint64_t firstDrawTimestamp; uint64_t swapBufferTimestamp; } VkAmigoProfilingSubmitInfoSEC; Valid Usage (Implicit) VUID-VkAmigoProfilingSubmitInfoSEC-sType-sType sType must be VK_STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC Revision 1, 2022-07-29 (Ralph Potter) Initial specification Name String VK_VALVE_descriptor_set_host_mapping Extension Type Device extension Registered Extension Number 421 Revision 1 Ratification Status Not ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 Special Use D3D support Contact Hans-Kristian Arntzen HansKristian-Work Last Modified Date 2022-02-22 IP Status No known IP claims. Contributors Hans-Kristian Arntzen, Valve This extension allows applications to directly query a host pointer for a VkDescriptorSet which can be used to copy descriptors between descriptor sets without the use of an API command. Memory offsets and sizes for descriptors can be queried from a VkDescriptorSetLayout as well. There is currently no specification language written for this extension. The links to APIs defined by the extension are to stubs that only include generated content such as API declarations and implicit valid usage statements. This extension is only intended for use in specific embedded environments with known implementation details, and is therefore undocumented. vkGetDescriptorSetHostMappingVALVE vkGetDescriptorSetLayoutHostMappingInfoVALVE VkDescriptorSetBindingReferenceVALVE VkDescriptorSetLayoutHostMappingInfoVALVE Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE VK_VALVE_DESCRIPTOR_SET_HOST_MAPPING_EXTENSION_NAME VK_VALVE_DESCRIPTOR_SET_HOST_MAPPING_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE There is currently no specification language written for this command. This section acts only as placeholder and to avoid dead links in the specification and reference pages. // Provided by VK_VALVE_descriptor_set_host_mapping void vkGetDescriptorSetLayoutHostMappingInfoVALVE( VkDevice device, const VkDescriptorSetBindingReferenceVALVE* pBindingReference, VkDescriptorSetLayoutHostMappingInfoVALVE* pHostMapping); Valid Usage (Implicit) VUID-vkGetDescriptorSetLayoutHostMappingInfoVALVE-device-parameter device must be a valid VkDevice handle VUID-vkGetDescriptorSetLayoutHostMappingInfoVALVE-pBindingReference-parameter pBindingReference must be a valid pointer to a valid VkDescriptorSetBindingReferenceVALVE structure VUID-vkGetDescriptorSetLayoutHostMappingInfoVALVE-pHostMapping-parameter pHostMapping must be a valid pointer to a VkDescriptorSetLayoutHostMappingInfoVALVE structure There is currently no specification language written for this command. This section acts only as placeholder and to avoid dead links in the specification and reference pages. // Provided by VK_VALVE_descriptor_set_host_mapping void vkGetDescriptorSetHostMappingVALVE( VkDevice device, VkDescriptorSet descriptorSet, void** ppData); Valid Usage (Implicit) VUID-vkGetDescriptorSetHostMappingVALVE-device-parameter device must be a valid VkDevice handle VUID-vkGetDescriptorSetHostMappingVALVE-descriptorSet-parameter descriptorSet must be a valid VkDescriptorSet handle VUID-vkGetDescriptorSetHostMappingVALVE-ppData-parameter ppData must be a valid pointer to a pointer value VUID-vkGetDescriptorSetHostMappingVALVE-descriptorSet-parent descriptorSet must have been created, allocated, or retrieved from device There is currently no specification language written for this type. This section acts only as placeholder and to avoid dead links in the specification and reference pages. // Provided by VK_VALVE_descriptor_set_host_mapping typedef struct VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE { VkStructureType sType; void* pNext; VkBool32 descriptorSetHostMapping; } VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE; Valid Usage (Implicit) VUID-VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE-sType-sType sType must be VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE There is currently no specification language written for this type. This section acts only as placeholder and to avoid dead links in the specification and reference pages. // Provided by VK_VALVE_descriptor_set_host_mapping typedef struct VkDescriptorSetBindingReferenceVALVE { VkStructureType sType; const void* pNext; VkDescriptorSetLayout descriptorSetLayout; uint32_t binding; } VkDescriptorSetBindingReferenceVALVE; Valid Usage (Implicit) VUID-VkDescriptorSetBindingReferenceVALVE-sType-sType sType must be VK_STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE VUID-VkDescriptorSetBindingReferenceVALVE-pNext-pNext pNext must be NULL VUID-VkDescriptorSetBindingReferenceVALVE-descriptorSetLayout-parameter descriptorSetLayout must be a valid VkDescriptorSetLayout handle There is currently no specification language written for this type. This section acts only as placeholder and to avoid dead links in the specification and reference pages. // Provided by VK_VALVE_descriptor_set_host_mapping typedef struct VkDescriptorSetLayoutHostMappingInfoVALVE { VkStructureType sType; void* pNext; size_t descriptorOffset; uint32_t descriptorSize; } VkDescriptorSetLayoutHostMappingInfoVALVE; Valid Usage (Implicit) VUID-VkDescriptorSetLayoutHostMappingInfoVALVE-sType-sType sType must be VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE VUID-VkDescriptorSetLayoutHostMappingInfoVALVE-pNext-pNext pNext must be NULL Revision 1, 2022-02-22 (Hans-Kristian Arntzen) Initial specification Name String VK_KHR_portability_subset Extension Type Device extension Registered Extension Number 164 Revision 1 Ratification Status Ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 This is a provisional extension and must be used with caution. See the description of provisional header files for enablement and stability details. Contact Bill Hollings billhollings Last Modified Date 2020-07-21 IP Status No known IP claims. Contributors Bill Hollings, The Brenwill Workshop Ltd. Daniel Koch, NVIDIA Dzmitry Malyshau, Mozilla Chip Davis, CodeWeavers Dan Ginsburg, Valve Mike Weiblen, LunarG Neil Trevett, NVIDIA Alexey Knyazev, Independent The VK_KHR_portability_subset extension allows a non-conformant Vulkan implementation to be built on top of another non-Vulkan graphics API, and identifies differences between that implementation and a fully-conformant native Vulkan implementation. This extension provides Vulkan implementations with the ability to mark otherwise-required capabilities as unsupported, or to establish additional properties and limits that the application should adhere to in order to guarantee portable behavior and operation across platforms, including platforms where Vulkan is not natively supported. The goal of this specification is to document, and make queryable, capabilities which are required to be supported by a fully-conformant Vulkan 1.0 implementation, but may be optional for an implementation of the Vulkan 1.0 Portability Subset. The intent is that this extension will be advertised only on implementations of the Vulkan 1.0 Portability Subset, and not on conformant implementations of Vulkan 1.0. Fully-conformant Vulkan implementations provide all the required capabilities, and so will not provide this extension. Therefore, the existence of this extension can be used to determine that an implementation is likely not fully conformant with the Vulkan spec. If this extension is supported by the Vulkan implementation, the application must enable this extension. This extension defines several new structures that can be chained to the existing structures used by certain standard Vulkan calls, in order to query for non-conformant portable behavior. Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDevicePortabilitySubsetFeaturesKHR Extending VkPhysicalDeviceProperties2: VkPhysicalDevicePortabilitySubsetPropertiesKHR VK_KHR_PORTABILITY_SUBSET_EXTENSION_NAME VK_KHR_PORTABILITY_SUBSET_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR None. Revision 1, 2020-07-21 (Bill Hollings) Initial draft. Name String VK_AMDX_shader_enqueue Extension Type Device extension Registered Extension Number 135 Revision 2 Ratification Status Not ratified Extension and Version Dependencies VK_KHR_synchronization2 and VK_KHR_spirv_1_4 and VK_EXT_extended_dynamic_state or Vulkan Version 1.3 and VK_KHR_maintenance5 and VK_KHR_pipeline_library This is a provisional extension and must be used with caution. See the description of provisional header files for enablement and stability details. API Interactions Interacts with VK_VERSION_1_4 Interacts with VK_EXT_mesh_shader Interacts with VK_KHR_maintenance5 SPIR-V Dependencies SPV_AMDX_shader_enqueue Contact Tobias Hector tobski Extension Proposal VK_AMDX_shader_enqueue Last Modified Date 2024-07-17 Provisional This extension is provisional and should not be used in production applications. The functionality may change in ways that break backwards compatibility between revisions, and before final release. Contributors Tobias Hector, AMD Matthaeus Chajdas, AMD Maciej Jesionowski, AMD Robert Martin, AMD Qun Lin, AMD Rex Xu, AMD Dominik Witczak, AMD Karthik Srinivasan, AMD Nicolai Haehnle, AMD Stuart Smith, AMD This extension adds the ability for developers to enqueue mesh and compute shader workgroups from other compute shaders. vkCmdDispatchGraphAMDX vkCmdDispatchGraphIndirectAMDX vkCmdDispatchGraphIndirectCountAMDX vkCmdInitializeGraphScratchMemoryAMDX vkCreateExecutionGraphPipelinesAMDX vkGetExecutionGraphPipelineNodeIndexAMDX vkGetExecutionGraphPipelineScratchSizeAMDX VkDispatchGraphCountInfoAMDX VkDispatchGraphInfoAMDX VkExecutionGraphPipelineCreateInfoAMDX VkExecutionGraphPipelineScratchSizeAMDX Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceShaderEnqueueFeaturesAMDX Extending VkPhysicalDeviceProperties2: VkPhysicalDeviceShaderEnqueuePropertiesAMDX Extending VkPipelineShaderStageCreateInfo: VkPipelineShaderStageNodeCreateInfoAMDX VkDeviceOrHostAddressConstAMDX VK_AMDX_SHADER_ENQUEUE_EXTENSION_NAME VK_AMDX_SHADER_ENQUEUE_SPEC_VERSION VK_SHADER_INDEX_UNUSED_AMDX Extending VkBufferUsageFlagBits: VK_BUFFER_USAGE_EXECUTION_GRAPH_SCRATCH_BIT_AMDX Extending VkPipelineBindPoint: VK_PIPELINE_BIND_POINT_EXECUTION_GRAPH_AMDX Extending VkStructureType: VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_CREATE_INFO_AMDX VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_SCRATCH_SIZE_AMDX VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_FEATURES_AMDX VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_PROPERTIES_AMDX VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_NODE_CREATE_INFO_AMDX If VK_KHR_maintenance5 or Vulkan Version 1.4 is supported: Extending VkBufferUsageFlagBits2: VK_BUFFER_USAGE_2_EXECUTION_GRAPH_SCRATCH_BIT_AMDX Extending VkPipelineCreateFlagBits2: VK_PIPELINE_CREATE_2_EXECUTION_GRAPH_BIT_AMDX Revision 2, 2024-07-17 (Tobias Hector) Add mesh nodes Revision 1, 2021-07-22 (Tobias Hector) Initial revision Name String VK_NV_cuda_kernel_launch Extension Type Device extension Registered Extension Number 308 Revision 2 Ratification Status Not ratified Extension and Version Dependencies None This is a provisional extension and must be used with caution. See the description of provisional header files for enablement and stability details. API Interactions Interacts with VK_EXT_debug_report Contact Tristan Lorach tlorach Last Modified Date 2020-09-30 Contributors Eric Werness, NVIDIA Interoperability between APIs can sometimes create additional overhead depending on the platform used. This extension targets deployment of existing CUDA kernels via Vulkan, with a way to directly upload PTX kernels and dispatch the kernels from Vulkans command buffer without the need to use interoperability between the Vulkan and CUDA contexts. However, we do encourage actual development using the native CUDA runtime for the purpose of debugging and profiling. The application will first have to create a CUDA module using vkCreateCudaModuleNV then create the CUDA function entry point with vkCreateCudaFunctionNV. Then in order to dispatch this function, the application will create a command buffer where it will launch the kernel with vkCmdCudaLaunchKernelNV. When done, the application will then destroy the function handle, as well as the CUDA module handle with vkDestroyCudaFunctionNV and vkDestroyCudaModuleNV. To reduce the impact of compilation time, this extension offers the capability to return a binary cache from the PTX that was provided. For this, a first query for the required cache size is made with vkGetCudaModuleCacheNV with a NULL pointer to a buffer and with a valid pointer receiving the size; then another call of the same function with a valid pointer to a buffer to retrieve the data. The resulting cache could then be used later for further runs of this application by sending this cache instead of the PTX code (using the same vkCreateCudaModuleNV), thus significantly speeding up the initialization of the CUDA module. As with VkPipelineCache, the binary cache depends on the hardware architecture. The application must assume the cache might fail, and need to handle falling back to the original PTX code as necessary. Most often, the cache will succeed if the same GPU driver and architecture is used between the cache generation from PTX and the use of this cache. In the event of a new driver version, or if using a different GPU architecture, the cache is likely to become invalid. VkCudaFunctionNV VkCudaModuleNV vkCmdCudaLaunchKernelNV vkCreateCudaFunctionNV vkCreateCudaModuleNV vkDestroyCudaFunctionNV vkDestroyCudaModuleNV vkGetCudaModuleCacheNV VkCudaFunctionCreateInfoNV VkCudaLaunchInfoNV VkCudaModuleCreateInfoNV Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceCudaKernelLaunchFeaturesNV Extending VkPhysicalDeviceProperties2: VkPhysicalDeviceCudaKernelLaunchPropertiesNV VK_NV_CUDA_KERNEL_LAUNCH_EXTENSION_NAME VK_NV_CUDA_KERNEL_LAUNCH_SPEC_VERSION Extending VkObjectType: VK_OBJECT_TYPE_CUDA_FUNCTION_NV VK_OBJECT_TYPE_CUDA_MODULE_NV Extending VkStructureType: VK_STRUCTURE_TYPE_CUDA_FUNCTION_CREATE_INFO_NV VK_STRUCTURE_TYPE_CUDA_LAUNCH_INFO_NV VK_STRUCTURE_TYPE_CUDA_MODULE_CREATE_INFO_NV VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_FEATURES_NV VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_PROPERTIES_NV If VK_EXT_debug_report is supported: Extending VkDebugReportObjectTypeEXT: VK_DEBUG_REPORT_OBJECT_TYPE_CUDA_FUNCTION_NV_EXT VK_DEBUG_REPORT_OBJECT_TYPE_CUDA_MODULE_NV_EXT None. Revision 1, 2020-03-01 (Tristan Lorach) Revision 2, 2020-09-30 (Tristan Lorach) Name String VK_NV_present_metering Extension Type Device extension Registered Extension Number 614 Revision 1 Ratification Status Not ratified Extension and Version Dependencies None This is a provisional extension and must be used with caution. See the description of provisional header files for enablement and stability details. Contact Charles Hansen chansen Last Modified Date 2025-01-08 Provisional *This extension is provisional and should not be used in production applications. The functionality defined by this extension may change in ways that break backwards compatibility between revisions, and before the final release of the non-provisional version of this extension. Contributors Charles Hansen, NVIDIA Lionel Duc, NVIDIA This extension is used to evenly meter presents. Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDevicePresentMeteringFeaturesNV Extending VkPresentInfoKHR: VkSetPresentConfigNV VK_NV_PRESENT_METERING_EXTENSION_NAME VK_NV_PRESENT_METERING_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_METERING_FEATURES_NV VK_STRUCTURE_TYPE_SET_PRESENT_CONFIG_NV Revision 1, 2025-01-08 (Charles Hansen) Internal revisions Name String VK_KHR_16bit_storage Extension Type Device extension Registered Extension Number 84 Revision 1 Ratification Status Ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 and VK_KHR_storage_buffer_storage_class or Vulkan Version 1.1 SPIR-V Dependencies SPV_KHR_16bit_storage Deprecation State Promoted to Vulkan 1.1 Contact Jan-Harald Fredriksen janharaldfredriksen-arm Last Modified Date 2017-09-05 IP Status No known IP claims. Interactions and External Dependencies This extension provides API support for GL_EXT_shader_16bit_storage Contributors Alexander Galazin, ARM Jan-Harald Fredriksen, ARM Joerg Wagner, ARM Neil Henning, Codeplay Jeff Bolz, Nvidia Daniel Koch, Nvidia David Neto, Google John Kessenich, Google The VK_KHR_16bit_storage extension allows use of 16-bit types in shader input and output interfaces, and push constant blocks. This extension introduces several new optional features which map to SPIR-V capabilities and allow access to 16-bit data in Block-decorated objects in the Uniform and the StorageBuffer storage classes, and objects in the PushConstant storage class. This extension allows 16-bit variables to be declared and used as user-defined shader inputs and outputs but does not change location assignment and component assignment rules. All functionality in this extension is included in core Vulkan 1.1, with the KHR suffix omitted. However, if Vulkan 1.1 is supported and this extension is not, the storageBuffer16BitAccess capability is optional. The original type, enum, and command names are still available as aliases of the core functionality. If Vulkan 1.4 is supported, support for the storageBuffer16BitAccess capability is required. Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDevice16BitStorageFeaturesKHR VK_KHR_16BIT_STORAGE_EXTENSION_NAME VK_KHR_16BIT_STORAGE_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR StorageBuffer16BitAccess UniformAndStorageBuffer16BitAccess StoragePushConstant16 StorageInputOutput16 Revision 1, 2017-03-23 (Alexander Galazin) Initial draft Name String VK_KHR_8bit_storage Extension Type Device extension Registered Extension Number 178 Revision 1 Ratification Status Ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 and VK_KHR_storage_buffer_storage_class or Vulkan Version 1.1 SPIR-V Dependencies SPV_KHR_8bit_storage Deprecation State Promoted to Vulkan 1.2 Contact Alexander Galazin alegal-arm Last Modified Date 2018-02-05 Interactions and External Dependencies This extension provides API support for GL_EXT_shader_16bit_storage IP Status No known IP claims. Contributors Alexander Galazin, Arm The VK_KHR_8bit_storage extension allows use of 8-bit types in uniform and storage buffers, and push constant blocks. This extension introduces several new optional features which map to SPIR-V capabilities and allow access to 8-bit data in Block-decorated objects in the Uniform and the StorageBuffer storage classes, and objects in the PushConstant storage class. The StorageBuffer8BitAccess capability must be supported by all implementations of this extension. The other capabilities are optional. Vulkan APIs in this extension are included in core Vulkan 1.2, with the KHR suffix omitted. However, if Vulkan 1.2 is supported and this extension is not, the StorageBuffer8BitAccess capability is optional. External interactions defined by this extension, such as SPIR-V token names, retain their original names. The original Vulkan API names are still available as aliases of the core functionality. If Vulkan 1.4 is supported, support for the storageBuffer8BitAccess capability is required. Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDevice8BitStorageFeaturesKHR VK_KHR_8BIT_STORAGE_EXTENSION_NAME VK_KHR_8BIT_STORAGE_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR StorageBuffer8BitAccess UniformAndStorageBuffer8BitAccess StoragePushConstant8 Revision 1, 2018-02-05 (Alexander Galazin) Initial draft Name String VK_KHR_bind_memory2 Extension Type Device extension Registered Extension Number 158 Revision 1 Ratification Status Ratified Extension and Version Dependencies None Deprecation State Promoted to Vulkan 1.1 Contact Tobias Hector tobski Last Modified Date 2017-09-05 IP Status No known IP claims. Contributors Jeff Bolz, NVIDIA Tobias Hector, Imagination Technologies This extension provides versions of vkBindBufferMemory and vkBindImageMemory that allow multiple bindings to be performed at once, and are extensible. This extension also introduces VK_IMAGE_CREATE_ALIAS_BIT_KHR, which allows identical images that alias the same memory to interpret the contents consistently, even across image layout changes. All functionality in this extension is included in core Vulkan 1.1, with the KHR suffix omitted. The original type, enum, and command names are still available as aliases of the core functionality. vkBindBufferMemory2KHR vkBindImageMemory2KHR VkBindBufferMemoryInfoKHR VkBindImageMemoryInfoKHR VK_KHR_BIND_MEMORY_2_EXTENSION_NAME VK_KHR_BIND_MEMORY_2_SPEC_VERSION Extending VkImageCreateFlagBits: VK_IMAGE_CREATE_ALIAS_BIT_KHR Extending VkStructureType: VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR Revision 1, 2017-05-19 (Tobias Hector) Pulled bind memory functions into their own extension Name String VK_KHR_buffer_device_address Extension Type Device extension Registered Extension Number 258 Revision 1 Ratification Status Ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 and VK_KHR_device_group or Vulkan Version 1.1 SPIR-V Dependencies SPV_KHR_physical_storage_buffer Deprecation State Promoted to Vulkan 1.2 Contact Jeff Bolz jeffbolznv Last Modified Date 2019-06-24 IP Status No known IP claims. Interactions and External Dependencies This extension provides API support for GL_EXT_buffer_reference and GL_EXT_buffer_reference2 and GL_EXT_buffer_reference_uvec2 Contributors Jeff Bolz, NVIDIA Neil Henning, AMD Tobias Hector, AMD Faith Ekstrand, Intel Baldur Karlsson, Valve Jan-Harald Fredriksen, Arm This extension allows the application to query a 64-bit buffer device address value for a buffer, which can be used to access the buffer memory via the PhysicalStorageBuffer storage class in the GL_EXT_buffer_reference GLSL extension and SPV_KHR_physical_storage_buffer SPIR-V extension. Another way to describe this extension is that it adds pointers to buffer memory in shaders. By calling vkGetBufferDeviceAddress with a VkBuffer, it will return a VkDeviceAddress value which represents the address of the start of the buffer. vkGetBufferOpaqueCaptureAddress and vkGetDeviceMemoryOpaqueCaptureAddress allow opaque addresses for buffers and memory objects to be queried for the current process. A trace capture and replay tool can then supply these addresses to be used at replay time to match the addresses used when the trace was captured. To enable tools to insert these queries, new memory allocation flags must be specified for memory objects that will be bound to buffers accessed via the PhysicalStorageBuffer storage class. Note that this mechanism is intended only to support capture/replay tools, and is not recommended for use in other applications. All functionality in this extension is included in core Vulkan 1.2, with the KHR suffix omitted. However, if Vulkan 1.2 is supported and this extension is not, the bufferDeviceAddress feature is optional. The original type, enum, and command names are still available as aliases of the core functionality. If Vulkan 1.3 is supported, support for the bufferDeviceAddress capability is required. vkGetBufferDeviceAddressKHR vkGetBufferOpaqueCaptureAddressKHR vkGetDeviceMemoryOpaqueCaptureAddressKHR VkBufferDeviceAddressInfoKHR VkDeviceMemoryOpaqueCaptureAddressInfoKHR Extending VkBufferCreateInfo: VkBufferOpaqueCaptureAddressCreateInfoKHR Extending VkMemoryAllocateInfo: VkMemoryOpaqueCaptureAddressAllocateInfoKHR Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceBufferDeviceAddressFeaturesKHR VK_KHR_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME VK_KHR_BUFFER_DEVICE_ADDRESS_SPEC_VERSION Extending VkBufferCreateFlagBits: VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR Extending VkBufferUsageFlagBits: VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_KHR Extending VkMemoryAllocateFlagBits: VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT_KHR VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR Extending VkResult: VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR Extending VkStructureType: VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_KHR VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO_KHR VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO_KHR VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO_KHR VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_KHR PhysicalStorageBufferAddresses Revision 1, 2019-06-24 (Jan-Harald Fredriksen) Internal revisions based on VK_EXT_buffer_device_address Name String VK_KHR_copy_commands2 Extension Type Device extension Registered Extension Number 338 Revision 1 Ratification Status Ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 Deprecation State Promoted to Vulkan 1.3 Contact Matthew Netsch mnetsch Last Modified Date 2020-07-06 Contributors Jeff Leger, Qualcomm Tobias Hector, AMD Jan-Harald Fredriksen, ARM Tom Olson, ARM This extension provides extensible versions of the Vulkan buffer and image copy commands. The new commands are functionally identical to the core commands, except that their copy parameters are specified using extensible structures that can be used to pass extension-specific information. The following extensible copy commands are introduced with this extension: vkCmdCopyBuffer2KHR, vkCmdCopyImage2KHR, vkCmdCopyBufferToImage2KHR, vkCmdCopyImageToBuffer2KHR, vkCmdBlitImage2KHR, and vkCmdResolveImage2KHR. Each command contains an *Info2KHR structure parameter that includes sType/pNext members. Lower level structures describing each region to be copied are also extended with sType/pNext members. vkCmdBlitImage2KHR vkCmdCopyBuffer2KHR vkCmdCopyBufferToImage2KHR vkCmdCopyImage2KHR vkCmdCopyImageToBuffer2KHR vkCmdResolveImage2KHR VkBlitImageInfo2KHR VkBufferCopy2KHR VkBufferImageCopy2KHR VkCopyBufferInfo2KHR VkCopyBufferToImageInfo2KHR VkCopyImageInfo2KHR VkCopyImageToBufferInfo2KHR VkImageBlit2KHR VkImageCopy2KHR VkImageResolve2KHR VkResolveImageInfo2KHR VK_KHR_COPY_COMMANDS_2_EXTENSION_NAME VK_KHR_COPY_COMMANDS_2_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2_KHR VK_STRUCTURE_TYPE_BUFFER_COPY_2_KHR VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2_KHR VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2_KHR VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2_KHR VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2_KHR VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2_KHR VK_STRUCTURE_TYPE_IMAGE_BLIT_2_KHR VK_STRUCTURE_TYPE_IMAGE_COPY_2_KHR VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2_KHR VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2_KHR Vulkan APIs in this extension are included in core Vulkan 1.3, with the KHR suffix omitted. External interactions defined by this extension, such as SPIR-V token names, retain their original names. The original Vulkan API names are still available as aliases of the core functionality. Revision 1, 2020-07-06 (Jeff Leger) Internal revisions Name String VK_KHR_create_renderpass2 Extension Type Device extension Registered Extension Number 110 Revision 1 Ratification Status Ratified Extension and Version Dependencies VK_KHR_multiview and VK_KHR_maintenance2 or Vulkan Version 1.1 Deprecation State Promoted to Vulkan 1.2 Contact Tobias Hector tobias Last Modified Date 2018-02-07 Contributors Tobias Hector Jeff Bolz This extension provides a new command to create render passes in a way that can be easily extended by other extensions through the substructures of render pass creation. The Vulkan 1.0 render pass creation sub-structures do not include sType/pNext members. Additionally, the render pass begin/next/end commands have been augmented with new extensible structures for passing additional subpass information. The VkRenderPassMultiviewCreateInfo and VkInputAttachmentAspectReference structures that extended the original VkRenderPassCreateInfo are not accepted into the new creation functions, and instead their parameters are folded into this extension as follows: Elements of VkRenderPassMultiviewCreateInfo::pViewMasks are now specified in VkSubpassDescription2KHR::viewMask. Elements of VkRenderPassMultiviewCreateInfo::pViewOffsets are now specified in VkSubpassDependency2KHR::viewOffset. VkRenderPassMultiviewCreateInfo::correlationMaskCount and VkRenderPassMultiviewCreateInfo::pCorrelationMasks are directly specified in VkRenderPassCreateInfo2KHR. VkInputAttachmentAspectReference::aspectMask is now specified in the relevant input attachment reference in VkAttachmentReference2KHR::aspectMask The details of these mappings are explained fully in the new structures. All functionality in this extension is included in core Vulkan 1.2, with the KHR suffix omitted. The original type, enum, and command names are still available as aliases of the core functionality. vkCmdBeginRenderPass2KHR vkCmdEndRenderPass2KHR vkCmdNextSubpass2KHR vkCreateRenderPass2KHR VkAttachmentDescription2KHR VkAttachmentReference2KHR VkRenderPassCreateInfo2KHR VkSubpassBeginInfoKHR VkSubpassDependency2KHR VkSubpassDescription2KHR VkSubpassEndInfoKHR VK_KHR_CREATE_RENDERPASS_2_EXTENSION_NAME VK_KHR_CREATE_RENDERPASS_2_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR Revision 1, 2018-02-07 (Tobias Hector) Internal revisions Name String VK_KHR_dedicated_allocation Extension Type Device extension Registered Extension Number 128 Revision 3 Ratification Status Ratified Extension and Version Dependencies VK_KHR_get_memory_requirements2 or Vulkan Version 1.1 Deprecation State Promoted to Vulkan 1.1 Contact James Jones cubanismo Last Modified Date 2017-09-05 IP Status No known IP claims. Contributors Jeff Bolz, NVIDIA Faith Ekstrand, Intel This extension enables resources to be bound to a dedicated allocation, rather than suballocated. For any particular resource, applications can query whether a dedicated allocation is recommended, in which case using a dedicated allocation may improve the performance of access to that resource. Normal device memory allocations must support multiple resources per allocation, memory aliasing and sparse binding, which could interfere with some optimizations. Applications should query the implementation for when a dedicated allocation may be beneficial by adding a VkMemoryDedicatedRequirementsKHR structure to the pNext chain of the VkMemoryRequirements2 structure passed as the pMemoryRequirements parameter of a call to vkGetBufferMemoryRequirements2 or vkGetImageMemoryRequirements2. Certain external handle types and external images or buffers may also depend on dedicated allocations on implementations that associate image or buffer metadata with OS-level memory objects. This extension adds a two small structures to memory requirements querying and memory allocation: a new structure that flags whether an image/buffer should have a dedicated allocation, and a structure indicating the image or buffer that an allocation will be bound to. All functionality in this extension is included in core Vulkan 1.1, with the KHR suffix omitted. The original type, enum, and command names are still available as aliases of the core functionality. Extending VkMemoryAllocateInfo: VkMemoryDedicatedAllocateInfoKHR Extending VkMemoryRequirements2: VkMemoryDedicatedRequirementsKHR VK_KHR_DEDICATED_ALLOCATION_EXTENSION_NAME VK_KHR_DEDICATED_ALLOCATION_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR // Create an image with a dedicated allocation based on the // implementation's preference VkImageCreateInfo imageCreateInfo = { // Image creation parameters }; VkImage image; VkResult result = vkCreateImage( device, &imageCreateInfo, NULL, // pAllocator &image); VkMemoryDedicatedRequirementsKHR dedicatedRequirements = { .sType = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR, .pNext = NULL, }; VkMemoryRequirements2 memoryRequirements = { .sType = VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2, .pNext = &dedicatedRequirements, }; const VkImageMemoryRequirementsInfo2 imageRequirementsInfo = { .sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2, .pNext = NULL, .image = image }; vkGetImageMemoryRequirements2( device, &imageRequirementsInfo, &memoryRequirements); if (dedicatedRequirements.prefersDedicatedAllocation) { // Allocate memory with VkMemoryDedicatedAllocateInfoKHR::image // pointing to the image we are allocating the memory for VkMemoryDedicatedAllocateInfoKHR dedicatedInfo = { .sType = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR, .pNext = NULL, .image = image, .buffer = VK_NULL_HANDLE, }; VkMemoryAllocateInfo memoryAllocateInfo = { .sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO, .pNext = &dedicatedInfo, .allocationSize = memoryRequirements.size, .memoryTypeIndex = FindMemoryTypeIndex(memoryRequirements.memoryTypeBits), }; VkDeviceMemory memory; vkAllocateMemory( device, &memoryAllocateInfo, NULL, // pAllocator &memory); // Bind the image to the memory vkBindImageMemory( device, image, memory, 0); } else { // Take the normal memory sub-allocation path } Revision 1, 2017-02-27 (James Jones) Copy content from VK_NV_dedicated_allocation Add some references to external object interactions to the overview. Revision 2, 2017-03-27 (Faith Ekstrand) Rework the extension to be query-based Revision 3, 2017-07-31 (Faith Ekstrand) Clarify that memory objects allocated with VkMemoryDedicatedAllocateInfoKHR can only have the specified resource bound and no others. Name String VK_KHR_depth_stencil_resolve Extension Type Device extension Registered Extension Number 200 Revision 1 Ratification Status Ratified Extension and Version Dependencies VK_KHR_create_renderpass2 or Vulkan Version 1.2 Deprecation State Promoted to Vulkan 1.2 Contact Jan-Harald Fredriksen janharald Last Modified Date 2018-04-09 Contributors Jan-Harald Fredriksen, Arm Andrew Garrard, Samsung Electronics Soowan Park, Samsung Electronics Jeff Bolz, NVIDIA Daniel Rakos, AMD This extension adds support for automatically resolving multisampled depth/stencil attachments in a subpass in a similar manner as for color attachments. Multisampled color attachments can be resolved at the end of a subpass by specifying pResolveAttachments entries corresponding to the pColorAttachments array entries. This does not allow for a way to map the resolve attachments to the depth/stencil attachment. The vkCmdResolveImage command does not allow for depth/stencil images. While there are other ways to resolve the depth/stencil attachment, they can give sub-optimal performance. Extending the VkSubpassDescription2 in this extension allows an application to add a pDepthStencilResolveAttachment, that is similar to the color pResolveAttachments, that the pDepthStencilAttachment can be resolved into. Depth and stencil samples are resolved to a single value based on the resolve mode. The set of possible resolve modes is defined in the VkResolveModeFlagBits enum. The VK_RESOLVE_MODE_SAMPLE_ZERO_BIT mode is the only mode that is required of all implementations (that support the extension or support Vulkan 1.2 or higher). Some implementations may also support averaging (the same as color sample resolve) or taking the minimum or maximum sample, which may be more suitable for depth/stencil resolve. All functionality in this extension is included in core Vulkan 1.2, with the KHR suffix omitted. The original type, enum, and command names are still available as aliases of the core functionality. Extending VkPhysicalDeviceProperties2: VkPhysicalDeviceDepthStencilResolvePropertiesKHR Extending VkSubpassDescription2: VkSubpassDescriptionDepthStencilResolveKHR VkResolveModeFlagBitsKHR VkResolveModeFlagsKHR VK_KHR_DEPTH_STENCIL_RESOLVE_EXTENSION_NAME VK_KHR_DEPTH_STENCIL_RESOLVE_SPEC_VERSION Extending VkResolveModeFlagBits: VK_RESOLVE_MODE_AVERAGE_BIT_KHR VK_RESOLVE_MODE_MAX_BIT_KHR VK_RESOLVE_MODE_MIN_BIT_KHR VK_RESOLVE_MODE_NONE_KHR VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR Revision 1, 2018-04-09 (Jan-Harald Fredriksen) Initial revision Name String VK_KHR_descriptor_update_template Extension Type Device extension Registered Extension Number 86 Revision 1 Ratification Status Ratified Extension and Version Dependencies None API Interactions Interacts with VK_EXT_debug_report Interacts with VK_KHR_push_descriptor Deprecation State Promoted to Vulkan 1.1 Contact Markus Tavenrath mtavenrath Last Modified Date 2017-09-05 IP Status No known IP claims. Interactions and External Dependencies Interacts with VK_KHR_push_descriptor Contributors Jeff Bolz, NVIDIA Michael Worcester, Imagination Technologies Applications may wish to update a fixed set of descriptors in a large number of descriptor sets very frequently, i.e. during initialization phase or if it is required to rebuild descriptor sets for each frame. For those cases it is also not unlikely that all information required to update a single descriptor set is stored in a single struct. This extension provides a way to update a fixed set of descriptors in a single VkDescriptorSet with a pointer to an application-defined data structure describing the new descriptors. vkCmdPushDescriptorSetWithTemplateKHR is included as an interaction with VK_KHR_push_descriptor. If Vulkan 1.1 and VK_KHR_push_descriptor are supported, this is included by VK_KHR_push_descriptor. The base functionality in this extension is included in core Vulkan 1.1, with the KHR suffix omitted. The original type, enum, and command names are still available as aliases of the core functionality. VkDescriptorUpdateTemplateKHR vkCreateDescriptorUpdateTemplateKHR vkDestroyDescriptorUpdateTemplateKHR vkUpdateDescriptorSetWithTemplateKHR If VK_KHR_push_descriptor is supported: vkCmdPushDescriptorSetWithTemplateKHR VkDescriptorUpdateTemplateCreateInfoKHR VkDescriptorUpdateTemplateEntryKHR VkDescriptorUpdateTemplateTypeKHR VkDescriptorUpdateTemplateCreateFlagsKHR VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_EXTENSION_NAME VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_SPEC_VERSION Extending VkDescriptorUpdateTemplateType: VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR Extending VkObjectType: VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR Extending VkStructureType: VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR If VK_EXT_debug_report is supported: Extending VkDebugReportObjectTypeEXT: VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT If VK_KHR_push_descriptor is supported: Extending VkDescriptorUpdateTemplateType: VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR Revision 1, 2016-01-11 (Markus Tavenrath) Initial draft Name String VK_KHR_device_group Extension Type Device extension Registered Extension Number 61 Revision 4 Ratification Status Ratified Extension and Version Dependencies VK_KHR_device_group_creation API Interactions Interacts with VK_KHR_bind_memory2 Interacts with VK_KHR_surface Interacts with VK_KHR_swapchain SPIR-V Dependencies SPV_KHR_device_group Deprecation State Promoted to Vulkan 1.1 Contact Jeff Bolz jeffbolznv Last Modified Date 2017-10-10 IP Status No known IP claims. Contributors Jeff Bolz, NVIDIA Tobias Hector, Imagination Technologies This extension provides functionality to use a logical device that consists of multiple physical devices, as created with the VK_KHR_device_group_creation extension. A device group can allocate memory across the subdevices, bind memory from one subdevice to a resource on another subdevice, record command buffers where some work executes on an arbitrary subset of the subdevices, and potentially present a swapchain image from one or more subdevices. The following enums, types and commands are included as interactions with VK_KHR_swapchain: VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR VkDeviceGroupPresentModeFlagBitsKHR VkDeviceGroupPresentCapabilitiesKHR VkImageSwapchainCreateInfoKHR VkBindImageMemorySwapchainInfoKHR VkAcquireNextImageInfoKHR VkDeviceGroupPresentInfoKHR VkDeviceGroupSwapchainCreateInfoKHR vkGetDeviceGroupPresentCapabilitiesKHR vkGetDeviceGroupSurfacePresentModesKHR vkGetPhysicalDevicePresentRectanglesKHR vkAcquireNextImage2KHR If Vulkan 1.1 and VK_KHR_swapchain are supported, these are included by VK_KHR_swapchain. The base functionality in this extension is included in core Vulkan 1.1, with the KHR suffix omitted. The original type, enum, and command names are still available as aliases of the core functionality. vkCmdDispatchBaseKHR vkCmdSetDeviceMaskKHR vkGetDeviceGroupPeerMemoryFeaturesKHR If VK_KHR_surface is supported: vkGetDeviceGroupPresentCapabilitiesKHR vkGetDeviceGroupSurfacePresentModesKHR vkGetPhysicalDevicePresentRectanglesKHR If VK_KHR_swapchain is supported: vkAcquireNextImage2KHR Extending VkBindSparseInfo: VkDeviceGroupBindSparseInfoKHR Extending VkCommandBufferBeginInfo: VkDeviceGroupCommandBufferBeginInfoKHR Extending VkMemoryAllocateInfo: VkMemoryAllocateFlagsInfoKHR Extending VkRenderPassBeginInfo, VkRenderingInfo: VkDeviceGroupRenderPassBeginInfoKHR Extending VkSubmitInfo: VkDeviceGroupSubmitInfoKHR If VK_KHR_bind_memory2 is supported: Extending VkBindBufferMemoryInfo: VkBindBufferMemoryDeviceGroupInfoKHR Extending VkBindImageMemoryInfo: VkBindImageMemoryDeviceGroupInfoKHR If VK_KHR_surface is supported: VkDeviceGroupPresentCapabilitiesKHR If VK_KHR_swapchain is supported: VkAcquireNextImageInfoKHR Extending VkBindImageMemoryInfo: VkBindImageMemorySwapchainInfoKHR Extending VkImageCreateInfo: VkImageSwapchainCreateInfoKHR Extending VkPresentInfoKHR: VkDeviceGroupPresentInfoKHR Extending VkSwapchainCreateInfoKHR: VkDeviceGroupSwapchainCreateInfoKHR VkMemoryAllocateFlagBitsKHR VkPeerMemoryFeatureFlagBitsKHR If VK_KHR_surface is supported: VkDeviceGroupPresentModeFlagBitsKHR VkMemoryAllocateFlagsKHR VkPeerMemoryFeatureFlagsKHR If VK_KHR_surface is supported: VkDeviceGroupPresentModeFlagsKHR VK_KHR_DEVICE_GROUP_EXTENSION_NAME VK_KHR_DEVICE_GROUP_SPEC_VERSION Extending VkDependencyFlagBits: VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR Extending VkMemoryAllocateFlagBits: VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR Extending VkPeerMemoryFeatureFlagBits: VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR Extending VkPipelineCreateFlagBits: VK_PIPELINE_CREATE_DISPATCH_BASE_KHR VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR Extending VkStructureType: VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHR VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHR VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR If VK_KHR_bind_memory2 is supported: Extending VkImageCreateFlagBits: VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR Extending VkStructureType: VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR If VK_KHR_surface is supported: Extending VkStructureType: VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR If VK_KHR_swapchain is supported: Extending VkStructureType: VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR Extending VkSwapchainCreateFlagBitsKHR: VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR DeviceIndex DeviceGroup Revision 1, 2016-10-19 (Jeff Bolz) Internal revisions Revision 2, 2017-05-19 (Tobias Hector) Removed extended memory bind functions to VK_KHR_bind_memory2, added dependency on that extension, and device-group-specific structs for those functions. Revision 3, 2017-10-06 (Ian Elliott) Corrected Vulkan 1.1 interactions with the WSI extensions. All Vulkan 1.1 WSI interactions are with the VK_KHR_swapchain extension. Revision 4, 2017-10-10 (Jeff Bolz) Rename SFR bits and structure members to use the phrase split instance bind regions. Name String VK_KHR_device_group_creation Extension Type Instance extension Registered Extension Number 71 Revision 1 Ratification Status Ratified Extension and Version Dependencies None Deprecation State Promoted to Vulkan 1.1 Contact Jeff Bolz jeffbolznv Last Modified Date 2016-10-19 IP Status No known IP claims. Contributors Jeff Bolz, NVIDIA This extension provides instance-level commands to enumerate groups of physical devices, and to create a logical device from a subset of one of those groups. Such a logical device can then be used with new features in the VK_KHR_device_group extension. All functionality in this extension is included in core Vulkan 1.1, with the KHR suffix omitted. The original type, enum, and command names are still available as aliases of the core functionality. vkEnumeratePhysicalDeviceGroupsKHR VkPhysicalDeviceGroupPropertiesKHR Extending VkDeviceCreateInfo: VkDeviceGroupDeviceCreateInfoKHR VK_KHR_DEVICE_GROUP_CREATION_EXTENSION_NAME VK_KHR_DEVICE_GROUP_CREATION_SPEC_VERSION VK_MAX_DEVICE_GROUP_SIZE_KHR Extending VkMemoryHeapFlagBits: VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHR Extending VkStructureType: VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHR VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR VkDeviceCreateInfo devCreateInfo = { VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO }; // (not shown) fill out devCreateInfo as usual. uint32_t deviceGroupCount = 0; VkPhysicalDeviceGroupPropertiesKHR *props = NULL; // Query the number of device groups vkEnumeratePhysicalDeviceGroupsKHR(g_vkInstance, &deviceGroupCount, NULL); // Allocate and initialize structures to query the device groups props = (VkPhysicalDeviceGroupPropertiesKHR *)malloc(deviceGroupCount*sizeof(VkPhysicalDeviceGroupPropertiesKHR)); for (i = 0; i 1) { deviceGroupInfo.physicalDeviceCount = props[0].physicalDeviceCount; deviceGroupInfo.pPhysicalDevices = props[0].physicalDevices; devCreateInfo.pNext = &deviceGroupInfo; } vkCreateDevice(props[0].physicalDevices[0], &devCreateInfo, NULL, &g_vkDevice); free(props); Revision 1, 2016-10-19 (Jeff Bolz) Internal revisions Name String VK_KHR_draw_indirect_count Extension Type Device extension Registered Extension Number 170 Revision 1 Ratification Status Ratified Extension and Version Dependencies None Deprecation State Promoted to Vulkan 1.2 Contact Piers Daniell pdaniell-nv Last Modified Date 2017-08-25 IP Status No known IP claims. Contributors Matthaeus G. Chajdas, AMD Derrick Owens, AMD Graham Sellers, AMD Daniel Rakos, AMD Dominik Witczak, AMD Piers Daniell, NVIDIA This extension is based on the VK_AMD_draw_indirect_count extension. This extension allows an application to source the number of draws for indirect drawing calls from a buffer. Applications might want to do culling on the GPU via a compute shader prior to drawing. This enables the application to generate an arbitrary number of drawing commands and execute them without host intervention. All functionality in this extension is included in core Vulkan 1.2, with the KHR suffix omitted. However, if Vulkan 1.2 is supported and this extension is not, the commands vkCmdDrawIndirectCount and vkCmdDrawIndexedIndirectCount are optional. The original type, enum, and command names are still available as aliases of the core functionality. vkCmdDrawIndexedIndirectCountKHR vkCmdDrawIndirectCountKHR VK_KHR_DRAW_INDIRECT_COUNT_EXTENSION_NAME VK_KHR_DRAW_INDIRECT_COUNT_SPEC_VERSION Revision 1, 2017-08-25 (Piers Daniell) Initial draft based on VK_AMD_draw_indirect_count Name String VK_KHR_driver_properties Extension Type Device extension Registered Extension Number 197 Revision 1 Ratification Status Ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 Deprecation State Promoted to Vulkan 1.2 Contact Daniel Rakos drakos-amd Last Modified Date 2018-04-11 IP Status No known IP claims. Contributors Baldur Karlsson Matthaeus G. Chajdas, AMD Piers Daniell, NVIDIA Alexander Galazin, Arm Jesse Hall, Google Daniel Rakos, AMD This extension provides a new physical device query which allows retrieving information about the driver implementation, allowing applications to determine which physical device corresponds to which particular vendors driver, and which conformance test suite version the driver implementation is compliant with. All functionality in this extension is included in core Vulkan 1.2, with the KHR suffix omitted. The original type, enum, and command names are still available as aliases of the core functionality. VkConformanceVersionKHR Extending VkPhysicalDeviceProperties2: VkPhysicalDeviceDriverPropertiesKHR VkDriverIdKHR VK_KHR_DRIVER_PROPERTIES_EXTENSION_NAME VK_KHR_DRIVER_PROPERTIES_SPEC_VERSION VK_MAX_DRIVER_INFO_SIZE_KHR VK_MAX_DRIVER_NAME_SIZE_KHR Extending VkDriverId: VK_DRIVER_ID_AMD_OPEN_SOURCE_KHR VK_DRIVER_ID_AMD_PROPRIETARY_KHR VK_DRIVER_ID_ARM_PROPRIETARY_KHR VK_DRIVER_ID_BROADCOM_PROPRIETARY_KHR VK_DRIVER_ID_GGP_PROPRIETARY_KHR VK_DRIVER_ID_GOOGLE_SWIFTSHADER_KHR VK_DRIVER_ID_IMAGINATION_PROPRIETARY_KHR VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA_KHR VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS_KHR VK_DRIVER_ID_MESA_RADV_KHR VK_DRIVER_ID_NVIDIA_PROPRIETARY_KHR VK_DRIVER_ID_QUALCOMM_PROPRIETARY_KHR Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR Revision 1, 2018-04-11 (Daniel Rakos) Internal revisions Name String VK_KHR_dynamic_rendering Extension Type Device extension Registered Extension Number 45 Revision 1 Ratification Status Ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 and VK_KHR_depth_stencil_resolve or Vulkan Version 1.2 Deprecation State Promoted to Vulkan 1.3 Contact Tobias Hector tobski Extension Proposal VK_KHR_dynamic_rendering Last Modified Date 2021-10-06 Contributors Tobias Hector, AMD Arseny Kapoulkine, Roblox Franois Duranleau, Gameloft Stuart Smith, AMD Hai Nguyen, Google Jean-Franois Roy, Google Jeff Leger, Qualcomm Jan-Harald Fredriksen, Arm Piers Daniell, Nvidia James Fitzpatrick, Imagination Piotr Byszewski, Mobica Jesse Hall, Google Mike Blumenkrantz, Valve This extension allows applications to create single-pass render pass instances without needing to create render pass objects or framebuffers. Dynamic render passes can also span across multiple primary command buffers, rather than relying on secondary command buffers. This extension also incorporates VK_ATTACHMENT_STORE_OP_NONE_KHR from VK_QCOM_render_pass_store_ops, enabling applications to avoid unnecessary synchronization when an attachment is not written during a render pass. vkCmdBeginRenderingKHR vkCmdEndRenderingKHR VkRenderingAttachmentInfoKHR VkRenderingInfoKHR Extending VkCommandBufferInheritanceInfo: VkCommandBufferInheritanceRenderingInfoKHR Extending VkGraphicsPipelineCreateInfo: VkPipelineRenderingCreateInfoKHR Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceDynamicRenderingFeaturesKHR VkRenderingFlagBitsKHR VkRenderingFlagsKHR VK_KHR_DYNAMIC_RENDERING_EXTENSION_NAME VK_KHR_DYNAMIC_RENDERING_SPEC_VERSION Extending VkAttachmentStoreOp: VK_ATTACHMENT_STORE_OP_NONE_KHR Extending VkRenderingFlagBits: VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT_KHR VK_RENDERING_RESUMING_BIT_KHR VK_RENDERING_SUSPENDING_BIT_KHR Extending VkStructureType: VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO_KHR VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES_KHR VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO_KHR VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO_KHR VK_STRUCTURE_TYPE_RENDERING_INFO_KHR Vulkan APIs in this extension are included in core Vulkan 1.3, with the KHR suffix omitted. External interactions defined by this extension, such as SPIR-V token names, retain their original names. The original Vulkan API names are still available as aliases of the core functionality. Revision 1, 2021-10-06 (Tobias Hector) Initial revision Name String VK_KHR_dynamic_rendering_local_read Extension Type Device extension Registered Extension Number 233 Revision 1 Ratification Status Ratified Extension and Version Dependencies VK_KHR_dynamic_rendering or Vulkan Version 1.3 Deprecation State Promoted to Vulkan 1.4 Contact Tobias Hector tobski Extension Proposal VK_KHR_dynamic_rendering_local_read Last Modified Date 2023-11-03 Contributors Tobias Hector, AMD Hans-Kristian Arntzen, Valve Connor Abbott, Valve Pan Gao, Huawei Lionel Landwerlin, Intel Shahbaz Youssefi, Google Alyssa Rosenzweig, Valve Jan-Harald Fredriksen, Arm Mike Blumenkrantz, Valve Graeme Leese, Broadcom Piers Daniell, Nvidia Stuart Smith, AMD Daniel Story, Nintendo James Fitzpatrick, Imagination Piotr Byszewski, Mobica Spencer Fricke, LunarG Tom Olson, Arm Michal Pietrasiuk, Intel Matthew Netsch, Qualcomm Marty Johnson, Khronos Wyvern Wang, Huawei Jeff Bolz, Nvidia Samuel (Sheng-Wen) Huang, MediaTek This extension enables reads from attachments and resources written by previous fragment shaders within a dynamic render pass. vkCmdSetRenderingAttachmentLocationsKHR vkCmdSetRenderingInputAttachmentIndicesKHR Extending VkGraphicsPipelineCreateInfo, VkCommandBufferInheritanceInfo: VkRenderingAttachmentLocationInfoKHR VkRenderingInputAttachmentIndexInfoKHR Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR VK_KHR_DYNAMIC_RENDERING_LOCAL_READ_EXTENSION_NAME VK_KHR_DYNAMIC_RENDERING_LOCAL_READ_SPEC_VERSION Extending VkImageLayout: VK_IMAGE_LAYOUT_RENDERING_LOCAL_READ_KHR Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES_KHR VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO_KHR VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO_KHR Functionality in this extension is included in core Vulkan 1.4, with the KHR suffix omitted. However, Vulkan 1.4 implementations only have to support local read for storage resources and single sampled color attachments. Support for reading depth/stencil attachments and multi-sampled attachments are respectively gated behind the new boolean dynamicRenderingLocalReadDepthStencilAttachments and dynamicRenderingLocalReadMultisampledAttachments properties, as described in the Version 1.4 appendix. The original type, enum, and command names are still available as aliases of the core functionality. Revision 1, 2023-11-03 (Tobias Hector) Initial revision Name String VK_KHR_external_fence Extension Type Device extension Registered Extension Number 114 Revision 1 Ratification Status Ratified Extension and Version Dependencies VK_KHR_external_fence_capabilities Deprecation State Promoted to Vulkan 1.1 Contact Jesse Hall critsec Last Modified Date 2017-05-08 IP Status No known IP claims. Contributors Jesse Hall, Google James Jones, NVIDIA Jeff Juliano, NVIDIA Cass Everitt, Oculus Contributors to VK_KHR_external_semaphore An application using external memory may wish to synchronize access to that memory using fences. This extension enables an application to create fences from which non-Vulkan handles that reference the underlying synchronization primitive can be exported. All functionality in this extension is included in core Vulkan 1.1, with the KHR suffix omitted. The original type, enum, and command names are still available as aliases of the core functionality. Extending VkFenceCreateInfo: VkExportFenceCreateInfoKHR VkFenceImportFlagBitsKHR VkFenceImportFlagsKHR VK_KHR_EXTERNAL_FENCE_EXTENSION_NAME VK_KHR_EXTERNAL_FENCE_SPEC_VERSION Extending VkFenceImportFlagBits: VK_FENCE_IMPORT_TEMPORARY_BIT_KHR Extending VkStructureType: VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR This extension borrows concepts, semantics, and language from VK_KHR_external_semaphore. That extensions issues apply equally to this extension. Revision 1, 2017-05-08 (Jesse Hall) Initial revision Name String VK_KHR_external_fence_capabilities Extension Type Instance extension Registered Extension Number 113 Revision 1 Ratification Status Ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 Deprecation State Promoted to Vulkan 1.1 Contact Jesse Hall critsec Last Modified Date 2017-05-08 IP Status No known IP claims. Contributors Jesse Hall, Google James Jones, NVIDIA Jeff Juliano, NVIDIA Cass Everitt, Oculus Contributors to VK_KHR_external_semaphore_capabilities An application may wish to reference device fences in multiple Vulkan logical devices or instances, in multiple processes, and/or in multiple APIs. This extension provides a set of capability queries and handle definitions that allow an application to determine what types of external fence handles an implementation supports for a given set of use cases. All functionality in this extension is included in core Vulkan 1.1, with the KHR suffix omitted. The original type, enum, and command names are still available as aliases of the core functionality. vkGetPhysicalDeviceExternalFencePropertiesKHR VkExternalFencePropertiesKHR VkPhysicalDeviceExternalFenceInfoKHR Extending VkPhysicalDeviceProperties2: VkPhysicalDeviceIDPropertiesKHR VkExternalFenceFeatureFlagBitsKHR VkExternalFenceHandleTypeFlagBitsKHR VkExternalFenceFeatureFlagsKHR VkExternalFenceHandleTypeFlagsKHR VK_KHR_EXTERNAL_FENCE_CAPABILITIES_EXTENSION_NAME VK_KHR_EXTERNAL_FENCE_CAPABILITIES_SPEC_VERSION VK_LUID_SIZE_KHR Extending VkExternalFenceFeatureFlagBits: VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR Extending VkExternalFenceHandleTypeFlagBits: VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR Extending VkStructureType: VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR Revision 1, 2017-05-08 (Jesse Hall) Initial version Name String VK_KHR_external_memory Extension Type Device extension Registered Extension Number 73 Revision 1 Ratification Status Ratified Extension and Version Dependencies VK_KHR_external_memory_capabilities or Vulkan Version 1.1 Deprecation State Promoted to Vulkan 1.1 Contact James Jones cubanismo Last Modified Date 2016-10-20 IP Status No known IP claims. Interactions and External Dependencies Interacts with VK_KHR_dedicated_allocation. Interacts with VK_NV_dedicated_allocation. Contributors Faith Ekstrand, Intel Ian Elliott, Google Jesse Hall, Google Tobias Hector, Imagination Technologies James Jones, NVIDIA Jeff Juliano, NVIDIA Matthew Netsch, Qualcomm Technologies, Inc. Daniel Rakos, AMD Carsten Rohde, NVIDIA Ray Smith, ARM Lina Versace, Google An application may wish to reference device memory in multiple Vulkan logical devices or instances, in multiple processes, and/or in multiple APIs. This extension enables an application to export non-Vulkan handles from Vulkan memory objects such that the underlying resources can be referenced outside the scope of the Vulkan logical device that created them. All functionality in this extension is included in core Vulkan 1.1, with the KHR suffix omitted. The original type, enum, and command names are still available as aliases of the core functionality. Extending VkBufferCreateInfo: VkExternalMemoryBufferCreateInfoKHR Extending VkImageCreateInfo: VkExternalMemoryImageCreateInfoKHR Extending VkMemoryAllocateInfo: VkExportMemoryAllocateInfoKHR VK_KHR_EXTERNAL_MEMORY_EXTENSION_NAME VK_KHR_EXTERNAL_MEMORY_SPEC_VERSION VK_QUEUE_FAMILY_EXTERNAL_KHR Extending VkResult: VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR Extending VkStructureType: VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR 1) How do applications correlate two physical devices across process or Vulkan instance boundaries? RESOLVED: New device ID fields have been introduced by VK_KHR_external_memory_capabilities. These fields, combined with the existing VkPhysicalDeviceProperties::driverVersion field can be used to identify compatible devices across processes, drivers, and APIs. VkPhysicalDeviceProperties::pipelineCacheUUID is not sufficient for this purpose because despite its description in the specification, it need only identify a unique pipeline cache format in practice. Multiple devices may be able to use the same pipeline cache data, and hence it would be desirable for all of them to have the same pipeline cache UUID. However, only the same concrete physical device can be used when sharing memory, so an actual unique device ID was introduced. Further, the pipeline cache UUID was specific to Vulkan, but correlation with other, non-extensible APIs is required to enable interoperation with those APIs. 2) If memory objects are shared between processes and APIs, is this considered aliasing according to the rules outlined in the Memory Aliasing section? RESOLVED: Yes. Applications must take care to obey all restrictions imposed on aliased resources when using memory across multiple Vulkan instances or other APIs. 3) Are new image layouts or metadata required to specify image layouts and layout transitions compatible with non-Vulkan APIs, or with other instances of the same Vulkan driver? RESOLVED: Separate instances of the same Vulkan driver running on the same GPU should have identical internal layout semantics, so applications have the tools they need to ensure views of images are consistent between the two instances. Other APIs will fall into two categories: Those that are Vulkan- compatible, and those that are Vulkan-incompatible. Vulkan-incompatible APIs will require the image to be in the GENERAL layout whenever they are accessing them. Note this does not attempt to address cross-device transitions, nor transitions to engines on the same device which are not visible within the Vulkan API. Both of these are beyond the scope of this extension. 4) Is a new barrier flag or operation of some type needed to prepare external memory for handoff to another Vulkan instance or API and/or receive it from another instance or API? RESOLVED: Yes. Some implementations need to perform additional cache management when transitioning memory between address spaces and other APIs, instances, or processes which may operate in a separate address space. Options for defining this transition include: A new structure that can be added to the pNext list in VkMemoryBarrier, VkBufferMemoryBarrier, and VkImageMemoryBarrier. A new bit in VkAccessFlags that can be set to indicate an external access. A new bit in VkDependencyFlags A new special queue family that represents an external queue. A new structure has the advantage that the type of external transition can be described in as much detail as necessary. However, there is not currently a known need for anything beyond differentiating between external and internal accesses, so this is likely an over-engineered solution. The access flag bit has the advantage that it can be applied at buffer, image, or global granularity, and semantically it maps pretty well to the operation being described. Additionally, the API already includes VK_ACCESS_MEMORY_READ_BIT and VK_ACCESS_MEMORY_WRITE_BIT which appear to be intended for this purpose. However, there is no obvious pipeline stage that would correspond to an external access, and therefore no clear way to use VK_ACCESS_MEMORY_READ_BIT or VK_ACCESS_MEMORY_WRITE_BIT. VkDependencyFlags and VkPipelineStageFlags operate at command granularity rather than image or buffer granularity, which would make an entire pipeline barrier an internalexternal or externalinternal barrier. This may not be a problem in practice, but seems like the wrong scope. Another downside of VkDependencyFlags is that it lacks inherent directionality: there are no src and dst variants of it in the barrier or dependency description semantics, so two bits might need to be added to describe both internalexternal and externalinternal transitions. Transitioning a resource to a special queue family corresponds well with the operation of transitioning to a separate Vulkan instance, in that both operations ideally include scheduling a barrier on both sides of the transition: Both the releasing and the acquiring queue or process. Using a special queue family requires adding an additional reserved queue family index. Reusing VK_QUEUE_FAMILY_IGNORED would have left it unclear how to transition a concurrent usage resource from one process to another, since the semantics would have likely been equivalent to the currently-ignored transition of VK_QUEUE_FAMILY_IGNORED  VK_QUEUE_FAMILY_IGNORED. Fortunately, creating a new reserved queue family index is not invasive. Based on the above analysis, the approach of transitioning to a special external queue family was chosen. 5) Do internal driver memory arrangements and/or other internal driver image properties need to be exported and imported when sharing images across processes or APIs. RESOLVED: Some vendors claim this is necessary on their implementations, but it was determined that the security risks of allowing opaque metadata to be passed from applications to the driver were too high. Therefore, implementations which require metadata will need to associate it with the objects represented by the external handles, and rely on the dedicated allocation mechanism to associate the exported and imported memory objects with a single image or buffer. 6) Most prior interoperation and cross-process sharing APIs have been based on image-level sharing. Should Vulkan sharing be based on memory-object sharing or image sharing? RESOLVED: These extensions have assumed memory-level sharing is the correct granularity. Vulkan is a lower-level API than most prior APIs, and as such attempts to closely align with to the underlying primitives of the hardware and system-level drivers it abstracts. In general, the resource that holds the backing store for both images and buffers of various types is memory. Images and buffers are merely metadata containing brief descriptions of the layout of bits within that memory. Because memory object-based sharing is aligned with the overall Vulkan API design, it enables the full range of Vulkan capabilities with external objects. External memory can be used as backing for sparse images, for example, whereas such usage would be awkward at best with a sharing mechanism based on higher-level primitives such as images. Further, aligning the mechanism with the API in this way provides some hope of trivial compatibility with future API enhancements. If new objects backed by memory objects are added to the API, they too can be used across processes with minimal additions to the base external memory APIs. Earlier APIs implemented interop at a higher level, and this necessitated entirely separate sharing APIs for images and buffers. To co-exist and interoperate with those APIs, the Vulkan external sharing mechanism must accommodate their model. However, if it can be agreed that memory-based sharing is the more desirable and forward-looking design, legacy interoperation constraints can be considered another reason to favor memory-based sharing: while native and legacy driver primitives that may be used to implement sharing may not be as low-level as the API here suggests, raw memory is still the least common denominator among the types. Image-based sharing can be cleanly derived from a set of base memory- object sharing APIs with minimal effort, whereas image-based sharing does not generalize well to buffer or raw-memory sharing. Therefore, following the general Vulkan design principle of minimalism, it is better to expose interopability with image-based native and external primitives via the memory sharing API, and place sufficient limits on their usage to ensure they can be used only as backing for equivalent Vulkan images. This provides a consistent API for applications regardless of which platform or external API they are targeting, which makes development of multi-API and multi-platform applications simpler. 7) Should Vulkan define a common external handle type and provide Vulkan functions to facilitate cross-process sharing of such handles rather than relying on native handles to define the external objects? RESOLVED: No. Cross-process sharing of resources is best left to native platforms. There are myriad security and extensibility issues with such a mechanism, and attempting to re-solve all those issues within Vulkan does not align with Vulkans purpose as a graphics API. If desired, such a mechanism could be built as a layer or helper library on top of the opaque native handle defined in this family of extensions. 8) Must implementations provide additional guarantees about state implicitly included in memory objects for those memory objects that may be exported? RESOLVED: Implementations must ensure that sharing memory objects does not transfer any information between the exporting and importing instances and APIs other than that required to share the data contained in the memory objects explicitly shared. As specific examples, data from previously freed memory objects that used the same underlying physical memory, and data from memory objects using adjacent physical memory must not be visible to applications importing an exported memory object. 9) Must implementations validate external handles the application provides as inputs to memory import operations? RESOLVED: Implementations must return an error to the application if the provided memory handle cannot be used to complete the requested import operation. However, implementations need not validate handles are of the exact type specified by the application. Revision 1, 2016-10-20 (James Jones) Initial version Name String VK_KHR_external_memory_capabilities Extension Type Instance extension Registered Extension Number 72 Revision 1 Ratification Status Ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 Deprecation State Promoted to Vulkan 1.1 Contact James Jones cubanismo Last Modified Date 2016-10-17 IP Status No known IP claims. Interactions and External Dependencies Interacts with VK_KHR_dedicated_allocation. Interacts with VK_NV_dedicated_allocation. Contributors Ian Elliott, Google Jesse Hall, Google James Jones, NVIDIA An application may wish to reference device memory in multiple Vulkan logical devices or instances, in multiple processes, and/or in multiple APIs. This extension provides a set of capability queries and handle definitions that allow an application to determine what types of external memory handles an implementation supports for a given set of use cases. All functionality in this extension is included in core Vulkan 1.1, with the KHR suffix omitted. The original type, enum, and command names are still available as aliases of the core functionality. vkGetPhysicalDeviceExternalBufferPropertiesKHR VkExternalBufferPropertiesKHR VkExternalMemoryPropertiesKHR VkPhysicalDeviceExternalBufferInfoKHR Extending VkImageFormatProperties2: VkExternalImageFormatPropertiesKHR Extending VkPhysicalDeviceImageFormatInfo2: VkPhysicalDeviceExternalImageFormatInfoKHR Extending VkPhysicalDeviceProperties2: VkPhysicalDeviceIDPropertiesKHR VkExternalMemoryFeatureFlagBitsKHR VkExternalMemoryHandleTypeFlagBitsKHR VkExternalMemoryFeatureFlagsKHR VkExternalMemoryHandleTypeFlagsKHR VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION VK_LUID_SIZE_KHR Extending VkExternalMemoryFeatureFlagBits: VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR Extending VkExternalMemoryHandleTypeFlagBits: VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR Extending VkStructureType: VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR 1) Why do so many external memory capabilities need to be queried on a per-memory-handle-type basis? PROPOSED RESOLUTION: This is because some handle types are based on OS-native objects that have far more limited capabilities than the very generic Vulkan memory objects. Not all memory handle types can name memory objects that support 3D images, for example. Some handle types cannot even support the deferred image and memory binding behavior of Vulkan and require specifying the image when allocating or importing the memory object. 2) Do the VkExternalImageFormatPropertiesKHR and VkExternalBufferPropertiesKHR structs need to include a list of memory type bits that support the given handle type? PROPOSED RESOLUTION: No. The memory types that do not support the handle types will simply be filtered out of the results returned by vkGetImageMemoryRequirements and vkGetBufferMemoryRequirements when a set of handle types was specified at image or buffer creation time. 3) Should the non-opaque handle types be moved to their own extension? PROPOSED RESOLUTION: Perhaps. However, defining the handle type bits does very little and does not require any platform-specific types on its own, and it is easier to maintain the bitfield values in a single extension for now. Presumably more handle types could be added by separate extensions though, and it would be midly weird to have some platform-specific ones defined in the core spec and some in extensions 4) Do we need a D3D11_TILEPOOL type? PROPOSED RESOLUTION: No. This is technically possible, but the synchronization is awkward. D3D11 surfaces must be synchronized using shared mutexes, and these synchronization primitives are shared by the entire memory object, so D3D11 shared allocations divided among multiple buffer and image bindings may be difficult to synchronize. 5) Should the Windows 7-compatible handle types be named KMT handles or GLOBAL_SHARE handles? PROPOSED RESOLUTION: KMT, simply because it is more concise. 6) How do applications identify compatible devices and drivers across instance, process, and API boundaries when sharing memory? PROPOSED RESOLUTION: New device properties are exposed that allow applications to correctly correlate devices and drivers. A device and driver UUID that must both match to ensure sharing compatibility between two Vulkan instances, or a Vulkan instance and an extensible external API are added. To allow correlating with Direct3D devices, a device LUID is added that corresponds to a DXGI adapter LUID. A driver ID is not needed for Direct3D because mismatched driver component versions are not currently supported on the Windows OS. Should support for such configurations be introduced at the OS level, further Vulkan extensions would be needed to correlate userspace component builds. Revision 1, 2016-10-17 (James Jones) Initial version Name String VK_KHR_external_semaphore Extension Type Device extension Registered Extension Number 78 Revision 1 Ratification Status Ratified Extension and Version Dependencies VK_KHR_external_semaphore_capabilities Deprecation State Promoted to Vulkan 1.1 Contact James Jones cubanismo Last Modified Date 2016-10-21 IP Status No known IP claims. Contributors Faith Ekstrand, Intel Jesse Hall, Google Tobias Hector, Imagination Technologies James Jones, NVIDIA Jeff Juliano, NVIDIA Matthew Netsch, Qualcomm Technologies, Inc. Ray Smith, ARM Lina Versace, Google An application using external memory may wish to synchronize access to that memory using semaphores. This extension enables an application to create semaphores from which non-Vulkan handles that reference the underlying synchronization primitive can be exported. All functionality in this extension is included in core Vulkan 1.1, with the KHR suffix omitted. The original type, enum, and command names are still available as aliases of the core functionality. Extending VkSemaphoreCreateInfo: VkExportSemaphoreCreateInfoKHR VkSemaphoreImportFlagBitsKHR VkSemaphoreImportFlagsKHR VK_KHR_EXTERNAL_SEMAPHORE_EXTENSION_NAME VK_KHR_EXTERNAL_SEMAPHORE_SPEC_VERSION Extending VkSemaphoreImportFlagBits: VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR Extending VkStructureType: VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR 1) Should there be restrictions on what side effects can occur when waiting on imported semaphores that are in an invalid state? RESOLVED: Yes. Normally, validating such state would be the responsibility of the application, and the implementation would be free to enter an undefined state if valid usage rules were violated. However, this could cause security concerns when using imported semaphores, as it would require the importing application to trust the exporting application to ensure the state is valid. Requiring this level of trust is undesirable for many potential use cases. 2) Must implementations validate external handles the application provides as input to semaphore state import operations? RESOLVED: Implementations must return an error to the application if the provided semaphore state handle cannot be used to complete the requested import operation. However, implementations need not validate handles are of the exact type specified by the application. Revision 1, 2016-10-21 (James Jones) Initial revision Name String VK_KHR_external_semaphore_capabilities Extension Type Instance extension Registered Extension Number 77 Revision 1 Ratification Status Ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 Deprecation State Promoted to Vulkan 1.1 Contact James Jones cubanismo Last Modified Date 2016-10-20 IP Status No known IP claims. Contributors Jesse Hall, Google James Jones, NVIDIA Jeff Juliano, NVIDIA An application may wish to reference device semaphores in multiple Vulkan logical devices or instances, in multiple processes, and/or in multiple APIs. This extension provides a set of capability queries and handle definitions that allow an application to determine what types of external semaphore handles an implementation supports for a given set of use cases. All functionality in this extension is included in core Vulkan 1.1, with the KHR suffix omitted. The original type, enum, and command names are still available as aliases of the core functionality. vkGetPhysicalDeviceExternalSemaphorePropertiesKHR VkExternalSemaphorePropertiesKHR VkPhysicalDeviceExternalSemaphoreInfoKHR Extending VkPhysicalDeviceProperties2: VkPhysicalDeviceIDPropertiesKHR VkExternalSemaphoreFeatureFlagBitsKHR VkExternalSemaphoreHandleTypeFlagBitsKHR VkExternalSemaphoreFeatureFlagsKHR VkExternalSemaphoreHandleTypeFlagsKHR VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION_NAME VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_SPEC_VERSION VK_LUID_SIZE_KHR Extending VkExternalSemaphoreFeatureFlagBits: VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR Extending VkExternalSemaphoreHandleTypeFlagBits: VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR Extending VkStructureType: VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR Revision 1, 2016-10-20 (James Jones) Initial revision Name String VK_KHR_format_feature_flags2 Extension Type Device extension Registered Extension Number 361 Revision 2 Ratification Status Ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 API Interactions Interacts with VK_VERSION_1_2 Interacts with VK_EXT_filter_cubic Interacts with VK_EXT_sampler_filter_minmax Interacts with VK_IMG_filter_cubic Deprecation State Promoted to Vulkan 1.3 Contact Lionel Landwerlin llandwerlin Last Modified Date 2021-07-01 IP Status No known IP claims. Contributors Lionel Landwerlin, Intel Faith Ekstrand, Intel Tobias Hector, AMD Spencer Fricke, Samsung Electronics Graeme Leese, Broadcom Jan-Harald Fredriksen, ARM This extension adds a new VkFormatFeatureFlagBits2KHR 64bits format feature flag type to extend the existing VkFormatFeatureFlagBits which is limited to 31 flags. At the time of this writing 29 bits of VkFormatFeatureFlagBits are already used. Because VkFormatProperties2 is already defined to extend the Vulkan 1.0 vkGetPhysicalDeviceFormatProperties command, this extension defines a new VkFormatProperties3KHR to extend the VkFormatProperties. On top of replicating all the bits from VkFormatFeatureFlagBits, VkFormatFeatureFlagBits2KHR adds the following bits : VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT_KHR and VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT_KHR specify that an implementation supports reading and writing, respectively, a given VkFormat through storage operations without specifying the format in the shader. VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT_KHR specifies that an implementation supports depth comparison performed by OpImage*Dref* instructions on a given VkFormat. Previously the result of executing a OpImage*Dref* instruction on an image view, where the format was not one of the depth/stencil formats with a depth component, was undefined. This bit clarifies on which formats such instructions can be used. Prior to version 2 of this extension, implementations exposing the shaderStorageImageReadWithoutFormat and shaderStorageImageWriteWithoutFormat features may not report VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT_KHR and VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT_KHR in VkFormatProperties3KHR::bufferFeatures. Despite this, buffer reads/writes are supported as intended by the original features. Extending VkFormatProperties2: VkFormatProperties3KHR VkFormatFeatureFlagBits2KHR VkFormatFeatureFlags2KHR VK_KHR_FORMAT_FEATURE_FLAGS_2_EXTENSION_NAME VK_KHR_FORMAT_FEATURE_FLAGS_2_SPEC_VERSION Extending VkFormatFeatureFlagBits2: VK_FORMAT_FEATURE_2_BLIT_DST_BIT_KHR VK_FORMAT_FEATURE_2_BLIT_SRC_BIT_KHR VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT_KHR VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BLEND_BIT_KHR VK_FORMAT_FEATURE_2_COSITED_CHROMA_SAMPLES_BIT_KHR VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT_KHR VK_FORMAT_FEATURE_2_DISJOINT_BIT_KHR VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT_KHR VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_BIT_KHR VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT_KHR VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_LINEAR_BIT_KHR VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR VK_FORMAT_FEATURE_2_STORAGE_IMAGE_ATOMIC_BIT_KHR VK_FORMAT_FEATURE_2_STORAGE_IMAGE_BIT_KHR VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT_KHR VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_ATOMIC_BIT_KHR VK_FORMAT_FEATURE_2_STORAGE_TEXEL_BUFFER_BIT_KHR VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT_KHR VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT_KHR VK_FORMAT_FEATURE_2_TRANSFER_SRC_BIT_KHR VK_FORMAT_FEATURE_2_UNIFORM_TEXEL_BUFFER_BIT_KHR VK_FORMAT_FEATURE_2_VERTEX_BUFFER_BIT_KHR Extending VkStructureType: VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3_KHR If VK_EXT_filter_cubic or VK_IMG_filter_cubic is supported: Extending VkFormatFeatureFlagBits2: VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT If Vulkan Version 1.2 or VK_EXT_sampler_filter_minmax is supported: Extending VkFormatFeatureFlagBits2: VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_FILTER_MINMAX_BIT_KHR Vulkan APIs in this extension are included in core Vulkan 1.3, with the KHR suffix omitted. External interactions defined by this extension, such as SPIR-V token names, retain their original names. The original Vulkan API names are still available as aliases of the core functionality. Revision 2, 2022-07-20 (Lionel Landwerlin) Clarify that VK_FORMAT_FEATURE_2_STORAGE_(READ|WRITE)_WITHOUT_FORMAT_BIT also apply to buffer views. Revision 1, 2020-07-21 (Lionel Landwerlin) Initial draft Name String VK_KHR_get_memory_requirements2 Extension Type Device extension Registered Extension Number 147 Revision 1 Ratification Status Ratified Extension and Version Dependencies None Deprecation State Promoted to Vulkan 1.1 Contact Faith Ekstrand gfxstrand Last Modified Date 2017-09-05 IP Status No known IP claims. Contributors Faith Ekstrand, Intel Jeff Bolz, NVIDIA Jesse Hall, Google This extension provides new queries for memory requirements of images and buffers that can be easily extended by other extensions, without introducing any additional commands. The Vulkan 1.0 VkMemoryRequirements and VkSparseImageMemoryRequirements structures do not include sType and pNext members. This extension wraps them in new structures with these members, so an application can query a chain of memory requirements structures by constructing the chain and letting the implementation fill them in. A new command is added for each vkGet*MemoryRequrements command in core Vulkan 1.0. All functionality in this extension is included in core Vulkan 1.1, with the KHR suffix omitted. The original type, enum, and command names are still available as aliases of the core functionality. vkGetBufferMemoryRequirements2KHR vkGetImageMemoryRequirements2KHR vkGetImageSparseMemoryRequirements2KHR VkBufferMemoryRequirementsInfo2KHR VkImageMemoryRequirementsInfo2KHR VkImageSparseMemoryRequirementsInfo2KHR VkMemoryRequirements2KHR VkSparseImageMemoryRequirements2KHR VK_KHR_GET_MEMORY_REQUIREMENTS_2_EXTENSION_NAME VK_KHR_GET_MEMORY_REQUIREMENTS_2_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR Revision 1, 2017-03-23 (Faith Ekstrand) Internal revisions Name String VK_KHR_get_physical_device_properties2 Extension Type Instance extension Registered Extension Number 60 Revision 2 Ratification Status Ratified Extension and Version Dependencies None Deprecation State Promoted to Vulkan 1.1 Contact Jeff Bolz jeffbolznv Last Modified Date 2017-09-05 IP Status No known IP claims. Contributors Jeff Bolz, NVIDIA Ian Elliott, Google This extension provides new queries for device features, device properties, and format properties that can be easily extended by other extensions, without introducing any further queries. The Vulkan 1.0 feature/limit/formatproperty structures do not include sType/pNext members. This extension wraps them in new structures with sType/pNext members, so an application can query a chain of feature/limit/formatproperty structures by constructing the chain and letting the implementation fill them in. A new command is added for each vkGetPhysicalDevice* command in core Vulkan 1.0. The new feature structure (and a pNext chain of extending structures) can also be passed in to device creation to enable features. This extension also allows applications to use the physical-device components of device extensions before vkCreateDevice is called. All functionality in this extension is included in core Vulkan 1.1, with the KHR suffix omitted. The original type, enum, and command names are still available as aliases of the core functionality. vkGetPhysicalDeviceFeatures2KHR vkGetPhysicalDeviceFormatProperties2KHR vkGetPhysicalDeviceImageFormatProperties2KHR vkGetPhysicalDeviceMemoryProperties2KHR vkGetPhysicalDeviceProperties2KHR vkGetPhysicalDeviceQueueFamilyProperties2KHR vkGetPhysicalDeviceSparseImageFormatProperties2KHR VkFormatProperties2KHR VkImageFormatProperties2KHR VkPhysicalDeviceImageFormatInfo2KHR VkPhysicalDeviceMemoryProperties2KHR VkPhysicalDeviceProperties2KHR VkPhysicalDeviceSparseImageFormatInfo2KHR VkQueueFamilyProperties2KHR VkSparseImageFormatProperties2KHR Extending VkDeviceCreateInfo: VkPhysicalDeviceFeatures2KHR VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR // Get features with a hypothetical future extension. VkHypotheticalExtensionFeaturesKHR hypotheticalFeatures = { .sType = VK_STRUCTURE_TYPE_HYPOTHETICAL_FEATURES_KHR, .pNext = NULL, }; VkPhysicalDeviceFeatures2KHR features = { .sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR, .pNext = &hypotheticalFeatures, }; // After this call, features and hypotheticalFeatures have been filled out. vkGetPhysicalDeviceFeatures2KHR(physicalDevice, &features); // Properties/limits can be chained and queried similarly. // Enable some features: VkHypotheticalExtensionFeaturesKHR enabledHypotheticalFeatures = { .sType = VK_STRUCTURE_TYPE_HYPOTHETICAL_FEATURES_KHR, .pNext = NULL, }; VkPhysicalDeviceFeatures2KHR enabledFeatures = { .sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR, .pNext = &enabledHypotheticalFeatures, }; enabledFeatures.features.xyz = VK_TRUE; enabledHypotheticalFeatures.abc = VK_TRUE; VkDeviceCreateInfo deviceCreateInfo = { .sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO, .pNext = &enabledFeatures, ... .pEnabledFeatures = NULL, }; VkDevice device; vkCreateDevice(physicalDevice, &deviceCreateInfo, NULL, &device); Revision 1, 2016-09-12 (Jeff Bolz) Internal revisions Revision 2, 2016-11-02 (Ian Elliott) Added ability for applications to use the physical-device components of device extensions before vkCreateDevice is called. Name String VK_KHR_global_priority Extension Type Device extension Registered Extension Number 189 Revision 1 Ratification Status Ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 Deprecation State Promoted to Vulkan 1.4 Contact Tobias Hector tobski Last Modified Date 2021-10-22 Contributors Tobias Hector, AMD Contributors to VK_EXT_global_priority Contributors to VK_EXT_global_priority_query In Vulkan, users can specify device-scope queue priorities. In some cases it may be useful to extend this concept to a system-wide scope. This device extension allows applications to query the global queue priorities supported by a queue family, and then set a priority when creating queues. The default queue priority is VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT. Implementations can report which global priority levels are treated differently by the implementation. It is intended primarily for use in system integration along with certain platform-specific priority enforcement rules. The driver implementation will attempt to skew hardware resource allocation in favor of the higher-priority task. Therefore, higher-priority work may retain similar latency and throughput characteristics even if the system is congested with lower priority work. The global priority level of a queue shall take precedence over the per-process queue priority (VkDeviceQueueCreateInfo::pQueuePriorities). Abuse of this feature may result in starving the rest of the system from hardware resources. Therefore, the driver implementation may deny requests to acquire a priority above the default priority (VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT) if the caller does not have sufficient privileges. In this scenario VK_ERROR_NOT_PERMITTED_EXT is returned. The driver implementation may fail the queue allocation request if resources required to complete the operation have been exhausted (either by the same process or a different process). In this scenario VK_ERROR_INITIALIZATION_FAILED is returned. Extending VkDeviceQueueCreateInfo: VkDeviceQueueGlobalPriorityCreateInfoKHR Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR Extending VkQueueFamilyProperties2: VkQueueFamilyGlobalPriorityPropertiesKHR VkQueueGlobalPriorityKHR VK_KHR_GLOBAL_PRIORITY_EXTENSION_NAME VK_KHR_GLOBAL_PRIORITY_SPEC_VERSION VK_MAX_GLOBAL_PRIORITY_SIZE_KHR Extending VkQueueGlobalPriority: VK_QUEUE_GLOBAL_PRIORITY_HIGH_KHR VK_QUEUE_GLOBAL_PRIORITY_LOW_KHR VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_KHR VK_QUEUE_GLOBAL_PRIORITY_REALTIME_KHR Extending VkResult: VK_ERROR_NOT_PERMITTED_KHR Extending VkStructureType: VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR Functionality in this extension is included in core Vulkan 1.4 with the KHR suffix omitted. The original type, enum and command names are still available as aliases of the core functionality. 1) Can we additionally query whether a caller is permitted to acquire a specific global queue priority in this extension? RESOLVED: No. Whether a caller has enough privilege goes with the OS, and the Vulkan driver cannot really guarantee that the privilege will not change in between this query and the actual queue creation call. 2) If more than 1 queue using global priority is requested, is there a good way to know which queue is failing the device creation? RESOLVED: No. There is not a good way at this moment, and it is also not quite actionable for the applications to know that because the information may not be accurate. Queue creation can fail because of runtime constraints like insufficient privilege or lack of resource, and the failure is not necessarily tied to that particular queue configuration requested. Revision 1, 2021-10-22 (Tobias Hector) Initial draft Name String VK_KHR_image_format_list Extension Type Device extension Registered Extension Number 148 Revision 1 Ratification Status Ratified Extension and Version Dependencies None Deprecation State Promoted to Vulkan 1.2 Contact Faith Ekstrand gfxstrand Last Modified Date 2017-03-20 IP Status No known IP claims. Contributors Faith Ekstrand, Intel Jan-Harald Fredriksen, ARM Jeff Bolz, NVIDIA Jeff Leger, Qualcomm Neil Henning, Codeplay On some implementations, setting the VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT on image creation can cause access to that image to perform worse than an equivalent image created without VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT because the implementation does not know what view formats will be paired with the image. This extension allows an application to provide the list of all formats that can be used with an image when it is created. The implementation may then be able to create a more efficient image that supports the subset of formats required by the application without having to support all formats in the format compatibility class of the image format. All functionality in this extension is included in core Vulkan 1.2, with the KHR suffix omitted. The original type, enum, and command names are still available as aliases of the core functionality. Extending VkImageCreateInfo, VkSwapchainCreateInfoKHR, VkPhysicalDeviceImageFormatInfo2: VkImageFormatListCreateInfoKHR VK_KHR_IMAGE_FORMAT_LIST_EXTENSION_NAME VK_KHR_IMAGE_FORMAT_LIST_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR Revision 1, 2017-03-20 (Faith Ekstrand) Initial revision Name String VK_KHR_imageless_framebuffer Extension Type Device extension Registered Extension Number 109 Revision 1 Ratification Status Ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 and VK_KHR_maintenance2 or Vulkan Version 1.1 and VK_KHR_image_format_list or Vulkan Version 1.2 Deprecation State Promoted to Vulkan 1.2 Contact Tobias Hector tobias Last Modified Date 2018-12-14 Contributors Tobias Hector Graham Wihlidal This extension allows framebuffers to be created without the need for creating images first, allowing more flexibility in how they are used, and avoiding the need for many of the confusing compatibility rules. Framebuffers are now created with a small amount of additional metadata about the image views that will be used in VkFramebufferAttachmentsCreateInfoKHR, and the actual image views are provided at render pass begin time via VkRenderPassAttachmentBeginInfoKHR. All functionality in this extension is included in core Vulkan 1.2, with the KHR suffix omitted. The original type, enum, and command names are still available as aliases of the core functionality. VkFramebufferAttachmentImageInfoKHR Extending VkFramebufferCreateInfo: VkFramebufferAttachmentsCreateInfoKHR Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceImagelessFramebufferFeaturesKHR Extending VkRenderPassBeginInfo: VkRenderPassAttachmentBeginInfoKHR VK_KHR_IMAGELESS_FRAMEBUFFER_EXTENSION_NAME VK_KHR_IMAGELESS_FRAMEBUFFER_SPEC_VERSION Extending VkFramebufferCreateFlagBits: VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT_KHR Extending VkStructureType: VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO_KHR VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO_KHR VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES_KHR VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO_KHR Revision 1, 2018-12-14 (Tobias Hector) Internal revisions Name String VK_KHR_index_type_uint8 Extension Type Device extension Registered Extension Number 534 Revision 1 Ratification Status Ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 Deprecation State Promoted to Vulkan 1.4 Contact Piers Daniell pdaniell-nv Last Modified Date 2023-06-06 IP Status No known IP claims. Contributors Jeff Bolz, NVIDIA This extension allows uint8_t indices to be used with vkCmdBindIndexBuffer. Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceIndexTypeUint8FeaturesKHR VK_KHR_INDEX_TYPE_UINT8_EXTENSION_NAME VK_KHR_INDEX_TYPE_UINT8_SPEC_VERSION Extending VkIndexType: VK_INDEX_TYPE_UINT8_KHR Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_KHR Functionality in this extension is included in core Vulkan 1.4 with the KHR suffix omitted. The original type, enum and command names are still available as aliases of the core functionality. Revision 1, 2023-06-06 (Piers Daniell) Internal revisions Name String VK_KHR_line_rasterization Extension Type Device extension Registered Extension Number 535 Revision 1 Ratification Status Ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 Deprecation State Promoted to Vulkan 1.4 Contact Piers Daniell pdaniell-nv Last Modified Date 2023-06-08 IP Status No known IP claims. Contributors Jeff Bolz, NVIDIA Allen Jensen, NVIDIA Faith Ekstrand, Intel This extension adds some line rasterization features that are commonly used in CAD applications and supported in other APIs like OpenGL. Bresenham-style line rasterization is supported, smooth rectangular lines (coverage to alpha) are supported, and stippled lines are supported for all three line rasterization modes. vkCmdSetLineStippleKHR Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceLineRasterizationFeaturesKHR Extending VkPhysicalDeviceProperties2: VkPhysicalDeviceLineRasterizationPropertiesKHR Extending VkPipelineRasterizationStateCreateInfo: VkPipelineRasterizationLineStateCreateInfoKHR VkLineRasterizationModeKHR VK_KHR_LINE_RASTERIZATION_EXTENSION_NAME VK_KHR_LINE_RASTERIZATION_SPEC_VERSION Extending VkDynamicState: VK_DYNAMIC_STATE_LINE_STIPPLE_KHR Extending VkLineRasterizationMode: VK_LINE_RASTERIZATION_MODE_BRESENHAM_KHR VK_LINE_RASTERIZATION_MODE_DEFAULT_KHR VK_LINE_RASTERIZATION_MODE_RECTANGULAR_KHR VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_KHR Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_KHR VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_KHR VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_KHR Functionality in this extension is included in core Vulkan 1.4 with the KHR suffix omitted. The original type, enum and command names are still available as aliases of the core functionality. When Version 1.4 is supported, the bresenhamLines feature must be supported. 1) Do we need to support Bresenham-style and smooth lines with more than one rasterization sample? i.e. the equivalent of glDisable(GL_MULTISAMPLE) in OpenGL when the framebuffer has more than one sample? RESOLVED: Yes. For simplicity, Bresenham line rasterization carries forward a few restrictions from OpenGL, such as not supporting per-sample shading, alpha to coverage, or alpha to one. Revision 1, 2019-05-09 (Jeff Bolz) Initial draft Name String VK_KHR_load_store_op_none Extension Type Device extension Registered Extension Number 527 Revision 1 Ratification Status Ratified Extension and Version Dependencies None Deprecation State Promoted to Vulkan 1.4 Contact Shahbaz Youssefi syoussefi Extension Proposal VK_KHR_load_store_op_none Last Modified Date 2023-05-16 Contributors Shahbaz Youssefi, Google Bill Licea-Kane, Qualcomm Technologies, Inc. Tobias Hector, AMD This extension provides VK_ATTACHMENT_LOAD_OP_NONE_KHR and VK_ATTACHMENT_STORE_OP_NONE_KHR, which are identically promoted from the VK_EXT_load_store_op_none extension. VK_KHR_LOAD_STORE_OP_NONE_EXTENSION_NAME VK_KHR_LOAD_STORE_OP_NONE_SPEC_VERSION Extending VkAttachmentLoadOp: VK_ATTACHMENT_LOAD_OP_NONE_KHR Extending VkAttachmentStoreOp: VK_ATTACHMENT_STORE_OP_NONE_KHR Functionality in this extension is included in core Vulkan 1.4 with the KHR suffix omitted. The original type, enum and command names are still available as aliases of the core functionality. While VK_ATTACHMENT_STORE_OP_NONE is part of Vulkan 1.3, this extension was not promoted to core Vulkan 1.3 either in whole or in part. This functionality was promoted from VK_KHR_dynamic_rendering. Revision 1, 2023-05-16 (Shahbaz Youssefi) Initial revision, based on VK_EXT_load_store_op_none. Name String VK_KHR_maintenance1 Extension Type Device extension Registered Extension Number 70 Revision 2 Ratification Status Ratified Extension and Version Dependencies None Deprecation State Promoted to Vulkan 1.1 Contact Piers Daniell pdaniell-nv Last Modified Date 2018-03-13 Contributors Dan Ginsburg, Valve Daniel Koch, NVIDIA Daniel Rakos, AMD Jan-Harald Fredriksen, ARM Faith Ekstrand, Intel Jeff Bolz, NVIDIA Jesse Hall, Google John Kessenich, Google Michael Worcester, Imagination Technologies Neil Henning, Codeplay Software Ltd. Piers Daniell, NVIDIA Slawomir Grajewski, Intel Tobias Hector, Imagination Technologies Tom Olson, ARM VK_KHR_maintenance1 adds a collection of minor features that were intentionally left out or overlooked from the original Vulkan 1.0 release. The new features are as follows: Allow 2D and 2D array image views to be created from 3D images, which can then be used as color framebuffer attachments. This allows applications to render to slices of a 3D image. Support vkCmdCopyImage between 2D array layers and 3D slices. This extension allows copying from layers of a 2D array image to slices of a 3D image and vice versa. Allow negative height to be specified in the VkViewport::height field to perform y-inversion of the clip-space to framebuffer-space transform. This allows apps to avoid having to use gl_Position.y = -gl_Position.y in shaders also targeting other APIs. Allow implementations to express support for doing just transfers and clears of image formats that they otherwise support no other format features for. This is done by adding new format feature flags VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR and VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR. Support vkCmdFillBuffer on transfer-only queues. Previously vkCmdFillBuffer was defined to only work on command buffers allocated from command pools which support graphics or compute queues. It is now allowed on queues that just support transfer operations. Fix the inconsistency of how error conditions are returned between the vkCreateGraphicsPipelines and vkCreateComputePipelines functions and the vkAllocateDescriptorSets and vkAllocateCommandBuffers functions. Add new VK_ERROR_OUT_OF_POOL_MEMORY_KHR error so implementations can give a more precise reason for vkAllocateDescriptorSets failures. Add a new command vkTrimCommandPoolKHR which gives the implementation an opportunity to release any unused command pool memory back to the system. All functionality in this extension is included in core Vulkan 1.1, with the KHR suffix omitted. The original type, enum, and command names are still available as aliases of the core functionality. vkTrimCommandPoolKHR VkCommandPoolTrimFlagsKHR VK_KHR_MAINTENANCE1_EXTENSION_NAME VK_KHR_MAINTENANCE1_SPEC_VERSION VK_KHR_MAINTENANCE_1_EXTENSION_NAME VK_KHR_MAINTENANCE_1_SPEC_VERSION Extending VkFormatFeatureFlagBits: VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR Extending VkImageCreateFlagBits: VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR Extending VkResult: VK_ERROR_OUT_OF_POOL_MEMORY_KHR Are viewports with zero height allowed? RESOLVED: Yes, although they have low utility. Revision 1, 2016-10-26 (Piers Daniell) Internal revisions Revision 2, 2018-03-13 (Jon Leech) Add issue for zero-height viewports Name String VK_KHR_maintenance2 Extension Type Device extension Registered Extension Number 118 Revision 1 Ratification Status Ratified Extension and Version Dependencies None Deprecation State Promoted to Vulkan 1.1 Contact Michael Worcester michaelworcester Last Modified Date 2017-09-05 Contributors Michael Worcester, Imagination Technologies Stuart Smith, Imagination Technologies Jeff Bolz, NVIDIA Daniel Koch, NVIDIA Jan-Harald Fredriksen, ARM Daniel Rakos, AMD Neil Henning, Codeplay Piers Daniell, NVIDIA VK_KHR_maintenance2 adds a collection of minor features that were intentionally left out or overlooked from the original Vulkan 1.0 release. The new features are as follows: Allow the application to specify which aspect of an input attachment might be read for a given subpass. Allow implementations to express the clipping behavior of points. Allow creating images with usage flags that may not be supported for the base images format, but are supported for image views of the image that have a different but compatible format. Allow creating uncompressed image views of compressed images. Allow the application to select between an upper-left and lower-left origin for the tessellation domain space. Adds two new image layouts for depth stencil images to allow either the depth or stencil aspect to be read-only while the other aspect is writable. Input attachment specification allows an application to specify which aspect of a multi-aspect image (e.g. a depth/stencil format) will be accessed via a subpassLoad operation. On some implementations there may be a performance penalty if the implementation does not know (at vkCreateRenderPass time) which aspect(s) of multi-aspect images can be accessed as input attachments. All functionality in this extension is included in core Vulkan 1.1, with the KHR suffix omitted. The original type, enum, and command names are still available as aliases of the core functionality. VkInputAttachmentAspectReferenceKHR Extending VkImageViewCreateInfo: VkImageViewUsageCreateInfoKHR Extending VkPhysicalDeviceProperties2: VkPhysicalDevicePointClippingPropertiesKHR Extending VkPipelineTessellationStateCreateInfo: VkPipelineTessellationDomainOriginStateCreateInfoKHR Extending VkRenderPassCreateInfo: VkRenderPassInputAttachmentAspectCreateInfoKHR VkPointClippingBehaviorKHR VkTessellationDomainOriginKHR VK_KHR_MAINTENANCE2_EXTENSION_NAME VK_KHR_MAINTENANCE2_SPEC_VERSION VK_KHR_MAINTENANCE_2_EXTENSION_NAME VK_KHR_MAINTENANCE_2_SPEC_VERSION Extending VkImageCreateFlagBits: VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR Extending VkImageLayout: VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR Extending VkPointClippingBehavior: VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES_KHR VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY_KHR Extending VkStructureType: VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO_KHR VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR Extending VkTessellationDomainOrigin: VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT_KHR VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT_KHR Consider the case where a render pass has two subpasses and two attachments. Attachment 0 has the format VK_FORMAT_D24_UNORM_S8_UINT, attachment 1 has some color format. Subpass 0 writes to attachment 0, subpass 1 reads only the depth information from attachment 0 (using inputAttachmentRead) and writes to attachment 1. VkInputAttachmentAspectReferenceKHR references[] = { { .subpass = 1, .inputAttachmentIndex = 0, .aspectMask = VK_IMAGE_ASPECT_DEPTH_BIT } }; VkRenderPassInputAttachmentAspectCreateInfoKHR specifyAspects = { .sType = VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR, .pNext = NULL, .aspectReferenceCount = 1, .pAspectReferences = references }; VkRenderPassCreateInfo createInfo = { ... .pNext = &specifyAspects, ... }; vkCreateRenderPass(...); 1) What is the default tessellation domain origin? RESOLVED: Vulkan 1.0 originally inadvertently documented a lower-left origin, but the conformance tests and all implementations implemented an upper-left origin. This extension adds a control to select between lower-left (for compatibility with OpenGL) and upper-left, and we retroactively fix unextended Vulkan to have a default of an upper-left origin. Revision 1, 2017-04-28 Name String VK_KHR_maintenance3 Extension Type Device extension Registered Extension Number 169 Revision 1 Ratification Status Ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 Deprecation State Promoted to Vulkan 1.1 Contact Jeff Bolz jeffbolznv Last Modified Date 2017-09-05 Contributors Jeff Bolz, NVIDIA VK_KHR_maintenance3 adds a collection of minor features that were intentionally left out or overlooked from the original Vulkan 1.0 release. The new features are as follows: A limit on the maximum number of descriptors that are supported in a single descriptor set layout. Some implementations have a limit on the total size of descriptors in a set, which cannot be expressed in terms of the limits in Vulkan 1.0. A limit on the maximum size of a single memory allocation. Some platforms have kernel interfaces that limit the maximum size of an allocation. All functionality in this extension is included in core Vulkan 1.1, with the KHR suffix omitted. The original type, enum, and command names are still available as aliases of the core functionality. vkGetDescriptorSetLayoutSupportKHR VkDescriptorSetLayoutSupportKHR Extending VkPhysicalDeviceProperties2: VkPhysicalDeviceMaintenance3PropertiesKHR VK_KHR_MAINTENANCE3_EXTENSION_NAME VK_KHR_MAINTENANCE3_SPEC_VERSION VK_KHR_MAINTENANCE_3_EXTENSION_NAME VK_KHR_MAINTENANCE_3_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR Revision 1, 2017-08-22 Name String VK_KHR_maintenance4 Extension Type Device extension Registered Extension Number 414 Revision 2 Ratification Status Ratified Extension and Version Dependencies Vulkan Version 1.1 Deprecation State Promoted to Vulkan 1.3 Contact Piers Daniell pdaniell-nv Last Modified Date 2021-10-25 Interactions and External Dependencies Requires SPIR-V 1.2 for LocalSizeId Contributors Lionel Duc, NVIDIA Faith Ekstrand, Intel Spencer Fricke, Samsung Tobias Hector, AMD Lionel Landwerlin, Intel Graeme Leese, Broadcom Tom Olson, Arm Stu Smith, AMD Yiwei Zhang, Google VK_KHR_maintenance4 adds a collection of minor features, none of which would warrant an entire extension of their own. The new features are as follows: Allow the application to destroy their VkPipelineLayout object immediately after it was used to create another object. It is no longer necessary to keep its handle valid while the created object is in use. Add a new maxBufferSize implementation-defined limit for the maximum size VkBuffer that can be created. Add support for the SPIR-V 1.2 LocalSizeId execution mode, which can be used as an alternative to LocalSize to specify the local workgroup size with specialization constants. Add a guarantee that images created with identical creation parameters will always have the same alignment requirements. Add new vkGetDeviceBufferMemoryRequirementsKHR, vkGetDeviceImageMemoryRequirementsKHR, and vkGetDeviceImageSparseMemoryRequirementsKHR to allow the application to query the image memory requirements without having to create an image object and query it. Relax the requirement that push constants must be initialized before they are dynamically accessed. Relax the interface matching rules to allow a larger output vector to match with a smaller input vector, with additional values being discarded. Add a guarantee for buffer memory requirement that the size memory requirement is never greater than the result of aligning create size with the alignment memory requirement. vkGetDeviceBufferMemoryRequirementsKHR vkGetDeviceImageMemoryRequirementsKHR vkGetDeviceImageSparseMemoryRequirementsKHR VkDeviceBufferMemoryRequirementsKHR VkDeviceImageMemoryRequirementsKHR Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceMaintenance4FeaturesKHR Extending VkPhysicalDeviceProperties2: VkPhysicalDeviceMaintenance4PropertiesKHR VK_KHR_MAINTENANCE_4_EXTENSION_NAME VK_KHR_MAINTENANCE_4_SPEC_VERSION Extending VkImageAspectFlagBits: VK_IMAGE_ASPECT_NONE_KHR Extending VkStructureType: VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS_KHR VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS_KHR VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES_KHR VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES_KHR Vulkan APIs in this extension are included in core Vulkan 1.3, with the KHR suffix omitted. External interactions defined by this extension, such as SPIR-V token names, retain their original names. The original Vulkan API names are still available as aliases of the core functionality. None. Revision 1, 2021-08-18 (Piers Daniell) Internal revisions Revision 2, 2021-10-25 (Yiwei Zhang) More guarantees on buffer memory requirements Name String VK_KHR_maintenance5 Extension Type Device extension Registered Extension Number 471 Revision 1 Ratification Status Ratified Extension and Version Dependencies Vulkan Version 1.1 and VK_KHR_dynamic_rendering or Vulkan Version 1.3 API Interactions Interacts with VK_VERSION_1_2 Interacts with VK_VERSION_1_3 Interacts with VK_VERSION_1_4 Interacts with VK_ARM_pipeline_opacity_micromap Interacts with VK_EXT_attachment_feedback_loop_layout Interacts with VK_EXT_buffer_device_address Interacts with VK_EXT_conditional_rendering Interacts with VK_EXT_descriptor_buffer Interacts with VK_EXT_fragment_density_map Interacts with VK_EXT_graphics_pipeline_library Interacts with VK_EXT_opacity_micromap Interacts with VK_EXT_pipeline_creation_cache_control Interacts with VK_EXT_pipeline_protected_access Interacts with VK_EXT_transform_feedback Interacts with VK_KHR_acceleration_structure Interacts with VK_KHR_buffer_device_address Interacts with VK_KHR_dynamic_rendering Interacts with VK_KHR_fragment_shading_rate Interacts with VK_KHR_pipeline_executable_properties Interacts with VK_KHR_pipeline_library Interacts with VK_KHR_ray_tracing_pipeline Interacts with VK_KHR_video_decode_queue Interacts with VK_KHR_video_encode_queue Interacts with VK_NV_device_generated_commands Interacts with VK_NV_displacement_micromap Interacts with VK_NV_ray_tracing Interacts with VK_NV_ray_tracing_motion_blur Deprecation State Promoted to Vulkan 1.4 Contact Stu Smith stu-s Extension Proposal VK_KHR_maintenance5 Last Modified Date 2023-05-02 Interactions and External Dependencies Contributors Stu Smith, AMD Tobias Hector, AMD Shahbaz Youssefi, Google Slawomir Cygan, Intel Lionel Landwerlin, Intel James Fitzpatrick, Imagination Technologies Andrew Garrard, Imagination Technologies Ralph Potter, Samsung Pan Gao, Huawei Jan-Harald Fredriksen, ARM Jon Leech, Khronos Mike Blumenkrantz, Valve VK_KHR_maintenance5 adds a collection of minor features, none of which would warrant an entire extension of their own. The new features are as follows: A new VK_FORMAT_A1B5G5R5_UNORM_PACK16_KHR format A new VK_FORMAT_A8_UNORM_KHR format A property to indicate that multisample coverage operations are performed after sample counting in EarlyFragmentTests mode Relax VkBufferView creation requirements by allowing subsets of the associated VkBuffer usage using VkBufferUsageFlags2CreateInfoKHR A new command vkCmdBindIndexBuffer2KHR, allowing a range of memory to be bound as an index buffer vkGetDeviceProcAddr must return NULL for supported core functions beyond the version requested by the application. A property to indicate that the sample mask test is performed after sample counting in EarlyFragmentTests mode vkCmdBindVertexBuffers2 now supports using VK_WHOLE_SIZE in the pSizes parameter. A default size of 1.0 is used if PointSize is not written Shader modules are deprecated - applications can now pass VkShaderModuleCreateInfo as a chained structure to pipeline creation via VkPipelineShaderStageCreateInfo A function vkGetRenderingAreaGranularityKHR to query the optimal render area for a dynamic rendering instance. A property to indicate that depth/stencil texturing operations with VK_COMPONENT_SWIZZLE_ONE have defined behavior Add vkGetImageSubresourceLayout2KHR and a new function vkGetDeviceImageSubresourceLayoutKHR to allow the application to query the image memory layout without having to create an image object and query it. Allow VK_REMAINING_ARRAY_LAYERS as the layerCount member of VkImageSubresourceLayers Adds stronger guarantees for propagation of VK_ERROR_DEVICE_LOST return values A property to indicate whether PointSize controls the final rasterization of polygons if polygon mode is VK_POLYGON_MODE_POINT Two properties to indicate the non-strict line rasterization algorithm used Two new flags words VkPipelineCreateFlagBits2KHR and VkBufferUsageFlagBits2KHR Physical-device-level functions can now be called with any value in the valid range for a type beyond the defined enumerants, such that applications can avoid checking individual features, extensions, or versions before querying supported properties of a particular enumerant. Clarification that copies between images of any type are allowed, treating 1D images as 2D images with a height of 1. vkCmdBindIndexBuffer2KHR vkGetDeviceImageSubresourceLayoutKHR vkGetImageSubresourceLayout2KHR vkGetRenderingAreaGranularityKHR VkDeviceImageSubresourceInfoKHR VkImageSubresource2KHR VkRenderingAreaInfoKHR VkSubresourceLayout2KHR Extending VkBufferViewCreateInfo, VkBufferCreateInfo, VkPhysicalDeviceExternalBufferInfo, VkDescriptorBufferBindingInfoEXT: VkBufferUsageFlags2CreateInfoKHR Extending VkComputePipelineCreateInfo, VkGraphicsPipelineCreateInfo, VkRayTracingPipelineCreateInfoNV, VkRayTracingPipelineCreateInfoKHR: VkPipelineCreateFlags2CreateInfoKHR Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceMaintenance5FeaturesKHR Extending VkPhysicalDeviceProperties2: VkPhysicalDeviceMaintenance5PropertiesKHR VkBufferUsageFlagBits2KHR VkPipelineCreateFlagBits2KHR VkBufferUsageFlags2KHR VkPipelineCreateFlags2KHR VK_KHR_MAINTENANCE_5_EXTENSION_NAME VK_KHR_MAINTENANCE_5_SPEC_VERSION Extending VkBufferUsageFlagBits2: VK_BUFFER_USAGE_2_INDEX_BUFFER_BIT_KHR VK_BUFFER_USAGE_2_INDIRECT_BUFFER_BIT_KHR VK_BUFFER_USAGE_2_STORAGE_BUFFER_BIT_KHR VK_BUFFER_USAGE_2_STORAGE_TEXEL_BUFFER_BIT_KHR VK_BUFFER_USAGE_2_TRANSFER_DST_BIT_KHR VK_BUFFER_USAGE_2_TRANSFER_SRC_BIT_KHR VK_BUFFER_USAGE_2_UNIFORM_BUFFER_BIT_KHR VK_BUFFER_USAGE_2_UNIFORM_TEXEL_BUFFER_BIT_KHR VK_BUFFER_USAGE_2_VERTEX_BUFFER_BIT_KHR Extending VkFormat: VK_FORMAT_A1B5G5R5_UNORM_PACK16_KHR VK_FORMAT_A8_UNORM_KHR Extending VkPipelineCreateFlagBits2: VK_PIPELINE_CREATE_2_ALLOW_DERIVATIVES_BIT_KHR VK_PIPELINE_CREATE_2_DERIVATIVE_BIT_KHR VK_PIPELINE_CREATE_2_DISABLE_OPTIMIZATION_BIT_KHR VK_PIPELINE_CREATE_2_DISPATCH_BASE_BIT_KHR VK_PIPELINE_CREATE_2_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR Extending VkStructureType: VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO_KHR VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO_KHR VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_KHR VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES_KHR VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES_KHR VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO_KHR VK_STRUCTURE_TYPE_RENDERING_AREA_INFO_KHR VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_KHR If VK_KHR_dynamic_rendering or Vulkan Version 1.3 and VK_EXT_fragment_density_map is supported: Extending VkPipelineCreateFlagBits2: VK_PIPELINE_CREATE_2_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT If VK_KHR_dynamic_rendering or Vulkan Version 1.3 and VK_KHR_fragment_shading_rate is supported: Extending VkPipelineCreateFlagBits2: VK_PIPELINE_CREATE_2_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR If VK_ARM_pipeline_opacity_micromap is supported: Extending VkPipelineCreateFlagBits2: VK_PIPELINE_CREATE_2_DISALLOW_OPACITY_MICROMAP_BIT_ARM If VK_EXT_attachment_feedback_loop_layout is supported: Extending VkPipelineCreateFlagBits2: VK_PIPELINE_CREATE_2_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT VK_PIPELINE_CREATE_2_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT If VK_EXT_conditional_rendering is supported: Extending VkBufferUsageFlagBits2: VK_BUFFER_USAGE_2_CONDITIONAL_RENDERING_BIT_EXT If VK_EXT_descriptor_buffer is supported: Extending VkBufferUsageFlagBits2: VK_BUFFER_USAGE_2_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT VK_BUFFER_USAGE_2_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT VK_BUFFER_USAGE_2_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT Extending VkPipelineCreateFlagBits2: VK_PIPELINE_CREATE_2_DESCRIPTOR_BUFFER_BIT_EXT If VK_EXT_graphics_pipeline_library is supported: Extending VkPipelineCreateFlagBits2: VK_PIPELINE_CREATE_2_LINK_TIME_OPTIMIZATION_BIT_EXT VK_PIPELINE_CREATE_2_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT If VK_EXT_opacity_micromap is supported: Extending VkBufferUsageFlagBits2: VK_BUFFER_USAGE_2_MICROMAP_BUILD_INPUT_READ_ONLY_BIT_EXT VK_BUFFER_USAGE_2_MICROMAP_STORAGE_BIT_EXT Extending VkPipelineCreateFlagBits2: VK_PIPELINE_CREATE_2_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT If VK_EXT_transform_feedback is supported: Extending VkBufferUsageFlagBits2: VK_BUFFER_USAGE_2_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT VK_BUFFER_USAGE_2_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT If VK_KHR_acceleration_structure is supported: Extending VkBufferUsageFlagBits2: VK_BUFFER_USAGE_2_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR VK_BUFFER_USAGE_2_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR If VK_KHR_pipeline_executable_properties is supported: Extending VkPipelineCreateFlagBits2: VK_PIPELINE_CREATE_2_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR VK_PIPELINE_CREATE_2_CAPTURE_STATISTICS_BIT_KHR If VK_KHR_pipeline_library is supported: Extending VkPipelineCreateFlagBits2: VK_PIPELINE_CREATE_2_LIBRARY_BIT_KHR If VK_KHR_ray_tracing_pipeline is supported: Extending VkBufferUsageFlagBits2: VK_BUFFER_USAGE_2_SHADER_BINDING_TABLE_BIT_KHR Extending VkPipelineCreateFlagBits2: VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR VK_PIPELINE_CREATE_2_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR VK_PIPELINE_CREATE_2_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR VK_PIPELINE_CREATE_2_RAY_TRACING_SKIP_AABBS_BIT_KHR VK_PIPELINE_CREATE_2_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR If VK_KHR_video_decode_queue is supported: Extending VkBufferUsageFlagBits2: VK_BUFFER_USAGE_2_VIDEO_DECODE_DST_BIT_KHR VK_BUFFER_USAGE_2_VIDEO_DECODE_SRC_BIT_KHR If VK_KHR_video_encode_queue is supported: Extending VkBufferUsageFlagBits2: VK_BUFFER_USAGE_2_VIDEO_ENCODE_DST_BIT_KHR VK_BUFFER_USAGE_2_VIDEO_ENCODE_SRC_BIT_KHR If VK_NV_device_generated_commands is supported: Extending VkPipelineCreateFlagBits2: VK_PIPELINE_CREATE_2_INDIRECT_BINDABLE_BIT_NV If VK_NV_displacement_micromap is supported: Extending VkPipelineCreateFlagBits2: VK_PIPELINE_CREATE_2_RAY_TRACING_DISPLACEMENT_MICROMAP_BIT_NV If VK_NV_ray_tracing is supported: Extending VkBufferUsageFlagBits2: VK_BUFFER_USAGE_2_RAY_TRACING_BIT_NV Extending VkPipelineCreateFlagBits2: VK_PIPELINE_CREATE_2_DEFER_COMPILE_BIT_NV If VK_NV_ray_tracing_motion_blur is supported: Extending VkPipelineCreateFlagBits2: VK_PIPELINE_CREATE_2_RAY_TRACING_ALLOW_MOTION_BIT_NV If Vulkan Version 1.2 or VK_KHR_buffer_device_address or VK_EXT_buffer_device_address is supported: Extending VkBufferUsageFlagBits2: VK_BUFFER_USAGE_2_SHADER_DEVICE_ADDRESS_BIT_KHR If Vulkan Version 1.3 or VK_EXT_pipeline_creation_cache_control is supported: Extending VkPipelineCreateFlagBits2: VK_PIPELINE_CREATE_2_EARLY_RETURN_ON_FAILURE_BIT_KHR VK_PIPELINE_CREATE_2_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_KHR If Vulkan Version 1.4 or VK_EXT_pipeline_protected_access is supported: Extending VkPipelineCreateFlagBits2: VK_PIPELINE_CREATE_2_NO_PROTECTED_ACCESS_BIT_EXT VK_PIPELINE_CREATE_2_PROTECTED_ACCESS_ONLY_BIT_EXT Functionality in this extension is included in core Vulkan 1.4 with the KHR suffix omitted. The original type, enum and command names are still available as aliases of the core functionality. Revision 1, 2022-12-12 (Stu Smith) Initial revision Name String VK_KHR_maintenance6 Extension Type Device extension Registered Extension Number 546 Revision 1 Ratification Status Ratified Extension and Version Dependencies Vulkan Version 1.1 API Interactions Interacts with VK_EXT_descriptor_buffer Interacts with VK_KHR_push_descriptor Deprecation State Promoted to Vulkan 1.4 Contact Jon Leech oddhack Extension Proposal VK_KHR_maintenance6 Last Modified Date 2023-08-03 Interactions and External Dependencies Interacts with VK_EXT_robustness2 Contributors Jon Leech, Khronos Stu Smith, AMD Mike Blumenkrantz, Valve Ralph Potter, Samsung James Fitzpatrick, Imagination Technologies Piers Daniell, NVIDIA Daniel Story, Nintendo VK_KHR_maintenance6 adds a collection of minor features, none of which would warrant an entire extension of their own. The new features are as follows: VkBindMemoryStatusKHR may be included in the pNext chain of VkBindBufferMemoryInfo and VkBindImageMemoryInfo, allowing applications to identify individual resources for which memory binding failed during calls to vkBindBufferMemory2 and vkBindImageMemory2. A new property fragmentShadingRateClampCombinerInputs to indicate if an implementation clamps the inputs to fragment shading rate combiner operations. VK_NULL_HANDLE is allowed to be used when binding an index buffer, instead of a valid VkBuffer handle. When the nullDescriptor feature is enabled, every index fetched results in a value of zero. A new property maxCombinedImageSamplerDescriptorCount to indicate the maximum number of descriptors needed for any of the formats that require a sampler YCBCR conversion supported by the implementation. A new property blockTexelViewCompatibleMultipleLayers indicating whether VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT is allowed to be used with layerCount > 1 pNext extensible *2 versions of all descriptor binding commands. vkCmdBindDescriptorSets2KHR vkCmdPushConstants2KHR If VK_EXT_descriptor_buffer is supported: vkCmdBindDescriptorBufferEmbeddedSamplers2EXT vkCmdSetDescriptorBufferOffsets2EXT If VK_KHR_push_descriptor is supported: vkCmdPushDescriptorSet2KHR vkCmdPushDescriptorSetWithTemplate2KHR VkBindDescriptorSetsInfoKHR VkPushConstantsInfoKHR Extending VkBindBufferMemoryInfo, VkBindImageMemoryInfo: VkBindMemoryStatusKHR Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceMaintenance6FeaturesKHR Extending VkPhysicalDeviceProperties2: VkPhysicalDeviceMaintenance6PropertiesKHR If VK_EXT_descriptor_buffer is supported: VkBindDescriptorBufferEmbeddedSamplersInfoEXT VkSetDescriptorBufferOffsetsInfoEXT If VK_KHR_push_descriptor is supported: VkPushDescriptorSetInfoKHR VkPushDescriptorSetWithTemplateInfoKHR VK_KHR_MAINTENANCE_6_EXTENSION_NAME VK_KHR_MAINTENANCE_6_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO_KHR VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS_KHR VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES_KHR VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES_KHR VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO_KHR If VK_EXT_descriptor_buffer is supported: Extending VkStructureType: VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_BUFFER_EMBEDDED_SAMPLERS_INFO_EXT VK_STRUCTURE_TYPE_SET_DESCRIPTOR_BUFFER_OFFSETS_INFO_EXT If VK_KHR_push_descriptor is supported: Extending VkStructureType: VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO_KHR VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_WITH_TEMPLATE_INFO_KHR Functionality in this extension is included in core Vulkan 1.4 with the KHR suffix omitted. The original type, enum and command names are still available as aliases of the core functionality. Revision 1, 2023-08-01 (Jon Leech) Initial revision Name String VK_KHR_map_memory2 Extension Type Device extension Registered Extension Number 272 Revision 1 Ratification Status Ratified Extension and Version Dependencies None Deprecation State Promoted to Vulkan 1.4 Contact Faith Ekstrand gfxstrand Extension Proposal VK_KHR_map_memory2 Last Modified Date 2023-03-14 Interactions and External Dependencies None Contributors Faith Ekstrand, Collabora Tobias Hector, AMD This extension provides extensible versions of the Vulkan memory map and unmap commands. The new commands are functionally identical to the core commands, except that their parameters are specified using extensible structures that can be used to pass extension-specific information. vkMapMemory2KHR vkUnmapMemory2KHR VkMemoryMapInfoKHR VkMemoryUnmapInfoKHR VkMemoryUnmapFlagBitsKHR VkMemoryUnmapFlagsKHR VK_KHR_MAP_MEMORY_2_EXTENSION_NAME VK_KHR_MAP_MEMORY_2_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_MEMORY_MAP_INFO_KHR VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO_KHR Functionality in this extension is included in core Vulkan 1.4 with the KHR suffix omitted. The original type, enum and command names are still available as aliases of the core functionality. Revision 0, 2022-08-03 (Faith Ekstrand) Internal revisions Revision 1, 2023-03-14 Public release Name String VK_KHR_multiview Extension Type Device extension Registered Extension Number 54 Revision 1 Ratification Status Ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 SPIR-V Dependencies SPV_KHR_multiview Deprecation State Promoted to Vulkan 1.1 Contact Jeff Bolz jeffbolznv Last Modified Date 2016-10-28 IP Status No known IP claims. Interactions and External Dependencies This extension provides API support for GL_EXT_multiview Contributors Jeff Bolz, NVIDIA This extension has the same goal as the OpenGL ES GL_OVR_multiview extension. Multiview is a rendering technique originally designed for VR where it is more efficient to record a single set of commands to be executed with slightly different behavior for each view. It includes a concise way to declare a render pass with multiple views, and gives implementations freedom to render the views in the most efficient way possible. This is done with a multiview configuration specified during render pass creation with the VkRenderPassMultiviewCreateInfo passed into VkRenderPassCreateInfo::pNext. This extension enables the use of the SPV_KHR_multiview shader extension, which adds a new ViewIndex built-in type that allows shaders to control what to do for each view. If using GLSL there is also the GL_EXT_multiview extension that introduces a highp int gl_ViewIndex; built-in variable for vertex, tessellation, geometry, and fragment shaders. All functionality in this extension is included in core Vulkan 1.1, with the KHR suffix omitted. The original type, enum, and command names are still available as aliases of the core functionality. Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceMultiviewFeaturesKHR Extending VkPhysicalDeviceProperties2: VkPhysicalDeviceMultiviewPropertiesKHR Extending VkRenderPassCreateInfo: VkRenderPassMultiviewCreateInfoKHR VK_KHR_MULTIVIEW_EXTENSION_NAME VK_KHR_MULTIVIEW_SPEC_VERSION Extending VkDependencyFlagBits: VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR ViewIndex MultiView Revision 1, 2016-10-28 (Jeff Bolz) Internal revisions Name String VK_KHR_push_descriptor Extension Type Device extension Registered Extension Number 81 Revision 2 Ratification Status Ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 API Interactions Interacts with VK_VERSION_1_1 Interacts with VK_KHR_descriptor_update_template Deprecation State Promoted to Vulkan 1.4 Contact Jeff Bolz jeffbolznv Last Modified Date 2017-09-12 IP Status No known IP claims. Contributors Jeff Bolz, NVIDIA Michael Worcester, Imagination Technologies This extension allows descriptors to be written into the command buffer, while the implementation is responsible for managing their memory. Push descriptors may enable easier porting from older APIs and in some cases can be more efficient than writing descriptors into descriptor sets. vkCmdPushDescriptorSetKHR If Vulkan Version 1.1 or VK_KHR_descriptor_update_template is supported: vkCmdPushDescriptorSetWithTemplateKHR Extending VkPhysicalDeviceProperties2: VkPhysicalDevicePushDescriptorPropertiesKHR VK_KHR_PUSH_DESCRIPTOR_EXTENSION_NAME VK_KHR_PUSH_DESCRIPTOR_SPEC_VERSION Extending VkDescriptorSetLayoutCreateFlagBits: VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR If Vulkan Version 1.1 or VK_KHR_descriptor_update_template is supported: Extending VkDescriptorUpdateTemplateType: VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR Functionality in this extension is included in core Vulkan 1.4 with the KHR suffix omitted. The original type, enum and command names are still available as aliases of the core functionality. Revision 1, 2016-10-15 (Jeff Bolz) Internal revisions Revision 2, 2017-09-12 (Tobias Hector) Added interactions with Vulkan 1.1 Name String VK_KHR_relaxed_block_layout Extension Type Device extension Registered Extension Number 145 Revision 1 Ratification Status Ratified Extension and Version Dependencies None Deprecation State Promoted to Vulkan 1.1 Contact John Kessenich johnkslang Last Modified Date 2017-03-26 IP Status No known IP claims. Contributors John Kessenich, Google The VK_KHR_relaxed_block_layout extension allows implementations to indicate they can support more variation in block Offset decorations. For example, placing a vector of three floats at an offset of 16N + 4. See Offset and Stride Assignment for details. All functionality in this extension is included in core Vulkan 1.1, with the KHR suffix omitted. The original type, enum, and command names are still available as aliases of the core functionality. VK_KHR_RELAXED_BLOCK_LAYOUT_EXTENSION_NAME VK_KHR_RELAXED_BLOCK_LAYOUT_SPEC_VERSION Revision 1, 2017-03-26 (JohnK) Name String VK_KHR_sampler_mirror_clamp_to_edge Extension Type Device extension Registered Extension Number 15 Revision 3 Ratification Status Ratified Extension and Version Dependencies None Deprecation State Promoted to Vulkan 1.2 Contact Tobias Hector tobski Last Modified Date 2019-08-17 Contributors Tobias Hector, Imagination Technologies Jon Leech, Khronos VK_KHR_sampler_mirror_clamp_to_edge extends the set of sampler address modes to include an additional mode (VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE) that effectively uses a texture map twice as large as the original image in which the additional half of the new image is a mirror image of the original image. This new mode relaxes the need to generate images whose opposite edges match by using the original image to generate a matching mirror image. This mode allows the texture to be mirrored only once in the negative s, t, and r directions. All functionality in this extension is included in core Vulkan 1.2. However, if Vulkan 1.2 is supported and this extension is not, the VkSamplerAddressMode VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE is optional. Since the original extension did not use an author suffix on the enum VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE, it is used by both core and extension implementations. VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_EXTENSION_NAME VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_SPEC_VERSION Extending VkSamplerAddressMode: VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE_KHR Creating a sampler with the new address mode in each dimension VkSamplerCreateInfo createInfo = { .sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO, // Other members set to application-desired values }; createInfo.addressModeU = VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE; createInfo.addressModeV = VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE; createInfo.addressModeW = VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE; VkSampler sampler; VkResult result = vkCreateSampler( device, &createInfo, &sampler); 1) Why are both KHR and core versions of the VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE token present? RESOLVED: This functionality was intended to be required in Vulkan 1.0. We realized shortly before public release that not all implementations could support it, and moved the functionality into an optional extension, but did not apply the KHR extension suffix. Adding a KHR-suffixed alias of the non-suffixed enum has been done to comply with our own naming rules. In a related change, before spec revision 1.1.121 this extension was hardwiring into the spec Makefile so it was always included with the Specification, even in the core-only versions. This has now been reverted, and it is treated as any other extension. Revision 1, 2016-02-16 (Tobias Hector) Initial draft Revision 2, 2019-08-14 (Jon Leech) Add KHR-suffixed alias of non-suffixed enum. Revision 3, 2019-08-17 (Jon Leech) Add an issue explaining the reason for the extension API not being suffixed with KHR. Name String VK_KHR_sampler_ycbcr_conversion Extension Type Device extension Registered Extension Number 157 Revision 14 Ratification Status Ratified Extension and Version Dependencies VK_KHR_maintenance1 and VK_KHR_bind_memory2 and VK_KHR_get_memory_requirements2 and VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 API Interactions Interacts with VK_EXT_debug_report Deprecation State Promoted to Vulkan 1.1 Contact Andrew Garrard fluppeteer Last Modified Date 2017-08-11 IP Status No known IP claims. Contributors Andrew Garrard, Samsung Electronics Tobias Hector, Imagination Technologies James Jones, NVIDIA Daniel Koch, NVIDIA Daniel Rakos, AMD Romain Guy, Google Jesse Hall, Google Tom Cooksey, ARM Ltd Jeff Leger, Qualcomm Technologies, Inc Jan-Harald Fredriksen, ARM Ltd Jan Outters, Samsung Electronics Alon Or-bach, Samsung Electronics Michael Worcester, Imagination Technologies Jeff Bolz, NVIDIA Tony Zlatinski, NVIDIA Matthew Netsch, Qualcomm Technologies, Inc The use of YCBCR sampler conversion is an area in 3D graphics not used by most Vulkan developers. It is mainly used for processing inputs from video decoders and cameras. The use of the extension assumes basic knowledge of YCBCR concepts. This extension provides the ability to perform specified color space conversions during texture sampling operations for the YCBCR color space natively. It also adds a selection of multi-planar formats, image aspect plane, and the ability to bind memory to the planes of an image collectively or separately. All functionality in this extension is included in core Vulkan 1.1, with the KHR suffix omitted. However, if Vulkan 1.1 is supported and this extension is not, the samplerYcbcrConversion capability is optional. The original type, enum, and command names are still available as aliases of the core functionality. If Vulkan 1.4 is supported, support for the samplerYcbcrConversion capability is required. VkSamplerYcbcrConversionKHR vkCreateSamplerYcbcrConversionKHR vkDestroySamplerYcbcrConversionKHR VkSamplerYcbcrConversionCreateInfoKHR Extending VkBindImageMemoryInfo: VkBindImagePlaneMemoryInfoKHR Extending VkImageFormatProperties2: VkSamplerYcbcrConversionImageFormatPropertiesKHR Extending VkImageMemoryRequirementsInfo2: VkImagePlaneMemoryRequirementsInfoKHR Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceSamplerYcbcrConversionFeaturesKHR Extending VkSamplerCreateInfo, VkImageViewCreateInfo: VkSamplerYcbcrConversionInfoKHR VkChromaLocationKHR VkSamplerYcbcrModelConversionKHR VkSamplerYcbcrRangeKHR VK_KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME VK_KHR_SAMPLER_YCBCR_CONVERSION_SPEC_VERSION Extending VkChromaLocation: VK_CHROMA_LOCATION_COSITED_EVEN_KHR VK_CHROMA_LOCATION_MIDPOINT_KHR Extending VkFormat: VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR VK_FORMAT_B16G16R16G16_422_UNORM_KHR VK_FORMAT_B8G8R8G8_422_UNORM_KHR VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR VK_FORMAT_G16B16G16R16_422_UNORM_KHR VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR VK_FORMAT_G8B8G8R8_422_UNORM_KHR VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR VK_FORMAT_R10X6G10X6_UNORM_2PACK16_KHR VK_FORMAT_R10X6_UNORM_PACK16_KHR VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR VK_FORMAT_R12X4G12X4_UNORM_2PACK16_KHR VK_FORMAT_R12X4_UNORM_PACK16_KHR Extending VkFormatFeatureFlagBits: VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR VK_FORMAT_FEATURE_DISJOINT_BIT_KHR VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR Extending VkImageAspectFlagBits: VK_IMAGE_ASPECT_PLANE_0_BIT_KHR VK_IMAGE_ASPECT_PLANE_1_BIT_KHR VK_IMAGE_ASPECT_PLANE_2_BIT_KHR Extending VkImageCreateFlagBits: VK_IMAGE_CREATE_DISJOINT_BIT_KHR Extending VkObjectType: VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR Extending VkSamplerYcbcrModelConversion: VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY_KHR VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020_KHR VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601_KHR VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709_KHR VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY_KHR Extending VkSamplerYcbcrRange: VK_SAMPLER_YCBCR_RANGE_ITU_FULL_KHR VK_SAMPLER_YCBCR_RANGE_ITU_NARROW_KHR Extending VkStructureType: VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO_KHR VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO_KHR If VK_EXT_debug_report is supported: Extending VkDebugReportObjectTypeEXT: VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR_EXT Revision 1, 2017-01-24 (Andrew Garrard) Initial draft Revision 2, 2017-01-25 (Andrew Garrard) After initial feedback Revision 3, 2017-01-27 (Andrew Garrard) Higher bit depth formats, renaming, swizzle Revision 4, 2017-02-22 (Andrew Garrard) Added query function, formats as RGB, clarifications Revision 5, 2017-04-?? (Andrew Garrard) Simplified query and removed output conversions Revision 6, 2017-04-24 (Andrew Garrard) Tidying, incorporated new image query, restored transfer functions Revision 7, 2017-04-25 (Andrew Garrard) Added cosited option/midpoint requirement for formats, bypassConversion Revision 8, 2017-04-25 (Andrew Garrard) Simplified further Revision 9, 2017-04-27 (Andrew Garrard) Disjoint no more Revision 10, 2017-04-28 (Andrew Garrard) Restored disjoint Revision 11, 2017-04-29 (Andrew Garrard) Now Ycbcr conversion, and KHR Revision 12, 2017-06-06 (Andrew Garrard) Added conversion to image view creation Revision 13, 2017-07-13 (Andrew Garrard) Allowed cosited-only chroma samples for formats Revision 14, 2017-08-11 (Andrew Garrard) Reflected quantization changes in BT.2100-1 Name String VK_KHR_separate_depth_stencil_layouts Extension Type Device extension Registered Extension Number 242 Revision 1 Ratification Status Ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 and VK_KHR_create_renderpass2 or Vulkan Version 1.2 Deprecation State Promoted to Vulkan 1.2 Contact Piers Daniell pdaniell-nv Last Modified Date 2019-06-25 Contributors Daniel Koch, NVIDIA Jeff Bolz, NVIDIA Jesse Barker, Unity Tobias Hector, AMD This extension allows image memory barriers for depth/stencil images to have just one of the VK_IMAGE_ASPECT_DEPTH_BIT or VK_IMAGE_ASPECT_STENCIL_BIT aspect bits set, rather than require both. This allows their layouts to be set independently. To support depth/stencil images with different layouts for the depth and stencil aspects, the depth/stencil attachment interface has been updated to support a separate layout for stencil. All functionality in this extension is included in core Vulkan 1.2, with the KHR suffix omitted. The original type, enum, and command names are still available as aliases of the core functionality. Extending VkAttachmentDescription2: VkAttachmentDescriptionStencilLayoutKHR Extending VkAttachmentReference2: VkAttachmentReferenceStencilLayoutKHR Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceSeparateDepthStencilLayoutsFeaturesKHR VK_KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS_EXTENSION_NAME VK_KHR_SEPARATE_DEPTH_STENCIL_LAYOUTS_SPEC_VERSION Extending VkImageLayout: VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL_KHR VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL_KHR VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL_KHR VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL_KHR Extending VkStructureType: VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT_KHR VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT_KHR VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES_KHR Revision 1, 2019-06-25 (Piers Daniell) Internal revisions Name String VK_KHR_shader_atomic_int64 Extension Type Device extension Registered Extension Number 181 Revision 1 Ratification Status Ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 Deprecation State Promoted to Vulkan 1.2 Contact Aaron Hagan ahagan Last Modified Date 2018-07-05 Interactions and External Dependencies This extension provides API support for GL_ARB_gpu_shader_int64 and GL_EXT_shader_atomic_int64 Contributors Aaron Hagan, AMD Daniel Rakos, AMD Jeff Bolz, NVIDIA Neil Henning, Codeplay This extension advertises the SPIR-V Int64Atomics capability for Vulkan, which allows a shader to contain 64-bit atomic operations on signed and unsigned integers. The supported operations include OpAtomicMin, OpAtomicMax, OpAtomicAnd, OpAtomicOr, OpAtomicXor, OpAtomicAdd, OpAtomicExchange, and OpAtomicCompareExchange. All functionality in this extension is included in core Vulkan 1.2, with the KHR suffix omitted. However, if Vulkan 1.2 is supported and this extension is not, the shaderBufferInt64Atomics capability is optional. The original type, enum, and command names are still available as aliases of the core functionality. Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceShaderAtomicInt64FeaturesKHR VK_KHR_SHADER_ATOMIC_INT64_EXTENSION_NAME VK_KHR_SHADER_ATOMIC_INT64_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR Int64Atomics Revision 1, 2018-07-05 (Aaron Hagan) Internal revisions Name String VK_KHR_shader_draw_parameters Extension Type Device extension Registered Extension Number 64 Revision 1 Ratification Status Ratified Extension and Version Dependencies None SPIR-V Dependencies SPV_KHR_shader_draw_parameters Deprecation State Promoted to Vulkan 1.1 Contact Daniel Koch dgkoch Last Modified Date 2017-09-05 IP Status No known IP claims. Interactions and External Dependencies This extension provides API support for GL_ARB_shader_draw_parameters Contributors Daniel Koch, NVIDIA Corporation Jeff Bolz, NVIDIA Daniel Rakos, AMD Jan-Harald Fredriksen, ARM John Kessenich, Google Stuart Smith, IMG This extension adds support for the following SPIR-V extension in Vulkan: SPV_KHR_shader_draw_parameters The extension provides access to three additional built-in shader variables in Vulkan: BaseInstance, containing the firstInstance parameter passed to drawing commands, BaseVertex, containing the firstVertex or vertexOffset parameter passed to drawing commands, and DrawIndex, containing the index of the draw call currently being processed from an indirect drawing call. When using GLSL source-based shader languages, the following variables from GL_ARB_shader_draw_parameters can map to these SPIR-V built-in decorations: in int gl_BaseInstanceARB;  BaseInstance, in int gl_BaseVertexARB;  BaseVertex, and in int gl_DrawIDARB;  DrawIndex. All functionality in this extension is included in core Vulkan 1.1. However, the shaderDrawParameters feature bit was added to distinguish whether it is actually available or not. VK_KHR_SHADER_DRAW_PARAMETERS_EXTENSION_NAME VK_KHR_SHADER_DRAW_PARAMETERS_SPEC_VERSION BaseInstance BaseVertex DrawIndex DrawParameters 1) Is this the same functionality as GL_ARB_shader_draw_parameters? RESOLVED: It is actually a superset, as it also adds in support for arrayed drawing commands. In GL for GL_ARB_shader_draw_parameters, gl_BaseVertexARB holds the integer value passed to the parameter to the command that resulted in the current shader invocation. In the case where the command has no baseVertex parameter, the value of gl_BaseVertexARB is zero. This means that gl_BaseVertexARB = baseVertex (for glDrawElements commands with baseVertex) or 0. In particular there are no glDrawArrays commands that take a baseVertex parameter. Now in Vulkan, we have BaseVertex = vertexOffset (for indexed drawing commands) or firstVertex (for arrayed drawing commands), and so Vulkans version is really a superset of GL functionality. Revision 1, 2016-10-05 (Daniel Koch) Internal revisions Name String VK_KHR_shader_expect_assume Extension Type Device extension Registered Extension Number 545 Revision 1 Ratification Status Ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 SPIR-V Dependencies SPV_KHR_expect_assume Deprecation State Promoted to Vulkan 1.4 Contact Kevin Petit kpet Extension Proposal VK_KHR_shader_expect_assume Last Modified Date 2023-12-06 IP Status No known IP claims. Contributors Kevin Petit, Arm Tobias Hector, AMD James Fitzpatrick, Imagination Technologies This extension allows the use of the SPV_KHR_expect_assume extension in SPIR-V shader modules which enables SPIR-V producers to provide optimization hints to the Vulkan implementation. Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceShaderExpectAssumeFeaturesKHR VK_KHR_SHADER_EXPECT_ASSUME_EXTENSION_NAME VK_KHR_SHADER_EXPECT_ASSUME_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES_KHR ExpectAssumeKHR Functionality in this extension is included in core Vulkan 1.4 with the KHR suffix omitted. The original type, enum and command names are still available as aliases of the core functionality. Revision 1, 2023-12-06 (Kevin Petit) Initial revision Name String VK_KHR_shader_float16_int8 Extension Type Device extension Registered Extension Number 83 Revision 1 Ratification Status Ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 Deprecation State Promoted to Vulkan 1.2 Contact Alexander Galazin alegal-arm Last Modified Date 2018-03-07 Interactions and External Dependencies This extension interacts with VK_KHR_8bit_storage This extension interacts with VK_KHR_16bit_storage This extension interacts with VK_KHR_shader_float_controls This extension provides API support for GL_EXT_shader_explicit_arithmetic_types IP Status No known IP claims. Contributors Alexander Galazin, Arm Jan-Harald Fredriksen, Arm Jeff Bolz, NVIDIA Graeme Leese, Broadcom Daniel Rakos, AMD The VK_KHR_shader_float16_int8 extension allows use of 16-bit floating-point types and 8-bit integer types in shaders for arithmetic operations. It introduces two new optional features shaderFloat16 and shaderInt8 which directly map to the Float16 and the Int8 SPIR-V capabilities. The VK_KHR_shader_float16_int8 extension also specifies precision requirements for half-precision floating-point SPIR-V operations. This extension does not enable use of 8-bit integer types or 16-bit floating-point types in any shader input and output interfaces and therefore does not supersede the VK_KHR_8bit_storage or VK_KHR_16bit_storage extensions. All functionality in this extension is included in core Vulkan 1.2, with the KHR suffix omitted. However, if Vulkan 1.2 is supported and this extension is not, both the shaderFloat16 and shaderInt8 capabilities are optional. The original type, enum, and command names are still available as aliases of the core functionality. If Vulkan 1.4 is supported, support for the shaderInt8 capability is required. Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceFloat16Int8FeaturesKHR VkPhysicalDeviceShaderFloat16Int8FeaturesKHR VK_KHR_SHADER_FLOAT16_INT8_EXTENSION_NAME VK_KHR_SHADER_FLOAT16_INT8_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT16_INT8_FEATURES_KHR VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR Revision 1, 2018-03-07 (Alexander Galazin) Initial draft Name String VK_KHR_shader_float_controls Extension Type Device extension Registered Extension Number 198 Revision 4 Ratification Status Ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 SPIR-V Dependencies SPV_KHR_float_controls Deprecation State Promoted to Vulkan 1.2 Contact Alexander Galazin alegal-arm Last Modified Date 2018-09-11 IP Status No known IP claims. Contributors Alexander Galazin, Arm Jan-Harald Fredriksen, Arm Jeff Bolz, NVIDIA Graeme Leese, Broadcom Daniel Rakos, AMD The VK_KHR_shader_float_controls extension enables efficient use of floating-point computations through the ability to query and override the implementations default behavior for rounding modes, denormals, signed zero, and infinity. All functionality in this extension is included in core Vulkan 1.2, with the KHR suffix omitted. The original type, enum, and command names are still available as aliases of the core functionality. Extending VkPhysicalDeviceProperties2: VkPhysicalDeviceFloatControlsPropertiesKHR VkShaderFloatControlsIndependenceKHR VK_KHR_SHADER_FLOAT_CONTROLS_EXTENSION_NAME VK_KHR_SHADER_FLOAT_CONTROLS_SPEC_VERSION Extending VkShaderFloatControlsIndependence: VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY_KHR VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL_KHR VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE_KHR Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR DenormPreserve DenormFlushToZero SignedZeroInfNanPreserve RoundingModeRTE RoundingModeRTZ 1) Which instructions must flush denorms? RESOLVED: Only floating-point conversion, floating-point arithmetic, floating-point relational (except OpIsNaN, OpIsInf), and floating-point GLSL.std.450 extended instructions must flush denormals. 2) What is the denorm behavior for intermediate results? RESOLVED: When a SPIR-V instruction is implemented as a sequence of other instructions: in the DenormFlushToZero execution mode, the intermediate instructions may flush denormals, the final result of the sequence must not be denormal. in the DenormPreserve execution mode, denormals must be preserved throughout the whole sequence. 3) Do denorm and rounding mode controls apply to OpSpecConstantOp? RESOLVED: Yes, except when the opcode is OpQuantizeToF16. 4) The SPIR-V specification says that OpConvertFToU and OpConvertFToS unconditionally round towards zero. Do the rounding mode controls specified through the execution modes apply to them? RESOLVED: No, these instructions unconditionally round towards zero. 5) Do any of the Pack GLSL.std.450 instructions count as conversion instructions and have the rounding mode applied? RESOLVED: No, only instructions listed in section 3.32.11. Conversion Instructions of the SPIR-V specification count as conversion instructions. 6) When using inf/nan-ignore mode, what is expected of OpIsNan and OpIsInf? RESOLVED: These instructions must always accurately detect inf/nan if it is passed to them. The original versions of VK_KHR_shader_float_controls shipped with booleans named separateDenormSettings and separateRoundingModeSettings, which at first glance could have indicated they can all be set independently, or not. However the spec language as written indicated that the 32-bit value could always be set independently, and only the 16- and 64-bit controls needed to be the same if these values were VK_FALSE. As a result of this slight disparity, and lack of test coverage for this facet of the extension, we ended up with two different behaviors in the wild, where some implementations worked as written, and others worked based on the naming. As these are hard limits in hardware with reasons for exposure as written, it was not possible to standardize on a single way to make this work within the existing API. No known users of this part of the extension exist in the wild, and as such the Vulkan WG took the unusual step of retroactively changing the once boolean value into a tri-state enum, breaking source compatibility. This was however done in such a way as to retain ABI compatibility, in case any code using this did exist; with the numerical values 0 and 1 retaining their original specified meaning, and a new value signifying the additional all need to be set together state. If any applications exist today, compiled binaries will continue to work as written in most cases, but will need changes before the code can be recompiled. Revision 4, 2019-06-18 (Tobias Hector) Modified settings restrictions, see Version 4 API incompatibility Revision 3, 2018-09-11 (Alexander Galazin) Minor restructuring Revision 2, 2018-04-17 (Alexander Galazin) Added issues and resolutions Revision 1, 2018-04-11 (Alexander Galazin) Initial draft Name String VK_KHR_shader_float_controls2 Extension Type Device extension Registered Extension Number 529 Revision 1 Ratification Status Ratified Extension and Version Dependencies Vulkan Version 1.1 and VK_KHR_shader_float_controls SPIR-V Dependencies SPV_KHR_float_controls2 Deprecation State Promoted to Vulkan 1.4 Contact Graeme Leese gnl21 Extension Proposal VK_KHR_shader_float_controls2 Last Modified Date 2023-05-16 Interactions and External Dependencies This extension requires SPV_KHR_float_controls2. Contributors Graeme Leese, Broadcom This extension enables use of the more expressive fast floating-point math flags in the SPV_KHR_float_controls2 extension. These flags give finer- grained control over which optimizations compilers may apply, potentially speeding up execution while retaining correct results. The extension also adds control over the fast-math modes to the GLSL extended instruction set, making these operations more consistent with SPIR-V and allowing their use in situations where floating-point conformance is important. Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceShaderFloatControls2FeaturesKHR VK_KHR_SHADER_FLOAT_CONTROLS_2_EXTENSION_NAME VK_KHR_SHADER_FLOAT_CONTROLS_2_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES_KHR FloatControls2 Functionality in this extension is included in core Vulkan 1.4 with the KHR suffix omitted. The original type, enum and command names are still available as aliases of the core functionality. Revision 1, 2023-05-16 (Graeme Leese) Initial draft Name String VK_KHR_shader_integer_dot_product Extension Type Device extension Registered Extension Number 281 Revision 1 Ratification Status Ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 SPIR-V Dependencies SPV_KHR_integer_dot_product Deprecation State Promoted to Vulkan 1.3 Contact Kevin Petit kpet Extension Proposal VK_KHR_shader_integer_dot_product Last Modified Date 2021-06-16 Interactions and External Dependencies This extension interacts with VK_KHR_shader_float16_int8. IP Status No known IP claims. Contributors Kvin Petit, Arm Ltd. Jeff Bolz, NVidia Spencer Fricke, Samsung Jesse Hall, Google John Kessenich, Google Graeme Leese, Broadcom Einar Hov, Arm Ltd. Stuart Brady, Arm Ltd. Pablo Cascon, Arm Ltd. Tobias Hector, AMD Jeff Leger, Qualcomm Ruihao Zhang, Qualcomm Pierre Boudier, NVidia Jon Leech, The Khronos Group Tom Olson, Arm Ltd. This extension adds support for the integer dot product SPIR-V instructions defined in SPV_KHR_integer_dot_product. These instructions are particularly useful for neural network inference and training but find uses in other general-purpose compute applications as well. Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR Extending VkPhysicalDeviceProperties2: VkPhysicalDeviceShaderIntegerDotProductPropertiesKHR VK_KHR_SHADER_INTEGER_DOT_PRODUCT_EXTENSION_NAME VK_KHR_SHADER_INTEGER_DOT_PRODUCT_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES_KHR VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES_KHR Vulkan APIs in this extension are included in core Vulkan 1.3, with the KHR suffix omitted. External interactions defined by this extension, such as SPIR-V token names, retain their original names. The original Vulkan API names are still available as aliases of the core functionality. DotProductInputAllKHR DotProductInput4x8BitKHR DotProductInput4x8BitPackedKHR DotProductKHR Revision 1, 2021-06-16 (Kvin Petit) Initial revision Name String VK_KHR_shader_non_semantic_info Extension Type Device extension Registered Extension Number 294 Revision 1 Ratification Status Ratified Extension and Version Dependencies None SPIR-V Dependencies SPV_KHR_non_semantic_info Deprecation State Promoted to Vulkan 1.3 Contact Baldur Karlsson baldurk Last Modified Date 2019-10-16 IP Status No known IP claims. Contributors Baldur Karlsson, Valve This extension allows the use of the SPV_KHR_non_semantic_info extension in SPIR-V shader modules. VK_KHR_SHADER_NON_SEMANTIC_INFO_EXTENSION_NAME VK_KHR_SHADER_NON_SEMANTIC_INFO_SPEC_VERSION Functionality in this extension is included in core Vulkan 1.3. Because the extension has no API controlling its functionality, this results only in a change to the SPIR-V Extensions table. Revision 1, 2019-10-16 (Baldur Karlsson) Initial revision Name String VK_KHR_shader_subgroup_extended_types Extension Type Device extension Registered Extension Number 176 Revision 1 Ratification Status Ratified Extension and Version Dependencies Vulkan Version 1.1 Deprecation State Promoted to Vulkan 1.2 Contact Neil Henning sheredom Last Modified Date 2019-01-08 IP Status No known IP claims. Interactions and External Dependencies This extension provides API support for GLSL_EXT_shader_subgroup_extended_types Contributors Jeff Bolz, NVIDIA Jan-Harald Fredriksen, Arm Neil Henning, AMD Daniel Koch, NVIDIA Jeff Leger, Qualcomm Graeme Leese, Broadcom David Neto, Google Daniel Rakos, AMD This extension enables the Non Uniform Group Operations in SPIR-V to support 8-bit integer, 16-bit integer, 64-bit integer, 16-bit floating-point, and vectors of these types. All functionality in this extension is included in core Vulkan 1.2, with the KHR suffix omitted. The original type, enum, and command names are still available as aliases of the core functionality. Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR VK_KHR_SHADER_SUBGROUP_EXTENDED_TYPES_EXTENSION_NAME VK_KHR_SHADER_SUBGROUP_EXTENDED_TYPES_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES_KHR Revision 1, 2019-01-08 (Neil Henning) Initial draft Name String VK_KHR_shader_subgroup_rotate Extension Type Device extension Registered Extension Number 417 Revision 2 Ratification Status Ratified Extension and Version Dependencies None SPIR-V Dependencies SPV_KHR_subgroup_rotate Deprecation State Promoted to Vulkan 1.4 Contact Kevin Petit kpet Extension Proposal VK_KHR_shader_subgroup_rotate Last Modified Date 2024-01-29 IP Status No known IP claims. Contributors Kvin Petit, Arm Ltd. Tobias Hector, AMD Jon Leech, Khronos Matthew Netsch, Qualcomm Jan-Harald Fredriksen, Arm Ltd. Graeme Leese, Broadcom Tom Olson, Arm Ltd. Spencer Fricke, LunarG Inc. This extension adds support for the subgroup rotate instruction defined in SPV_KHR_subgroup_rotate. Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR VK_KHR_SHADER_SUBGROUP_ROTATE_EXTENSION_NAME VK_KHR_SHADER_SUBGROUP_ROTATE_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES_KHR Extending VkSubgroupFeatureFlagBits: VK_SUBGROUP_FEATURE_ROTATE_BIT_KHR VK_SUBGROUP_FEATURE_ROTATE_CLUSTERED_BIT_KHR GroupNonUniformRotateKHR Functionality in this extension is included in core Vulkan 1.4 with the KHR suffix omitted. The original type, enum and command names are still available as aliases of the core functionality. Revision 2, 2024-01-29 (Kvin Petit) Add VK_SUBGROUP_FEATURE_ROTATE_BIT_KHR and VK_SUBGROUP_FEATURE_ROTATE_CLUSTERED_BIT_KHR Revision 1, 2023-06-20 (Kvin Petit) Initial revision Name String VK_KHR_shader_terminate_invocation Extension Type Device extension Registered Extension Number 216 Revision 1 Ratification Status Ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 SPIR-V Dependencies SPV_KHR_terminate_invocation Deprecation State Promoted to Vulkan 1.3 Contact Jesse Hall critsec Last Modified Date 2020-08-11 IP Status No known IP claims. Contributors Alan Baker, Google Jeff Bolz, NVIDIA Jesse Hall, Google Ralph Potter, Samsung Tom Olson, Arm This extension adds Vulkan support for the SPV_KHR_terminate_invocation SPIR-V extension. That SPIR-V extension provides a new instruction, OpTerminateInvocation, which causes a shader invocation to immediately terminate and sets the coverage of shaded samples to 0; only previously executed instructions will have observable effects. The OpTerminateInvocation instruction, along with the OpDemoteToHelperInvocation instruction from the VK_EXT_shader_demote_to_helper_invocation extension, together replace the OpKill instruction, which could behave like either of these instructions. OpTerminateInvocation provides the behavior required by the GLSL discard statement, and should be used when available by GLSL compilers and applications that need the GLSL discard behavior. Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR VK_KHR_SHADER_TERMINATE_INVOCATION_EXTENSION_NAME VK_KHR_SHADER_TERMINATE_INVOCATION_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES_KHR Vulkan APIs in this extension are included in core Vulkan 1.3, with the KHR suffix omitted. External interactions defined by this extension, such as SPIR-V token names, retain their original names. The original Vulkan API names are still available as aliases of the core functionality. Revision 1, 2020-08-11 (Jesse Hall) Name String VK_KHR_spirv_1_4 Extension Type Device extension Registered Extension Number 237 Revision 1 Ratification Status Ratified Extension and Version Dependencies Vulkan Version 1.1 and VK_KHR_shader_float_controls Deprecation State Promoted to Vulkan 1.2 Contact Jesse Hall critsec Last Modified Date 2019-04-01 IP Status No known IP claims. Interactions and External Dependencies Requires SPIR-V 1.4. Contributors Alexander Galazin, Arm David Neto, Google Jesse Hall, Google John Kessenich, Google Neil Henning, AMD Tom Olson, Arm This extension allows the use of SPIR-V 1.4 shader modules. SPIR-V 1.4s new features primarily make it an easier target for compilers from high-level languages, rather than exposing new hardware functionality. SPIR-V 1.4 incorporates features that are also available separately as extensions. SPIR-V 1.4 shader modules do not need to enable those extensions with the OpExtension opcode, since they are integral parts of SPIR-V 1.4. SPIR-V 1.4 introduces new floating-point execution mode capabilities, also available via SPV_KHR_float_controls. Implementations are not required to support all of these new capabilities; support can be queried using VkPhysicalDeviceFloatControlsPropertiesKHR from the VK_KHR_shader_float_controls extension. All functionality in this extension is included in core Vulkan 1.2, with the KHR suffix omitted. The original type, enum, and command names are still available as aliases of the core functionality. VK_KHR_SPIRV_1_4_EXTENSION_NAME VK_KHR_SPIRV_1_4_SPEC_VERSION 1. Should we have an extension specific to this SPIR-V version, or add a version-generic query for SPIR-V version? SPIR-V 1.4 does not need any other API changes. RESOLVED: Just expose SPIR-V 1.4. Most new SPIR-V versions introduce optionally-required capabilities or have implementation-defined limits, and would need more API and specification changes specific to that version to make them available in Vulkan. For example, to support the subgroup capabilities added in SPIR-V 1.3 required introducing VkPhysicalDeviceSubgroupProperties to allow querying the supported group operation categories, maximum supported subgroup size, etc. While we could expose the parts of a new SPIR-V version that do not need accompanying changes generically, we will still end up writing extensions specific to each version for the remaining parts. Thus the generic mechanism will not reduce future spec-writing effort. In addition, making it clear which parts of a future version are supported by the generic mechanism and which cannot be used without specific support would be difficult to get right ahead of time. 2. Can different stages of the same pipeline use shaders with different SPIR-V versions? RESOLVED: Yes. Mixing SPIR-V versions 1.0-1.3 in the same pipeline has not been disallowed, so it would be inconsistent to disallow mixing 1.4 with previous versions. SPIR-V 1.4 does not introduce anything that should cause new difficulties here. 3. Must Vulkan extensions corresponding to SPIR-V extensions that were promoted to core in 1.4 be enabled in order to use that functionality in a SPIR-V 1.4 module? RESOLVED: No, with caveats. The SPIR-V 1.4 module does not need to declare the SPIR-V extensions, since the functionality is now part of core, so there is no need to enable the Vulkan extension that allows SPIR-V modules to declare the SPIR-V extension. However, when the functionality that is now core in SPIR-V 1.4 is optionally supported, the query for support is provided by a Vulkan extension, and that query can only be used if the extension is enabled. This applies to any SPIR-V version; specifically for SPIR-V 1.4 this only applies to the functionality from SPV_KHR_float_controls, which was made available in Vulkan by VK_KHR_shader_float_controls. Even though the extension was promoted in SPIR-V 1.4, the capabilities are still optional in implementations that support VK_KHR_spirv_1_4. A SPIR-V 1.4 module does not need to enable SPV_KHR_float_controls in order to use the capabilities, so if the application has a priori knowledge that the implementation supports the capabilities, it does not need to enable VK_KHR_shader_float_controls. However, if it does not have this knowledge and has to query for support at runtime, it must enable VK_KHR_shader_float_controls in order to use VkPhysicalDeviceFloatControlsPropertiesKHR. Revision 1, 2019-04-01 (Jesse Hall) Internal draft versions Name String VK_KHR_storage_buffer_storage_class Extension Type Device extension Registered Extension Number 132 Revision 1 Ratification Status Ratified Extension and Version Dependencies None SPIR-V Dependencies SPV_KHR_storage_buffer_storage_class Deprecation State Promoted to Vulkan 1.1 Contact Alexander Galazin alegal-arm Last Modified Date 2017-09-05 IP Status No known IP claims. Contributors Alexander Galazin, ARM David Neto, Google This extension adds support for the following SPIR-V extension in Vulkan: SPV_KHR_storage_buffer_storage_class This extension provides a new SPIR-V StorageBuffer storage class. A Block-decorated object in this class is equivalent to a BufferBlock-decorated object in the Uniform storage class. All functionality in this extension is included in core Vulkan 1.1. VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_EXTENSION_NAME VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_SPEC_VERSION Revision 1, 2017-03-23 (Alexander Galazin) Initial draft Name String VK_KHR_synchronization2 Extension Type Device extension Registered Extension Number 315 Revision 1 Ratification Status Ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 API Interactions Interacts with VK_EXT_blend_operation_advanced Interacts with VK_EXT_conditional_rendering Interacts with VK_EXT_device_generated_commands Interacts with VK_EXT_fragment_density_map Interacts with VK_EXT_mesh_shader Interacts with VK_EXT_transform_feedback Interacts with VK_KHR_acceleration_structure Interacts with VK_KHR_fragment_shading_rate Interacts with VK_KHR_ray_tracing_pipeline Interacts with VK_NV_device_generated_commands Interacts with VK_NV_mesh_shader Interacts with VK_NV_ray_tracing Interacts with VK_NV_shading_rate_image Deprecation State Promoted to Vulkan 1.3 Contact Tobias Hector tobski Last Modified Date 2020-12-03 Interactions and External Dependencies Interacts with VK_KHR_create_renderpass2 Contributors Tobias Hector This extension modifies the original core synchronization APIs to simplify the interface and improve usability of these APIs. It also adds new pipeline stage and access flag types that extend into the 64-bit range, as we have run out within the 32-bit range. The new flags are identical to the old values within the 32-bit range, with new stages and bits beyond that. Pipeline stages and access flags are now specified together in memory barrier structures, making the connection between the two more obvious. Additionally, scoping the pipeline stages into the barrier structs allows the use of the MEMORY_READ and MEMORY_WRITE flags without sacrificing precision. The per-stage access flags should be used to disambiguate specific accesses in a given stage or set of stages - for instance, between uniform reads and sampling operations. Layout transitions have been simplified as well; rather than requiring a different set of layouts for depth/stencil/color attachments, there are generic VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL_KHR and VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR layouts which are contextually applied based on the image format. For example, for a depth format image, VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR is equivalent to VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL_KHR. VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR also functionally replaces VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL. Events are now more efficient, because they include memory dependency information when you set them on the device. Previously, this information was only known when waiting on an event, so the dependencies could not be satisfied until the wait occurred. That sometimes meant stalling the pipeline when the wait occurred. The new API provides enough information for implementations to satisfy these dependencies in parallel with other tasks. Queue submission has been changed to wrap command buffers and semaphores in extensible structures, which incorporate changes from Vulkan 1.1, VK_KHR_device_group, and VK_KHR_timeline_semaphore. This also adds a pipeline stage to the semaphore signal operation, mirroring the existing pipeline stage specification for wait operations. Other miscellaneous changes include: Events can now be specified as interacting only with the device, allowing more efficient access to the underlying object. Image memory barriers that do not perform an image layout transition can be specified by setting oldLayout equal to newLayout. E.g. the old and new layout can both be set to VK_IMAGE_LAYOUT_UNDEFINED, without discarding data in the image. Queue family ownership transfer parameters are simplified in some cases. Extensions with commands or functions with a VkPipelineStageFlags or VkPipelineStageFlagBits parameter have had those APIs replaced with equivalents using VkPipelineStageFlags2KHR. The new event and barrier interfaces are now more extensible for future changes. Relevant pipeline stage masks can now be specified as empty with the new VK_PIPELINE_STAGE_NONE_KHR and VK_PIPELINE_STAGE_2_NONE_KHR values. VkMemoryBarrier2KHR can be chained to VkSubpassDependency2, overriding the original 32-bit stage and access masks. VkFlags64 vkCmdPipelineBarrier2KHR vkCmdResetEvent2KHR vkCmdSetEvent2KHR vkCmdWaitEvents2KHR vkCmdWriteTimestamp2KHR vkQueueSubmit2KHR VkBufferMemoryBarrier2KHR VkCommandBufferSubmitInfoKHR VkDependencyInfoKHR VkImageMemoryBarrier2KHR VkSemaphoreSubmitInfoKHR VkSubmitInfo2KHR Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceSynchronization2FeaturesKHR Extending VkSubpassDependency2: VkMemoryBarrier2KHR VkAccessFlagBits2KHR VkPipelineStageFlagBits2KHR VkSubmitFlagBitsKHR VkAccessFlags2KHR VkPipelineStageFlags2KHR VkSubmitFlagsKHR VK_KHR_SYNCHRONIZATION_2_EXTENSION_NAME VK_KHR_SYNCHRONIZATION_2_SPEC_VERSION Extending VkAccessFlagBits: VK_ACCESS_NONE_KHR Extending VkAccessFlagBits2: VK_ACCESS_2_COLOR_ATTACHMENT_READ_BIT_KHR VK_ACCESS_2_COLOR_ATTACHMENT_WRITE_BIT_KHR VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_READ_BIT_KHR VK_ACCESS_2_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT_KHR VK_ACCESS_2_HOST_READ_BIT_KHR VK_ACCESS_2_HOST_WRITE_BIT_KHR VK_ACCESS_2_INDEX_READ_BIT_KHR VK_ACCESS_2_INDIRECT_COMMAND_READ_BIT_KHR VK_ACCESS_2_INPUT_ATTACHMENT_READ_BIT_KHR VK_ACCESS_2_MEMORY_READ_BIT_KHR VK_ACCESS_2_MEMORY_WRITE_BIT_KHR VK_ACCESS_2_NONE_KHR VK_ACCESS_2_SHADER_READ_BIT_KHR VK_ACCESS_2_SHADER_SAMPLED_READ_BIT_KHR VK_ACCESS_2_SHADER_STORAGE_READ_BIT_KHR VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT_KHR VK_ACCESS_2_SHADER_WRITE_BIT_KHR VK_ACCESS_2_TRANSFER_READ_BIT_KHR VK_ACCESS_2_TRANSFER_WRITE_BIT_KHR VK_ACCESS_2_UNIFORM_READ_BIT_KHR VK_ACCESS_2_VERTEX_ATTRIBUTE_READ_BIT_KHR Extending VkEventCreateFlagBits: VK_EVENT_CREATE_DEVICE_ONLY_BIT_KHR Extending VkImageLayout: VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL_KHR VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR Extending VkPipelineStageFlagBits: VK_PIPELINE_STAGE_NONE_KHR Extending VkPipelineStageFlagBits2: VK_PIPELINE_STAGE_2_ALL_COMMANDS_BIT_KHR VK_PIPELINE_STAGE_2_ALL_GRAPHICS_BIT_KHR VK_PIPELINE_STAGE_2_ALL_TRANSFER_BIT_KHR VK_PIPELINE_STAGE_2_BLIT_BIT_KHR VK_PIPELINE_STAGE_2_BOTTOM_OF_PIPE_BIT_KHR VK_PIPELINE_STAGE_2_CLEAR_BIT_KHR VK_PIPELINE_STAGE_2_COLOR_ATTACHMENT_OUTPUT_BIT_KHR VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT_KHR VK_PIPELINE_STAGE_2_COPY_BIT_KHR VK_PIPELINE_STAGE_2_DRAW_INDIRECT_BIT_KHR VK_PIPELINE_STAGE_2_EARLY_FRAGMENT_TESTS_BIT_KHR VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT_KHR VK_PIPELINE_STAGE_2_GEOMETRY_SHADER_BIT_KHR VK_PIPELINE_STAGE_2_HOST_BIT_KHR VK_PIPELINE_STAGE_2_INDEX_INPUT_BIT_KHR VK_PIPELINE_STAGE_2_LATE_FRAGMENT_TESTS_BIT_KHR VK_PIPELINE_STAGE_2_NONE_KHR VK_PIPELINE_STAGE_2_PRE_RASTERIZATION_SHADERS_BIT_KHR VK_PIPELINE_STAGE_2_RESOLVE_BIT_KHR VK_PIPELINE_STAGE_2_TESSELLATION_CONTROL_SHADER_BIT_KHR VK_PIPELINE_STAGE_2_TESSELLATION_EVALUATION_SHADER_BIT_KHR VK_PIPELINE_STAGE_2_TOP_OF_PIPE_BIT_KHR VK_PIPELINE_STAGE_2_TRANSFER_BIT_KHR VK_PIPELINE_STAGE_2_VERTEX_ATTRIBUTE_INPUT_BIT_KHR VK_PIPELINE_STAGE_2_VERTEX_INPUT_BIT_KHR VK_PIPELINE_STAGE_2_VERTEX_SHADER_BIT_KHR Extending VkStructureType: VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2_KHR VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO_KHR VK_STRUCTURE_TYPE_DEPENDENCY_INFO_KHR VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2_KHR VK_STRUCTURE_TYPE_MEMORY_BARRIER_2_KHR VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES_KHR VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO_KHR VK_STRUCTURE_TYPE_SUBMIT_INFO_2_KHR Extending VkSubmitFlagBits: VK_SUBMIT_PROTECTED_BIT_KHR If VK_EXT_blend_operation_advanced is supported: Extending VkAccessFlagBits2: VK_ACCESS_2_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT If VK_EXT_conditional_rendering is supported: Extending VkAccessFlagBits2: VK_ACCESS_2_CONDITIONAL_RENDERING_READ_BIT_EXT Extending VkPipelineStageFlagBits2: VK_PIPELINE_STAGE_2_CONDITIONAL_RENDERING_BIT_EXT If VK_EXT_device_generated_commands is supported: Extending VkAccessFlagBits2: VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_EXT VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_EXT Extending VkPipelineStageFlagBits2: VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_EXT If VK_EXT_fragment_density_map is supported: Extending VkAccessFlagBits2: VK_ACCESS_2_FRAGMENT_DENSITY_MAP_READ_BIT_EXT Extending VkPipelineStageFlagBits2: VK_PIPELINE_STAGE_2_FRAGMENT_DENSITY_PROCESS_BIT_EXT If VK_EXT_mesh_shader is supported: Extending VkPipelineStageFlagBits2: VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_EXT VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_EXT If VK_EXT_transform_feedback is supported: Extending VkAccessFlagBits2: VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT VK_ACCESS_2_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT VK_ACCESS_2_TRANSFORM_FEEDBACK_WRITE_BIT_EXT Extending VkPipelineStageFlagBits2: VK_PIPELINE_STAGE_2_TRANSFORM_FEEDBACK_BIT_EXT If VK_KHR_acceleration_structure is supported: Extending VkAccessFlagBits2: VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_KHR VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_KHR Extending VkPipelineStageFlagBits2: VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_KHR If VK_KHR_fragment_shading_rate is supported: Extending VkAccessFlagBits2: VK_ACCESS_2_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR Extending VkPipelineStageFlagBits2: VK_PIPELINE_STAGE_2_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR If VK_KHR_ray_tracing_pipeline is supported: Extending VkPipelineStageFlagBits2: VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_KHR If VK_NV_device_generated_commands is supported: Extending VkAccessFlagBits2: VK_ACCESS_2_COMMAND_PREPROCESS_READ_BIT_NV VK_ACCESS_2_COMMAND_PREPROCESS_WRITE_BIT_NV Extending VkPipelineStageFlagBits2: VK_PIPELINE_STAGE_2_COMMAND_PREPROCESS_BIT_NV If VK_NV_mesh_shader is supported: Extending VkPipelineStageFlagBits2: VK_PIPELINE_STAGE_2_MESH_SHADER_BIT_NV VK_PIPELINE_STAGE_2_TASK_SHADER_BIT_NV If VK_NV_ray_tracing is supported: Extending VkAccessFlagBits2: VK_ACCESS_2_ACCELERATION_STRUCTURE_READ_BIT_NV VK_ACCESS_2_ACCELERATION_STRUCTURE_WRITE_BIT_NV Extending VkPipelineStageFlagBits2: VK_PIPELINE_STAGE_2_ACCELERATION_STRUCTURE_BUILD_BIT_NV VK_PIPELINE_STAGE_2_RAY_TRACING_SHADER_BIT_NV If VK_NV_shading_rate_image is supported: Extending VkAccessFlagBits2: VK_ACCESS_2_SHADING_RATE_IMAGE_READ_BIT_NV Extending VkPipelineStageFlagBits2: VK_PIPELINE_STAGE_2_SHADING_RATE_IMAGE_BIT_NV Vulkan APIs in this extension are included in core Vulkan 1.3, with the KHR suffix omitted. External interactions defined by this extension, such as SPIR-V token names, retain their original names. The original Vulkan API names are still available as aliases of the core functionality. See https://github.com/KhronosGroup/Vulkan-Docs/wiki/Synchronization-Examples Revision 1, 2020-12-03 (Tobias Hector) Internal revisions Name String VK_KHR_timeline_semaphore Extension Type Device extension Registered Extension Number 208 Revision 2 Ratification Status Ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 Deprecation State Promoted to Vulkan 1.2 Contact Faith Ekstrand gfxstrand Last Modified Date 2019-06-12 IP Status No known IP claims. Interactions and External Dependencies This extension interacts with VK_KHR_external_semaphore_capabilities This extension interacts with VK_KHR_external_semaphore This extension interacts with VK_KHR_external_semaphore_win32 Contributors Jeff Bolz, NVIDIA Yuriy ODonnell, Epic Games Faith Ekstrand, Intel Jesse Hall, Google James Jones, NVIDIA Jeff Juliano, NVIDIA Daniel Rakos, AMD Ray Smith, Arm This extension introduces a new type of semaphore that has an integer payload identifying a point in a timeline. Such timeline semaphores support the following operations: Host query - A host operation that allows querying the payload of the timeline semaphore. Host wait - A host operation that allows a blocking wait for a timeline semaphore to reach a specified value. Host signal - A host operation that allows advancing the timeline semaphore to a specified value. Device wait - A device operation that allows waiting for a timeline semaphore to reach a specified value. Device signal - A device operation that allows advancing the timeline semaphore to a specified value. All functionality in this extension is included in core Vulkan 1.2, with the KHR suffix omitted. The original type, enum, and command names are still available as aliases of the core functionality. vkGetSemaphoreCounterValueKHR vkSignalSemaphoreKHR vkWaitSemaphoresKHR VkSemaphoreSignalInfoKHR VkSemaphoreWaitInfoKHR Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceTimelineSemaphoreFeaturesKHR Extending VkPhysicalDeviceProperties2: VkPhysicalDeviceTimelineSemaphorePropertiesKHR Extending VkSemaphoreCreateInfo, VkPhysicalDeviceExternalSemaphoreInfo: VkSemaphoreTypeCreateInfoKHR Extending VkSubmitInfo, VkBindSparseInfo: VkTimelineSemaphoreSubmitInfoKHR VkSemaphoreTypeKHR VkSemaphoreWaitFlagBitsKHR VkSemaphoreWaitFlagsKHR VK_KHR_TIMELINE_SEMAPHORE_EXTENSION_NAME VK_KHR_TIMELINE_SEMAPHORE_SPEC_VERSION Extending VkSemaphoreType: VK_SEMAPHORE_TYPE_BINARY_KHR VK_SEMAPHORE_TYPE_TIMELINE_KHR Extending VkSemaphoreWaitFlagBits: VK_SEMAPHORE_WAIT_ANY_BIT_KHR Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES_KHR VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES_KHR VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO_KHR VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO_KHR VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO_KHR VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO_KHR 1) Do we need a new object type for this? RESOLVED: No, we just introduce a new type of semaphore object, as VK_KHR_external_semaphore_win32 already uses semaphores as the destination for importing D3D12 fence objects, which are semantically close/identical to the proposed synchronization primitive. 2) What type of payload the new synchronization primitive has? RESOLVED: A 64-bit unsigned integer that can only be set to strictly increasing values by signal operations and is not changed by wait operations. 3) Does the new synchronization primitive have the same signal-before-wait requirement as the existing semaphores do? RESOLVED: No. Timeline semaphores support signaling and waiting entirely asynchronously. It is the responsibility of the application to avoid deadlock. 4) Does the new synchronization primitive allow resetting its payload? RESOLVED: No, allowing the payload value to go backwards is problematic. Applications looking for reset behavior should create a new instance of the synchronization primitive instead. 5) How do we enable host waits on the synchronization primitive? RESOLVED: Both a non-blocking query of the current payload value of the synchronization primitive, and a blocking wait operation are provided. 6) How do we enable device waits and signals on the synchronization primitive? RESOLVED: Similar to VK_KHR_external_semaphore_win32, this extension introduces a new structure that can be chained to VkSubmitInfo to specify the values signaled semaphores should be set to, and the values waited semaphores need to reach. 7) Can the new synchronization primitive be used to synchronize presentation and swapchain image acquisition operations? RESOLVED: Some implementations may have problems with supporting that directly, thus it is not allowed in this extension. 8) Do we want to support external sharing of the new synchronization primitive type? RESOLVED: Yes. Timeline semaphore specific external sharing capabilities can be queried using vkGetPhysicalDeviceExternalSemaphoreProperties by chaining the new VkSemaphoreTypeCreateInfoKHR structure to its pExternalSemaphoreInfo structure. This allows having a different set of external semaphore handle types supported for timeline semaphores vs. binary semaphores. 9) Do we need to add a host signal operation for the new synchronization primitive type? RESOLVED: Yes. This helps in situations where one host thread submits a workload but another host thread has the information on when the workload is ready to be executed. 10) How should the new synchronization primitive interact with the ordering requirements of the original VkSemaphore? RESOLVED: Prior to calling any command which may cause a wait operation on a binary semaphore, the application must ensure that the semaphore signal operation that has been submitted for execution and any semaphore signal operations on which it depends (if any) must have also been submitted for execution. 11) Should we have separate feature bits for different sub-features of timeline semaphores? RESOLVED: No. The only feature which cannot be supported universally is timeline semaphore import/export. For import/export, the application is already required to query available external handle types via vkGetPhysicalDeviceExternalSemaphoreProperties and provide the semaphore type by adding a VkSemaphoreTypeCreateInfoKHR structure to the pNext chain of VkPhysicalDeviceExternalSemaphoreInfo so no new feature bit is required. Revision 1, 2018-05-10 (Faith Ekstrand) Initial version Revision 2, 2019-06-12 (Faith Ekstrand) Added an initialValue parameter to timeline semaphore creation Name String VK_KHR_uniform_buffer_standard_layout Extension Type Device extension Registered Extension Number 254 Revision 1 Ratification Status Ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 Deprecation State Promoted to Vulkan 1.2 Contact Graeme Leese gnl21 Last Modified Date 2019-01-25 Contributors Graeme Leese, Broadcom Jeff Bolz, NVIDIA Tobias Hector, AMD Faith Ekstrand, Intel Neil Henning, AMD This extension enables tighter array and structure packing to be used with uniform buffers. It modifies the alignment rules for uniform buffers, allowing for tighter packing of arrays and structures. This allows, for example, the std430 layout, as defined in GLSL to be supported in uniform buffers. All functionality in this extension is included in core Vulkan 1.2, with the KHR suffix omitted. The original type, enum, and command names are still available as aliases of the core functionality. Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR VK_KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_EXTENSION_NAME VK_KHR_UNIFORM_BUFFER_STANDARD_LAYOUT_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR Revision 1, 2019-01-25 (Graeme Leese) Initial draft Name String VK_KHR_variable_pointers Extension Type Device extension Registered Extension Number 121 Revision 1 Ratification Status Ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 and VK_KHR_storage_buffer_storage_class or Vulkan Version 1.1 SPIR-V Dependencies SPV_KHR_variable_pointers Deprecation State Promoted to Vulkan 1.1 Contact Jesse Hall critsec Last Modified Date 2017-09-05 IP Status No known IP claims. Contributors John Kessenich, Google Neil Henning, Codeplay David Neto, Google Daniel Koch, Nvidia Graeme Leese, Broadcom Weifeng Zhang, Qualcomm Stephen Clarke, Imagination Technologies Faith Ekstrand, Intel Jesse Hall, Google The VK_KHR_variable_pointers extension allows implementations to indicate their level of support for the SPV_KHR_variable_pointers SPIR-V extension. The SPIR-V extension allows shader modules to use invocation-private pointers into uniform and/or storage buffers, where the pointer values can be dynamic and non-uniform. The SPV_KHR_variable_pointers extension introduces two capabilities. The first, VariablePointersStorageBuffer, must be supported by all implementations of this extension. The second, VariablePointers, is optional. All functionality in this extension is included in core Vulkan 1.1, with the KHR suffix omitted, however support for the variablePointersStorageBuffer feature is made optional. The original type, enum, and command names are still available as aliases of the core functionality. If Vulkan 1.4 is supported, support for the variablePointers and variablePointersStorageBuffer features is required. Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceVariablePointerFeaturesKHR VkPhysicalDeviceVariablePointersFeaturesKHR VK_KHR_VARIABLE_POINTERS_EXTENSION_NAME VK_KHR_VARIABLE_POINTERS_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES_KHR VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR VariablePointers VariablePointersStorageBuffer 1) Do we need an optional property for the SPIR-V VariablePointersStorageBuffer capability or should it be mandatory when this extension is advertised? RESOLVED: Add it as a distinct feature, but make support mandatory. Adding it as a feature makes the extension easier to include in a future core API version. In the extension, the feature is mandatory, so that presence of the extension guarantees some functionality. When included in a core API version, the feature would be optional. 2) Can support for these capabilities vary between shader stages? RESOLVED: No, if the capability is supported in any stage it must be supported in all stages. 3) Should the capabilities be features or limits? RESOLVED: Features, primarily for consistency with other similar extensions. Revision 1, 2017-03-14 (Jesse Hall and John Kessenich) Internal revisions Name String VK_KHR_vertex_attribute_divisor Extension Type Device extension Registered Extension Number 526 Revision 1 Ratification Status Ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 Deprecation State Promoted to Vulkan 1.4 Contact Shahbaz Youssefi syoussefi Extension Proposal VK_KHR_vertex_attribute_divisor Last Modified Date 2023-09-20 IP Status No known IP claims. Contributors Shahbaz Youssefi, Google Contributors to VK_EXT_vertex_attribute_divisor This extension is based on the VK_EXT_vertex_attribute_divisor extension. The only difference is the new property supportsNonZeroFirstInstance, which indicates support for non-zero values in firstInstance. This allows the extension to be supported on implementations that have traditionally only supported OpenGL ES. VkVertexInputBindingDivisorDescriptionKHR Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR Extending VkPhysicalDeviceProperties2: VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR Extending VkPipelineVertexInputStateCreateInfo: VkPipelineVertexInputDivisorStateCreateInfoKHR VK_KHR_VERTEX_ATTRIBUTE_DIVISOR_EXTENSION_NAME VK_KHR_VERTEX_ATTRIBUTE_DIVISOR_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_KHR VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_KHR VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_KHR Functionality in this extension is included in core Vulkan 1.4 with the KHR suffix omitted. The original type, enum and command names are still available as aliases of the core functionality. Revision 1, 2023-09-20 (Shahbaz Youssefi) First Version, based on VK_EXT_vertex_attribute_divisor Name String VK_KHR_vulkan_memory_model Extension Type Device extension Registered Extension Number 212 Revision 3 Ratification Status Ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 SPIR-V Dependencies SPV_KHR_vulkan_memory_model Deprecation State Promoted to Vulkan 1.2 Contact Jeff Bolz jeffbolznv Last Modified Date 2018-12-10 IP Status No known IP claims. Contributors Jeff Bolz, NVIDIA Alan Baker, Google Tobias Hector, AMD David Neto, Google Robert Simpson, Qualcomm Technologies, Inc. Brian Sumner, AMD The VK_KHR_vulkan_memory_model extension allows use of the features guarded by the VulkanMemoryModel, VulkanMemoryModelDeviceScope, and VulkanMemoryModelAvailabilityVisibilityChains capabilities in shader modules. The Vulkan Memory Model formally defines how to synchronize memory accesses to the same memory locations performed by multiple shader invocations. Version 3 of the spec added a member (vulkanMemoryModelAvailabilityVisibilityChains) to VkPhysicalDeviceVulkanMemoryModelFeaturesKHR, which is an incompatible change from version 2. All functionality in this extension is included in core Vulkan 1.2, with the KHR suffix omitted. However, if Vulkan 1.2 is supported and this extension is not, the vulkanMemoryModel capability is optional. The original type, enum, and command names are still available as aliases of the core functionality. If Vulkan 1.3 is supported, support for the vulkanMemoryModel and vulkanMemoryModelDeviceScope capabilities is required. Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceVulkanMemoryModelFeaturesKHR VK_KHR_VULKAN_MEMORY_MODEL_EXTENSION_NAME VK_KHR_VULKAN_MEMORY_MODEL_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR VulkanMemoryModelKHR Revision 1, 2018-06-24 (Jeff Bolz) Initial draft Revision 3, 2018-12-10 (Jeff Bolz) Add vulkanMemoryModelAvailabilityVisibilityChains member to the VkPhysicalDeviceVulkanMemoryModelFeaturesKHR structure. Name String VK_KHR_zero_initialize_workgroup_memory Extension Type Device extension Registered Extension Number 326 Revision 1 Ratification Status Ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 Deprecation State Promoted to Vulkan 1.3 Contact Alan Baker alan-baker Last Modified Date 2020-11-18 IP Status No known IP claims. Contributors Alan Baker, Google Jeff Bolz, Nvidia Faith Ekstrand, Intel This extension allows the use of a null constant initializer on shader Workgroup memory variables, allowing implementations to expose any special hardware or instructions they may have. Zero initialization is commonly used by applications running untrusted content (e.g. web browsers) as way of defeating memory-scraping attacks. Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR VK_KHR_ZERO_INITIALIZE_WORKGROUP_MEMORY_EXTENSION_NAME VK_KHR_ZERO_INITIALIZE_WORKGROUP_MEMORY_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES_KHR Vulkan APIs in this extension are included in core Vulkan 1.3, with the KHR suffix omitted. External interactions defined by this extension, such as SPIR-V token names, retain their original names. The original Vulkan API names are still available as aliases of the core functionality. Revision 1, 2020-11-18 (Alan Baker) Internal draft version Name String VK_EXT_4444_formats Extension Type Device extension Registered Extension Number 341 Revision 1 Ratification Status Not ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 Deprecation State Promoted to Vulkan 1.3 Contact Joshua Ashton Joshua-Ashton Last Modified Date 2020-07-28 IP Status No known IP claims. Contributors Joshua Ashton, Valve Faith Ekstrand, Intel This extension defines the VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT and VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT formats which are defined in other current graphics APIs. This extension may be useful for building translation layers for those APIs or for porting applications that use these formats without having to resort to swizzles. When VK_EXT_custom_border_color is used, these formats are not subject to the same restrictions for border color without format as with VK_FORMAT_B4G4R4A4_UNORM_PACK16. Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDevice4444FormatsFeaturesEXT VK_EXT_4444_FORMATS_EXTENSION_NAME VK_EXT_4444_FORMATS_SPEC_VERSION Extending VkFormat: VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT The format enumerants introduced by the extension are included in core Vulkan 1.3, with the EXT suffix omitted. However, runtime support for these formats is optional in core Vulkan 1.3, while if this extension is supported, runtime support is mandatory. The feature structure is not promoted. The original enum names are still available as aliases of the core functionality. Revision 1, 2020-07-04 (Joshua Ashton) Initial draft Name String VK_EXT_buffer_device_address Extension Type Device extension Registered Extension Number 245 Revision 2 Ratification Status Not ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 SPIR-V Dependencies SPV_EXT_physical_storage_buffer Deprecation State Deprecated by VK_KHR_buffer_device_address extension Which in turn was promoted to Vulkan 1.2 Contact Jeff Bolz jeffbolznv Last Modified Date 2019-01-06 IP Status No known IP claims. Interactions and External Dependencies This extension provides API support for GLSL_EXT_buffer_reference and GLSL_EXT_buffer_reference_uvec2 Contributors Jeff Bolz, NVIDIA Neil Henning, AMD Tobias Hector, AMD Faith Ekstrand, Intel Baldur Karlsson, Valve This extension allows the application to query a 64-bit buffer device address value for a buffer, which can be used to access the buffer memory via the PhysicalStorageBufferEXT storage class in the GL_EXT_buffer_reference GLSL extension and SPV_EXT_physical_storage_buffer SPIR-V extension. It also allows buffer device addresses to be provided by a trace replay tool, so that it matches the address used when the trace was captured. vkGetBufferDeviceAddressEXT VkBufferDeviceAddressInfoEXT Extending VkBufferCreateInfo: VkBufferDeviceAddressCreateInfoEXT Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceBufferAddressFeaturesEXT VkPhysicalDeviceBufferDeviceAddressFeaturesEXT VK_EXT_BUFFER_DEVICE_ADDRESS_EXTENSION_NAME VK_EXT_BUFFER_DEVICE_ADDRESS_SPEC_VERSION Extending VkBufferCreateFlagBits: VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT Extending VkBufferUsageFlagBits: VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT Extending VkResult: VK_ERROR_INVALID_DEVICE_ADDRESS_EXT Extending VkStructureType: VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_EXT VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_ADDRESS_FEATURES_EXT VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT PhysicalStorageBufferAddressesEXT 1) Where is VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_ADDRESS_FEATURES_EXT and VkPhysicalDeviceBufferAddressFeaturesEXT? RESOLVED: They were renamed as VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT and VkPhysicalDeviceBufferDeviceAddressFeaturesEXT accordingly for consistency. Even though, the old names can still be found in the generated header files for compatibility. Revision 1, 2018-11-01 (Jeff Bolz) Internal revisions Revision 2, 2019-01-06 (Jon Leech) Minor updates to appendix for publication Name String VK_EXT_calibrated_timestamps Extension Type Device extension Registered Extension Number 185 Revision 2 Ratification Status Not ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 Deprecation State Promoted to VK_KHR_calibrated_timestamps extension Contact Daniel Rakos drakos-amd Extension Proposal VK_EXT_calibrated_timestamps Last Modified Date 2018-10-04 IP Status No known IP claims. Contributors Matthaeus G. Chajdas, AMD Alan Harrison, AMD Derrick Owens, AMD Daniel Rakos, AMD Faith Ekstrand, Intel Keith Packard, Valve This extension provides an interface to query calibrated timestamps obtained quasi simultaneously from two time domains. All functionality in this extension is included in VK_KHR_calibrated_timestamps, with the suffix changed to KHR. The original enum names are still available as aliases of the KHR functionality. vkGetCalibratedTimestampsEXT vkGetPhysicalDeviceCalibrateableTimeDomainsEXT VkCalibratedTimestampInfoEXT VkTimeDomainEXT VK_EXT_CALIBRATED_TIMESTAMPS_EXTENSION_NAME VK_EXT_CALIBRATED_TIMESTAMPS_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT Extending VkTimeDomainKHR: VK_TIME_DOMAIN_CLOCK_MONOTONIC_EXT VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_EXT VK_TIME_DOMAIN_DEVICE_EXT VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_EXT Revision 2, 2021-03-16 (Lionel Landwerlin) Specify requirement on device timestamps Revision 1, 2018-10-04 (Daniel Rakos) Internal revisions. Name String VK_EXT_debug_marker Extension Type Device extension Registered Extension Number 23 Revision 4 Ratification Status Not ratified Extension and Version Dependencies VK_EXT_debug_report Deprecation State Promoted to VK_EXT_debug_utils extension Special Use Debugging tools Contact Baldur Karlsson baldurk Last Modified Date 2017-01-31 IP Status No known IP claims. Contributors Baldur Karlsson Dan Ginsburg, Valve Jon Ashburn, LunarG Kyle Spagnoli, NVIDIA The VK_EXT_debug_marker extension is a device extension. It introduces concepts of object naming and tagging, for better tracking of Vulkan objects, as well as additional commands for recording annotations of named sections of a workload to aid organization and offline analysis in external tools. vkCmdDebugMarkerBeginEXT vkCmdDebugMarkerEndEXT vkCmdDebugMarkerInsertEXT vkDebugMarkerSetObjectNameEXT vkDebugMarkerSetObjectTagEXT VkDebugMarkerMarkerInfoEXT VkDebugMarkerObjectNameInfoEXT VkDebugMarkerObjectTagInfoEXT VkDebugReportObjectTypeEXT VK_EXT_DEBUG_MARKER_EXTENSION_NAME VK_EXT_DEBUG_MARKER_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT Example 1 Associate a name with an image, for easier debugging in external tools or with validation layers that can print a friendly name when referring to objects in error messages. extern VkDevice device; extern VkImage image; // Must call extension functions through a function pointer: PFN_vkDebugMarkerSetObjectNameEXT pfnDebugMarkerSetObjectNameEXT = (PFN_vkDebugMarkerSetObjectNameEXT)vkGetDeviceProcAddr(device, "vkDebugMarkerSetObjectNameEXT"); // Set a name on the image const VkDebugMarkerObjectNameInfoEXT imageNameInfo = { .sType = VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT, .pNext = NULL, .objectType = VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT, .object = (uint64_t)image, .pObjectName = "Brick Diffuse Texture", }; pfnDebugMarkerSetObjectNameEXT(device, &imageNameInfo); // A subsequent error might print: // Image 'Brick Diffuse Texture' (0xc0dec0dedeadbeef) is used in a // command buffer with no memory bound to it. Example 2 Annotating regions of a workload with naming information so that offline analysis tools can display a more usable visualization of the commands submitted. extern VkDevice device; extern VkCommandBuffer commandBuffer; // Must call extension functions through a function pointer: PFN_vkCmdDebugMarkerBeginEXT pfnCmdDebugMarkerBeginEXT = (PFN_vkCmdDebugMarkerBeginEXT)vkGetDeviceProcAddr(device, "vkCmdDebugMarkerBeginEXT"); PFN_vkCmdDebugMarkerEndEXT pfnCmdDebugMarkerEndEXT = (PFN_vkCmdDebugMarkerEndEXT)vkGetDeviceProcAddr(device, "vkCmdDebugMarkerEndEXT"); PFN_vkCmdDebugMarkerInsertEXT pfnCmdDebugMarkerInsertEXT = (PFN_vkCmdDebugMarkerInsertEXT)vkGetDeviceProcAddr(device, "vkCmdDebugMarkerInsertEXT"); // Describe the area being rendered const VkDebugMarkerMarkerInfoEXT houseMarker = { .sType = VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT, .pNext = NULL, .pMarkerName = "Brick House", .color = { 1.0f, 0.0f, 0.0f, 1.0f }, }; // Start an annotated group of calls under the 'Brick House' name pfnCmdDebugMarkerBeginEXT(commandBuffer, &houseMarker); { // A mutable structure for each part being rendered VkDebugMarkerMarkerInfoEXT housePartMarker = { .sType = VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT, .pNext = NULL, .pMarkerName = NULL, .color = { 0.0f, 0.0f, 0.0f, 0.0f }, }; // Set the name and insert the marker housePartMarker.pMarkerName = "Walls"; pfnCmdDebugMarkerInsertEXT(commandBuffer, &housePartMarker); // Insert the drawcall for the walls vkCmdDrawIndexed(commandBuffer, 1000, 1, 0, 0, 0); // Insert a recursive region for two sets of windows housePartMarker.pMarkerName = "Windows"; pfnCmdDebugMarkerBeginEXT(commandBuffer, &housePartMarker); { vkCmdDrawIndexed(commandBuffer, 75, 6, 1000, 0, 0); vkCmdDrawIndexed(commandBuffer, 100, 2, 1450, 0, 0); } pfnCmdDebugMarkerEndEXT(commandBuffer); housePartMarker.pMarkerName = "Front Door"; pfnCmdDebugMarkerInsertEXT(commandBuffer, &housePartMarker); vkCmdDrawIndexed(commandBuffer, 350, 1, 1650, 0, 0); housePartMarker.pMarkerName = "Roof"; pfnCmdDebugMarkerInsertEXT(commandBuffer, &housePartMarker); vkCmdDrawIndexed(commandBuffer, 500, 1, 2000, 0, 0); } // End the house annotation started above pfnCmdDebugMarkerEndEXT(commandBuffer); 1) Should the tag or name for an object be specified using the pNext parameter in the objects Vk*CreateInfo structure? RESOLVED: No. While this fits with other Vulkan patterns and would allow more type safety and future proofing against future objects, it has notable downsides. In particular passing the name at Vk*CreateInfo time does not allow renaming, prevents late binding of naming information, and does not allow naming of implicitly created objects such as queues and swapchain images. 2) Should the command annotation functions vkCmdDebugMarkerBeginEXT and vkCmdDebugMarkerEndEXT support the ability to specify a color? RESOLVED: Yes. The functions have been expanded to take an optional color which can be used at will by implementations consuming the command buffer annotations in their visualization. 3) Should the functions added in this extension accept an extensible structure as their parameter for a more flexible API, as opposed to direct function parameters? If so, which functions? RESOLVED: Yes. All functions have been modified to take a structure type with extensible pNext pointer, to allow future extensions to add additional annotation information in the same commands. Revision 1, 2016-02-24 (Baldur Karlsson) Initial draft, based on LunarG marker spec Revision 2, 2016-02-26 (Baldur Karlsson) Renamed Dbg to DebugMarker in function names Allow markers in secondary command buffers under certain circumstances Minor language tweaks and edits Revision 3, 2016-04-23 (Baldur Karlsson) Reorganize spec layout to closer match desired organization Added optional color to markers (both regions and inserted labels) Changed functions to take extensible structs instead of direct function parameters Revision 4, 2017-01-31 (Baldur Karlsson) Added explicit dependency on VK_EXT_debug_report Moved definition of VkDebugReportObjectTypeEXT to debug report chapter. Fixed typo in dates in revision history Name String VK_EXT_debug_report Extension Type Instance extension Registered Extension Number 12 Revision 10 Ratification Status Not ratified Extension and Version Dependencies None API Interactions Interacts with VK_VERSION_1_1 Deprecation State Deprecated by VK_EXT_debug_utils extension Special Use Debugging tools Contact Courtney Goeltzenleuchter courtney-g Last Modified Date 2020-12-14 IP Status No known IP claims. Contributors Courtney Goeltzenleuchter, LunarG Dan Ginsburg, Valve Jon Ashburn, LunarG Mark Lobodzinski, LunarG Due to the nature of the Vulkan interface, there is very little error information available to the developer and application. By enabling optional validation layers and using the VK_EXT_debug_report extension, developers can obtain much more detailed feedback on the applications use of Vulkan. This extension defines a way for layers and the implementation to call back to the application for events of interest to the application. VkDebugReportCallbackEXT vkCreateDebugReportCallbackEXT vkDebugReportMessageEXT vkDestroyDebugReportCallbackEXT Extending VkInstanceCreateInfo: VkDebugReportCallbackCreateInfoEXT PFN_vkDebugReportCallbackEXT VkDebugReportFlagBitsEXT VkDebugReportObjectTypeEXT VkDebugReportFlagsEXT VK_EXT_DEBUG_REPORT_EXTENSION_NAME VK_EXT_DEBUG_REPORT_SPEC_VERSION Extending VkObjectType: VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT Extending VkResult: VK_ERROR_VALIDATION_FAILED_EXT Extending VkStructureType: VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT If Vulkan Version 1.1 is supported: Extending VkDebugReportObjectTypeEXT: VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT VK_EXT_debug_report allows an application to register multiple callbacks with the validation layers. Some callbacks may log the information to a file, others may cause a debug break point or other application-defined behavior. An application can register callbacks even when no validation layers are enabled, but they will only be called for loader and, if implemented, driver events. To capture events that occur while creating or destroying an instance an application can link a VkDebugReportCallbackCreateInfoEXT structure to the pNext chain of the VkInstanceCreateInfo structure passed to vkCreateInstance. Example uses: Create three callback objects. One will log errors and warnings to the debug console using Windows OutputDebugString. The second will cause the debugger to break at that callback when an error happens and the third will log warnings to stdout. VkResult res; VkDebugReportCallbackEXT cb1, cb2, cb3; VkDebugReportCallbackCreateInfoEXT callback1 = { .sType = VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT, .pNext = NULL, .flags = VK_DEBUG_REPORT_ERROR_BIT_EXT | VK_DEBUG_REPORT_WARNING_BIT_EXT, .pfnCallback = myOutputDebugString, .pUserData = NULL }; res = vkCreateDebugReportCallbackEXT(instance, &callback1, &cb1); if (res != VK_SUCCESS) /* Do error handling for VK_ERROR_OUT_OF_MEMORY */ callback.flags = VK_DEBUG_REPORT_ERROR_BIT_EXT; callback.pfnCallback = myDebugBreak; callback.pUserData = NULL; res = vkCreateDebugReportCallbackEXT(instance, &callback, &cb2); if (res != VK_SUCCESS) /* Do error handling for VK_ERROR_OUT_OF_MEMORY */ VkDebugReportCallbackCreateInfoEXT callback3 = { .sType = VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT, .pNext = NULL, .flags = VK_DEBUG_REPORT_WARNING_BIT_EXT, .pfnCallback = mystdOutLogger, .pUserData = NULL }; res = vkCreateDebugReportCallbackEXT(instance, &callback3, &cb3); if (res != VK_SUCCESS) /* Do error handling for VK_ERROR_OUT_OF_MEMORY */ ... /* remove callbacks when cleaning up */ vkDestroyDebugReportCallbackEXT(instance, cb1); vkDestroyDebugReportCallbackEXT(instance, cb2); vkDestroyDebugReportCallbackEXT(instance, cb3); In the initial release of the VK_EXT_debug_report extension, the token VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT was used. Starting in version 2 of the extension branch, VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT is used instead for consistency with Vulkan naming rules. The older enum is still available for backwards compatibility. In the initial release of the VK_EXT_debug_report extension, the token VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT was used. Starting in version 8 of the extension branch, VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT is used instead for consistency with Vulkan naming rules. The older enum is still available for backwards compatibility. 1) What is the hierarchy / seriousness of the message flags? E.g. ERROR > WARN > PERF_WARN  RESOLVED: There is no specific hierarchy. Each bit is independent and should be checked via bitwise AND. For example: if (localFlags & VK_DEBUG_REPORT_ERROR_BIT_EXT) { process error message } if (localFlags & VK_DEBUG_REPORT_DEBUG_BIT_EXT) { process debug message } The validation layers do use them in a hierarchical way (ERROR > WARN > PERF, WARN > DEBUG > INFO) and they (at least at the time of this writing) only set one bit at a time. But it is not a requirement of this extension. It is possible that a layer may intercept and change, or augment the flags with extension values the applications debug report handler may not be familiar with, so it is important to treat each flag independently. 2) Should there be a VU requiring VkDebugReportCallbackCreateInfoEXT::flags to be non-zero? RESOLVED: It may not be very useful, but we do not need VU statement requiring the VkDebugReportCallbackCreateInfoEXT::msgFlags at create-time to be non-zero. One can imagine that apps may prefer it as it allows them to set the mask as desired - including nothing - at runtime without having to check. 3) What is the difference between VK_DEBUG_REPORT_DEBUG_BIT_EXT and VK_DEBUG_REPORT_INFORMATION_BIT_EXT? RESOLVED: VK_DEBUG_REPORT_DEBUG_BIT_EXT specifies information that could be useful debugging the Vulkan implementation itself. 4) How do you compare handles returned by the debug_report callback to the applications handles? RESOLVED: Due to the different nature of dispatchable and nondispatchable handles there is no generic way (that we know of) that works for common compilers with 32bit, 64bit, C and C++. We recommend applications use the same cast that the validation layers use: + reinterpret_cast(dispatchableHandle) (uint64_t)(nondispatchableHandle) + This does require that the application treat dispatchable and nondispatchable handles differently. Revision 1, 2015-05-20 (Courtney Goetzenleuchter) Initial draft, based on LunarG KHR spec, other KHR specs Revision 2, 2016-02-16 (Courtney Goetzenleuchter) Update usage, documentation Revision 3, 2016-06-14 (Courtney Goetzenleuchter) Update VK_EXT_DEBUG_REPORT_SPEC_VERSION to indicate added support for vkCreateInstance and vkDestroyInstance Revision 4, 2016-12-08 (Mark Lobodzinski) Added Display_KHR, DisplayModeKHR extension objects Added ObjectTable_NVX, IndirectCommandsLayout_NVX extension objects Bumped spec revision Retroactively added version history Revision 5, 2017-01-31 (Baldur Karlsson) Moved definition of VkDebugReportObjectTypeEXT from debug marker chapter Revision 6, 2017-01-31 (Baldur Karlsson) Added VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT Revision 7, 2017-04-20 (Courtney Goeltzenleuchter) Clarify wording and address questions from developers. Revision 8, 2017-04-21 (Courtney Goeltzenleuchter) Remove unused enum VkDebugReportErrorEXT Revision 9, 2017-09-12 (Tobias Hector) Added interactions with Vulkan 1.1 Revision 10, 2020-12-14 (Courtney Goetzenleuchter) Add issue 4 discussing matching handles returned by the extension, based on suggestion in public issue 368. Name String VK_EXT_depth_clamp_zero_one Extension Type Device extension Registered Extension Number 422 Revision 1 Ratification Status Ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 Deprecation State Promoted to VK_KHR_depth_clamp_zero_one extension Contact Graeme Leese gnl21 Last Modified Date 2021-07-29 Contributors Graeme Leese, Broadcom This extension gives defined behavior to fragment depth values which end up outside the conventional [0, 1] range. It can be used to ensure portability in edge cases of features like depthBias. The particular behavior is chosen to match OpenGL to aid porting or emulation. All functionality in this extension is included in VK_KHR_depth_clamp_zero_one, with the suffix change to KHR. The original type, enum, and command names are still available as aliases of the core functionality. Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceDepthClampZeroOneFeaturesEXT VK_EXT_DEPTH_CLAMP_ZERO_ONE_EXTENSION_NAME VK_EXT_DEPTH_CLAMP_ZERO_ONE_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_EXT Revision 1, 2021-07-29 (Graeme Leese) Internal revisions Name String VK_EXT_descriptor_indexing Extension Type Device extension Registered Extension Number 162 Revision 2 Ratification Status Ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 and VK_KHR_maintenance3 or Vulkan Version 1.1 SPIR-V Dependencies SPV_EXT_descriptor_indexing Deprecation State Promoted to Vulkan 1.2 Contact Jeff Bolz jeffbolznv Last Modified Date 2017-10-02 Interactions and External Dependencies This extension provides API support for GL_EXT_nonuniform_qualifier Contributors Jeff Bolz, NVIDIA Daniel Rakos, AMD Slawomir Grajewski, Intel Tobias Hector, Imagination Technologies This extension adds several small features which together enable applications to create large descriptor sets containing substantially all of their resources, and selecting amongst those resources with dynamic (non-uniform) indexes in the shader. There are feature enables and SPIR-V capabilities for non-uniform descriptor indexing in the shader, and non-uniform indexing in the shader requires use of a new NonUniformEXT decoration defined in the SPV_EXT_descriptor_indexing SPIR-V extension. There are descriptor set layout binding creation flags enabling several features: Descriptors can be updated after they are bound to a command buffer, such that the execution of the command buffer reflects the most recent update to the descriptors. Descriptors that are not used by any pending command buffers can be updated, which enables writing new descriptors for frame N+1 while frame N is executing. Relax the requirement that all descriptors in a binding that is statically used must be valid, such that descriptors that are not accessed by a submission need not be valid and can be updated while that submission is executing. The final binding in a descriptor set layout can have a variable size (and unsized arrays of resources are allowed in the GL_EXT_nonuniform_qualifier and SPV_EXT_descriptor_indexing extensions). Note that it is valid for multiple descriptor arrays in a shader to use the same set and binding number, as long as they are all compatible with the descriptor type in the pipeline layout. This means a single array binding in the descriptor set can serve multiple texture dimensionalities, or an array of buffer descriptors can be used with multiple different block layouts. There are new descriptor set layout and descriptor pool creation flags that are required to opt in to the update-after-bind functionality, and there are separate maxPerStage* and maxDescriptorSet* limits that apply to these descriptor set layouts which may be much higher than the pre-existing limits. The old limits only count descriptors in non-updateAfterBind descriptor set layouts, and the new limits count descriptors in all descriptor set layouts in the pipeline layout. Vulkan APIs in this extension are included in core Vulkan 1.2, with the EXT suffix omitted. However, if Vulkan 1.2 is supported and this extension is not, the descriptorIndexing capability is optional. External interactions defined by this extension, such as SPIR-V token names, retain their original names. The original Vulkan API names are still available as aliases of the core functionality. If Vulkan 1.4 is supported, support for the shaderUniformTexelBufferArrayDynamicIndexing and shaderStorageTexelBufferArrayDynamicIndexing capabilities is required. Extending VkDescriptorSetAllocateInfo: VkDescriptorSetVariableDescriptorCountAllocateInfoEXT Extending VkDescriptorSetLayoutCreateInfo: VkDescriptorSetLayoutBindingFlagsCreateInfoEXT Extending VkDescriptorSetLayoutSupport: VkDescriptorSetVariableDescriptorCountLayoutSupportEXT Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceDescriptorIndexingFeaturesEXT Extending VkPhysicalDeviceProperties2: VkPhysicalDeviceDescriptorIndexingPropertiesEXT VkDescriptorBindingFlagBitsEXT VkDescriptorBindingFlagsEXT VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME VK_EXT_DESCRIPTOR_INDEXING_SPEC_VERSION Extending VkDescriptorBindingFlagBits: VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT Extending VkDescriptorPoolCreateFlagBits: VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT Extending VkDescriptorSetLayoutCreateFlagBits: VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT Extending VkResult: VK_ERROR_FRAGMENTATION_EXT Extending VkStructureType: VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT Revision 1, 2017-07-26 (Jeff Bolz) Internal revisions Revision 2, 2017-10-02 (Jeff Bolz) ??? Name String VK_EXT_extended_dynamic_state Extension Type Device extension Registered Extension Number 268 Revision 1 Ratification Status Not ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 Deprecation State Promoted to Vulkan 1.3 Contact Piers Daniell pdaniell-nv Last Modified Date 2019-12-09 IP Status No known IP claims. Contributors Dan Ginsburg, Valve Corporation Graeme Leese, Broadcom Hans-Kristian Arntzen, Valve Corporation Jan-Harald Fredriksen, Arm Limited Faith Ekstrand, Intel Jeff Bolz, NVIDIA Jesse Hall, Google Philip Rebohle, Valve Corporation Stuart Smith, Imagination Technologies Tobias Hector, AMD This extension adds some more dynamic state to support applications that need to reduce the number of pipeline state objects they compile and bind. vkCmdBindVertexBuffers2EXT vkCmdSetCullModeEXT vkCmdSetDepthBoundsTestEnableEXT vkCmdSetDepthCompareOpEXT vkCmdSetDepthTestEnableEXT vkCmdSetDepthWriteEnableEXT vkCmdSetFrontFaceEXT vkCmdSetPrimitiveTopologyEXT vkCmdSetScissorWithCountEXT vkCmdSetStencilOpEXT vkCmdSetStencilTestEnableEXT vkCmdSetViewportWithCountEXT Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceExtendedDynamicStateFeaturesEXT VK_EXT_EXTENDED_DYNAMIC_STATE_EXTENSION_NAME VK_EXT_EXTENDED_DYNAMIC_STATE_SPEC_VERSION Extending VkDynamicState: VK_DYNAMIC_STATE_CULL_MODE_EXT VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE_EXT VK_DYNAMIC_STATE_DEPTH_COMPARE_OP_EXT VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE_EXT VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE_EXT VK_DYNAMIC_STATE_FRONT_FACE_EXT VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY_EXT VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT_EXT VK_DYNAMIC_STATE_STENCIL_OP_EXT VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE_EXT VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE_EXT VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT_EXT Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT All dynamic state enumerants and commands in this extension are included in core Vulkan 1.3, with the EXT suffix omitted. The feature structure is not promoted. Extension interfaces that were promoted remain available as aliases of the core functionality. 1) Why are the values of pStrides in vkCmdBindVertexBuffers2 limited to be between 0 and the maximum extent of the binding, when this restriction is not present for the same static state? Implementing these edge cases adds overhead to some implementations that would require significant cost when calling this function, and the intention is that this state should be more or less free to change. VK_EXT_vertex_input_dynamic_state allows the stride to be changed freely when supported via vkCmdSetVertexInputEXT. Revision 1, 2019-12-09 (Piers Daniell) Internal revisions Name String VK_EXT_extended_dynamic_state2 Extension Type Device extension Registered Extension Number 378 Revision 1 Ratification Status Not ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 Deprecation State Promoted to Vulkan 1.3 Contact Vikram Kushwaha vkushwaha-nv Last Modified Date 2021-04-12 IP Status No known IP claims. Contributors Vikram Kushwaha, NVIDIA Piers Daniell, NVIDIA Jeff Bolz, NVIDIA This extension adds some more dynamic state to support applications that need to reduce the number of pipeline state objects they compile and bind. vkCmdSetDepthBiasEnableEXT vkCmdSetLogicOpEXT vkCmdSetPatchControlPointsEXT vkCmdSetPrimitiveRestartEnableEXT vkCmdSetRasterizerDiscardEnableEXT Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceExtendedDynamicState2FeaturesEXT VK_EXT_EXTENDED_DYNAMIC_STATE_2_EXTENSION_NAME VK_EXT_EXTENDED_DYNAMIC_STATE_2_SPEC_VERSION Extending VkDynamicState: VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE_EXT VK_DYNAMIC_STATE_LOGIC_OP_EXT VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE_EXT VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE_EXT Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT The dynamic state enumerants VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE_EXT, VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE_EXT, and VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE_EXT; and the corresponding commands in this extension are included in core Vulkan 1.3, with the EXT suffix omitted. The enumerants and commands for dynamic logic operation and patch control points are not promoted, nor is the feature structure. Extension interfaces that were promoted remain available as aliases of the core functionality. Revision 1, 2021-04-12 (Vikram Kushwaha) Internal revisions Name String VK_EXT_global_priority Extension Type Device extension Registered Extension Number 175 Revision 2 Ratification Status Not ratified Extension and Version Dependencies None Deprecation State Promoted to VK_KHR_global_priority extension Which in turn was promoted to Vulkan 1.4 Contact Andres Rodriguez lostgoat Last Modified Date 2017-10-06 IP Status No known IP claims. Contributors Andres Rodriguez, Valve Pierre-Loup Griffais, Valve Dan Ginsburg, Valve Mitch Singer, AMD In Vulkan, users can specify device-scope queue priorities. In some cases it may be useful to extend this concept to a system-wide scope. This extension provides a mechanism for callers to set their system-wide priority. The default queue priority is VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT. The driver implementation will attempt to skew hardware resource allocation in favor of the higher-priority task. Therefore, higher-priority work may retain similar latency and throughput characteristics even if the system is congested with lower priority work. The global priority level of a queue shall take precedence over the per-process queue priority (VkDeviceQueueCreateInfo::pQueuePriorities). Abuse of this feature may result in starving the rest of the system from hardware resources. Therefore, the driver implementation may deny requests to acquire a priority above the default priority (VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT) if the caller does not have sufficient privileges. In this scenario VK_ERROR_NOT_PERMITTED_EXT is returned. The driver implementation may fail the queue allocation request if resources required to complete the operation have been exhausted (either by the same process or a different process). In this scenario VK_ERROR_INITIALIZATION_FAILED is returned. Extending VkDeviceQueueCreateInfo: VkDeviceQueueGlobalPriorityCreateInfoEXT VkQueueGlobalPriorityEXT VK_EXT_GLOBAL_PRIORITY_EXTENSION_NAME VK_EXT_GLOBAL_PRIORITY_SPEC_VERSION Extending VkQueueGlobalPriority: VK_QUEUE_GLOBAL_PRIORITY_HIGH_EXT VK_QUEUE_GLOBAL_PRIORITY_LOW_EXT VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT VK_QUEUE_GLOBAL_PRIORITY_REALTIME_EXT Extending VkResult: VK_ERROR_NOT_PERMITTED_EXT Extending VkStructureType: VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT Revision 2, 2017-11-03 (Andres Rodriguez) Fixed VkQueueGlobalPriorityEXT missing _EXT suffix Revision 1, 2017-10-06 (Andres Rodriguez) First version. Name String VK_EXT_global_priority_query Extension Type Device extension Registered Extension Number 389 Revision 1 Ratification Status Not ratified Extension and Version Dependencies VK_EXT_global_priority and VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 Deprecation State Promoted to VK_KHR_global_priority extension Which in turn was promoted to Vulkan 1.4 Contact Yiwei Zhang zhangyiwei Last Modified Date 2021-03-29 IP Status No known IP claims. Contributors Yiwei Zhang, Google This device extension allows applications to query the global queue priorities supported by a queue family. It allows implementations to report which global priority levels are treated differently by the implementation, instead of silently mapping multiple requested global priority levels to the same internal priority, or using device creation failure to signal that a requested priority is not supported. It is intended primarily for use by system integration along with certain platform-specific priority enforcement rules. Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT Extending VkQueueFamilyProperties2: VkQueueFamilyGlobalPriorityPropertiesEXT VK_EXT_GLOBAL_PRIORITY_QUERY_EXTENSION_NAME VK_EXT_GLOBAL_PRIORITY_QUERY_SPEC_VERSION VK_MAX_GLOBAL_PRIORITY_SIZE_EXT Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_EXT VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_EXT 1) Can we additionally query whether a caller is permitted to acquire a specific global queue priority in this extension? RESOLVED: No. Whether a caller has enough privilege goes with the OS, and the Vulkan driver cannot really guarantee that the privilege will not change in between this query and the actual queue creation call. 2) If more than 1 queue using global priority is requested, is there a good way to know which queue is failing the device creation? RESOLVED: No. There is not a good way at this moment, and it is also not quite actionable for the applications to know that because the information may not be accurate. Queue creation can fail because of runtime constraints like insufficient privilege or lack of resource, and the failure is not necessarily tied to that particular queue configuration requested. Revision 1, 2021-03-29 (Yiwei Zhang) Name String VK_EXT_host_image_copy Extension Type Device extension Registered Extension Number 271 Revision 1 Ratification Status Ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 and VK_KHR_copy_commands2 and VK_KHR_format_feature_flags2 or Vulkan Version 1.3 Deprecation State Promoted to Vulkan 1.4 Contact Shahbaz Youssefi syoussefi Extension Proposal VK_EXT_host_image_copy Last Modified Date 2023-04-26 Contributors Shahbaz Youssefi, Google Faith Ekstrand, Collabora Hans-Kristian Arntzen, Valve Piers Daniell, NVIDIA Jan-Harald Fredriksen, Arm James Fitzpatrick, Imagination Daniel Story, Nintendo This extension allows applications to copy data between host memory and images on the host processor, without staging the data through a GPU-accessible buffer. This removes the need to allocate and manage the buffer and its associated memory. On some architectures it may also eliminate an extra copy operation. This extension additionally allows applications to copy data between images on the host. To support initializing a new image in preparation for a host copy, it is now possible to transition a new image to VK_IMAGE_LAYOUT_GENERAL or other host-copyable layouts via vkTransitionImageLayoutEXT. Additionally, it is possible to perform copies that preserve the swizzling layout of the image by using the VK_HOST_IMAGE_COPY_MEMCPY_EXT flag. In that case, the memory size needed for copies to or from a buffer can be retrieved by chaining VkSubresourceHostMemcpySizeEXT to pLayout in vkGetImageSubresourceLayout2EXT. vkCopyImageToImageEXT vkCopyImageToMemoryEXT vkCopyMemoryToImageEXT vkGetImageSubresourceLayout2EXT vkTransitionImageLayoutEXT VkCopyImageToImageInfoEXT VkCopyImageToMemoryInfoEXT VkCopyMemoryToImageInfoEXT VkHostImageLayoutTransitionInfoEXT VkImageSubresource2EXT VkImageToMemoryCopyEXT VkMemoryToImageCopyEXT VkSubresourceLayout2EXT Extending VkImageFormatProperties2: VkHostImageCopyDevicePerformanceQueryEXT Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceHostImageCopyFeaturesEXT Extending VkPhysicalDeviceProperties2: VkPhysicalDeviceHostImageCopyPropertiesEXT Extending VkSubresourceLayout2: VkSubresourceHostMemcpySizeEXT VkHostImageCopyFlagBitsEXT VkHostImageCopyFlagsEXT VK_EXT_HOST_IMAGE_COPY_EXTENSION_NAME VK_EXT_HOST_IMAGE_COPY_SPEC_VERSION Extending VkFormatFeatureFlagBits2: VK_FORMAT_FEATURE_2_HOST_IMAGE_TRANSFER_BIT_EXT Extending VkHostImageCopyFlagBits: VK_HOST_IMAGE_COPY_MEMCPY_EXT Extending VkImageUsageFlagBits: VK_IMAGE_USAGE_HOST_TRANSFER_BIT_EXT Extending VkStructureType: VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO_EXT VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO_EXT VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO_EXT VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY_EXT VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO_EXT VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY_EXT VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY_EXT VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES_EXT VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES_EXT VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE_EXT Functionality in this extension is included in core Vulkan 1.4, with the EXT suffix omitted. However, the feature is made optional in Vulkan 1.4. The original type, enum and command names are still available as aliases of the core functionality. A Vulkan 1.4 implementation that has a VK_QUEUE_GRAPHICS_BIT queue must support either: the hostImageCopy feature; or an additional queue that supports VK_QUEUE_TRANSFER_BIT. Additionally, all queues supporting VK_QUEUE_GRAPHICS_BIT or VK_QUEUE_COMPUTE_BIT must also advertise VK_QUEUE_TRANSFER_BIT. 1) When uploading data to an image, the data is usually loaded from disk. Why not have the application load the data directly into a VkDeviceMemory bound to a buffer (instead of host memory), and use vkCmdCopyBufferToImage? The same could be done when downloading data from an image. RESOLVED: This may not always be possible. Complicated Vulkan applications such as game engines often have decoupled subsystems for streaming data and rendering. It may be unreasonable to require the streaming subsystem to coordinate with the rendering subsystem to allocate memory on its behalf, especially as Vulkan may not be the only API supported by the engine. In emulation layers, the image data is necessarily provided by the application in host memory, so an optimization as suggested is not possible. Most importantly, the device memory may not be mappable by an application, but still accessible to the driver. 2) Are optimalBufferCopyOffsetAlignment and optimalBufferCopyRowPitchAlignment applicable to host memory as well with the functions introduced by this extension? Or should there be new limits? RESOLVED: No alignment requirements for the host memory pointer. 3) Should there be granularity requirements for image offsets and extents? RESOLVED: No granularity requirements, i.e. a granularity of 1 pixel (for non-compressed formats) and 1 texel block (for compressed formats) is assumed. 4) How should the application deal with layout transitions before or after copying to or from images? RESOLVED: An existing issue with linear images is that when emulating other APIs, it is impossible to know when to transition them as they are written to by the host and then used bindlessly. The copy operations in this extension are affected by the same limitation. A new command is thus introduced by this extension to address this problem by allowing the host to perform an image layout transition between a handful of layouts. Revision 0, 2021-01-20 (Faith Ekstrand) Initial idea and xml Revision 1, 2023-04-26 (Shahbaz Youssefi) Initial revision Name String VK_EXT_host_query_reset Extension Type Device extension Registered Extension Number 262 Revision 1 Ratification Status Not ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 Deprecation State Promoted to Vulkan 1.2 Contact Bas Nieuwenhuizen BNieuwenhuizen Last Modified Date 2019-03-06 IP Status No known IP claims. Contributors Bas Nieuwenhuizen, Google Faith Ekstrand, Intel Jeff Bolz, NVIDIA Piers Daniell, NVIDIA This extension adds a new function to reset queries from the host. All functionality in this extension is included in core Vulkan 1.2, with the EXT suffix omitted. The original type, enum, and command names are still available as aliases of the core functionality. vkResetQueryPoolEXT Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceHostQueryResetFeaturesEXT VK_EXT_HOST_QUERY_RESET_EXTENSION_NAME VK_EXT_HOST_QUERY_RESET_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT Revision 1, 2019-03-12 (Bas Nieuwenhuizen) Initial draft Name String VK_EXT_image_robustness Extension Type Device extension Registered Extension Number 336 Revision 1 Ratification Status Not ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 Deprecation State Promoted to Vulkan 1.3 Contact Graeme Leese gnl21 Last Modified Date 2020-04-27 IP Status No known IP claims. Contributors Graeme Leese, Broadcom Jan-Harald Fredriksen, ARM Jeff Bolz, NVIDIA Spencer Fricke, Samsung Courtney Goeltzenleuchter, Google Slawomir Cygan, Intel This extension adds stricter requirements for how out of bounds reads from images are handled. Rather than returning undefined values, most out of bounds reads return R, G, and B values of zero and alpha values of either zero or one. Components not present in the image format may be set to zero or to values based on the format as described in Conversion to RGBA. Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceImageRobustnessFeaturesEXT VK_EXT_IMAGE_ROBUSTNESS_EXTENSION_NAME VK_EXT_IMAGE_ROBUSTNESS_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES_EXT Vulkan APIs in this extension are included in core Vulkan 1.3, with the EXT suffix omitted. External interactions defined by this extension, such as SPIR-V token names, retain their original names. The original Vulkan API names are still available as aliases of the core functionality. How does this extension differ from VK_EXT_robustness2? The guarantees provided by this extension are a subset of those provided by the robustImageAccess2 feature of VK_EXT_robustness2. Where this extension allows return values of (0, 0, 0, 0) or (0, 0, 0, 1), robustImageAccess2 requires that a particular value dependent on the image format be returned. This extension provides no guarantees about the values returned for an access to an invalid Lod. None. Revision 1, 2020-04-27 (Graeme Leese) Initial draft Name String VK_EXT_index_type_uint8 Extension Type Device extension Registered Extension Number 266 Revision 1 Ratification Status Not ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 Deprecation State Promoted to VK_KHR_index_type_uint8 extension Which in turn was promoted to Vulkan 1.4 Contact Piers Daniell pdaniell-nv Last Modified Date 2019-05-02 IP Status No known IP claims. Contributors Jeff Bolz, NVIDIA This extension allows uint8_t indices to be used with vkCmdBindIndexBuffer. All functionality in this extension is included in VK_KHR_index_type_uint8, with the suffix changed to KHR. The original enum names are still available as aliases of the KHR functionality. Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceIndexTypeUint8FeaturesEXT VK_EXT_INDEX_TYPE_UINT8_EXTENSION_NAME VK_EXT_INDEX_TYPE_UINT8_SPEC_VERSION Extending VkIndexType: VK_INDEX_TYPE_UINT8_EXT Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT Revision 1, 2019-05-02 (Piers Daniell) Internal revisions Name String VK_EXT_inline_uniform_block Extension Type Device extension Registered Extension Number 139 Revision 1 Ratification Status Not ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 and VK_KHR_maintenance1 or Vulkan Version 1.1 API Interactions Interacts with VK_VERSION_1_2 Interacts with VK_EXT_descriptor_indexing Interacts with VkPhysicalDeviceVulkan12Features::descriptorIndexing Deprecation State Promoted to Vulkan 1.3 Contact Daniel Rakos aqnuep Last Modified Date 2018-08-01 IP Status No known IP claims. Contributors Daniel Rakos, AMD Jeff Bolz, NVIDIA Slawomir Grajewski, Intel Neil Henning, Codeplay This extension introduces the ability to back uniform blocks directly with descriptor sets by storing inline uniform data within descriptor pool storage. Compared to push constants this new construct allows uniform data to be reused across multiple disjoint sets of drawing or dispatching commands and may enable uniform data to be accessed with fewer indirections compared to uniforms backed by buffer memory. Extending VkDescriptorPoolCreateInfo: VkDescriptorPoolInlineUniformBlockCreateInfoEXT Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceInlineUniformBlockFeaturesEXT Extending VkPhysicalDeviceProperties2: VkPhysicalDeviceInlineUniformBlockPropertiesEXT Extending VkWriteDescriptorSet: VkWriteDescriptorSetInlineUniformBlockEXT VK_EXT_INLINE_UNIFORM_BLOCK_EXTENSION_NAME VK_EXT_INLINE_UNIFORM_BLOCK_SPEC_VERSION Extending VkDescriptorType: VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT Extending VkStructureType: VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT Vulkan APIs in this extension are included in core Vulkan 1.3, with the EXT suffix omitted. External interactions defined by this extension, such as SPIR-V token names, retain their original names. The original Vulkan API names are still available as aliases of the core functionality. Vulkan 1.3 adds additional functionality related to this extension in the form of the maxInlineUniformTotalSize limit. 1) Do we need a new storage class for inline uniform blocks vs. uniform blocks? RESOLVED: No. The Uniform storage class is used to allow the same syntax used for both uniform buffers and inline uniform blocks. 2) Is the descriptor array index and array size expressed in terms of bytes or dwords for inline uniform block descriptors? RESOLVED: In bytes, but both must be a multiple of 4, similar to how push constant ranges are specified. The descriptorCount of VkDescriptorSetLayoutBinding thus provides the total number of bytes a particular binding with an inline uniform block descriptor type can hold, while the srcArrayElement, dstArrayElement, and descriptorCount members of VkWriteDescriptorSet, VkCopyDescriptorSet, and VkDescriptorUpdateTemplateEntry (where applicable) specify the byte offset and number of bytes to write/copy to the bindings backing store. Additionally, the stride member of VkDescriptorUpdateTemplateEntry is ignored for inline uniform blocks and a default value of one is used, meaning that the data to update inline uniform block bindings with must be contiguous in memory. 3) What layout rules apply for uniform blocks corresponding to inline constants? RESOLVED: They use the same layout rules as uniform buffers. 4) Do we need to add non-uniform indexing features/properties as introduced by VK_EXT_descriptor_indexing for inline uniform blocks? RESOLVED: No, because inline uniform blocks are not allowed to be arrayed. A single binding with an inline uniform block descriptor type corresponds to a single uniform block instance and the array indices inside that binding refer to individual offsets within the uniform block (see issue #2). However, this extension does introduce new features/properties about the level of support for update-after-bind inline uniform blocks. 5) Is the descriptorBindingVariableDescriptorCount feature introduced by VK_EXT_descriptor_indexing supported for inline uniform blocks? RESOLVED: Yes, as long as other inline uniform block specific limits are respected. 6) Do the robustness guarantees of robustBufferAccess apply to inline uniform block accesses? RESOLVED: No, similarly to push constants, as they are not backed by buffer memory like uniform buffers. Revision 1, 2018-08-01 (Daniel Rakos) Internal revisions Name String VK_EXT_line_rasterization Extension Type Device extension Registered Extension Number 260 Revision 1 Ratification Status Not ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 Deprecation State Promoted to VK_KHR_line_rasterization extension Which in turn was promoted to Vulkan 1.4 Special Use CAD support Contact Jeff Bolz jeffbolznv Last Modified Date 2019-05-09 IP Status No known IP claims. Contributors Jeff Bolz, NVIDIA Allen Jensen, NVIDIA Faith Ekstrand, Intel This extension adds some line rasterization features that are commonly used in CAD applications and supported in other APIs like OpenGL. Bresenham-style line rasterization is supported, smooth rectangular lines (coverage to alpha) are supported, and stippled lines are supported for all three line rasterization modes. All functionality in this extension is included in VK_KHR_line_rasterization, with the suffix changed to KHR. The original enum names are still available as aliases of the KHR functionality. vkCmdSetLineStippleEXT Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceLineRasterizationFeaturesEXT Extending VkPhysicalDeviceProperties2: VkPhysicalDeviceLineRasterizationPropertiesEXT Extending VkPipelineRasterizationStateCreateInfo: VkPipelineRasterizationLineStateCreateInfoEXT VkLineRasterizationModeEXT VK_EXT_LINE_RASTERIZATION_EXTENSION_NAME VK_EXT_LINE_RASTERIZATION_SPEC_VERSION Extending VkDynamicState: VK_DYNAMIC_STATE_LINE_STIPPLE_EXT Extending VkLineRasterizationMode: VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT 1) Do we need to support Bresenham-style and smooth lines with more than one rasterization sample? i.e. the equivalent of glDisable(GL_MULTISAMPLE) in OpenGL when the framebuffer has more than one sample? RESOLVED: Yes. For simplicity, Bresenham line rasterization carries forward a few restrictions from OpenGL, such as not supporting per-sample shading, alpha to coverage, or alpha to one. Revision 1, 2019-05-09 (Jeff Bolz) Initial draft Name String VK_EXT_load_store_op_none Extension Type Device extension Registered Extension Number 401 Revision 1 Ratification Status Ratified Extension and Version Dependencies None Deprecation State Promoted to VK_KHR_load_store_op_none extension Which in turn was promoted to Vulkan 1.4 Contact Shahbaz Youssefi syoussefi Last Modified Date 2021-06-06 Contributors Shahbaz Youssefi, Google Bill Licea-Kane, Qualcomm Technologies, Inc. Tobias Hector, AMD This extension incorporates VK_ATTACHMENT_STORE_OP_NONE_EXT from VK_QCOM_render_pass_store_ops, enabling applications to avoid unnecessary synchronization when an attachment is not written during a render pass. Additionally, VK_ATTACHMENT_LOAD_OP_NONE_EXT is introduced to avoid unnecessary synchronization when an attachment is not used during a render pass at all. In combination with VK_ATTACHMENT_STORE_OP_NONE_EXT, this is useful as an alternative to preserve attachments in applications that cannot decide if an attachment will be used in a render pass until after the necessary pipelines have been created. All functionality in this extension is included in VK_KHR_load_store_op_none, with the suffix changed to KHR. The original enum names are still available as aliases of the KHR functionality. VK_EXT_LOAD_STORE_OP_NONE_EXTENSION_NAME VK_EXT_LOAD_STORE_OP_NONE_SPEC_VERSION Extending VkAttachmentLoadOp: VK_ATTACHMENT_LOAD_OP_NONE_EXT Extending VkAttachmentStoreOp: VK_ATTACHMENT_STORE_OP_NONE_EXT While VK_ATTACHMENT_STORE_OP_NONE is part of Vulkan 1.3, this extension was not promoted to core either in whole or in part. This functionality was promoted from VK_KHR_dynamic_rendering. Revision 1, 2021-06-06 (Shahbaz Youssefi) Initial revision, based on VK_QCOM_render_pass_store_ops. Added VK_ATTACHMENT_LOAD_OP_NONE_EXT. Name String VK_EXT_pipeline_creation_cache_control Extension Type Device extension Registered Extension Number 298 Revision 3 Ratification Status Not ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 Deprecation State Promoted to Vulkan 1.3 Contact Gregory Grebe grgrebe_amd Last Modified Date 2020-03-23 IP Status No known IP claims. Contributors Gregory Grebe, AMD Tobias Hector, AMD Matthaeus Chajdas, AMD Mitch Singer, AMD Spencer Fricke, Samsung Electronics Stuart Smith, Imagination Technologies Jeff Bolz, NVIDIA Corporation Daniel Koch, NVIDIA Corporation Dan Ginsburg, Valve Corporation Jeff Leger, QUALCOMM Michal Pietrasiuk, Intel Jan-Harald Fredriksen, Arm Limited This extension adds flags to Vk*PipelineCreateInfo and VkPipelineCacheCreateInfo structures with the aim of improving the predictability of pipeline creation cost. The goal is to provide information about potentially expensive hazards within the client driver during pipeline creation to the application before carrying them out rather than after. Pipeline creation is a costly operation, and the explicit nature of the Vulkan design means that cost is not hidden from the developer. Applications are also expected to schedule, prioritize, and load balance all calls for pipeline creation. It is strongly advised that applications create pipelines sufficiently ahead of their usage. Failure to do so will result in an unresponsive application, intermittent stuttering, or other poor user experiences. Proper usage of pipeline caches and/or derivative pipelines help mitigate this but is not assured to eliminate disruption in all cases. In the event that an ahead-of-time creation is not possible, considerations should be taken to ensure that the current execution context is suitable for the workload of pipeline creation including possible shader compilation. Applications making API calls to create a pipeline must be prepared for any of the following to occur: OS/kernel calls to be made by the ICD Internal memory allocation not tracked by the pAllocator passed to vkCreate*Pipelines Internal thread synchronization or yielding of the current threads core Extremely long (multi-millisecond+), blocking, compilation times Arbitrary call stacks depths and stack memory usage The job or task based game engines that are being developed to take advantage of explicit graphics APIs like Vulkan may behave exceptionally poorly if any of the above scenarios occur. However, most game engines are already built to stream in assets dynamically as the user plays the game. By adding control by way of VkPipelineCreateFlags, we can require an ICD to report back a failure in critical execution paths rather than forcing an unexpected wait. Applications can prevent unexpected compilation by setting VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_EXT on Vk*PipelineCreateInfo::flags. When set, an ICD must not attempt pipeline or shader compilation to create the pipeline object. In such a case, if the implementation fails to create a pipeline without compilation, the implementation must return the result VK_PIPELINE_COMPILE_REQUIRED_EXT and return VK_NULL_HANDLE for the pipeline. By default vkCreate*Pipelines calls must attempt to create all pipelines before returning. Setting VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT_EXT on Vk*PipelineCreateInfo::flags can be used as an escape hatch for batched pipeline creates. Hidden locks also add to the unpredictability of the cost of pipeline creation. The most common case of locks inside the vkCreate*Pipelines is internal synchronization of the VkPipelineCache object. VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT_EXT can be set when calling vkCreatePipelineCache to state the cache is externally synchronized. The hope is that armed with this information application and engine developers can leverage existing asset streaming systems to recover from "just-in-time" pipeline creation stalls. Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT VkPipelineCacheCreateFlagBits VK_EXT_PIPELINE_CREATION_CACHE_CONTROL_EXTENSION_NAME VK_EXT_PIPELINE_CREATION_CACHE_CONTROL_SPEC_VERSION Extending VkPipelineCacheCreateFlagBits: VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT_EXT Extending VkPipelineCreateFlagBits: VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT_EXT VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_EXT Extending VkResult: VK_ERROR_PIPELINE_COMPILE_REQUIRED_EXT VK_PIPELINE_COMPILE_REQUIRED_EXT Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES_EXT Vulkan APIs in this extension are included in core Vulkan 1.3, with the EXT suffix omitted. External interactions defined by this extension, such as SPIR-V token names, retain their original names. The original Vulkan API names are still available as aliases of the core functionality. Revision 1, 2019-11-01 (Gregory Grebe) Initial revision Revision 2, 2020-02-24 (Gregory Grebe) Initial public revision Revision 3, 2020-03-23 (Tobias Hector) Changed VK_PIPELINE_COMPILE_REQUIRED_EXT to a success code, adding an alias for the original VK_ERROR_PIPELINE_COMPILE_REQUIRED_EXT. Also updated the xml to include these codes as return values. Name String VK_EXT_pipeline_creation_feedback Extension Type Device extension Registered Extension Number 193 Revision 1 Ratification Status Not ratified Extension and Version Dependencies None Deprecation State Promoted to Vulkan 1.3 Special Use Developer tools Contact Jean-Francois Roy jfroy Last Modified Date 2019-03-12 IP Status No known IP claims. Contributors Jean-Francois Roy, Google Hai Nguyen, Google Andrew Ellem, Google Bob Fraser, Google Sujeevan Rajayogam, Google Jan-Harald Fredriksen, ARM Jeff Leger, Qualcomm Technologies, Inc. Jeff Bolz, NVIDIA Daniel Koch, NVIDIA Neil Henning, AMD This extension adds a mechanism to provide feedback to an application about pipeline creation, with the specific goal of allowing a feedback loop between build systems and in-the-field application executions to ensure effective pipeline caches are shipped to customers. VkPipelineCreationFeedbackEXT Extending VkGraphicsPipelineCreateInfo, VkComputePipelineCreateInfo, VkRayTracingPipelineCreateInfoNV, VkRayTracingPipelineCreateInfoKHR, VkExecutionGraphPipelineCreateInfoAMDX: VkPipelineCreationFeedbackCreateInfoEXT VkPipelineCreationFeedbackFlagBitsEXT VkPipelineCreationFeedbackFlagsEXT VK_EXT_PIPELINE_CREATION_FEEDBACK_EXTENSION_NAME VK_EXT_PIPELINE_CREATION_FEEDBACK_SPEC_VERSION Extending VkPipelineCreationFeedbackFlagBits: VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT_EXT VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT Extending VkStructureType: VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT Vulkan APIs in this extension are included in core Vulkan 1.3, with the EXT suffix omitted. External interactions defined by this extension, such as SPIR-V token names, retain their original names. The original Vulkan API names are still available as aliases of the core functionality. Revision 1, 2019-03-12 (Jean-Francois Roy) Initial revision Name String VK_EXT_pipeline_protected_access Extension Type Device extension Registered Extension Number 467 Revision 1 Ratification Status Not ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 Deprecation State Promoted to Vulkan 1.4 Contact Shahbaz Youssefi syoussefi Extension Proposal VK_EXT_pipeline_protected_access Last Modified Date 2022-07-28 Contributors Shahbaz Youssefi, Google Jrg Wagner, Arm Ralph Potter, Samsung Daniel Koch, NVIDIA This extension allows protected memory access to be specified per pipeline as opposed to per device. Through the usage of this extension, any performance penalty paid due to access to protected memory will be limited to the specific pipelines that make such accesses. Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDevicePipelineProtectedAccessFeaturesEXT VK_EXT_PIPELINE_PROTECTED_ACCESS_EXTENSION_NAME VK_EXT_PIPELINE_PROTECTED_ACCESS_SPEC_VERSION Extending VkPipelineCreateFlagBits: VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT_EXT VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT_EXT Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES_EXT Functionality in this extension is included in core Vulkan 1.4 with the EXT suffix omitted. The original type, enum and command names are still available as aliases of the core functionality. Revision 1, 2022-07-28 (Shahbaz Youssefi) Internal revisions Name String VK_EXT_pipeline_robustness Extension Type Device extension Registered Extension Number 69 Revision 1 Ratification Status Ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 Deprecation State Promoted to Vulkan 1.4 Contact Jarred Davies Last Modified Date 2022-07-12 Interactions and External Dependencies Interacts with VK_EXT_robustness2 Interacts with VK_EXT_image_robustness Interacts with VK_KHR_ray_tracing_pipeline Contributors Jarred Davies, Imagination Technologies Alex Walters, Imagination Technologies Piers Daniell, NVIDIA Graeme Leese, Broadcom Corporation Jeff Leger, Qualcomm Technologies, Inc. Faith Ekstrand, Intel Lionel Landwerlin, Intel Shahbaz Youssefi, Google, Inc. This extension allows users to request robustness on a per-pipeline stage basis. As robustBufferAccess and other robustness features may have an adverse effect on performance, this extension is designed to allow users to request robust behavior only where it may be needed. Extending VkGraphicsPipelineCreateInfo, VkComputePipelineCreateInfo, VkPipelineShaderStageCreateInfo, VkRayTracingPipelineCreateInfoKHR: VkPipelineRobustnessCreateInfoEXT Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDevicePipelineRobustnessFeaturesEXT Extending VkPhysicalDeviceProperties2: VkPhysicalDevicePipelineRobustnessPropertiesEXT VkPipelineRobustnessBufferBehaviorEXT VkPipelineRobustnessImageBehaviorEXT VK_EXT_PIPELINE_ROBUSTNESS_EXTENSION_NAME VK_EXT_PIPELINE_ROBUSTNESS_SPEC_VERSION Extending VkPipelineRobustnessBufferBehavior: VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT_EXT VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED_EXT VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2_EXT VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_EXT Extending VkPipelineRobustnessImageBehavior: VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT_EXT VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DISABLED_EXT VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2_EXT VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_EXT Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES_EXT VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES_EXT VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT Functionality in this extension is included in core Vulkan 1.4 with the EXT suffix omitted. The original type, enum and command names are still available as aliases of the core functionality. Revision 1, 2022-07-12 (Jarred Davies) Initial version Name String VK_EXT_private_data Extension Type Device extension Registered Extension Number 296 Revision 1 Ratification Status Not ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 Deprecation State Promoted to Vulkan 1.3 Contact Matthew Rusch mattruschnv Last Modified Date 2020-03-25 IP Status No known IP claims. Contributors Matthew Rusch, NVIDIA Nuno Subtil, NVIDIA Piers Daniell, NVIDIA Jeff Bolz, NVIDIA This extension is a device extension which enables attaching arbitrary payloads to Vulkan objects. It introduces the idea of private data slots as a means of storing a 64-bit unsigned integer of application-defined data. Private data slots can be created or destroyed any time an associated device is available. Private data slots can be reserved at device creation time, and limiting use to the amount reserved will allow the extension to exhibit better performance characteristics. VkPrivateDataSlotEXT vkCreatePrivateDataSlotEXT vkDestroyPrivateDataSlotEXT vkGetPrivateDataEXT vkSetPrivateDataEXT VkPrivateDataSlotCreateInfoEXT Extending VkDeviceCreateInfo: VkDevicePrivateDataCreateInfoEXT Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDevicePrivateDataFeaturesEXT VkPrivateDataSlotCreateFlagsEXT VK_EXT_PRIVATE_DATA_EXTENSION_NAME VK_EXT_PRIVATE_DATA_SPEC_VERSION Extending VkObjectType: VK_OBJECT_TYPE_PRIVATE_DATA_SLOT_EXT Extending VkStructureType: VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO_EXT VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES_EXT VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO_EXT Vulkan APIs in this extension are included in core Vulkan 1.3, with the EXT suffix omitted. External interactions defined by this extension, such as SPIR-V token names, retain their original names. The original Vulkan API names are still available as aliases of the core functionality. In progress (1) If I have to create a VkPrivateDataSlot to store and retrieve data on an object, how does this extension help me? Will I not need to store the VkPrivateDataSlot mapping with each object, and if I am doing that, I might as well just store the original data! RESOLVED: The VkPrivateDataSlot can be thought of as an opaque index into storage that is reserved in each object. That is, you can use the same VkPrivateDataSlot with each object for a specific piece of information. For example, if a layer wishes to track per-object information, the layer only needs to allocate one VkPrivateDataSlot per device and it can use that private data slot for all of the devices child objects. This allows multiple layers to store private data without conflicting with each others and/or the applications private data. (2) What if I need to store more than 64-bits of information per object? RESOLVED: The data that you store per object could be a pointer to another object or structure of your own allocation. Revision 1, 2020-01-15 (Matthew Rusch) Initial draft Name String VK_EXT_robustness2 Extension Type Device extension Registered Extension Number 287 Revision 1 Ratification Status Ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 Deprecation State Promoted to VK_KHR_robustness2 extension Contact Liam Middlebrook liam-middlebrook Last Modified Date 2020-01-29 IP Status No known IP claims. Contributors Liam Middlebrook, NVIDIA Jeff Bolz, NVIDIA This extension adds stricter requirements for how out of bounds reads and writes are handled. Most accesses must be tightly bounds-checked, out of bounds writes must be discarded, out of bound reads must return zero. Rather than allowing multiple possible (0,0,0,x) vectors, the out of bounds values are treated as zero, and then missing components are inserted based on the format as described in Conversion to RGBA and vertex input attribute extraction. These additional requirements may be expensive on some implementations, and should only be enabled when truly necessary. This extension also adds support for null descriptors, where VK_NULL_HANDLE can be used instead of a valid handle. Accesses to null descriptors have well-defined behavior, and do not rely on robustness. All functionality in this extension is included in VK_KHR_robustness2, with the suffix changed to KHR. The original type, enum, and command names are still available as aliases of the core functionality. Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceRobustness2FeaturesEXT Extending VkPhysicalDeviceProperties2: VkPhysicalDeviceRobustness2PropertiesEXT VK_EXT_ROBUSTNESS_2_EXTENSION_NAME VK_EXT_ROBUSTNESS_2_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT Why do VkPhysicalDeviceRobustness2PropertiesEXT::robustUniformBufferAccessSizeAlignment and VkPhysicalDeviceRobustness2PropertiesEXT::robustStorageBufferAccessSizeAlignment exist? RESOLVED: Some implementations cannot efficiently tightly bounds-check all buffer accesses. Rather, the size of the bound range is padded to some power of two multiple, up to 256 bytes for uniform buffers and up to 4 bytes for storage buffers, and that padded size is bounds-checked. This is sufficient to implement D3D-like behavior, because D3D only allows binding whole uniform buffers or ranges that are a multiple of 256 bytes, and D3D raw and structured buffers only support 32-bit accesses. None. Revision 1, 2019-11-01 (Jeff Bolz, Liam Middlebrook) Initial draft Name String VK_EXT_sampler_filter_minmax Extension Type Device extension Registered Extension Number 131 Revision 2 Ratification Status Not ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 Deprecation State Promoted to Vulkan 1.2 Contact Jeff Bolz jeffbolznv Last Modified Date 2017-05-19 IP Status No known IP claims. Contributors Jeff Bolz, NVIDIA Piers Daniell, NVIDIA In unextended Vulkan, minification and magnification filters such as LINEAR allow sampled image lookups to return a filtered texel value produced by computing a weighted average of a collection of texels in the neighborhood of the texture coordinate provided. This extension provides a new sampler parameter which allows applications to produce a filtered texel value by computing a component-wise minimum (MIN) or maximum (MAX) of the texels that would normally be averaged. The reduction mode is orthogonal to the minification and magnification filter parameters. The filter parameters are used to identify the set of texels used to produce a final filtered value; the reduction mode identifies how these texels are combined. All functionality in this extension is included in core Vulkan 1.2, with the EXT suffix omitted. The original type, enum, and command names are still available as aliases of the core functionality. Extending VkPhysicalDeviceProperties2: VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT Extending VkSamplerCreateInfo: VkSamplerReductionModeCreateInfoEXT VkSamplerReductionModeEXT VK_EXT_SAMPLER_FILTER_MINMAX_EXTENSION_NAME VK_EXT_SAMPLER_FILTER_MINMAX_SPEC_VERSION Extending VkFormatFeatureFlagBits: VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT Extending VkSamplerReductionMode: VK_SAMPLER_REDUCTION_MODE_MAX_EXT VK_SAMPLER_REDUCTION_MODE_MIN_EXT VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT Revision 2, 2017-05-19 (Piers Daniell) Renamed to EXT Revision 1, 2017-03-25 (Jeff Bolz) Internal revisions Name String VK_EXT_scalar_block_layout Extension Type Device extension Registered Extension Number 222 Revision 1 Ratification Status Not ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 Deprecation State Promoted to Vulkan 1.2 Contact Tobias Hector tobski Last Modified Date 2018-11-14 Contributors Jeff Bolz Jan-Harald Fredriksen Graeme Leese Faith Ekstrand John Kessenich This extension enables C-like structure layout for SPIR-V blocks. It modifies the alignment rules for uniform buffers, storage buffers and push constants, allowing non-scalar types to be aligned solely based on the size of their components, without additional requirements. Vulkan APIs in this extension are included in core Vulkan 1.2, with the EXT suffix omitted. However, if Vulkan 1.2 is supported and this extension is not, the scalarBlockLayout capability is optional. External interactions defined by this extension, such as SPIR-V token names, retain their original names. The original Vulkan API names are still available as aliases of the core functionality. If Vulkan 1.4 is supported, support for the scalarBlockLayout capability is required. Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceScalarBlockLayoutFeaturesEXT VK_EXT_SCALAR_BLOCK_LAYOUT_EXTENSION_NAME VK_EXT_SCALAR_BLOCK_LAYOUT_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT Revision 1, 2018-11-14 (Tobias Hector) Initial draft Name String VK_EXT_separate_stencil_usage Extension Type Device extension Registered Extension Number 247 Revision 1 Ratification Status Not ratified Extension and Version Dependencies None Deprecation State Promoted to Vulkan 1.2 Contact Daniel Rakos drakos-amd Last Modified Date 2018-11-08 IP Status No known IP claims. Contributors Daniel Rakos, AMD Jordan Logan, AMD This extension allows specifying separate usage flags for the stencil aspect of images with a depth-stencil format at image creation time. All functionality in this extension is included in core Vulkan 1.2, with the EXT suffix omitted. The original type, enum, and command names are still available as aliases of the core functionality. Extending VkImageCreateInfo, VkPhysicalDeviceImageFormatInfo2: VkImageStencilUsageCreateInfoEXT VK_EXT_SEPARATE_STENCIL_USAGE_EXTENSION_NAME VK_EXT_SEPARATE_STENCIL_USAGE_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO_EXT Revision 1, 2018-11-08 (Daniel Rakos) Internal revisions. Name String VK_EXT_shader_demote_to_helper_invocation Extension Type Device extension Registered Extension Number 277 Revision 1 Ratification Status Not ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 SPIR-V Dependencies SPV_EXT_demote_to_helper_invocation Deprecation State Promoted to Vulkan 1.3 Contact Jeff Bolz jeffbolznv Last Modified Date 2019-06-01 IP Status No known IP claims. Interactions and External Dependencies This extension provides API support for GL_EXT_demote_to_helper_invocation Contributors Jeff Bolz, NVIDIA This extension adds Vulkan support for the SPV_EXT_demote_to_helper_invocation SPIR-V extension. That SPIR-V extension provides a new instruction OpDemoteToHelperInvocationEXT allowing shaders to demote a fragment shader invocation to behave like a helper invocation for its duration. The demoted invocation will have no further side effects and will not output to the framebuffer, but remains active and can participate in computing derivatives and in group operations. This is a better match for the discard instruction in HLSL. Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT VK_EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_EXTENSION_NAME VK_EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT DemoteToHelperInvocationEXT Vulkan APIs in this extension are included in core Vulkan 1.3, with the EXT suffix omitted. External interactions defined by this extension, such as SPIR-V token names, retain their original names. The original Vulkan API names are still available as aliases of the core functionality. Revision 1, 2019-06-01 (Jeff Bolz) Initial draft Name String VK_EXT_shader_subgroup_ballot Extension Type Device extension Registered Extension Number 65 Revision 1 Ratification Status Not ratified Extension and Version Dependencies None SPIR-V Dependencies SPV_KHR_shader_ballot Deprecation State Deprecated by Vulkan 1.2 Contact Daniel Koch dgkoch Last Modified Date 2016-11-28 IP Status No known IP claims. Interactions and External Dependencies This extension provides API support for GL_ARB_shader_ballot Contributors Jeff Bolz, NVIDIA Neil Henning, Codeplay Daniel Koch, NVIDIA Corporation This extension adds support for the following SPIR-V extension in Vulkan: SPV_KHR_shader_ballot This extension provides the ability for a group of invocations, which execute in parallel, to do limited forms of cross-invocation communication via a group broadcast of an invocation value, or broadcast of a bit array representing a predicate value from each invocation in the group. This extension provides access to a number of additional built-in shader variables in Vulkan: SubgroupEqMaskKHR, containing the subgroup mask of the current subgroup invocation, SubgroupGeMaskKHR, containing the subgroup mask of the invocations greater than or equal to the current invocation, SubgroupGtMaskKHR, containing the subgroup mask of the invocations greater than the current invocation, SubgroupLeMaskKHR, containing the subgroup mask of the invocations less than or equal to the current invocation, SubgroupLtMaskKHR, containing the subgroup mask of the invocations less than the current invocation, SubgroupLocalInvocationId, containing the index of an invocation within a subgroup, and SubgroupSize, containing the maximum number of invocations in a subgroup. Additionally, this extension provides access to the new SPIR-V instructions: OpSubgroupBallotKHR, OpSubgroupFirstInvocationKHR, and OpSubgroupReadInvocationKHR, When using GLSL source-based shader languages, the following variables and shader functions from GL_ARB_shader_ballot can map to these SPIR-V built-in decorations and instructions: in uint64_t gl_SubGroupEqMaskARB;  SubgroupEqMaskKHR, in uint64_t gl_SubGroupGeMaskARB;  SubgroupGeMaskKHR, in uint64_t gl_SubGroupGtMaskARB;  SubgroupGtMaskKHR, in uint64_t gl_SubGroupLeMaskARB;  SubgroupLeMaskKHR, in uint64_t gl_SubGroupLtMaskARB;  SubgroupLtMaskKHR, in uint gl_SubGroupInvocationARB;  SubgroupLocalInvocationId, uniform uint gl_SubGroupSizeARB;  SubgroupSize, ballotARB()  OpSubgroupBallotKHR, readFirstInvocationARB()  OpSubgroupFirstInvocationKHR, and readInvocationARB()  OpSubgroupReadInvocationKHR. Most of the functionality in this extension is superseded by the core Vulkan 1.1 subgroup operations. However, Vulkan 1.1 required the OpGroupNonUniformBroadcast Id to be constant. This restriction was removed in Vulkan 1.2 with the addition of the subgroupBroadcastDynamicId feature. VK_EXT_SHADER_SUBGROUP_BALLOT_EXTENSION_NAME VK_EXT_SHADER_SUBGROUP_BALLOT_SPEC_VERSION SubgroupEqMaskKHR SubgroupGeMaskKHR SubgroupGtMaskKHR SubgroupLeMaskKHR SubgroupLtMaskKHR SubgroupLocalInvocationId SubgroupSize SubgroupBallotKHR Revision 1, 2016-11-28 (Daniel Koch) Initial draft Name String VK_EXT_shader_subgroup_vote Extension Type Device extension Registered Extension Number 66 Revision 1 Ratification Status Not ratified Extension and Version Dependencies None SPIR-V Dependencies SPV_KHR_subgroup_vote Deprecation State Deprecated by Vulkan 1.1 Contact Daniel Koch dgkoch Last Modified Date 2016-11-28 IP Status No known IP claims. Interactions and External Dependencies This extension provides API support for GL_ARB_shader_group_vote Contributors Neil Henning, Codeplay Daniel Koch, NVIDIA Corporation This extension adds support for the following SPIR-V extension in Vulkan: SPV_KHR_subgroup_vote This extension provides new SPIR-V instructions: OpSubgroupAllKHR, OpSubgroupAnyKHR, and OpSubgroupAllEqualKHR. to compute the composite of a set of boolean conditions across a group of shader invocations that are running concurrently (a subgroup). These composite results may be used to execute shaders more efficiently on a VkPhysicalDevice. When using GLSL source-based shader languages, the following shader functions from GL_ARB_shader_group_vote can map to these SPIR-V instructions: anyInvocationARB()  OpSubgroupAnyKHR, allInvocationsARB()  OpSubgroupAllKHR, and allInvocationsEqualARB()  OpSubgroupAllEqualKHR. The subgroup across which the boolean conditions are evaluated is implementation-dependent, and this extension provides no guarantee over how individual shader invocations are assigned to subgroups. In particular, a subgroup has no necessary relationship with the compute shader local workgroup  any pair of shader invocations in a compute local workgroup may execute in different subgroups as used by these instructions. Compute shaders operate on an explicitly specified group of threads (a local workgroup), but many implementations will also group non-compute shader invocations and execute them concurrently. When executing code like if (condition) { result = do_fast_path(); } else { result = do_general_path(); } where condition diverges between invocations, an implementation might first execute do_fast_path() for the invocations where condition is true and leave the other invocations dormant. Once do_fast_path() returns, it might call do_general_path() for invocations where condition is false and leave the other invocations dormant. In this case, the shader executes both the fast and the general path and might be better off just using the general path for all invocations. This extension provides the ability to avoid divergent execution by evaluating a condition across an entire subgroup using code like: if (allInvocationsARB(condition)) { result = do_fast_path(); } else { result = do_general_path(); } The built-in function allInvocationsARB() will return the same value for all invocations in the group, so the group will either execute do_fast_path() or do_general_path(), but never both. For example, shader code might want to evaluate a complex function iteratively by starting with an approximation of the result and then refining the approximation. Some input values may require a small number of iterations to generate an accurate result (do_fast_path) while others require a larger number (do_general_path). In another example, shader code might want to evaluate a complex function (do_general_path) that can be greatly simplified when assuming a specific value for one of its inputs (do_fast_path). All functionality in this extension is superseded by the core Vulkan 1.1 subgroup operations. VK_EXT_SHADER_SUBGROUP_VOTE_EXTENSION_NAME VK_EXT_SHADER_SUBGROUP_VOTE_SPEC_VERSION SubgroupVoteKHR Revision 1, 2016-11-28 (Daniel Koch) Initial draft Name String VK_EXT_shader_viewport_index_layer Extension Type Device extension Registered Extension Number 163 Revision 1 Ratification Status Not ratified Extension and Version Dependencies None SPIR-V Dependencies SPV_EXT_shader_viewport_index_layer Deprecation State Promoted to Vulkan 1.2 Contact Daniel Koch dgkoch Last Modified Date 2017-08-08 Interactions and External Dependencies This extension provides API support for GL_ARB_shader_viewport_layer_array, GL_AMD_vertex_shader_layer, GL_AMD_vertex_shader_viewport_index, and GL_NV_viewport_array2 This extension requires the multiViewport feature. This extension interacts with the tessellationShader feature. Contributors Piers Daniell, NVIDIA Jeff Bolz, NVIDIA Jan-Harald Fredriksen, ARM Daniel Rakos, AMD Slawomir Grajeswki, Intel This extension adds support for the ShaderViewportIndexLayerEXT capability from the SPV_EXT_shader_viewport_index_layer extension in Vulkan. This extension allows variables decorated with the Layer and ViewportIndex built-ins to be exported from vertex or tessellation shaders, using the ShaderViewportIndexLayerEXT capability. When using GLSL source-based shading languages, the gl_ViewportIndex and gl_Layer built-in variables map to the SPIR-V ViewportIndex and Layer built-in decorations, respectively. Behavior of these variables is extended as described in the GL_ARB_shader_viewport_layer_array (or the precursor GL_AMD_vertex_shader_layer, GL_AMD_vertex_shader_viewport_index, and GL_NV_viewport_array2 extensions). The ShaderViewportIndexLayerEXT capability is equivalent to the ShaderViewportIndexLayerNV capability added by VK_NV_viewport_array2. All functionality in this extension is included in core Vulkan 1.2. The single ShaderViewportIndexLayerEXT capability from the SPV_EXT_shader_viewport_index_layer extension is replaced by the ShaderViewportIndex and ShaderLayer capabilities from SPIR-V 1.5 which are enabled by the shaderOutputViewportIndex and shaderOutputLayer features, respectively. Additionally, if Vulkan 1.2 is supported but this extension is not, these capabilities are optional. Enabling both features is equivalent to enabling the VK_EXT_shader_viewport_index_layer extension. VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_EXTENSION_NAME VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_SPEC_VERSION (modified) Layer (modified) ViewportIndex ShaderViewportIndexLayerEXT Revision 1, 2017-08-08 (Daniel Koch) Internal drafts Name String VK_EXT_subgroup_size_control Extension Type Device extension Registered Extension Number 226 Revision 2 Ratification Status Not ratified Extension and Version Dependencies Vulkan Version 1.1 Deprecation State Promoted to Vulkan 1.3 Contact Neil Henning sheredom Last Modified Date 2019-03-05 Contributors Jeff Bolz, NVIDIA Faith Ekstrand, Intel Sawek Grajewski, Intel Jesse Hall, Google Neil Henning, AMD Daniel Koch, NVIDIA Jeff Leger, Qualcomm Graeme Leese, Broadcom Allan MacKinnon, Google Mariusz Merecki, Intel Graham Wihlidal, Electronic Arts This extension enables an implementation to control the subgroup size by allowing a varying subgroup size and also specifying a required subgroup size. It extends the subgroup support in Vulkan 1.1 to allow an implementation to expose a varying subgroup size. Previously Vulkan exposed a single subgroup size per physical device, with the expectation that implementations will behave as if all subgroups have the same size. Some implementations may dispatch shaders with a varying subgroup size for different subgroups. As a result they could implicitly split a large subgroup into smaller subgroups or represent a small subgroup as a larger subgroup, some of whose invocations were inactive on launch. To aid developers in understanding the performance characteristics of their programs, this extension exposes a minimum and maximum subgroup size that a physical device supports and a pipeline create flag to enable that pipeline to vary its subgroup size. If enabled, any SubgroupSize decorated variables in the SPIR-V shader modules provided to pipeline creation may vary between the minimum and maximum subgroup sizes. An implementation is also optionally allowed to support specifying a required subgroup size for a given pipeline stage. Implementations advertise which stages support a required subgroup size, and any pipeline of a supported stage can be passed a VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT structure to set the subgroup size for that shader stage of the pipeline. For compute shaders, this requires the developer to query the maxComputeWorkgroupSubgroups and ensure that: Developers can also specify a new pipeline shader stage create flag that requires the implementation to have fully populated subgroups within local workgroups. This requires the workgroup size in the X dimension to be a multiple of the subgroup size. Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceSubgroupSizeControlFeaturesEXT Extending VkPhysicalDeviceProperties2: VkPhysicalDeviceSubgroupSizeControlPropertiesEXT Extending VkPipelineShaderStageCreateInfo, VkShaderCreateInfoEXT: VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT VK_EXT_SUBGROUP_SIZE_CONTROL_EXTENSION_NAME VK_EXT_SUBGROUP_SIZE_CONTROL_SPEC_VERSION Extending VkPipelineShaderStageCreateFlagBits: VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT Vulkan APIs in this extension are included in core Vulkan 1.3, with the EXT suffix omitted. External interactions defined by this extension, such as SPIR-V token names, retain their original names. The original Vulkan API names are still available as aliases of the core functionality. Revision 1, 2019-03-05 (Neil Henning) Initial draft Revision 2, 2019-07-26 (Faith Ekstrand) Add the missing VkPhysicalDeviceSubgroupSizeControlFeaturesEXT for querying subgroup size control features. Name String VK_EXT_texel_buffer_alignment Extension Type Device extension Registered Extension Number 282 Revision 1 Ratification Status Not ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 Deprecation State Promoted to Vulkan 1.3 Contact Jeff Bolz jeffbolznv Last Modified Date 2019-06-06 IP Status No known IP claims. Contributors Jeff Bolz, NVIDIA This extension adds more expressive alignment requirements for uniform and storage texel buffers. Some implementations have single texel alignment requirements that cannot be expressed via VkPhysicalDeviceLimits::minTexelBufferOffsetAlignment. Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT Extending VkPhysicalDeviceProperties2: VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT VK_EXT_TEXEL_BUFFER_ALIGNMENT_EXTENSION_NAME VK_EXT_TEXEL_BUFFER_ALIGNMENT_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT Vulkan APIs in this extension are included in core Vulkan 1.3, with the EXT suffix omitted. However, only the properties structure is promoted. The feature structure is not promoted and texelBufferAlignment is enabled if using a Vulkan 1.3 instance. External interactions defined by this extension, such as SPIR-V token names, retain their original names. The original Vulkan API name is still available as an alias of the core functionality. Revision 1, 2019-06-06 (Jeff Bolz) Initial draft Name String VK_EXT_texture_compression_astc_hdr Extension Type Device extension Registered Extension Number 67 Revision 1 Ratification Status Not ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 Deprecation State Promoted to Vulkan 1.3 Contact Jan-Harald Fredriksen janharaldfredriksen-arm Last Modified Date 2019-05-28 IP Status No known issues. Contributors Jan-Harald Fredriksen, Arm This extension adds support for textures compressed using the Adaptive Scalable Texture Compression (ASTC) High Dynamic Range (HDR) profile. When this extension is enabled, the HDR profile is supported for all ASTC formats listed in ASTC Compressed Image Formats. Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT VK_EXT_TEXTURE_COMPRESSION_ASTC_HDR_EXTENSION_NAME VK_EXT_TEXTURE_COMPRESSION_ASTC_HDR_SPEC_VERSION Extending VkFormat: VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT Vulkan APIs in this extension are included in core Vulkan 1.3, with the EXT suffix omitted. However, the feature is made optional in Vulkan 1.3. External interactions defined by this extension, such as SPIR-V token names, retain their original names. The original Vulkan API names are still available as aliases of the core functionality. 1) Should we add a feature or limit for this functionality? Yes. It is consistent with the ASTC LDR support to add a feature like textureCompressionASTC_HDR. The feature is strictly speaking redundant as long as this is just an extension; it would be sufficient to just enable the extension. But adding the feature is more forward-looking if wanted to make this an optional core feature in the future. 2) Should we introduce new format enums for HDR? Yes. Vulkan 1.0 describes the ASTC format enums as UNORM, e.g. VK_FORMAT_ASTC_4x4_UNORM_BLOCK, so it is confusing to make these contain HDR data. Note that the OpenGL (ES) extensions did not make this distinction because a single ASTC HDR texture may contain both unorm and float blocks. Implementations may not be able to distinguish between LDR and HDR ASTC textures internally and just treat them as the same format, i.e. if this extension is supported then sampling from a VK_FORMAT_ASTC_4x4_UNORM_BLOCK image format may return HDR results. Applications can get predictable results by using the appropriate image format. Revision 1, 2019-05-28 (Jan-Harald Fredriksen) Initial version Name String VK_EXT_tooling_info Extension Type Device extension Registered Extension Number 246 Revision 1 Ratification Status Not ratified Extension and Version Dependencies None API Interactions Interacts with VK_EXT_debug_marker Interacts with VK_EXT_debug_report Interacts with VK_EXT_debug_utils Deprecation State Promoted to Vulkan 1.3 Contact Tobias Hector tobski Last Modified Date 2018-11-05 Contributors Rolando Caloca Matthaeus Chajdas Baldur Karlsson Daniel Rakos When an error occurs during application development, a common question is "What tools are actually running right now?" This extension adds the ability to query that information directly from the Vulkan implementation. Outdated versions of one tool might not play nicely with another, or perhaps a tool is not actually running when it should have been. Trying to figure that out can cause headaches as it is necessary to consult each known tool to figure out what is going on  in some cases the tool might not even be known. Typically, the expectation is that developers will simply print out this information for visual inspection when an issue occurs, however a small amount of semantic information about what the tool is doing is provided to help identify it programmatically. For example, if the advertised limits or features of an implementation are unexpected, is there a tool active which modifies these limits? Or if an application is providing debug markers, but the implementation is not actually doing anything with that information, this can quickly point that out. vkGetPhysicalDeviceToolPropertiesEXT VkPhysicalDeviceToolPropertiesEXT VkToolPurposeFlagBitsEXT VkToolPurposeFlagsEXT VK_EXT_TOOLING_INFO_EXTENSION_NAME VK_EXT_TOOLING_INFO_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES_EXT Extending VkToolPurposeFlagBits: VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT_EXT VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT_EXT VK_TOOL_PURPOSE_PROFILING_BIT_EXT VK_TOOL_PURPOSE_TRACING_BIT_EXT VK_TOOL_PURPOSE_VALIDATION_BIT_EXT If VK_EXT_debug_marker is supported: Extending VkToolPurposeFlagBits: VK_TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT If VK_EXT_debug_report is supported: Extending VkToolPurposeFlagBits: VK_TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT If VK_EXT_debug_utils is supported: Extending VkToolPurposeFlagBits: VK_TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT VK_TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT Vulkan APIs in this extension are included in core Vulkan 1.3, with the EXT suffix omitted. External interactions defined by this extension, such as SPIR-V token names, retain their original names. The original Vulkan API names are still available as aliases of the core functionality. Printing Tool Information uint32_t num_tools; VkPhysicalDeviceToolPropertiesEXT *pToolProperties; vkGetPhysicalDeviceToolPropertiesEXT(physicalDevice, &num_tools, NULL); pToolProperties = (VkPhysicalDeviceToolPropertiesEXT*)malloc(sizeof(VkPhysicalDeviceToolPropertiesEXT) * num_tools); vkGetPhysicalDeviceToolPropertiesEXT(physicalDevice, &num_tools, pToolProperties); for (int i = 0; i 0) { printf("Corresponding Layer:\n"); printf("\t%s\n", pToolProperties[i].layer); } } 1) Why is this information separate from the layer mechanism? Some tooling may be built into a driver, or be part of the Vulkan loader etc. Tying this information directly to layers would have been awkward at best. Revision 1, 2018-11-05 (Tobias Hector) Initial draft Name String VK_EXT_validation_features Extension Type Instance extension Registered Extension Number 248 Revision 6 Ratification Status Ratified Extension and Version Dependencies None Deprecation State Deprecated by VK_EXT_layer_settings extension Special Use Debugging tools Contact Karl Schultz karl-lunarg Last Modified Date 2018-11-14 IP Status No known IP claims. Contributors Karl Schultz, LunarG Dave Houlton, LunarG Mark Lobodzinski, LunarG Camden Stocker, LunarG Tony Barbour, LunarG John Zulauf, LunarG This extension provides the VkValidationFeaturesEXT structure that can be included in the pNext chain of the VkInstanceCreateInfo structure passed as the pCreateInfo parameter of vkCreateInstance. The structure contains an array of VkValidationFeatureEnableEXT enum values that enable specific validation features that are disabled by default. The structure also contains an array of VkValidationFeatureDisableEXT enum values that disable specific validation layer features that are enabled by default. Functionality in this extension is subsumed into the VK_EXT_layer_settings extension. Extending VkInstanceCreateInfo, VkShaderModuleCreateInfo, VkShaderCreateInfoEXT: VkValidationFeaturesEXT VkValidationFeatureDisableEXT VkValidationFeatureEnableEXT VK_EXT_VALIDATION_FEATURES_EXTENSION_NAME VK_EXT_VALIDATION_FEATURES_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT Revision 1, 2018-11-14 (Karl Schultz) Initial revision Revision 2, 2019-08-06 (Mark Lobodzinski) Add Best Practices enable Revision 3, 2020-03-04 (Tony Barbour) Add Debug Printf enable Revision 4, 2020-07-29 (John Zulauf) Add Synchronization Validation enable Revision 5, 2021-05-18 (Tony Barbour) Add Shader Validation Cache disable Revision 6, 2023-09-25 (Christophe Riccio) Marked as deprecated by VK_EXT_layer_settings Name String VK_EXT_validation_flags Extension Type Instance extension Registered Extension Number 62 Revision 3 Ratification Status Not ratified Extension and Version Dependencies None Deprecation State Deprecated by VK_EXT_layer_settings extension Special Use Debugging tools Contact Tobin Ehlis tobine Last Modified Date 2019-08-19 IP Status No known IP claims. Contributors Tobin Ehlis, Google Courtney Goeltzenleuchter, Google This extension provides the VkValidationFlagsEXT structure that can be included in the pNext chain of the VkInstanceCreateInfo structure passed as the pCreateInfo parameter of vkCreateInstance. The structure contains an array of VkValidationCheckEXT values that will be disabled by the validation layers. Functionality in this extension is subsumed into the VK_EXT_layer_settings extension. Extending VkInstanceCreateInfo: VkValidationFlagsEXT VkValidationCheckEXT VK_EXT_VALIDATION_FLAGS_EXTENSION_NAME VK_EXT_VALIDATION_FLAGS_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT Revision 3, 2023-09-25 (Christophe Riccio) Marked as deprecated by VK_EXT_layer_settings Revision 2, 2019-08-19 (Mark Lobodzinski) Marked as deprecated by VK_EXT_validation_features Revision 1, 2016-08-26 (Courtney Goeltzenleuchter) Initial draft Name String VK_EXT_vertex_attribute_divisor Extension Type Device extension Registered Extension Number 191 Revision 3 Ratification Status Not ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 Deprecation State Promoted to VK_KHR_vertex_attribute_divisor extension Which in turn was promoted to Vulkan 1.4 Contact Vikram Kushwaha vkushwaha Last Modified Date 2018-08-03 IP Status No known IP claims. Contributors Vikram Kushwaha, NVIDIA Faith Ekstrand, Intel This extension allows instance-rate vertex attributes to be repeated for certain number of instances instead of advancing for every instance when instanced rendering is enabled. VkVertexInputBindingDivisorDescriptionEXT Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT Extending VkPhysicalDeviceProperties2: VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT Extending VkPipelineVertexInputStateCreateInfo: VkPipelineVertexInputDivisorStateCreateInfoEXT VK_EXT_VERTEX_ATTRIBUTE_DIVISOR_EXTENSION_NAME VK_EXT_VERTEX_ATTRIBUTE_DIVISOR_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT 1) What is the effect of a non-zero value for firstInstance? RESOLVED: The Vulkan API should follow the OpenGL convention and offset attribute fetching by firstInstance while computing vertex attribute offsets. 2) Should zero be an allowed divisor? RESOLVED: Yes. A zero divisor means the vertex attribute is repeated for all instances. To create a vertex binding such that the first binding uses instanced rendering and the same attribute is used for every 4 draw instances, an application could use the following set of structures: const VkVertexInputBindingDivisorDescriptionEXT divisorDesc = { .binding = 0, .divisor = 4 }; const VkPipelineVertexInputDivisorStateCreateInfoEXT divisorInfo = { .sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT, .pNext = NULL, .vertexBindingDivisorCount = 1, .pVertexBindingDivisors = &divisorDesc } const VkVertexInputBindingDescription binding = { .binding = 0, .stride = sizeof(Vertex), .inputRate = VK_VERTEX_INPUT_RATE_INSTANCE }; const VkPipelineVertexInputStateCreateInfo viInfo = { .sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_CREATE_INFO, .pNext = &divisorInfo, ... }; //... Revision 1, 2017-12-04 (Vikram Kushwaha) First Version Revision 2, 2018-07-16 (Faith Ekstrand) Adjust the interaction between divisor and firstInstance to match the OpenGL convention. Disallow divisors of zero. Revision 3, 2018-08-03 (Vikram Kushwaha) Allow a zero divisor. Add a physical device features structure to query/enable this feature. Name String VK_EXT_ycbcr_2plane_444_formats Extension Type Device extension Registered Extension Number 331 Revision 1 Ratification Status Not ratified Extension and Version Dependencies VK_KHR_sampler_ycbcr_conversion or Vulkan Version 1.1 Deprecation State Promoted to Vulkan 1.3 Contact Tony Zlatinski tzlatinski Last Modified Date 2020-07-28 IP Status No known IP claims. Contributors Piers Daniell, NVIDIA Ping Liu, Intel This extension adds some YCBCR formats that are in common use for video encode and decode, but were not part of the VK_KHR_sampler_ycbcr_conversion extension. Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT VK_EXT_YCBCR_2PLANE_444_FORMATS_EXTENSION_NAME VK_EXT_YCBCR_2PLANE_444_FORMATS_SPEC_VERSION Extending VkFormat: VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16_EXT VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16_EXT VK_FORMAT_G16_B16R16_2PLANE_444_UNORM_EXT VK_FORMAT_G8_B8R8_2PLANE_444_UNORM_EXT Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT The format enumerants introduced by the extension are included in core Vulkan 1.3, with the EXT suffix omitted. However, runtime support for these formats is optional in core Vulkan 1.3, while if this extension is supported, runtime support is mandatory. The feature structure is not promoted. The original enum names are still available as aliases of the core functionality. Revision 1, 2020-03-08 (Piers Daniell) Initial draft Name String VK_AMD_draw_indirect_count Extension Type Device extension Registered Extension Number 34 Revision 2 Ratification Status Not ratified Extension and Version Dependencies None Deprecation State Promoted to VK_KHR_draw_indirect_count extension Which in turn was promoted to Vulkan 1.2 Contact Daniel Rakos drakos-amd Last Modified Date 2016-08-23 IP Status No known IP claims. Contributors Matthaeus G. Chajdas, AMD Derrick Owens, AMD Graham Sellers, AMD Daniel Rakos, AMD Dominik Witczak, AMD This extension allows an application to source the number of draws for indirect drawing commands from a buffer. This enables applications to generate an arbitrary number of drawing commands and execute them without host intervention. All functionality in this extension is included in VK_KHR_draw_indirect_count, with the suffix changed to KHR. The original type, enum, and command names are still available as aliases of the core functionality. vkCmdDrawIndexedIndirectCountAMD vkCmdDrawIndirectCountAMD VK_AMD_DRAW_INDIRECT_COUNT_EXTENSION_NAME VK_AMD_DRAW_INDIRECT_COUNT_SPEC_VERSION Revision 2, 2016-08-23 (Dominik Witczak) Minor fixes Revision 1, 2016-07-21 (Matthaeus Chajdas) Initial draft Name String VK_AMD_gpu_shader_half_float Extension Type Device extension Registered Extension Number 37 Revision 2 Ratification Status Not ratified Extension and Version Dependencies None SPIR-V Dependencies SPV_AMD_gpu_shader_half_float Deprecation State Deprecated by VK_KHR_shader_float16_int8 extension Which in turn was promoted to Vulkan 1.2 Contact Dominik Witczak dominikwitczakamd Last Modified Date 2019-04-11 IP Status No known IP claims. Interactions and External Dependencies This extension provides API support for GL_AMD_gpu_shader_half_float Contributors Daniel Rakos, AMD Dominik Witczak, AMD Donglin Wei, AMD Graham Sellers, AMD Qun Lin, AMD Rex Xu, AMD This extension adds support for using half float variables in shaders. Functionality in this extension is included in the VK_KHR_shader_float16_int8 extension, when the shaderFloat16 feature is enabled. VK_AMD_GPU_SHADER_HALF_FLOAT_EXTENSION_NAME VK_AMD_GPU_SHADER_HALF_FLOAT_SPEC_VERSION Revision 2, 2019-04-11 (Tobias Hector) Marked as deprecated Revision 1, 2016-09-21 (Dominik Witczak) Initial draft Name String VK_AMD_gpu_shader_int16 Extension Type Device extension Registered Extension Number 133 Revision 2 Ratification Status Not ratified Extension and Version Dependencies None SPIR-V Dependencies SPV_AMD_gpu_shader_int16 Deprecation State Deprecated by VK_KHR_shader_float16_int8 extension Which in turn was promoted to Vulkan 1.2 Contact Qun Lin linqun Last Modified Date 2019-04-11 IP Status No known IP claims. Interactions and External Dependencies This extension provides API support for GL_AMD_gpu_shader_int16 Contributors Daniel Rakos, AMD Dominik Witczak, AMD Matthaeus G. Chajdas, AMD Rex Xu, AMD Timothy Lottes, AMD Zhi Cai, AMD This extension adds support for using 16-bit integer variables in shaders. Functionality in this extension is included in the VK_KHR_shader_float16_int8 extension, when the shaderInt16 and shaderFloat16 features are enabled. VK_AMD_GPU_SHADER_INT16_EXTENSION_NAME VK_AMD_GPU_SHADER_INT16_SPEC_VERSION Revision 2, 2019-04-11 (Tobias Hector) Marked as deprecated Revision 1, 2017-06-18 (Dominik Witczak) First version Name String VK_AMD_negative_viewport_height Extension Type Device extension Registered Extension Number 36 Revision 1 Ratification Status Not ratified Extension and Version Dependencies None Deprecation State Obsoleted by VK_KHR_maintenance1 extension Which in turn was promoted to Vulkan 1.1 Contact Matthaeus G. Chajdas anteru Last Modified Date 2016-09-02 IP Status No known IP claims. Contributors Matthaeus G. Chajdas, AMD Graham Sellers, AMD Baldur Karlsson This extension allows an application to specify a negative viewport height. The result is that the viewport transformation will flip along the y-axis. Allow negative height to be specified in the VkViewport::height field to perform y-inversion of the clip-space to framebuffer-space transform. This allows apps to avoid having to use gl_Position.y = -gl_Position.y in shaders also targeting other APIs. Functionality in this extension is included in the VK_KHR_maintenance1 extension and subsequently Vulkan 1.1. Due to some slight behavioral differences, this extension must not be enabled alongside VK_KHR_maintenance1, or in an instance created with version 1.1 or later requested in VkApplicationInfo::apiVersion. VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_EXTENSION_NAME VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_SPEC_VERSION Revision 1, 2016-09-02 (Matthaeus Chajdas) Initial draft Name String VK_ARM_rasterization_order_attachment_access Extension Type Device extension Registered Extension Number 343 Revision 1 Ratification Status Not ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 Deprecation State Promoted to VK_EXT_rasterization_order_attachment_access extension Contact Jan-Harald Fredriksen janharaldfredriksen-arm Last Modified Date 2021-11-12 IP Status No known IP claims. Contributors Tobias Hector, AMD Jan-Harald Fredriksen, Arm Render passes, and specifically subpass dependencies, enable much of the same functionality as the framebuffer fetch and pixel local storage extensions did for OpenGL ES. But certain techniques such as programmable blending are awkward or impractical to implement with these alone, in part because a self-dependency is required every time a fragment will read a value at a given sample coordinate. This extension extends the mechanism of input attachments to allow access to framebuffer attachments when used as both input and color, or depth/stencil, attachments from one fragment to the next, in rasterization order, without explicit synchronization. Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesARM VK_ARM_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_EXTENSION_NAME VK_ARM_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_SPEC_VERSION Extending VkPipelineColorBlendStateCreateFlagBits: VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_ARM Extending VkPipelineDepthStencilStateCreateFlagBits: VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_ARM Extending VkSubpassDescriptionFlagBits: VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_ARM VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_ARM VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_ARM 1) Is there any interaction with the VK_KHR_dynamic_rendering extension? No. This extension only affects reads from input attachments. Render pass instances begun with vkCmdBeginRenderingKHR do not have input attachments and a different mechanism will be needed to provide similar functionality in this case. None. Revision 1, 2021-11-12 (Jan-Harald Fredriksen) Initial draft Name String VK_IMG_format_pvrtc Extension Type Device extension Registered Extension Number 55 Revision 1 Ratification Status Not ratified Extension and Version Dependencies None Deprecation State Deprecated without replacement Contact Stuart Smith Last Modified Date 2019-09-02 IP Status Imagination Technologies Proprietary Contributors Stuart Smith, Imagination Technologies VK_IMG_format_pvrtc provides additional texture compression functionality specific to Imagination Technologies PowerVR Texture compression format (called PVRTC). As also noted in the Khronos Data Format Specification, PVRTC1 images must have dimensions that are a power of two. Both PVRTC1 and PVRTC2 are slower than standard image formats on PowerVR GPUs, and support will be removed from future hardware. VK_IMG_FORMAT_PVRTC_EXTENSION_NAME VK_IMG_FORMAT_PVRTC_SPEC_VERSION Extending VkFormat: VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG Revision 1, 2019-09-02 (Stuart Smith) Initial version Name String VK_MVK_ios_surface Extension Type Instance extension Registered Extension Number 123 Revision 3 Ratification Status Not ratified Extension and Version Dependencies VK_KHR_surface Deprecation State Deprecated by VK_EXT_metal_surface extension Contact Bill Hollings billhollings Last Modified Date 2020-07-31 IP Status No known IP claims. Contributors Bill Hollings, The Brenwill Workshop Ltd. The VK_MVK_ios_surface extension is an instance extension. It provides a mechanism to create a VkSurfaceKHR object (defined by the VK_KHR_surface extension) based on a UIView, the native surface type of iOS, which is underpinned by a CAMetalLayer, to support rendering to the surface using Apples Metal framework. The VK_MVK_ios_surface extension is considered deprecated and has been superseded by the VK_EXT_metal_surface extension. vkCreateIOSSurfaceMVK VkIOSSurfaceCreateInfoMVK VkIOSSurfaceCreateFlagsMVK VK_MVK_IOS_SURFACE_EXTENSION_NAME VK_MVK_IOS_SURFACE_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK Revision 1, 2017-02-15 (Bill Hollings) Initial draft. Revision 2, 2017-02-24 (Bill Hollings) Minor syntax fix to emphasize firm requirement for UIView to be backed by a CAMetalLayer. Revision 3, 2020-07-31 (Bill Hollings) Update documentation on requirements for UIView. Mark as deprecated by VK_EXT_metal_surface. Name String VK_MVK_macos_surface Extension Type Instance extension Registered Extension Number 124 Revision 3 Ratification Status Not ratified Extension and Version Dependencies VK_KHR_surface Deprecation State Deprecated by VK_EXT_metal_surface extension Contact Bill Hollings billhollings Last Modified Date 2020-07-31 IP Status No known IP claims. Contributors Bill Hollings, The Brenwill Workshop Ltd. The VK_MVK_macos_surface extension is an instance extension. It provides a mechanism to create a VkSurfaceKHR object (defined by the VK_KHR_surface extension) based on an NSView, the native surface type of macOS, which is underpinned by a CAMetalLayer, to support rendering to the surface using Apples Metal framework. The VK_MVK_macos_surface extension is considered deprecated and has been superseded by the VK_EXT_metal_surface extension. vkCreateMacOSSurfaceMVK VkMacOSSurfaceCreateInfoMVK VkMacOSSurfaceCreateFlagsMVK VK_MVK_MACOS_SURFACE_EXTENSION_NAME VK_MVK_MACOS_SURFACE_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK Revision 1, 2017-02-15 (Bill Hollings) Initial draft. Revision 2, 2017-02-24 (Bill Hollings) Minor syntax fix to emphasize firm requirement for NSView to be backed by a CAMetalLayer. Revision 3, 2020-07-31 (Bill Hollings) Update documentation on requirements for NSView. Mark as deprecated by VK_EXT_metal_surface. Name String VK_NV_compute_shader_derivatives Extension Type Device extension Registered Extension Number 202 Revision 1 Ratification Status Not ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 SPIR-V Dependencies SPV_NV_compute_shader_derivatives Deprecation State Promoted to VK_KHR_compute_shader_derivatives extension Contact Pat Brown nvpbrown Last Modified Date 2018-07-19 IP Status No known IP claims. Interactions and External Dependencies This extension provides API support for GL_NV_compute_shader_derivatives Contributors Pat Brown, NVIDIA This extension adds Vulkan support for the SPV_NV_compute_shader_derivatives SPIR-V extension. The SPIR-V extension provides two new execution modes, both of which allow compute shaders to use built-ins that evaluate compute derivatives explicitly or implicitly. Derivatives will be computed via differencing over a 2x2 group of shader invocations. The DerivativeGroupQuadsNV execution mode assembles shader invocations into 2x2 groups, where each group has x and y coordinates of the local invocation ID of the form (2m+{0,1}, 2n+{0,1}). The DerivativeGroupLinearNV execution mode assembles shader invocations into 2x2 groups, where each group has local invocation index values of the form 4m+{0,1,2,3}. Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceComputeShaderDerivativesFeaturesNV VK_NV_COMPUTE_SHADER_DERIVATIVES_EXTENSION_NAME VK_NV_COMPUTE_SHADER_DERIVATIVES_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV ComputeDerivativeGroupQuadsNV ComputeDerivativeGroupLinearNV (1) Should we specify that the groups of four shader invocations used for derivatives in a compute shader are the same groups of four invocations that form a quad in shader subgroups? RESOLVED: Yes. None. Revision 1, 2018-07-19 (Pat Brown) Initial draft Name String VK_NV_dedicated_allocation Extension Type Device extension Registered Extension Number 27 Revision 1 Ratification Status Not ratified Extension and Version Dependencies None Deprecation State Deprecated by VK_KHR_dedicated_allocation extension Which in turn was promoted to Vulkan 1.1 Contact Jeff Bolz jeffbolznv Last Modified Date 2016-05-31 IP Status No known IP claims. Contributors Jeff Bolz, NVIDIA This extension allows device memory to be allocated for a particular buffer or image resource, which on some devices can significantly improve the performance of that resource. Normal device memory allocations must support memory aliasing and sparse binding, which could interfere with optimizations like framebuffer compression or efficient page table usage. This is important for render targets and very large resources, but need not (and probably should not) be used for smaller resources that can benefit from suballocation. This extension adds a few small structures to resource creation and memory allocation: a new structure that flags whether am image/buffer will have a dedicated allocation, and a structure indicating the image or buffer that an allocation will be bound to. Extending VkBufferCreateInfo: VkDedicatedAllocationBufferCreateInfoNV Extending VkImageCreateInfo: VkDedicatedAllocationImageCreateInfoNV Extending VkMemoryAllocateInfo: VkDedicatedAllocationMemoryAllocateInfoNV VK_NV_DEDICATED_ALLOCATION_EXTENSION_NAME VK_NV_DEDICATED_ALLOCATION_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV // Create an image with // VkDedicatedAllocationImageCreateInfoNV::dedicatedAllocation // set to VK_TRUE VkDedicatedAllocationImageCreateInfoNV dedicatedImageInfo = { .sType = VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV, .pNext = NULL, .dedicatedAllocation = VK_TRUE, }; VkImageCreateInfo imageCreateInfo = { .sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO, .pNext = &dedicatedImageInfo // Other members set as usual }; VkImage image; VkResult result = vkCreateImage( device, &imageCreateInfo, NULL, // pAllocator &image); VkMemoryRequirements memoryRequirements; vkGetImageMemoryRequirements( device, image, &memoryRequirements); // Allocate memory with VkDedicatedAllocationMemoryAllocateInfoNV::image // pointing to the image we are allocating the memory for VkDedicatedAllocationMemoryAllocateInfoNV dedicatedInfo = { .sType = VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV, .pNext = NULL, .image = image, .buffer = VK_NULL_HANDLE, }; VkMemoryAllocateInfo memoryAllocateInfo = { .sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO, .pNext = &dedicatedInfo, .allocationSize = memoryRequirements.size, .memoryTypeIndex = FindMemoryTypeIndex(memoryRequirements.memoryTypeBits), }; VkDeviceMemory memory; vkAllocateMemory( device, &memoryAllocateInfo, NULL, // pAllocator &memory); // Bind the image to the memory vkBindImageMemory( device, image, memory, 0); Revision 1, 2016-05-31 (Jeff Bolz) Internal revisions Name String VK_NV_displacement_micromap Extension Type Device extension Registered Extension Number 398 Revision 2 Ratification Status Not ratified Extension and Version Dependencies VK_EXT_opacity_micromap This is a provisional extension and must be used with caution. See the description of provisional header files for enablement and stability details. Deprecation State Deprecated by VK_NV_cluster_acceleration_structure extension Contact Christoph Kubisch pixeljetstream Eric Werness ewerness-nv Last Modified Date 2023-03-17 Interactions and External Dependencies TBD Contributors Christoph Kubisch, NVIDIA Eric Werness, NVIDIA Ray tracing can very efficiently render from geometry which has very fine detail, but when using only a basic triangle representation, memory consumption can be an issue. This extension adds the ability to add a displacement map to add more detail to triangles in an acceleration structure with an efficient in-memory format. The format is externally visible to allow the application to compress its internal geometry representations into the compressed format ahead of time. This format adds displacements along a defined vector to subtriangle vertices which are subdivided from the main triangles. This extension provides: a new VkMicromapTypeEXT format for the displacement micromap, a structure to extend VkAccelerationStructureGeometryTrianglesDataKHR to attach a displacement micromap to the geometry of the acceleration structure, enums extending VkBuildAccelerationStructureFlagBitsKHR to allow for updates. Extending VkAccelerationStructureGeometryTrianglesDataKHR: VkAccelerationStructureTrianglesDisplacementMicromapNV Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceDisplacementMicromapFeaturesNV Extending VkPhysicalDeviceProperties2: VkPhysicalDeviceDisplacementMicromapPropertiesNV VkDisplacementMicromapFormatNV VK_NV_DISPLACEMENT_MICROMAP_EXTENSION_NAME VK_NV_DISPLACEMENT_MICROMAP_SPEC_VERSION Extending VkBuildAccelerationStructureFlagBitsKHR: VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISPLACEMENT_MICROMAP_UPDATE_NV Extending VkMicromapTypeEXT: VK_MICROMAP_TYPE_DISPLACEMENT_MICROMAP_NV Extending VkPipelineCreateFlagBits: VK_PIPELINE_CREATE_RAY_TRACING_DISPLACEMENT_MICROMAP_BIT_NV Extending VkStructureType: VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_DISPLACEMENT_MICROMAP_NV VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_FEATURES_NV VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_PROPERTIES_NV (1) What is the status of this extension? Deprecated. The VK_NV_cluster_acceleration_structure extension is not a one-to-one replacement for this extension but enables similar performance improvements for high-tessellation geometry and is considered the preferred direction to improve high-tessellation geometry performance. Revision 1, 2023-03-17 (Eric Werness) Initial public revision Revision 2, 2023-07-07 (Eric Werness) Add shader support for decode intrinsics Name String VK_NV_external_memory Extension Type Device extension Registered Extension Number 57 Revision 1 Ratification Status Not ratified Extension and Version Dependencies VK_NV_external_memory_capabilities Deprecation State Deprecated by VK_KHR_external_memory extension Which in turn was promoted to Vulkan 1.1 Contact James Jones cubanismo Last Modified Date 2016-08-19 IP Status No known IP claims. Contributors James Jones, NVIDIA Carsten Rohde, NVIDIA Applications may wish to export memory to other Vulkan instances or other APIs, or import memory from other Vulkan instances or other APIs to enable Vulkan workloads to be split up across application module, process, or API boundaries. This extension enables applications to create exportable Vulkan memory objects such that the underlying resources can be referenced outside the Vulkan instance that created them. Extending VkImageCreateInfo: VkExternalMemoryImageCreateInfoNV Extending VkMemoryAllocateInfo: VkExportMemoryAllocateInfoNV VK_NV_EXTERNAL_MEMORY_EXTENSION_NAME VK_NV_EXTERNAL_MEMORY_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV 1) If memory objects are shared between processes and APIs, is this considered aliasing according to the rules outlined in the Memory Aliasing section? RESOLVED: Yes, but strict exceptions to the rules are added to allow some forms of aliasing in these cases. Further, other extensions may build upon these new aliasing rules to define specific support usage within Vulkan for imported native memory objects, or memory objects from other APIs. 2) Are new image layouts or metadata required to specify image layouts and layout transitions compatible with non-Vulkan APIs, or with other instances of the same Vulkan driver? RESOLVED: No. Separate instances of the same Vulkan driver running on the same GPU should have identical internal layout semantics, so applications have the tools they need to ensure views of images are consistent between the two instances. Other APIs will fall into two categories: Those that are Vulkan compatible (a term to be defined by subsequent interopability extensions), or Vulkan incompatible. When sharing images with Vulkan incompatible APIs, the Vulkan image must be transitioned to the VK_IMAGE_LAYOUT_GENERAL layout before handing it off to the external API. Note this does not attempt to address cross-device transitions, nor transitions to engines on the same device which are not visible within the Vulkan API. Both of these are beyond the scope of this extension. // TODO: Write some sample code here. Revision 1, 2016-08-19 (James Jones) Initial draft Name String VK_NV_external_memory_capabilities Extension Type Instance extension Registered Extension Number 56 Revision 1 Ratification Status Not ratified Extension and Version Dependencies None Deprecation State Deprecated by VK_KHR_external_memory_capabilities extension Which in turn was promoted to Vulkan 1.1 Contact James Jones cubanismo Last Modified Date 2016-08-19 IP Status No known IP claims. Interactions and External Dependencies Interacts with Vulkan 1.1. Interacts with VK_KHR_dedicated_allocation. Interacts with VK_NV_dedicated_allocation. Contributors James Jones, NVIDIA Applications may wish to import memory from the Direct 3D API, or export memory to other Vulkan instances. This extension provides a set of capability queries that allow applications determine what types of win32 memory handles an implementation supports for a given set of use cases. vkGetPhysicalDeviceExternalImageFormatPropertiesNV VkExternalImageFormatPropertiesNV VkExternalMemoryFeatureFlagBitsNV VkExternalMemoryHandleTypeFlagBitsNV VkExternalMemoryFeatureFlagsNV VkExternalMemoryHandleTypeFlagsNV VK_NV_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME VK_NV_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION 1) Why do so many external memory capabilities need to be queried on a per-memory-handle-type basis? RESOLVED: This is because some handle types are based on OS-native objects that have far more limited capabilities than the very generic Vulkan memory objects. Not all memory handle types can name memory objects that support 3D images, for example. Some handle types cannot even support the deferred image and memory binding behavior of Vulkan and require specifying the image when allocating or importing the memory object. 2) Does the VkExternalImageFormatPropertiesNV structure need to include a list of memory type bits that support the given handle type? RESOLVED: No. The memory types that do not support the handle types will simply be filtered out of the results returned by vkGetImageMemoryRequirements when a set of handle types was specified at image creation time. 3) Should the non-opaque handle types be moved to their own extension? RESOLVED: Perhaps. However, defining the handle type bits does very little and does not require any platform-specific types on its own, and it is easier to maintain the bitmask values in a single extension for now. Presumably more handle types could be added by separate extensions though, and it would be midly weird to have some platform-specific ones defined in the core spec and some in extensions Revision 1, 2016-08-19 (James Jones) Initial version Name String VK_NV_external_memory_win32 Extension Type Device extension Registered Extension Number 58 Revision 1 Ratification Status Not ratified Extension and Version Dependencies VK_NV_external_memory Deprecation State Deprecated by VK_KHR_external_memory_win32 extension Contact James Jones cubanismo Last Modified Date 2016-08-19 IP Status No known IP claims. Contributors James Jones, NVIDIA Carsten Rohde, NVIDIA Applications may wish to export memory to other Vulkan instances or other APIs, or import memory from other Vulkan instances or other APIs to enable Vulkan workloads to be split up across application module, process, or API boundaries. This extension enables win32 applications to export win32 handles from Vulkan memory objects such that the underlying resources can be referenced outside the Vulkan instance that created them, and import win32 handles created in the Direct3D API to Vulkan memory objects. vkGetMemoryWin32HandleNV Extending VkMemoryAllocateInfo: VkExportMemoryWin32HandleInfoNV VkImportMemoryWin32HandleInfoNV VK_NV_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME VK_NV_EXTERNAL_MEMORY_WIN32_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV 1) If memory objects are shared between processes and APIs, is this considered aliasing according to the rules outlined in the Memory Aliasing section? RESOLVED: Yes, but strict exceptions to the rules are added to allow some forms of aliasing in these cases. Further, other extensions may build upon these new aliasing rules to define specific support usage within Vulkan for imported native memory objects, or memory objects from other APIs. 2) Are new image layouts or metadata required to specify image layouts and layout transitions compatible with non-Vulkan APIs, or with other instances of the same Vulkan driver? RESOLVED: No. Separate instances of the same Vulkan driver running on the same GPU should have identical internal layout semantics, so applications have the tools they need to ensure views of images are consistent between the two instances. Other APIs will fall into two categories: Those that are Vulkan compatible (a term to be defined by subsequent interopability extensions), or Vulkan incompatible. When sharing images with Vulkan incompatible APIs, the Vulkan image must be transitioned to the VK_IMAGE_LAYOUT_GENERAL layout before handing it off to the external API. Note this does not attempt to address cross-device transitions, nor transitions to engines on the same device which are not visible within the Vulkan API. Both of these are beyond the scope of this extension. 3) Do applications need to call CloseHandle() on the values returned from vkGetMemoryWin32HandleNV when handleType is VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV? RESOLVED: Yes, unless it is passed back in to another driver instance to import the object. A successful get call transfers ownership of the handle to the application, while an import transfers ownership to the associated driver. Destroying the memory object will not destroy the handle or the handles reference to the underlying memory resource. // // Create an exportable memory object and export an external // handle from it. // // Pick an external format and handle type. static const VkFormat format = VK_FORMAT_R8G8B8A8_UNORM; static const VkExternalMemoryHandleTypeFlagsNV handleType = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV; extern VkPhysicalDevice physicalDevice; extern VkDevice device; VkPhysicalDeviceMemoryProperties memoryProperties; VkExternalImageFormatPropertiesNV properties; VkExternalMemoryImageCreateInfoNV externalMemoryImageCreateInfo; VkDedicatedAllocationImageCreateInfoNV dedicatedImageCreateInfo; VkImageCreateInfo imageCreateInfo; VkImage image; VkMemoryRequirements imageMemoryRequirements; uint32_t numMemoryTypes; uint32_t memoryType; VkExportMemoryAllocateInfoNV exportMemoryAllocateInfo; VkDedicatedAllocationMemoryAllocateInfoNV dedicatedAllocationInfo; VkMemoryAllocateInfo memoryAllocateInfo; VkDeviceMemory memory; VkResult result; HANDLE memoryHnd; // Figure out how many memory types the device supports vkGetPhysicalDeviceMemoryProperties(physicalDevice, &memoryProperties); numMemoryTypes = memoryProperties.memoryTypeCount; // Check the external handle type capabilities for the chosen format // Exportable 2D image support with at least 1 mip level, 1 array // layer, and VK_SAMPLE_COUNT_1_BIT using optimal tiling and supporting // texturing and color rendering is required. result = vkGetPhysicalDeviceExternalImageFormatPropertiesNV( physicalDevice, format, VK_IMAGE_TYPE_2D, VK_IMAGE_TILING_OPTIMAL, VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, 0, handleType, &properties); if ((result != VK_SUCCESS) || !(properties.externalMemoryFeatures & VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV)) { abort(); } // Set up the external memory image creation info memset(&externalMemoryImageCreateInfo, 0, sizeof(externalMemoryImageCreateInfo)); externalMemoryImageCreateInfo.sType = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV; externalMemoryImageCreateInfo.handleTypes = handleType; if (properties.externalMemoryFeatures & VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV) { memset(&dedicatedImageCreateInfo, 0, sizeof(dedicatedImageCreateInfo)); dedicatedImageCreateInfo.sType = VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV; dedicatedImageCreateInfo.dedicatedAllocation = VK_TRUE; externalMemoryImageCreateInfo.pNext = &dedicatedImageCreateInfo; } // Set up the core image creation info memset(&imageCreateInfo, 0, sizeof(imageCreateInfo)); imageCreateInfo.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO; imageCreateInfo.pNext = &externalMemoryImageCreateInfo; imageCreateInfo.format = format; imageCreateInfo.extent.width = 64; imageCreateInfo.extent.height = 64; imageCreateInfo.extent.depth = 1; imageCreateInfo.mipLevels = 1; imageCreateInfo.arrayLayers = 1; imageCreateInfo.samples = VK_SAMPLE_COUNT_1_BIT; imageCreateInfo.tiling = VK_IMAGE_TILING_OPTIMAL; imageCreateInfo.usage = VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT; imageCreateInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE; imageCreateInfo.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED; vkCreateImage(device, &imageCreateInfo, NULL, &image); vkGetImageMemoryRequirements(device, image, &imageMemoryRequirements); // For simplicity, just pick the first compatible memory type. for (memoryType = 0; memoryType < numMemoryTypes; memoryType++) { if ((1 << memoryType) & imageMemoryRequirements.memoryTypeBits) { break; } } // At least one memory type must be supported given the prior external // handle capability check. assert(memoryType < numMemoryTypes); // Allocate the external memory object. memset(&exportMemoryAllocateInfo, 0, sizeof(exportMemoryAllocateInfo)); exportMemoryAllocateInfo.sType = VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV; exportMemoryAllocateInfo.handleTypes = handleType; if (properties.externalMemoryFeatures & VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV) { memset(&dedicatedAllocationInfo, 0, sizeof(dedicatedAllocationInfo)); dedicatedAllocationInfo.sType = VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV; dedicatedAllocationInfo.image = image; exportMemoryAllocateInfo.pNext = &dedicatedAllocationInfo; } memset(&memoryAllocateInfo, 0, sizeof(memoryAllocateInfo)); memoryAllocateInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO; memoryAllocateInfo.pNext = &exportMemoryAllocateInfo; memoryAllocateInfo.allocationSize = imageMemoryRequirements.size; memoryAllocateInfo.memoryTypeIndex = memoryType; vkAllocateMemory(device, &memoryAllocateInfo, NULL, &memory); if (!(properties.externalMemoryFeatures & VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV)) { vkBindImageMemory(device, image, memory, 0); } // Get the external memory opaque FD handle vkGetMemoryWin32HandleNV(device, memory, &memoryHnd); Revision 1, 2016-08-11 (James Jones) Initial draft Name String VK_NV_fragment_shader_barycentric Extension Type Device extension Registered Extension Number 204 Revision 1 Ratification Status Not ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 SPIR-V Dependencies SPV_NV_fragment_shader_barycentric Deprecation State Promoted to VK_KHR_fragment_shader_barycentric extension Contact Pat Brown nvpbrown Last Modified Date 2018-08-03 IP Status No known IP claims. Interactions and External Dependencies This extension provides API support for GL_NV_fragment_shader_barycentric Contributors Pat Brown, NVIDIA Daniel Koch, NVIDIA This extension adds support for the following SPIR-V extension in Vulkan: SPV_NV_fragment_shader_barycentric The extension provides access to three additional fragment shader variable decorations in SPIR-V: PerVertexNV, which indicates that a fragment shader input will not have interpolated values, but instead must be accessed with an extra array index that identifies one of the vertices of the primitive producing the fragment BaryCoordNV, which indicates that the variable is a three-component floating-point vector holding barycentric weights for the fragment produced using perspective interpolation BaryCoordNoPerspNV, which indicates that the variable is a three-component floating-point vector holding barycentric weights for the fragment produced using linear interpolation When using GLSL source-based shader languages, the following variables from GL_NV_fragment_shader_barycentric maps to these SPIR-V built-in decorations: in vec3 gl_BaryCoordNV;  BaryCoordNV in vec3 gl_BaryCoordNoPerspNV;  BaryCoordNoPerspNV GLSL variables declared using the __pervertexNV GLSL qualifier are expected to be decorated with PerVertexNV in SPIR-V. All functionality in this extension is included in VK_KHR_fragment_shader_barycentric, with the suffix changed to KHR. Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV VK_NV_FRAGMENT_SHADER_BARYCENTRIC_EXTENSION_NAME VK_NV_FRAGMENT_SHADER_BARYCENTRIC_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV BaryCoordNV BaryCoordNoPerspNV PerVertexNV FragmentBarycentricNV (1) The AMD_shader_explicit_vertex_parameter extension provides similar functionality. Why write a new extension, and how is this extension different? RESOLVED: For the purposes of Vulkan/SPIR-V, we chose to implement a separate extension due to several functional differences. First, the hardware supporting this extension can provide a three-component barycentric weight vector for variables decorated with BaryCoordNV, while variables decorated with BaryCoordSmoothAMD provide only two components. In some cases, it may be more efficient to explicitly interpolate an attribute via: float value = (baryCoordNV.x * v[0].attrib + baryCoordNV.y * v[1].attrib + baryCoordNV.z * v[2].attrib); instead of float value = (baryCoordSmoothAMD.x * (v[0].attrib - v[2].attrib) + baryCoordSmoothAMD.y * (v[1].attrib - v[2].attrib) + v[2].attrib); Additionally, the semantics of the decoration BaryCoordPullModelAMD do not appear to map to anything supported by the initial hardware implementation of this extension. This extension provides a smaller number of decorations than the AMD extension, as we expect that shaders could derive variables decorated with things like BaryCoordNoPerspCentroidAMD with explicit attribute interpolation instructions. One other relevant difference is that explicit per-vertex attribute access using this extension does not require a constant vertex number. (2) Why do the built-in SPIR-V decorations for this extension include two separate built-ins BaryCoordNV and BaryCoordNoPerspNV when a no perspective variable could be decorated with BaryCoordNV and NoPerspective? RESOLVED: The SPIR-V extension for this feature chose to mirror the behavior of the GLSL extension, which provides two built-in variables. Additionally, it is not clear that its a good idea (or even legal) to have two variables using the same attribute, but with different interpolation modifiers. Revision 1, 2018-08-03 (Pat Brown) Internal revisions Name String VK_NV_glsl_shader Extension Type Device extension Registered Extension Number 13 Revision 1 Ratification Status Not ratified Extension and Version Dependencies None Deprecation State Deprecated without replacement Contact Piers Daniell pdaniell-nv Last Modified Date 2016-02-14 IP Status No known IP claims. Contributors Piers Daniell, NVIDIA This extension allows GLSL shaders written to the GL_KHR_vulkan_glsl extension specification to be used instead of SPIR-V. The implementation will automatically detect whether the shader is SPIR-V or GLSL, and compile it appropriately. Functionality in this extension is outside of the scope of Vulkan and is better served by a compiler library such as glslang. No new implementations will support this extension, so applications should not use it. VK_NV_GLSL_SHADER_EXTENSION_NAME VK_NV_GLSL_SHADER_SPEC_VERSION Extending VkResult: VK_ERROR_INVALID_SHADER_NV Example 1 Passing in GLSL code char const vss[] = "#version 450 core\n" "layout(location = 0) in vec2 aVertex;\n" "layout(location = 1) in vec4 aColor;\n" "out vec4 vColor;\n" "void main()\n" "{\n" " vColor = aColor;\n" " gl_Position = vec4(aVertex, 0, 1);\n" "}\n" ; VkShaderModuleCreateInfo vertexShaderInfo = { VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO }; vertexShaderInfo.codeSize = sizeof vss; vertexShaderInfo.pCode = vss; VkShaderModule vertexShader; vkCreateShaderModule(device, &vertexShaderInfo, 0, &vertexShader); Revision 1, 2016-02-14 (Piers Daniell) Initial draft Name String VK_NV_ray_tracing Extension Type Device extension Registered Extension Number 166 Revision 3 Ratification Status Not ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 and VK_KHR_get_memory_requirements2 or Vulkan Version 1.1 API Interactions Interacts with VK_VERSION_1_1 Interacts with VK_EXT_debug_report Interacts with VK_KHR_get_memory_requirements2 SPIR-V Dependencies SPV_NV_ray_tracing Deprecation State Deprecated by VK_KHR_ray_tracing_pipeline extension Contact Eric Werness ewerness-nv Last Modified Date 2018-11-20 Interactions and External Dependencies This extension provides API support for GL_NV_ray_tracing Contributors Eric Werness, NVIDIA Ashwin Lele, NVIDIA Robert Stepinski, NVIDIA Nuno Subtil, NVIDIA Christoph Kubisch, NVIDIA Martin Stich, NVIDIA Daniel Koch, NVIDIA Jeff Bolz, NVIDIA Joshua Barczak, Intel Tobias Hector, AMD Henrik Rydgard, NVIDIA Pascal Gautron, NVIDIA Rasterization has been the dominant method to produce interactive graphics, but increasing performance of graphics hardware has made ray tracing a viable option for interactive rendering. Being able to integrate ray tracing with traditional rasterization makes it easier for applications to incrementally add ray traced effects to existing applications or to do hybrid approaches with rasterization for primary visibility and ray tracing for secondary queries. To enable ray tracing, this extension adds a few different categories of new functionality: Acceleration structure objects and build commands A new pipeline type with new shader domains An indirection table to link shader groups with acceleration structure items This extension adds support for the following SPIR-V extension in Vulkan: SPV_NV_ray_tracing VkAccelerationStructureNV vkBindAccelerationStructureMemoryNV vkCmdBuildAccelerationStructureNV vkCmdCopyAccelerationStructureNV vkCmdTraceRaysNV vkCmdWriteAccelerationStructuresPropertiesNV vkCompileDeferredNV vkCreateAccelerationStructureNV vkCreateRayTracingPipelinesNV vkDestroyAccelerationStructureNV vkGetAccelerationStructureHandleNV vkGetAccelerationStructureMemoryRequirementsNV vkGetRayTracingShaderGroupHandlesNV VkAabbPositionsNV VkAccelerationStructureCreateInfoNV VkAccelerationStructureInfoNV VkAccelerationStructureInstanceNV VkAccelerationStructureMemoryRequirementsInfoNV VkBindAccelerationStructureMemoryInfoNV VkGeometryAABBNV VkGeometryDataNV VkGeometryNV VkGeometryTrianglesNV VkRayTracingPipelineCreateInfoNV VkRayTracingShaderGroupCreateInfoNV VkTransformMatrixNV Extending VkPhysicalDeviceProperties2: VkPhysicalDeviceRayTracingPropertiesNV Extending VkWriteDescriptorSet: VkWriteDescriptorSetAccelerationStructureNV If VK_KHR_get_memory_requirements2 or Vulkan Version 1.1 is supported: VkMemoryRequirements2KHR VkAccelerationStructureMemoryRequirementsTypeNV VkAccelerationStructureTypeNV VkBuildAccelerationStructureFlagBitsNV VkCopyAccelerationStructureModeNV VkGeometryFlagBitsNV VkGeometryInstanceFlagBitsNV VkGeometryTypeNV VkRayTracingShaderGroupTypeNV VkBuildAccelerationStructureFlagsNV VkGeometryFlagsNV VkGeometryInstanceFlagsNV VK_NV_RAY_TRACING_EXTENSION_NAME VK_NV_RAY_TRACING_SPEC_VERSION VK_SHADER_UNUSED_NV Extending VkAccelerationStructureTypeKHR: VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_NV VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_NV Extending VkAccessFlagBits: VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV Extending VkBufferUsageFlagBits: VK_BUFFER_USAGE_RAY_TRACING_BIT_NV Extending VkBuildAccelerationStructureFlagBitsKHR: VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_NV VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NV VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_NV VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NV VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_NV Extending VkCopyAccelerationStructureModeKHR: VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_NV VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_NV Extending VkDescriptorType: VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV Extending VkGeometryFlagBitsKHR: VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_NV VK_GEOMETRY_OPAQUE_BIT_NV Extending VkGeometryInstanceFlagBitsKHR: VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_NV VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_NV VK_GEOMETRY_INSTANCE_TRIANGLE_CULL_DISABLE_BIT_NV VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_NV Extending VkGeometryTypeKHR: VK_GEOMETRY_TYPE_AABBS_NV VK_GEOMETRY_TYPE_TRIANGLES_NV Extending VkIndexType: VK_INDEX_TYPE_NONE_NV Extending VkObjectType: VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV Extending VkPipelineBindPoint: VK_PIPELINE_BIND_POINT_RAY_TRACING_NV Extending VkPipelineCreateFlagBits: VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV Extending VkPipelineStageFlagBits: VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV Extending VkQueryType: VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV Extending VkRayTracingShaderGroupTypeKHR: VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV Extending VkShaderStageFlagBits: VK_SHADER_STAGE_ANY_HIT_BIT_NV VK_SHADER_STAGE_CALLABLE_BIT_NV VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV VK_SHADER_STAGE_INTERSECTION_BIT_NV VK_SHADER_STAGE_MISS_BIT_NV VK_SHADER_STAGE_RAYGEN_BIT_NV Extending VkStructureType: VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV VK_STRUCTURE_TYPE_GEOMETRY_NV VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV If VK_EXT_debug_report is supported: Extending VkDebugReportObjectTypeEXT: VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV_EXT LaunchIdNV LaunchSizeNV WorldRayOriginNV WorldRayDirectionNV ObjectRayOriginNV ObjectRayDirectionNV RayTminNV RayTmaxNV InstanceCustomIndexNV InstanceId ObjectToWorldNV WorldToObjectNV HitTNV HitKindNV IncomingRayFlagsNV (modified)PrimitiveId RayTracingNV 1) Are there issues? RESOLVED: Yes. Example ray generation GLSL shader #version 450 core #extension GL_NV_ray_tracing : require layout(set = 0, binding = 0, rgba8) uniform image2D image; layout(set = 0, binding = 1) uniform accelerationStructureNV as; layout(location = 0) rayPayloadNV float payload; void main() { vec4 col = vec4(0, 0, 0, 1); vec3 origin = vec3(float(gl_LaunchIDNV.x)/float(gl_LaunchSizeNV.x), float(gl_LaunchIDNV.y)/float(gl_LaunchSizeNV.y), 1.0); vec3 dir = vec3(0.0, 0.0, -1.0); traceNV(as, 0, 0xff, 0, 1, 0, origin, 0.0, dir, 1000.0, 0); col.y = payload; imageStore(image, ivec2(gl_LaunchIDNV.xy), col); } Revision 1, 2018-09-11 (Robert Stepinski, Nuno Subtil, Eric Werness) Internal revisions Revision 2, 2018-10-19 (Eric Werness) rename to VK_NV_ray_tracing, add support for callables. too many updates to list Revision 3, 2018-11-20 (Daniel Koch) update to use InstanceId instead of InstanceIndex as implemented. Name String VK_NV_win32_keyed_mutex Extension Type Device extension Registered Extension Number 59 Revision 2 Ratification Status Not ratified Extension and Version Dependencies VK_NV_external_memory_win32 Deprecation State Promoted to VK_KHR_win32_keyed_mutex extension Contact Carsten Rohde crohde Last Modified Date 2016-08-19 IP Status No known IP claims. Contributors James Jones, NVIDIA Carsten Rohde, NVIDIA Applications that wish to import Direct3D 11 memory objects into the Vulkan API may wish to use the native keyed mutex mechanism to synchronize access to the memory between Vulkan and Direct3D. This extension provides a way for an application to access the keyed mutex associated with an imported Vulkan memory object when submitting command buffers to a queue. Extending VkSubmitInfo, VkSubmitInfo2: VkWin32KeyedMutexAcquireReleaseInfoNV VK_NV_WIN32_KEYED_MUTEX_EXTENSION_NAME VK_NV_WIN32_KEYED_MUTEX_SPEC_VERSION Extending VkStructureType: VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV // // Import a memory object from Direct3D 11, and synchronize // access to it in Vulkan using keyed mutex objects. // extern VkPhysicalDevice physicalDevice; extern VkDevice device; extern HANDLE sharedNtHandle; static const VkFormat format = VK_FORMAT_R8G8B8A8_UNORM; static const VkExternalMemoryHandleTypeFlagsNV handleType = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV; VkPhysicalDeviceMemoryProperties memoryProperties; VkExternalImageFormatPropertiesNV properties; VkExternalMemoryImageCreateInfoNV externalMemoryImageCreateInfo; VkImageCreateInfo imageCreateInfo; VkImage image; VkMemoryRequirements imageMemoryRequirements; uint32_t numMemoryTypes; uint32_t memoryType; VkImportMemoryWin32HandleInfoNV importMemoryInfo; VkMemoryAllocateInfo memoryAllocateInfo; VkDeviceMemory mem; VkResult result; // Figure out how many memory types the device supports vkGetPhysicalDeviceMemoryProperties(physicalDevice, &memoryProperties); numMemoryTypes = memoryProperties.memoryTypeCount; // Check the external handle type capabilities for the chosen format // Importable 2D image support with at least 1 mip level, 1 array // layer, and VK_SAMPLE_COUNT_1_BIT using optimal tiling and supporting // texturing and color rendering is required. result = vkGetPhysicalDeviceExternalImageFormatPropertiesNV( physicalDevice, format, VK_IMAGE_TYPE_2D, VK_IMAGE_TILING_OPTIMAL, VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, 0, handleType, &properties); if ((result != VK_SUCCESS) || !(properties.externalMemoryFeatures & VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV)) { abort(); } // Set up the external memory image creation info memset(&externalMemoryImageCreateInfo, 0, sizeof(externalMemoryImageCreateInfo)); externalMemoryImageCreateInfo.sType = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV; externalMemoryImageCreateInfo.handleTypes = handleType; // Set up the core image creation info memset(&imageCreateInfo, 0, sizeof(imageCreateInfo)); imageCreateInfo.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO; imageCreateInfo.pNext = &externalMemoryImageCreateInfo; imageCreateInfo.format = format; imageCreateInfo.extent.width = 64; imageCreateInfo.extent.height = 64; imageCreateInfo.extent.depth = 1; imageCreateInfo.mipLevels = 1; imageCreateInfo.arrayLayers = 1; imageCreateInfo.samples = VK_SAMPLE_COUNT_1_BIT; imageCreateInfo.tiling = VK_IMAGE_TILING_OPTIMAL; imageCreateInfo.usage = VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT; imageCreateInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE; imageCreateInfo.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED; vkCreateImage(device, &imageCreateInfo, NULL, &image); vkGetImageMemoryRequirements(device, image, &imageMemoryRequirements); // For simplicity, just pick the first compatible memory type. for (memoryType = 0; memoryType < numMemoryTypes; memoryType++) { if ((1 << memoryType) & imageMemoryRequirements.memoryTypeBits) { break; } } // At least one memory type must be supported given the prior external // handle capability check. assert(memoryType < numMemoryTypes); // Allocate the external memory object. memset(&exportMemoryAllocateInfo, 0, sizeof(exportMemoryAllocateInfo)); exportMemoryAllocateInfo.sType = VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV; importMemoryInfo.handleTypes = handleType; importMemoryInfo.handle = sharedNtHandle; memset(&memoryAllocateInfo, 0, sizeof(memoryAllocateInfo)); memoryAllocateInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO; memoryAllocateInfo.pNext = &exportMemoryAllocateInfo; memoryAllocateInfo.allocationSize = imageMemoryRequirements.size; memoryAllocateInfo.memoryTypeIndex = memoryType; vkAllocateMemory(device, &memoryAllocateInfo, NULL, &mem); vkBindImageMemory(device, image, mem, 0); ... const uint64_t acquireKey = 1; const uint32_t timeout = INFINITE; const uint64_t releaseKey = 2; VkWin32KeyedMutexAcquireReleaseInfoNV keyedMutex = { VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV }; keyedMutex.acquireCount = 1; keyedMutex.pAcquireSyncs = &mem; keyedMutex.pAcquireKeys = &acquireKey; keyedMutex.pAcquireTimeoutMilliseconds = &timeout; keyedMutex.releaseCount = 1; keyedMutex.pReleaseSyncs = &mem; keyedMutex.pReleaseKeys = &releaseKey; VkSubmitInfo submit_info = { VK_STRUCTURE_TYPE_SUBMIT_INFO, &keyedMutex }; submit_info.commandBufferCount = 1; submit_info.pCommandBuffers = &cmd_buf; vkQueueSubmit(queue, 1, &submit_info, VK_NULL_HANDLE); Revision 2, 2016-08-11 (James Jones) Updated sample code based on the NV external memory extensions. Renamed from NVX to NV extension. Added Overview and Description sections. Updated sample code to use the NV external memory extensions. Revision 1, 2016-06-14 (Carsten Rohde) Initial draft. Name String VK_QCOM_fragment_density_map_offset Extension Type Device extension Registered Extension Number 426 Revision 3 Ratification Status Not ratified Extension and Version Dependencies VK_KHR_get_physical_device_properties2 or Vulkan Version 1.1 and VK_EXT_fragment_density_map Deprecation State Promoted to VK_EXT_fragment_density_map_offset extension Contact Matthew Netsch mnetsch Last Modified Date 2024-06-17 Contributors Matthew Netsch, Qualcomm Technologies, Inc. Jonathan Wicks, Qualcomm Technologies, Inc. Jonathan Tinkham, Qualcomm Technologies, Inc. Jeff Leger, Qualcomm Technologies, Inc. Manan Katwala, Qualcomm Technologies, Inc. Connor Abbott, Valve Corporation This extension allows an application to specify offsets to a fragment density map attachment, changing the location where the fragment density map is applied to the framebuffer. This is helpful for eye-tracking use cases where the fovea needs to be moved around the framebuffer to match the eye pose. Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM Extending VkPhysicalDeviceProperties2: VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM Extending VkSubpassEndInfo, VkRenderingEndInfoEXT: VkSubpassFragmentDensityMapOffsetEndInfoQCOM VK_QCOM_FRAGMENT_DENSITY_MAP_OFFSET_EXTENSION_NAME VK_QCOM_FRAGMENT_DENSITY_MAP_OFFSET_SPEC_VERSION Extending VkImageCreateFlagBits: VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM Extending VkStructureType: VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM VK_STRUCTURE_TYPE_SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM Revision 3, 2025-03-20 (Connor Abbott/Matthew Netsch) Fix clamp equation and clarify the offsets are FDM relative (editorial only) Revision 2, 2024-06-17 (Matthew Netsch) Fix typo in spec regarding fragmentDensityMapOffset feature Revision 1, 2021-09-03 (Matthew Netsch) Initial version Name String VK_VALVE_mutable_descriptor_type Extension Type Device extension Registered Extension Number 352 Revision 1 Ratification Status Not ratified Extension and Version Dependencies VK_KHR_maintenance3 Deprecation State Promoted to VK_EXT_mutable_descriptor_type extension Special Use D3D support Contact Joshua Ashton Joshua-Ashton Hans-Kristian Arntzen HansKristian-Work Last Modified Date 2020-12-02 IP Status No known IP claims. Contributors Joshua Ashton, Valve Hans-Kristian Arntzen, Valve This extension allows applications to reduce descriptor memory footprint by allowing a descriptor to be able to mutate to a given list of descriptor types depending on which descriptor types are written into, or copied into a descriptor set. The main use case this extension intends to address is descriptor indexing with VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT where the descriptor types are completely generic, as this means applications can allocate one large descriptor set, rather than having one large descriptor set per descriptor type, which significantly bloats descriptor memory usage and causes performance issues. This extension also adds a mechanism to declare that a descriptor pool, and therefore the descriptor sets that are allocated from it, reside only in host memory; as such these descriptors can only be updated/copied, but not bound. These features together allow much more efficient emulation of the raw D3D12 binding model. This extension is primarily intended to be useful for API layering efforts. VkMutableDescriptorTypeListVALVE Extending VkDescriptorSetLayoutCreateInfo, VkDescriptorPoolCreateInfo: VkMutableDescriptorTypeCreateInfoVALVE Extending VkPhysicalDeviceFeatures2, VkDeviceCreateInfo: VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE VK_VALVE_MUTABLE_DESCRIPTOR_TYPE_EXTENSION_NAME VK_VALVE_MUTABLE_DESCRIPTOR_TYPE_SPEC_VERSION Extending VkDescriptorPoolCreateFlagBits: VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_VALVE Extending VkDescriptorSetLayoutCreateFlagBits: VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_VALVE Extending VkDescriptorType: VK_DESCRIPTOR_TYPE_MUTABLE_VALVE Extending VkStructureType: VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_VALVE VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_VALVE Revision 1, 2020-12-01 (Joshua Ashton, Hans-Kristian Arntzen) Initial specification, squashed from public draft.

# Image Operations

## Metadata

- **Component**: spec
- **Version**: latest
- **URL**: /spec/latest/chapters/textures.html

## Table of Contents

- [Image Operations Overview](#_image_operations_overview)
- [Image_Operations_Overview](#_image_operations_overview)
- [Texel Coordinate Systems](#textures-texel-coordinate-systems)
- [Texel_Coordinate_Systems](#textures-texel-coordinate-systems)
- [Conversion Formulas](#_conversion_formulas)
- [RGB to Shared Exponent Conversion](#textures-RGB-sexp)
- [RGB_to_Shared_Exponent_Conversion](#textures-RGB-sexp)
- [Shared Exponent to RGB](#textures-sexp-RGB)
- [Shared_Exponent_to_RGB](#textures-sexp-RGB)
- [Texel Input Operations](#textures-input)
- [Texel_Input_Operations](#textures-input)
- [Texel Input Validation Operations](#textures-input-validation)
- [Texel_Input_Validation_Operations](#textures-input-validation)
- [Instruction/Sampler/Image View Validation](#textures-operation-validation)
- [Instruction/Sampler/Image_View_Validation](#textures-operation-validation)
- [Integer Texel Coordinate Validation](#textures-integer-coordinate-validation)
- [Integer_Texel_Coordinate_Validation](#textures-integer-coordinate-validation)
- [Cube Map Edge Handling](#textures-cubemapedge)
- [Cube_Map_Edge_Handling](#textures-cubemapedge)
- [Sparse Validation](#textures-sparse-validation)
- [Layout Validation](#textures-layout-validation)
- [Format Conversion](#textures-format-conversion)
- [Texel Replacement](#textures-texel-replacement)
- [Depth Compare Operation](#textures-depth-compare-operation)
- [Depth_Compare_Operation](#textures-depth-compare-operation)
- [Conversion to RGBA](#textures-conversion-to-rgba)
- [Conversion_to_RGBA](#textures-conversion-to-rgba)
- [Component Swizzle](#textures-component-swizzle)
- [Sparse Residency](#textures-sparse-residency)
- [Chroma Reconstruction](#textures-chroma-reconstruction)
- [Explicit Reconstruction](#textures-explicit-reconstruction)
- [Implicit Reconstruction](#textures-implict-reconstruction)
- [Sampler Y′CBCR Conversion](#textures-sampler-YCbCr-conversion)
- [Sampler_Y′CBCR_Conversion](#textures-sampler-YCbCr-conversion)
- [Sampler Y′CBCR Range Expansion](#textures-sampler-YCbCr-conversion-rangeexpand)
- [Sampler_Y′CBCR_Range_Expansion](#textures-sampler-YCbCr-conversion-rangeexpand)
- [Sampler Y′CBCR Model Conversion](#textures-sampler-YCbCr-conversion-modelconversion)
- [Sampler_Y′CBCR_Model_Conversion](#textures-sampler-YCbCr-conversion-modelconversion)
- [Texel Output Operations](#_texel_output_operations)
- [Texel_Output_Operations](#_texel_output_operations)
- [Texel Output Validation Operations](#textures-output-validation)
- [Texel_Output_Validation_Operations](#textures-output-validation)
- [Texel Format Validation](#textures-format-validation)
- [Texel_Format_Validation](#textures-format-validation)
- [Texel Type Validation](#textures-type-validation)
- [Texel_Type_Validation](#textures-type-validation)
- [Integer Texel Coordinate Validation](#textures-output-coordinate-validation)
- [Integer_Texel_Coordinate_Validation](#textures-output-coordinate-validation)
- [Sparse Texel Operation](#textures-output-sparse-validation)
- [Sparse_Texel_Operation](#textures-output-sparse-validation)
- [Texel Output Format Conversion](#textures-output-format-conversion)
- [Texel_Output_Format_Conversion](#textures-output-format-conversion)
- [Normalized Texel Coordinate Operations](#textures-normalized-operations)
- [Normalized_Texel_Coordinate_Operations](#textures-normalized-operations)
- [Projection Operation](#textures-projection)
- [Derivative Image Operations](#textures-derivative-image-operations)
- [Derivative_Image_Operations](#textures-derivative-image-operations)
- [Cube Map Face Selection and Transformations](#_cube_map_face_selection_and_transformations)
- [Cube_Map_Face_Selection_and_Transformations](#_cube_map_face_selection_and_transformations)
- [Cube Map Face Selection](#_cube_map_face_selection)
- [Cube_Map_Face_Selection](#_cube_map_face_selection)
- [Cube Map Coordinate Transformation](#textures-cube-map-coordinate-transform)
- [Cube_Map_Coordinate_Transformation](#textures-cube-map-coordinate-transform)
- [Cube Map Derivative Transformation](#_cube_map_derivative_transformation)
- [Cube_Map_Derivative_Transformation](#_cube_map_derivative_transformation)
- [Scale Factor Operation, LOD Operation and Image Level(s) Selection](#textures-lod-and-scale-factor)
- [Scale_Factor_Operation,_LOD_Operation_and_Image_Level(s)_Selection](#textures-lod-and-scale-factor)
- [Scale Factor Operation](#textures-scale-factor)
- [Scale_Factor_Operation](#textures-scale-factor)
- [LOD Operation](#textures-level-of-detail-operation)
- [Image Level(s) Selection](#textures-image-level-selection)
- [Image_Level(s)_Selection](#textures-image-level-selection)
- [(s,t,r,q,a) to (u,v,w,a) Transformation](#textures-normalized-to-unnormalized)
- [(s,t,r,q,a)_to_(u,v,w,a)_Transformation](#textures-normalized-to-unnormalized)
- [Unnormalized Texel Coordinate Operations](#_unnormalized_texel_coordinate_operations)
- [Unnormalized_Texel_Coordinate_Operations](#_unnormalized_texel_coordinate_operations)
- [(u,v,w,a) to (i,j,k,l,n) Transformation and Array Layer Selection](#textures-unnormalized-to-integer)
- [(u,v,w,a)_to_(i,j,k,l,n)_Transformation_and_Array_Layer_Selection](#textures-unnormalized-to-integer)
- [Integer Texel Coordinate Operations](#textures-integer-coordinate-operations)
- [Integer_Texel_Coordinate_Operations](#textures-integer-coordinate-operations)
- [Image Sample Operations](#textures-sample-operations)
- [Image_Sample_Operations](#textures-sample-operations)
- [Wrapping Operation](#textures-wrapping-operation)
- [Texel Gathering](#textures-gather)
- [Texel Filtering](#textures-texel-filtering)
- [Texel Nearest Filtering](#textures-texel-nearest-filtering)
- [Texel_Nearest_Filtering](#textures-texel-nearest-filtering)
- [Texel Linear Filtering](#textures-texel-linear-filtering)
- [Texel_Linear_Filtering](#textures-texel-linear-filtering)
- [Texel Cubic Filtering](#textures-texel-cubic-filtering)
- [Texel_Cubic_Filtering](#textures-texel-cubic-filtering)
- [Texel Range Clamp](#textures-texel-range-clamp)
- [Texel_Range_Clamp](#textures-texel-range-clamp)
- [Texel Mipmap Filtering](#textures-texel-mipmap-filtering)
- [Texel_Mipmap_Filtering](#textures-texel-mipmap-filtering)
- [Texel Anisotropic Filtering](#textures-texel-anisotropic-filtering)
- [Texel_Anisotropic_Filtering](#textures-texel-anisotropic-filtering)
- [Texel Footprint Evaluation](#textures-footprint)
- [Texel_Footprint_Evaluation](#textures-footprint)
- [Weight Image Sampling](#textures-weightimage)
- [Weight_Image_Sampling](#textures-weightimage)
- [Weight Image Layout](#textures-weightimage-layout)
- [Weight_Image_Layout](#textures-weightimage-layout)
- [2D Non-Separable Weight Filters](#_2d_non_separable_weight_filters)
- [2D_Non-Separable_Weight_Filters](#_2d_non_separable_weight_filters)
- [1D Separable Weight Filters](#_1d_separable_weight_filters)
- [1D_Separable_Weight_Filters](#_1d_separable_weight_filters)
- [Weight Sampling Phases](#textures-weightimage-filterphases)
- [Weight_Sampling_Phases](#textures-weightimage-filterphases)
- [Weight Sampler Parameters](#textures-weightimage-sampler)
- [Weight_Sampler_Parameters](#textures-weightimage-sampler)
- [Weight Sampling Operation](#textures-weightimage-filteroperation)
- [Weight_Sampling_Operation](#textures-weightimage-filteroperation)
- [Block Matching](#textures-blockmatch)
- [Block Matching Sampler Parameters](#textures-blockmatch-sampler)
- [Block_Matching_Sampler_Parameters](#textures-blockmatch-sampler)
- [Block Matching Operation](#textures-blockmatch-filteroperation)
- [Block_Matching_Operation](#textures-blockmatch-filteroperation)
- [Block Matching Window Operation](#textures-blockmatchwindow-filteroperation)
- [Block_Matching_Window_Operation](#textures-blockmatchwindow-filteroperation)
- [Block Matching Gather Operation](#textures-blockmatchgather-filteroperation)
- [Block_Matching_Gather_Operation](#textures-blockmatchgather-filteroperation)
- [Box Filter Sampling](#textures-boxfilter)
- [Box_Filter_Sampling](#textures-boxfilter)
- [Box Filter Sampler Parameters](#textures-boxfilter-sampler)
- [Box_Filter_Sampler_Parameters](#textures-boxfilter-sampler)
- [Box Filter Operation](#textures-boxfilter-filteroperation)
- [Box_Filter_Operation](#textures-boxfilter-filteroperation)
- [Image Operation Steps](#textures-instructions)
- [Image_Operation_Steps](#textures-instructions)
- [Image Query Instructions](#textures-queries)
- [Image_Query_Instructions](#textures-queries)
- [Image Property Queries](#_image_property_queries)
- [Image_Property_Queries](#_image_property_queries)
- [LOD Query](#_lod_query)

## Content

Vulkan Image Operations are operations performed by those SPIR-V Image Instructions which take an OpTypeImage (representing a VkImageView) or OpTypeSampledImage (representing a (VkImageView, VkSampler) pair). Read, write, and atomic operations also take texel coordinates as operands, and return a value based on a neighborhood of texture elements (texels) within the image. Query operations return properties of the bound image or of the lookup itself. The “Depth” operand of OpTypeImage is ignored. Texel is a term which is a combination of the words texture and element. Early interactive computer graphics supported texture operations on textures, a small subset of the image operations on images described here. The discrete samples remain essentially equivalent, however, so we retain the historical term texel to refer to them. Image Operations include the functionality of the following SPIR-V Image Instructions: OpImageSample* and OpImageSparseSample* read one or more neighboring texels of the image, and filter the texel values based on the state of the sampler. Instructions with ImplicitLod in the name determine the LOD used in the sampling operation based on the coordinates used in neighboring fragments. Instructions with ExplicitLod in the name determine the LOD used in the sampling operation based on additional coordinates. Instructions with Proj in the name apply homogeneous projection to the coordinates. OpImageFetch and OpImageSparseFetch return a single texel of the image. No sampler is used. OpImage*Gather and OpImageSparse*Gather read neighboring texels and return a single component of each. OpImageRead (and OpImageSparseRead) and OpImageWrite read and write, respectively, a texel in the image. No sampler is used. OpImageSampleFootprintNV identifies and returns information about the set of texels in the image that would be accessed by an equivalent OpImageSample* instruction. OpImage*Dref* instructions apply depth comparison on the texel values. OpImageSparse* instructions additionally return a sparse residency code. OpImageQuerySize, OpImageQuerySizeLod, OpImageQueryLevels, and OpImageQuerySamples return properties of the image descriptor that would be accessed. The image itself is not accessed. OpImageQueryLod returns the LOD parameters that would be used in a sample operation. The actual operation is not performed. OpImageWeightedSampleQCOM reads a 2D neighborhood of texels and computes a weighted average using weight values from a separate weight texture. opImageBlockMatchSADQCOM and opTextureBlockMatchSSD compare 2D neighborhoods of texels from two textures. OpImageBoxFilterQCOM reads a 2D neighborhood of texels and computes a weighted average of the texels. opImageBlockMatchWindowSADQCOM and opImageBlockMatchWindowSSDQCOM compare 2D neighborhoods of texels from two textures with the comparison repeated across a window region in the target texture. opImageBlockMatchGatherSADQCOM and opImageBlockMatchWindowSSDQCOM compares four 2D neighborhoods of texels from a target texture with a single 2D neighborhood in the reference texture. The R component of each comparison is gathered and returned in the output. Images are addressed by texel coordinates. There are three texel coordinate systems: normalized texel coordinates [0.0, 1.0] unnormalized texel coordinates [0.0, width / height / depth) integer texel coordinates [0, width / height / depth) SPIR-V OpImageFetch, OpImageSparseFetch, OpImageRead, OpImageSparseRead, opImageBlockMatchSADQCOM, opImageBlockMatchSSDQCOM, opImageBlockMatchWindowSADQCOM, opImageBlockMatchWindowSSDQCOM, and OpImageWrite instructions use integer texel coordinates. Other image instructions can use either normalized or unnormalized texel coordinates (selected by the unnormalizedCoordinates state of the sampler used in the instruction), but there are limitations on what operations, image state, and sampler state is supported. Normalized coordinates are logically converted to unnormalized as part of image operations, and certain steps are only performed on normalized coordinates. The array layer coordinate is always treated as unnormalized even when other coordinates are normalized. Normalized texel coordinates are referred to as (s,t,r,q,a), with the coordinates having the following meanings: s: Coordinate in the first dimension of an image. t: Coordinate in the second dimension of an image. r: Coordinate in the third dimension of an image. (s,t,r) are interpreted as a direction vector for Cube images. q: Fourth coordinate, for homogeneous (projective) coordinates. a: Coordinate for array layer. The coordinates are extracted from the SPIR-V operand based on the dimensionality of the image variable and type of instruction. For Proj instructions, the components are in order (s, [t,] [r,] q), with t and r being conditionally present based on the Dim of the image. For non-Proj instructions, the coordinates are (s [,t] [,r] [,a]), with t and r being conditionally present based on the Dim of the image and a being conditionally present based on the Arrayed property of the image. Projective image instructions are not supported on Arrayed images. Unnormalized texel coordinates are referred to as (u,v,w,a), with the coordinates having the following meanings: u: Coordinate in the first dimension of an image. v: Coordinate in the second dimension of an image. w: Coordinate in the third dimension of an image. a: Coordinate for array layer. Only the u and v coordinates are directly extracted from the SPIR-V operand, because only 1D and 2D (non-Arrayed) dimensionalities support unnormalized coordinates. The components are in order (u [,v]), with v being conditionally present when the dimensionality is 2D. When normalized coordinates are converted to unnormalized coordinates, all four coordinates are used. Integer texel coordinates are referred to as (i,j,k,l,n), with the coordinates having the following meanings: i: Coordinate in the first dimension of an image. j: Coordinate in the second dimension of an image. k: Coordinate in the third dimension of an image. l: Coordinate for array layer. n: Index of the sample within the texel. They are extracted from the SPIR-V operand in order (i [,j] [,k] [,l] [,n]), with j and k conditionally present based on the Dim of the image, and l conditionally present based on the Arrayed property of the image. n is conditionally present and is taken from the Sample image operand. If an accessed image was created from a view using VkImageViewSlicedCreateInfoEXT and accessed through a VK_DESCRIPTOR_TYPE_STORAGE_IMAGE descriptor, then the value of k is incremented by VkImageViewSlicedCreateInfoEXT::sliceOffset, giving k ← sliceOffset + k. The image’s accessible range in the third dimension is k 1, sampling is anisotropic. The sampling rate (N) is derived as: N = ⌈η⌉ An implementation may round N up to the nearest supported sampling rate. An implementation may use the value of N as an approximation of η. The LOD parameter λ is computed as follows: where: and maxSamplerLodBias is the value of the VkPhysicalDeviceLimits feature maxSamplerLodBias. The image level(s) d, dhi, and dlo which texels are read from are determined by an image-level parameter dl, which is computed based on the LOD parameter, as follows: where: and: baseMipLevel and levelCount are taken from the subresourceRange of the image view. minLodimageView must be less or equal to levelbase + q. If the sampler’s mipmapMode is VK_SAMPLER_MIPMAP_MODE_NEAREST, then the level selected is d = dl. If the sampler’s mipmapMode is VK_SAMPLER_MIPMAP_MODE_LINEAR, two neighboring levels are selected: δ is the fractional value, quantized to the number of mipmap precision bits, used for linear filtering between levels. The normalized texel coordinates are scaled by the image level dimensions and the array layer is selected. This transformation is performed once for each level used in filtering (either d, or dhi and dlo). where: widthscale = widthlevel heightscale = heightlevel depthscale = depthlevel for conventional images, and: widthscale = widthlevel - 1 heightscale = heightlevel - 1 depthscale = depthlevel - 1 for corner-sampled images. and where (Δi, Δj, Δk) are taken from the image instruction if it includes a ConstOffset or Offset operand, otherwise they are taken to be zero. Operations then proceed to Unnormalized Texel Coordinate Operations. The unnormalized texel coordinates are transformed to integer texel coordinates relative to the selected mipmap level. The layer index l is computed as: l = clamp(RNE(a), 0, layerCount - 1) + baseArrayLayer where layerCount is the number of layers in the image subresource range of the image view, baseArrayLayer is the first layer from the subresource range, and where: The sample index n is assigned the value 0. Nearest filtering (VK_FILTER_NEAREST) computes the integer texel coordinates that the unnormalized coordinates lie within: where: shift = 0.0 for conventional images, and: shift = 0.5 for corner-sampled images. Linear filtering (VK_FILTER_LINEAR) computes a set of neighboring coordinates which bound the unnormalized coordinates. The integer texel coordinates are combinations of i0 or i1, j0 or j1, k0 or k1, as well as weights α, β, and γ. where: shift = 0.5 for conventional images, and: shift = 0.0 for corner-sampled images, and where: where the number of fraction bits retained is specified by VkPhysicalDeviceLimits::subTexelPrecisionBits. Cubic filtering (VK_FILTER_CUBIC_EXT) computes a set of neighboring coordinates which bound the unnormalized coordinates. The integer texel coordinates are combinations of i0, i1, i2 or i3, j0, j1, j2 or j3, k0, k1, k2 or k3, as well as weights α, β, and γ. where: where the number of fraction bits retained is specified by VkPhysicalDeviceLimits::subTexelPrecisionBits. Integer texel coordinate operations may supply a LOD which texels are to be read from or written to using the optional SPIR-V operand Lod. If the Lod is provided then it must be an integer. The image level selected is: If d does not lie in the range [baseMipLevel, baseMipLevel + levelCount) or d is less than minLodIntegerimageView, then any values fetched are zero if the robustImageAccess2 feature is enabled, otherwise are undefined, and any writes (if supported) are discarded. If the used sampler was created without VK_SAMPLER_CREATE_NON_SEAMLESS_CUBE_MAP_BIT_EXT, Cube images ignore the wrap modes specified in the sampler. Instead, if VK_FILTER_NEAREST is used within a mip level then VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE is used, and if VK_FILTER_LINEAR is used within a mip level then sampling at the edges is performed as described earlier in the Cube map edge handling section. The first integer texel coordinate i is transformed based on the addressModeU parameter of the sampler. where: j (for 2D and Cube image) and k (for 3D image) are similarly transformed based on the addressModeV and addressModeW parameters of the sampler, respectively. SPIR-V instructions with Gather in the name return a vector derived from 4 texels in the base level of the image view. The rules for the VK_FILTER_LINEAR minification filter are applied to identify the four selected texels. Each texel is then converted to an RGBA value according to conversion to RGBA and then swizzled. A four-component vector is then assembled by taking the component indicated by the Component value in the instruction from the swizzled color value of the four texels. If the operation does not use the ConstOffsets image operand then the four texels form the 2 × 2 rectangle used for texture filtering: If the operation does use the ConstOffsets image operand then the offsets allow a custom filter to be defined: where: OpImage*Gather must not be used on a sampled image with sampler Y′CBCR conversion enabled. If levelbase maxSAD) { maxSAD = SAD; maxCoord = uvec2(x,y); } } } if (compareMode==MIN) { return vec4(minSAD, minCoord.x, minCoord.y, 0.0); } else { return vec4(maxSAD, maxCoord.x, maxCoord.y, 0.0); } } Block matching Gather SPIR-V instructions opImageBlockMatchGatherSAD and opImageBlockMatchGatherSSD specify two sets of 2D integer texel coordinates: target coordinates and reference coordinates . These instructions perform the block matching operation 4 times, using integer target coordinates , , , and . The R component from each of those 4 operations is gathered and returned in the R, G, B, and A components of the output respectively. For each block match operation, the reference coordinate is . For each block match operation, only the R component of the target and reference images are compared. The following pseudocode describes the operation opImageBlockMatchGatherSAD. The pseudocode for opImageBlockMatchGatherSSD follows an identical pattern. vec4 opImageBlockMatchGatherSAD(sampler2D target, uvec2 targetCoord, samler2D reference, uvec2 refCoord, uvec2 blocksize) { vec4 out; for (uint x=0, x<4; x++) { float SAD = textureBlockMatchSAD(target, targetCoord + uvec2(x, 0), reference, refCoord, blocksize).x; if (x == 0) { out.x = SAD; } if (x == 1) { out.y = SAD; } if (x == 2) { out.z = SAD; } if (x == 3) { out.w = SAD; } } return out; } The SPIR-V instruction OpImageBoxFilterQCOM specifies texture box filtering operation where a weighted average of a region of texels is computed, with the weights proportional to the coverage of each of the texels. In addition to the inputs that would be accepted by an equivalent OpImageSample* instruction, OpImageBoxFilterQCOM accepts one additional input, boxSize which specifies the width and height in texels of the region to be averaged. The figure below shows an example of using OpImageBoxFilterQCOM to sample from a 8 × 4 texel two-dimensional image, with unnormalized texture coordinates (4.125, 2.625) and boxSize of (2.75, 2.25). The filter will read 12 texel values and compute a weights based portion of each texel covered by the box. Figure 12. Box Filter Sampling Example If boxSize has height and width both equal to 1.0, then this instruction will behave as traditional bilinear filtering. The boxSize parameter must be greater than or equal to 1.0 and must not be greater than VkPhysicalDeviceImageProcessingPropertiesQCOM.maxBoxFilterBlockSize. The input sampler must be created with addressModeU and addressModeV, equal to VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE, or VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER with VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK. The 2D unnormalized texel coordinates are transformed by to specify integer texel coordinates \((i_{0}, j_{0})\) of the bottom left texel for the filter. where and are specified by the code:(x,y) components of the boxSize operand. The filter dimensions are computed from the fractional portion of the coordinates and the . where the number of fraction bits retained by is specified by VkPhysicalDeviceLimits::subTexelPrecisionBits. A set of neighboring integer texel coordinates are generated. The neighboring coordinates are combinations of to and to , with being the top-left coordinate of this set. The set is of size . Each of the generated integer coordinates is transformed by texture wrapping operation, followed by integer texel coordinate validation, If any coordinate fails coordinate validation, it is a Border Texel and texel replacement is performed. Horizontal weights to and vertical weights to are computed. Texels that are fully covered by the box will have a horizontal and vertical weight of 1. Texels partially covered by the box will have will have a reduced weights proportional to the coverage. The values of multiple texels, together with their horizontal and vertical weights, are combined to produce a box filtered value. When VkSamplerReductionModeCreateInfo::reductionMode is VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE, the above summation is used. However, if the reduction mode is VK_SAMPLER_REDUCTION_MODE_MIN or VK_SAMPLER_REDUCTION_MODE_MAX, the process operates on the above values, computing a component-wise minimum or maximum of the texels. Each step described in this chapter is performed by a subset of the image instructions: Texel Input Validation Operations, Format Conversion, Texel Replacement, Conversion to RGBA, and Component Swizzle: Performed by all instructions except OpImageWrite. Depth Comparison: Performed by OpImage*Dref instructions. All Texel output operations: Performed by OpImageWrite. Projection: Performed by all OpImage*Proj instructions. Derivative Image Operations, Cube Map Operations, Scale Factor Operation, LOD Operation and Image Level(s) Selection, and Texel Anisotropic Filtering: Performed by all OpImageSample* and OpImageSparseSample* instructions. (s,t,r,q,a) to (u,v,w,a) Transformation, Wrapping, and (u,v,w,a) to (i,j,k,l,n) Transformation And Array Layer Selection: Performed by all OpImageSample, OpImageSparseSample, and OpImage*Gather instructions. Texel Gathering: Performed by OpImage*Gather instructions. Texel Footprint Evaluation: Performed by OpImageSampleFootprint instructions. Texel Filtering: Performed by all OpImageSample* and OpImageSparseSample* instructions. Sparse Residency: Performed by all OpImageSparse* instructions. (s,t,r,q,a) to (u,v,w,a) Transformation, Wrapping, and Weight Image Sampling: Performed by OpImageWeightedSample* instructions. (s,t,r,q,a) to (u,v,w,a) Transformation, Wrapping, and Block Matching: Performed by opImageBlockMatch* instructions. (s,t,r,q,a) to (u,v,w,a) Transformation, Wrapping, and Box Filter Sampling: Performed by OpImageBoxFilter* instructions. OpImageQuerySize, OpImageQuerySizeLod, OpImageQueryLevels, and OpImageQuerySamples query properties of the image descriptor that would be accessed by a shader image operation. They return 0 if the bound descriptor is a null descriptor. OpImageQuerySizeLod returns the size of the image level identified by the Level of Detail operand. If that level does not exist in the image, and the descriptor is not null, then the value returned is undefined. OpImageQueryLod returns the LOD parameters that would be used in an image operation with the given image and coordinates. If the descriptor that would be accessed is a null descriptor then (0,0) is returned. Otherwise, the steps described in this chapter are performed as if for OpImageSampleImplicitLod, up to Scale Factor Operation, LOD Operation and Image Level(s) Selection. The return value is the vector (λ', dl - levelbase). These values may be subject to implementation-specific maxima and minima for very large, out-of-range values.

# Execution Graphs

## Metadata

- **Component**: spec
- **Version**: latest
- **URL**: /spec/latest/chapters/executiongraphs.html

## Table of Contents

- [Pipeline Creation](#_pipeline_creation)
- [Initializing Scratch Memory](#_initializing_scratch_memory)
- [Initializing_Scratch_Memory](#_initializing_scratch_memory)
- [Dispatching a Graph](#_dispatching_a_graph)
- [Dispatching_a_Graph](#_dispatching_a_graph)
- [Shader Enqueue](#_shader_enqueue)
- [Compute Nodes](#_compute_nodes)
- [Mesh Nodes](#executiongraphs-meshnodes)

## Content

Execution graphs provide a way for applications to dispatch multiple operations dynamically from a single initial command on the host. To achieve this, a new execution graph pipeline is provided, that links together multiple shaders or pipelines which each describe one or more operations that can be dispatched within the execution graph. Each linked pipeline or shader describes an execution node within the graph, which can be dispatched dynamically from another shader within the same graph. This allows applications to describe much richer execution topologies at a finer granularity than would typically be possible with API commands alone. To create execution graph pipelines, call: // Provided by VK_AMDX_shader_enqueue VkResult vkCreateExecutionGraphPipelinesAMDX( VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkExecutionGraphPipelineCreateInfoAMDX* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines); device is the logical device that creates the execution graph pipelines. pipelineCache is either VK_NULL_HANDLE, indicating that pipeline caching is disabled; or the handle of a valid pipeline cache object, in which case use of that cache is enabled for the duration of the command. The implementation must not access this object outside of the duration of this command. createInfoCount is the length of the pCreateInfos and pPipelines arrays. pCreateInfos is a pointer to an array of VkExecutionGraphPipelineCreateInfoAMDX structures. pAllocator controls host memory allocation as described in the Memory Allocation chapter. pPipelines is a pointer to an array of VkPipeline handles in which the resulting execution graph pipeline objects are returned. Pipelines are created and returned as described for Multiple Pipeline Creation. Valid Usage VUID-vkCreateExecutionGraphPipelinesAMDX-shaderEnqueue-09124 The shaderEnqueue feature must be enabled VUID-vkCreateExecutionGraphPipelinesAMDX-flags-09125 If the flags member of any element of pCreateInfos contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and the basePipelineIndex member of that same element is not -1, basePipelineIndex must be less than the index into pCreateInfos that corresponds to that element VUID-vkCreateExecutionGraphPipelinesAMDX-flags-09126 If the flags member of any element of pCreateInfos contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, the base pipeline must have been created with the VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT flag set VUID-vkCreateExecutionGraphPipelinesAMDX-pipelineCache-09127 If pipelineCache was created with VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT, host access to pipelineCache must be externally synchronized VUID-vkCreateExecutionGraphPipelinesAMDX-pNext-09616 If VkPipelineBinaryInfoKHR::binaryCount is not 0 for any element of pCreateInfos, pipelineCache must be VK_NULL_HANDLE VUID-vkCreateExecutionGraphPipelinesAMDX-pNext-09617 If a VkPipelineCreateFlags2CreateInfoKHR structure with the VK_PIPELINE_CREATE_2_CAPTURE_DATA_BIT_KHR flag set is included in the pNext chain of any element of pCreateInfos, pipelineCache must be VK_NULL_HANDLE VUID-vkCreateExecutionGraphPipelinesAMDX-binaryCount-09620 If VkPipelineBinaryInfoKHR::binaryCount is not 0 for any element of pCreateInfos, VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT must not be set in the flags of that element VUID-vkCreateExecutionGraphPipelinesAMDX-binaryCount-09621 If VkPipelineBinaryInfoKHR::binaryCount is not 0 for any element of pCreateInfos, VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT must not be set in the flags of that element VUID-vkCreateExecutionGraphPipelinesAMDX-binaryCount-09622 If VkPipelineBinaryInfoKHR::binaryCount is not 0 for any element of pCreateInfos, VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_EXT must not be set in the flags of that element Valid Usage (Implicit) VUID-vkCreateExecutionGraphPipelinesAMDX-device-parameter device must be a valid VkDevice handle VUID-vkCreateExecutionGraphPipelinesAMDX-pipelineCache-parameter If pipelineCache is not VK_NULL_HANDLE, pipelineCache must be a valid VkPipelineCache handle VUID-vkCreateExecutionGraphPipelinesAMDX-pCreateInfos-parameter pCreateInfos must be a valid pointer to an array of createInfoCount valid VkExecutionGraphPipelineCreateInfoAMDX structures VUID-vkCreateExecutionGraphPipelinesAMDX-pAllocator-parameter If pAllocator is not NULL, pAllocator must be a valid pointer to a valid VkAllocationCallbacks structure VUID-vkCreateExecutionGraphPipelinesAMDX-pPipelines-parameter pPipelines must be a valid pointer to an array of createInfoCount VkPipeline handles VUID-vkCreateExecutionGraphPipelinesAMDX-createInfoCount-arraylength createInfoCount must be greater than 0 VUID-vkCreateExecutionGraphPipelinesAMDX-pipelineCache-parent If pipelineCache is a valid handle, it must have been created, allocated, or retrieved from device Return Codes Success VK_SUCCESS VK_PIPELINE_COMPILE_REQUIRED_EXT Failure VK_ERROR_OUT_OF_HOST_MEMORY VK_ERROR_OUT_OF_DEVICE_MEMORY The VkExecutionGraphPipelineCreateInfoAMDX structure is defined as: // Provided by VK_AMDX_shader_enqueue typedef struct VkExecutionGraphPipelineCreateInfoAMDX { VkStructureType sType; const void* pNext; VkPipelineCreateFlags flags; uint32_t stageCount; const VkPipelineShaderStageCreateInfo* pStages; const VkPipelineLibraryCreateInfoKHR* pLibraryInfo; VkPipelineLayout layout; VkPipeline basePipelineHandle; int32_t basePipelineIndex; } VkExecutionGraphPipelineCreateInfoAMDX; sType is a VkStructureType value identifying this structure. pNext is NULL or a pointer to a structure extending this structure. flags is a bitmask of VkPipelineCreateFlagBits specifying how the pipeline will be generated. stageCount is the number of entries in the pStages array. pStages is a pointer to an array of stageCount VkPipelineShaderStageCreateInfo structures describing the set of the shader stages to be included in the execution graph pipeline. pLibraryInfo is a pointer to a VkPipelineLibraryCreateInfoKHR structure defining pipeline libraries to include. layout is the description of binding locations used by both the pipeline and descriptor sets used with the pipeline. The implementation must not access this object outside of the duration of the command this structure is passed to. basePipelineHandle is a pipeline to derive from basePipelineIndex is an index into the pCreateInfos parameter to use as a pipeline to derive from The parameters basePipelineHandle and basePipelineIndex are described in more detail in Pipeline Derivatives. Each shader stage provided when creating an execution graph pipeline (including those in libraries) is associated with a name and an index, determined by the inclusion or omission of a VkPipelineShaderStageNodeCreateInfoAMDX structure in its pNext chain. For any graphics pipeline libraries, only the name and index of the vertex or mesh shader stage is linked directly to the graph as a node - other shader stages in the pipeline will be executed after those shader stages as normal. Task shaders cannot be included in a graphics pipeline used for a draw node. In addition to the shader name and index, an internal "node index" is also generated for each node, which can be queried with vkGetExecutionGraphPipelineNodeIndexAMDX, and is used exclusively for initial dispatch of an execution graph. Valid Usage VUID-VkExecutionGraphPipelineCreateInfoAMDX-None-09497 If the pNext chain does not include a VkPipelineCreateFlags2CreateInfo structure, flags must be a valid combination of VkPipelineCreateFlagBits values VUID-VkExecutionGraphPipelineCreateInfoAMDX-flags-07984 If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and basePipelineIndex is -1, basePipelineHandle must be a valid execution graph VkPipeline handle VUID-VkExecutionGraphPipelineCreateInfoAMDX-flags-07985 If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and basePipelineHandle is VK_NULL_HANDLE, basePipelineIndex must be a valid index into the calling command’s pCreateInfos parameter VUID-VkExecutionGraphPipelineCreateInfoAMDX-flags-07986 If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, basePipelineIndex must be -1 or basePipelineHandle must be VK_NULL_HANDLE VUID-VkExecutionGraphPipelineCreateInfoAMDX-layout-07987 If a push constant block is declared in a shader, a push constant range in layout must match the shader stage VUID-VkExecutionGraphPipelineCreateInfoAMDX-layout-10069 If a push constant block is declared in a shader, the block must be contained inside the push constant range in layout that matches the stage VUID-VkExecutionGraphPipelineCreateInfoAMDX-layout-07988 If a resource variable is declared in a shader, the corresponding descriptor set in layout must match the shader stage VUID-VkExecutionGraphPipelineCreateInfoAMDX-layout-07990 If a resource variable is declared in a shader, and the descriptor type is not VK_DESCRIPTOR_TYPE_MUTABLE_EXT, the corresponding descriptor set in layout must match the descriptor type VUID-VkExecutionGraphPipelineCreateInfoAMDX-layout-07991 If a resource variable is declared in a shader as an array, the corresponding descriptor set in layout must match the descriptor count VUID-VkExecutionGraphPipelineCreateInfoAMDX-None-10391 If a resource variables is declared in a shader as an array of descriptors, then the descriptor type of that variable must not be VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK VUID-VkExecutionGraphPipelineCreateInfoAMDX-flags-03365 flags must not include VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR VUID-VkExecutionGraphPipelineCreateInfoAMDX-flags-03366 flags must not include VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR VUID-VkExecutionGraphPipelineCreateInfoAMDX-flags-03367 flags must not include VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR VUID-VkExecutionGraphPipelineCreateInfoAMDX-flags-03368 flags must not include VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR VUID-VkExecutionGraphPipelineCreateInfoAMDX-flags-03369 flags must not include VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR VUID-VkExecutionGraphPipelineCreateInfoAMDX-flags-03370 flags must not include VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR VUID-VkExecutionGraphPipelineCreateInfoAMDX-flags-03576 flags must not include VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR VUID-VkExecutionGraphPipelineCreateInfoAMDX-flags-04945 flags must not include VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV VUID-VkExecutionGraphPipelineCreateInfoAMDX-flags-09007 If the VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV::deviceGeneratedComputePipelines feature is not enabled, flags must not include VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV VUID-VkExecutionGraphPipelineCreateInfoAMDX-flags-09008 If flags includes VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV, then the pNext chain must include a pointer to a valid instance of VkComputePipelineIndirectBufferInfoNV specifying the address where the pipeline’s metadata will be saved VUID-VkExecutionGraphPipelineCreateInfoAMDX-flags-11007 If flags includes VK_PIPELINE_CREATE_2_INDIRECT_BINDABLE_BIT_EXT, then the VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT::deviceGeneratedCommands feature must be enabled VUID-VkExecutionGraphPipelineCreateInfoAMDX-pipelineCreationCacheControl-02875 If the pipelineCreationCacheControl feature is not enabled, flags must not include VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT or VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT VUID-VkExecutionGraphPipelineCreateInfoAMDX-stage-09128 The stage member of any element of pStages must be VK_SHADER_STAGE_COMPUTE_BIT VUID-VkExecutionGraphPipelineCreateInfoAMDX-pStages-09129 The shader code for the entry point identified by each element of pStages and the rest of the state identified by this structure must adhere to the pipeline linking rules described in the Shader Interfaces chapter VUID-VkExecutionGraphPipelineCreateInfoAMDX-layout-09130 layout must be consistent with the layout of the shaders specified in pStages VUID-VkExecutionGraphPipelineCreateInfoAMDX-pLibraryInfo-09131 If pLibraryInfo is not NULL, each element of its pLibraries member must have been created with a layout that is compatible with the layout in this pipeline VUID-VkExecutionGraphPipelineCreateInfoAMDX-layout-09132 The number of resources in layout accessible to each shader stage that is used by the pipeline must be less than or equal to VkPhysicalDeviceLimits::maxPerStageResources VUID-VkExecutionGraphPipelineCreateInfoAMDX-pLibraryInfo-09133 If pLibraryInfo is not NULL, each element of pLibraryInfo->pLibraries must be either a compute pipeline, an execution graph pipeline, or a graphics pipeline VUID-VkExecutionGraphPipelineCreateInfoAMDX-pLibraryInfo-10181 If pLibraryInfo is not NULL, each element of pLibraryInfo->pLibraries that is a compute pipeline or a graphics pipeline must have been created with VK_PIPELINE_CREATE_2_EXECUTION_GRAPH_BIT_AMDX set VUID-VkExecutionGraphPipelineCreateInfoAMDX-shaderMeshEnqueue-10182 If the shaderMeshEnqueue feature is not enabled, and pLibraryInfo->pLibraries is not NULL, pLibraryInfo->pLibraries must not contain any graphics pipelines VUID-VkExecutionGraphPipelineCreateInfoAMDX-pLibraryInfo-10183 Any element of pLibraryInfo->pLibraries identifying a graphics pipeline must have been created with all possible state subsets VUID-VkExecutionGraphPipelineCreateInfoAMDX-None-09134 There must be no two nodes in the pipeline that share both the same shader name and index, as specified by VkPipelineShaderStageNodeCreateInfoAMDX VUID-VkExecutionGraphPipelineCreateInfoAMDX-None-09135 There must be no two nodes in the pipeline that share the same shader name and have input payload declarations with different sizes VUID-VkExecutionGraphPipelineCreateInfoAMDX-None-09136 There must be no two nodes in the pipeline that share the same name but have different execution models VUID-VkExecutionGraphPipelineCreateInfoAMDX-CoalescedInputCountAMDX-09137 There must be no two nodes in the pipeline that share the same name where one includes CoalescedInputCountAMDX and the other does not VUID-VkExecutionGraphPipelineCreateInfoAMDX-StaticNumWorkgroupsAMDX-09138 There must be no two nodes in the pipeline that share the same name where one includes StaticNumWorkgroupsAMDX and the other does not VUID-VkExecutionGraphPipelineCreateInfoAMDX-PayloadNodeNameAMDX-09139 If an output payload declared in any shader in the pipeline has a PayloadNodeNameAMDX decoration with a Node Name that matches the shader name of any other node in the graph, the size of the output payload must match the size of the input payload in the matching node VUID-VkExecutionGraphPipelineCreateInfoAMDX-flags-10184 If flags does not include VK_PIPELINE_CREATE_LIBRARY_BIT_KHR, and an output payload declared in any shader in the pipeline does not have a PayloadNodeSparseArrayAMDX decoration, there must be a node in the graph corresponding to every index from 0 to its PayloadNodeArraySizeAMDX decoration Valid Usage (Implicit) VUID-VkExecutionGraphPipelineCreateInfoAMDX-sType-sType sType must be VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_CREATE_INFO_AMDX VUID-VkExecutionGraphPipelineCreateInfoAMDX-pNext-pNext Each pNext member of any structure (including this one) in the pNext chain must be either NULL or a pointer to a valid instance of VkPipelineCompilerControlCreateInfoAMD or VkPipelineCreationFeedbackCreateInfo VUID-VkExecutionGraphPipelineCreateInfoAMDX-sType-unique The sType value of each structure in the pNext chain must be unique VUID-VkExecutionGraphPipelineCreateInfoAMDX-pStages-parameter If stageCount is not 0, and pStages is not NULL, pStages must be a valid pointer to an array of stageCount valid VkPipelineShaderStageCreateInfo structures VUID-VkExecutionGraphPipelineCreateInfoAMDX-pLibraryInfo-parameter If pLibraryInfo is not NULL, pLibraryInfo must be a valid pointer to a valid VkPipelineLibraryCreateInfoKHR structure VUID-VkExecutionGraphPipelineCreateInfoAMDX-layout-parameter layout must be a valid VkPipelineLayout handle VUID-VkExecutionGraphPipelineCreateInfoAMDX-commonparent Both of basePipelineHandle, and layout that are valid handles of non-ignored parameters must have been created, allocated, or retrieved from the same VkDevice VK_SHADER_INDEX_UNUSED_AMDX is a special shader index used to indicate that the created node does not override the index. In this case, the shader index is determined through other means. It is defined as: #define VK_SHADER_INDEX_UNUSED_AMDX (~0U) The VkPipelineShaderStageNodeCreateInfoAMDX structure is defined as: // Provided by VK_AMDX_shader_enqueue typedef struct VkPipelineShaderStageNodeCreateInfoAMDX { VkStructureType sType; const void* pNext; const char* pName; uint32_t index; } VkPipelineShaderStageNodeCreateInfoAMDX; sType is a VkStructureType value identifying this structure. pNext is NULL or a pointer to a structure extending this structure. pName is the shader name to use when creating a node in an execution graph. If pName is NULL, the name of the entry point specified in SPIR-V is used as the shader name. index is the shader index to use when creating a node in an execution graph. If index is VK_SHADER_INDEX_UNUSED_AMDX then the original index is used, either as specified by the ShaderIndexAMDX execution mode, or 0 if that too is not specified. When included in the pNext chain of a VkPipelineShaderStageCreateInfo structure, this structure specifies the shader name and shader index of a node when creating an execution graph pipeline. If this structure is omitted, the shader name is set to the name of the entry point in SPIR-V and the shader index is set to 0. When dispatching a node from another shader, the name is fixed at pipeline creation, but the index can be set dynamically. By associating multiple shaders with the same name but different indexes, applications can dynamically select different nodes to execute. Applications must ensure each node has a unique name and index. Shaders with the same name must be of the same type - e.g. a compute and graphics shader, or even two compute shaders where one is coalescing and the other is not, cannot share the same name. Valid Usage (Implicit) VUID-VkPipelineShaderStageNodeCreateInfoAMDX-sType-sType sType must be VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_NODE_CREATE_INFO_AMDX VUID-VkPipelineShaderStageNodeCreateInfoAMDX-pName-parameter If pName is not NULL, pName must be a null-terminated UTF-8 string To query the internal node index for a particular node in an execution graph, call: // Provided by VK_AMDX_shader_enqueue VkResult vkGetExecutionGraphPipelineNodeIndexAMDX( VkDevice device, VkPipeline executionGraph, const VkPipelineShaderStageNodeCreateInfoAMDX* pNodeInfo, uint32_t* pNodeIndex); device is the logical device that executionGraph was created on. executionGraph is the execution graph pipeline to query the internal node index for. pNodeInfo is a pointer to a VkPipelineShaderStageNodeCreateInfoAMDX structure identifying the name and index of the node to query. pNodeIndex is the returned internal node index of the identified node. Once this function returns, the contents of pNodeIndex contain the internal node index of the identified node. Valid Usage VUID-vkGetExecutionGraphPipelineNodeIndexAMDX-pNodeInfo-09140 pNodeInfo->pName must not be NULL VUID-vkGetExecutionGraphPipelineNodeIndexAMDX-pNodeInfo-09141 pNodeInfo->index must not be VK_SHADER_INDEX_UNUSED_AMDX VUID-vkGetExecutionGraphPipelineNodeIndexAMDX-executionGraph-09142 There must be a node in executionGraph with a shader name and index equal to pNodeInfo->pName and pNodeInfo->index Valid Usage (Implicit) VUID-vkGetExecutionGraphPipelineNodeIndexAMDX-device-parameter device must be a valid VkDevice handle VUID-vkGetExecutionGraphPipelineNodeIndexAMDX-executionGraph-parameter executionGraph must be a valid VkPipeline handle VUID-vkGetExecutionGraphPipelineNodeIndexAMDX-pNodeInfo-parameter pNodeInfo must be a valid pointer to a valid VkPipelineShaderStageNodeCreateInfoAMDX structure VUID-vkGetExecutionGraphPipelineNodeIndexAMDX-pNodeIndex-parameter pNodeIndex must be a valid pointer to a uint32_t value VUID-vkGetExecutionGraphPipelineNodeIndexAMDX-executionGraph-parent executionGraph must have been created, allocated, or retrieved from device Return Codes Success VK_SUCCESS Failure VK_ERROR_OUT_OF_HOST_MEMORY Implementations may need scratch memory to manage dispatch queues or similar when executing a pipeline graph, and this is explicitly managed by the application. To query the scratch space required to dispatch an execution graph, call: // Provided by VK_AMDX_shader_enqueue VkResult vkGetExecutionGraphPipelineScratchSizeAMDX( VkDevice device, VkPipeline executionGraph, VkExecutionGraphPipelineScratchSizeAMDX* pSizeInfo); device is the logical device that executionGraph was created on. executionGraph is the execution graph pipeline to query the scratch space for. pSizeInfo is a pointer to a VkExecutionGraphPipelineScratchSizeAMDX structure that will contain the required scratch size. After this function returns, information about the scratch space required will be returned in pSizeInfo. Valid Usage (Implicit) VUID-vkGetExecutionGraphPipelineScratchSizeAMDX-device-parameter device must be a valid VkDevice handle VUID-vkGetExecutionGraphPipelineScratchSizeAMDX-executionGraph-parameter executionGraph must be a valid VkPipeline handle VUID-vkGetExecutionGraphPipelineScratchSizeAMDX-pSizeInfo-parameter pSizeInfo must be a valid pointer to a VkExecutionGraphPipelineScratchSizeAMDX structure VUID-vkGetExecutionGraphPipelineScratchSizeAMDX-executionGraph-parent executionGraph must have been created, allocated, or retrieved from device Return Codes Success VK_SUCCESS Failure VK_ERROR_OUT_OF_HOST_MEMORY The VkExecutionGraphPipelineScratchSizeAMDX structure is defined as: // Provided by VK_AMDX_shader_enqueue typedef struct VkExecutionGraphPipelineScratchSizeAMDX { VkStructureType sType; void* pNext; VkDeviceSize minSize; VkDeviceSize maxSize; VkDeviceSize sizeGranularity; } VkExecutionGraphPipelineScratchSizeAMDX; sType is a VkStructureType value identifying this structure. pNext is NULL or a pointer to a structure extending this structure. minSize indicates the minimum scratch space required for dispatching the queried execution graph. maxSize indicates the maximum scratch space that can be used for dispatching the queried execution graph. sizeGranularity indicates the granularity at which the scratch space can be increased from minSize. Applications can use any amount of scratch memory greater than minSize for dispatching a graph, however only the values equal to minSize + an integer multiple of sizeGranularity will be used. Greater values may result in higher performance, up to maxSize which indicates the most memory that an implementation can use effectively. Valid Usage (Implicit) VUID-VkExecutionGraphPipelineScratchSizeAMDX-sType-sType sType must be VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_SCRATCH_SIZE_AMDX To initialize scratch memory for a particular execution graph, call: // Provided by VK_AMDX_shader_enqueue void vkCmdInitializeGraphScratchMemoryAMDX( VkCommandBuffer commandBuffer, VkPipeline executionGraph, VkDeviceAddress scratch, VkDeviceSize scratchSize); commandBuffer is the command buffer into which the command will be recorded. executionGraph is the execution graph pipeline to initialize the scratch memory for. scratch is the address of scratch memory to be initialized. scratchSize is a range in bytes of scratch memory to be initialized. This command must be called before using scratch to dispatch the bound execution graph pipeline. Execution of this command may modify any memory locations in the range [scratch,scratch + scratchSize). Accesses to this memory range are performed in the VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT pipeline stage with the VK_ACCESS_2_SHADER_STORAGE_READ_BIT and VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT access flags. If any portion of scratch is modified by any command other than vkCmdDispatchGraphAMDX, vkCmdDispatchGraphIndirectAMDX, vkCmdDispatchGraphIndirectCountAMDX, or vkCmdInitializeGraphScratchMemoryAMDX with the same execution graph, it must be reinitialized for the execution graph again before dispatching against it. Valid Usage VUID-vkCmdInitializeGraphScratchMemoryAMDX-scratch-10185 scratch must be the device address of an allocated memory range at least as large as scratchSize VUID-vkCmdInitializeGraphScratchMemoryAMDX-scratchSize-10186 scratchSize must be greater than or equal to VkExecutionGraphPipelineScratchSizeAMDX::minSize returned by vkGetExecutionGraphPipelineScratchSizeAMDX for the bound execution graph pipeline VUID-vkCmdInitializeGraphScratchMemoryAMDX-scratch-09144 scratch must be a multiple of 64 Valid Usage (Implicit) VUID-vkCmdInitializeGraphScratchMemoryAMDX-commandBuffer-parameter commandBuffer must be a valid VkCommandBuffer handle VUID-vkCmdInitializeGraphScratchMemoryAMDX-executionGraph-parameter executionGraph must be a valid VkPipeline handle VUID-vkCmdInitializeGraphScratchMemoryAMDX-commandBuffer-recording commandBuffer must be in the recording state VUID-vkCmdInitializeGraphScratchMemoryAMDX-commandBuffer-cmdpool The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations VUID-vkCmdInitializeGraphScratchMemoryAMDX-videocoding This command must only be called outside of a video coding scope VUID-vkCmdInitializeGraphScratchMemoryAMDX-bufferlevel commandBuffer must be a primary VkCommandBuffer VUID-vkCmdInitializeGraphScratchMemoryAMDX-commonparent Both of commandBuffer, and executionGraph must have been created, allocated, or retrieved from the same VkDevice Host Synchronization Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized Command Properties Command Buffer Levels Render Pass Scope Video Coding Scope Supported Queue Types Command Type Primary Both Outside Graphics Compute Action Initial dispatch of an execution graph is done from the host in the same way as any other command, and can be used in a similar way to compute dispatch commands, with indirect variants available. To record an execution graph dispatch, call: // Provided by VK_AMDX_shader_enqueue void vkCmdDispatchGraphAMDX( VkCommandBuffer commandBuffer, VkDeviceAddress scratch, VkDeviceSize scratchSize, const VkDispatchGraphCountInfoAMDX* pCountInfo); commandBuffer is the command buffer into which the command will be recorded. scratch is the address of scratch memory to be used. scratchSize is a range in bytes of scratch memory to be used. pCountInfo is a host pointer to a VkDispatchGraphCountInfoAMDX structure defining the nodes which will be initially executed. When this command is executed, the nodes specified in pCountInfo are executed. Nodes executed as part of this command are not implicitly synchronized in any way against each other once they are dispatched. There are no rasterization order guarantees between separately dispatched graphics nodes, though individual primitives within a single dispatch do adhere to rasterization order. Draw calls executed before or after the execution graph also execute relative to each graphics node with respect to rasterization order. For this command, all device/host pointers in substructures are treated as host pointers and read only during host execution of this command. Once this command returns, no reference to the original pointers is retained. Execution of this command may modify any memory locations in the range [scratch,scratch + scratchSize). Accesses to this memory range are performed in the VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT pipeline stage with the VK_ACCESS_2_SHADER_STORAGE_READ_BIT and VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT access flags. This command captures command buffer state for mesh nodes similarly to draw commands. Valid Usage VUID-vkCmdDispatchGraphAMDX-magFilter-04553 If a VkSampler created with magFilter or minFilter equal to VK_FILTER_LINEAR, reductionMode equal to VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE, and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT VUID-vkCmdDispatchGraphAMDX-magFilter-09598 If a VkSampler created with magFilter or minFilter equal to VK_FILTER_LINEAR and reductionMode equal to either VK_SAMPLER_REDUCTION_MODE_MIN or VK_SAMPLER_REDUCTION_MODE_MAX is used to sample a VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT VUID-vkCmdDispatchGraphAMDX-mipmapMode-04770 If a VkSampler created with mipmapMode equal to VK_SAMPLER_MIPMAP_MODE_LINEAR, reductionMode equal to VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE, and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT VUID-vkCmdDispatchGraphAMDX-mipmapMode-09599 If a VkSampler created with mipmapMode equal to VK_SAMPLER_MIPMAP_MODE_LINEAR and reductionMode equal to either VK_SAMPLER_REDUCTION_MODE_MIN or VK_SAMPLER_REDUCTION_MODE_MAX is used to sample a VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT VUID-vkCmdDispatchGraphAMDX-unnormalizedCoordinates-09635 If a VkSampler created with unnormalizedCoordinates equal to VK_TRUE is used to sample a VkImageView as a result of this command, then the image view’s levelCount and layerCount must be 1 VUID-vkCmdDispatchGraphAMDX-None-08609 If a VkSampler created with unnormalizedCoordinates equal to VK_TRUE is used to sample a VkImageView as a result of this command, then the image view’s viewType must be VK_IMAGE_VIEW_TYPE_1D or VK_IMAGE_VIEW_TYPE_2D VUID-vkCmdDispatchGraphAMDX-None-08610 If a VkSampler created with unnormalizedCoordinates equal to VK_TRUE is used to sample a VkImageView as a result of this command, then the sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name VUID-vkCmdDispatchGraphAMDX-None-08611 If a VkSampler created with unnormalizedCoordinates equal to VK_TRUE is used to sample a VkImageView as a result of this command, then the sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values VUID-vkCmdDispatchGraphAMDX-None-06479 If a VkImageView is sampled with depth comparison, the image view’s format features must contain VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT VUID-vkCmdDispatchGraphAMDX-None-02691 If a VkImageView is accessed using atomic operations as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT VUID-vkCmdDispatchGraphAMDX-None-07888 If a VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER descriptor is accessed using atomic operations as a result of this command, then the storage texel buffer’s format features must contain VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT VUID-vkCmdDispatchGraphAMDX-None-02692 If a VkImageView is sampled with VK_FILTER_CUBIC_EXT as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT VUID-vkCmdDispatchGraphAMDX-None-02693 If the VK_EXT_filter_cubic extension is not enabled and any VkImageView is sampled with VK_FILTER_CUBIC_EXT as a result of this command, it must not have a VkImageViewType of VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY VUID-vkCmdDispatchGraphAMDX-filterCubic-02694 Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic returned by vkGetPhysicalDeviceImageFormatProperties2 VUID-vkCmdDispatchGraphAMDX-filterCubicMinmax-02695 Any VkImageView being sampled with VK_FILTER_CUBIC_EXT with a reduction mode of either VK_SAMPLER_REDUCTION_MODE_MIN or VK_SAMPLER_REDUCTION_MODE_MAX as a result of this command must have a VkImageViewType and format that supports cubic filtering together with minmax filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax returned by vkGetPhysicalDeviceImageFormatProperties2 VUID-vkCmdDispatchGraphAMDX-cubicRangeClamp-09212 If the cubicRangeClamp feature is not enabled, then any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must not have a VkSamplerReductionModeCreateInfo::reductionMode equal to VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM VUID-vkCmdDispatchGraphAMDX-reductionMode-09213 Any VkImageView being sampled with a VkSamplerReductionModeCreateInfo::reductionMode equal to VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM as a result of this command must sample with VK_FILTER_CUBIC_EXT VUID-vkCmdDispatchGraphAMDX-selectableCubicWeights-09214 If the selectableCubicWeights feature is not enabled, then any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must have VkSamplerCubicWeightsCreateInfoQCOM::cubicWeights equal to VK_CUBIC_FILTER_WEIGHTS_CATMULL_ROM_QCOM VUID-vkCmdDispatchGraphAMDX-flags-02696 Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE VUID-vkCmdDispatchGraphAMDX-OpTypeImage-07027 For any VkImageView being written as a storage image where the image format field of the OpTypeImage is Unknown, the view’s format features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT VUID-vkCmdDispatchGraphAMDX-OpTypeImage-07028 For any VkImageView being read as a storage image where the image format field of the OpTypeImage is Unknown, the view’s format features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT VUID-vkCmdDispatchGraphAMDX-OpTypeImage-07029 For any VkBufferView being written as a storage texel buffer where the image format field of the OpTypeImage is Unknown, the view’s buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT VUID-vkCmdDispatchGraphAMDX-OpTypeImage-07030 Any VkBufferView being read as a storage texel buffer where the image format field of the OpTypeImage is Unknown then the view’s buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT VUID-vkCmdDispatchGraphAMDX-None-08600 For each set n that is statically used by a bound shader, a descriptor set must have been bound to n at the same pipeline bind point, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline or the VkDescriptorSetLayout array used to create the current VkShaderEXT , as described in Pipeline Layout Compatibility VUID-vkCmdDispatchGraphAMDX-None-08601 For each push constant that is statically used by a bound shader, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline or the VkDescriptorSetLayout array used to create the current VkShaderEXT , as described in Pipeline Layout Compatibility VUID-vkCmdDispatchGraphAMDX-None-10068 For each array of resources that is used by a bound shader, the indices used to access members of the array must be less than the descriptor count for the identified binding in the descriptor sets used by this command VUID-vkCmdDispatchGraphAMDX-maintenance4-08602 If the maintenance4 feature is not enabled, then for each push constant that is statically used by a bound shader, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline or the VkDescriptorSetLayout and VkPushConstantRange arrays used to create the current VkShaderEXT , as described in Pipeline Layout Compatibility VUID-vkCmdDispatchGraphAMDX-None-08114 Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid as described by descriptor validity if they are statically used by the VkPipeline bound to the pipeline bind point used by this command and the bound VkPipeline was not created with VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT VUID-vkCmdDispatchGraphAMDX-None-08115 If the descriptors used by the VkPipeline bound to the pipeline bind point were specified via vkCmdBindDescriptorSets, the bound VkPipeline must have been created without VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT VUID-vkCmdDispatchGraphAMDX-None-08116 Descriptors in bound descriptor buffers, specified via vkCmdSetDescriptorBufferOffsetsEXT, must be valid if they are dynamically used by the VkPipeline bound to the pipeline bind point used by this command and the bound VkPipeline was created with VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT VUID-vkCmdDispatchGraphAMDX-None-08604 Descriptors in bound descriptor buffers, specified via vkCmdSetDescriptorBufferOffsetsEXT, must be valid if they are dynamically used by any VkShaderEXT bound to a stage corresponding to the pipeline bind point used by this command VUID-vkCmdDispatchGraphAMDX-None-08117 If the descriptors used by the VkPipeline bound to the pipeline bind point were specified via vkCmdSetDescriptorBufferOffsetsEXT, the bound VkPipeline must have been created with VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT VUID-vkCmdDispatchGraphAMDX-None-08119 If a descriptor is dynamically used with a VkPipeline created with VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT, the descriptor memory must be resident VUID-vkCmdDispatchGraphAMDX-None-08605 If a descriptor is dynamically used with a VkShaderEXT created with a VkDescriptorSetLayout that was created with VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT, the descriptor memory must be resident VUID-vkCmdDispatchGraphAMDX-None-08606 If the shaderObject feature is not enabled, a valid pipeline must be bound to the pipeline bind point used by this command VUID-vkCmdDispatchGraphAMDX-None-08608 If a pipeline is bound to the pipeline bind point used by this command, there must not have been any calls to dynamic state setting commands for any state specified statically in the VkPipeline object bound to the pipeline bind point used by this command, since that pipeline was bound VUID-vkCmdDispatchGraphAMDX-uniformBuffers-06935 If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a uniform buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2 for uniformBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point VUID-vkCmdDispatchGraphAMDX-None-08612 If the robustBufferAccess feature is not enabled, and any VkShaderEXT bound to a stage corresponding to the pipeline bind point used by this command accesses a uniform buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point VUID-vkCmdDispatchGraphAMDX-storageBuffers-06936 If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a storage buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2 for storageBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point VUID-vkCmdDispatchGraphAMDX-None-08613 If the robustBufferAccess feature is not enabled, and any VkShaderEXT bound to a stage corresponding to the pipeline bind point used by this command accesses a storage buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point VUID-vkCmdDispatchGraphAMDX-commandBuffer-02707 If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, any resource accessed by bound shaders must not be a protected resource VUID-vkCmdDispatchGraphAMDX-viewType-07752 If a VkImageView is accessed as a result of this command, then the image view’s viewType must match the Dim operand of the OpTypeImage as described in Compatibility Between SPIR-V Image Dimensions and Vulkan ImageView Types VUID-vkCmdDispatchGraphAMDX-format-07753 If a VkImageView or VkBufferView is accessed as a result of this command, then the numeric type of the view’s format and the Sampled Type operand of the OpTypeImage must match VUID-vkCmdDispatchGraphAMDX-OpImageWrite-08795 If a VkImageView created with a format other than VK_FORMAT_A8_UNORM is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the image view’s format VUID-vkCmdDispatchGraphAMDX-OpImageWrite-08796 If a VkImageView created with the format VK_FORMAT_A8_UNORM is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have four components VUID-vkCmdDispatchGraphAMDX-OpImageWrite-04469 If a VkBufferView is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the buffer view’s format VUID-vkCmdDispatchGraphAMDX-SampledType-04470 If a VkImageView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64 VUID-vkCmdDispatchGraphAMDX-SampledType-04471 If a VkImageView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32 VUID-vkCmdDispatchGraphAMDX-SampledType-04472 If a VkBufferView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64 VUID-vkCmdDispatchGraphAMDX-SampledType-04473 If a VkBufferView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32 VUID-vkCmdDispatchGraphAMDX-sparseImageInt64Atomics-04474 If the sparseImageInt64Atomics feature is not enabled, VkImage objects created with the VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command VUID-vkCmdDispatchGraphAMDX-sparseImageInt64Atomics-04475 If the sparseImageInt64Atomics feature is not enabled, VkBuffer objects created with the VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command VUID-vkCmdDispatchGraphAMDX-OpImageWeightedSampleQCOM-06971 If OpImageWeightedSampleQCOM is used to sample a VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM VUID-vkCmdDispatchGraphAMDX-OpImageWeightedSampleQCOM-06972 If OpImageWeightedSampleQCOM uses a VkImageView as a sample weight image as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM VUID-vkCmdDispatchGraphAMDX-OpImageBoxFilterQCOM-06973 If OpImageBoxFilterQCOM is used to sample a VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM VUID-vkCmdDispatchGraphAMDX-OpImageBlockMatchSSDQCOM-06974 If OpImageBlockMatchSSDQCOM is used to read from an VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM VUID-vkCmdDispatchGraphAMDX-OpImageBlockMatchSADQCOM-06975 If OpImageBlockMatchSADQCOM is used to read from an VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM VUID-vkCmdDispatchGraphAMDX-OpImageBlockMatchSADQCOM-06976 If OpImageBlockMatchSADQCOM or OpImageBlockMatchSSDQCOM is used to read from a reference image as result of this command, then the specified reference coordinates must not fail integer texel coordinate validation VUID-vkCmdDispatchGraphAMDX-OpImageWeightedSampleQCOM-06977 If OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchWindowSSDQCOM, OpImageBlockMatchWindowSADQCOM, OpImageBlockMatchGatherSSDQCOM, OpImageBlockMatchGatherSADQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM VUID-vkCmdDispatchGraphAMDX-OpImageWeightedSampleQCOM-06978 If any command other than OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchWindowSSDQCOM, OpImageBlockMatchWindowSADQCOM, OpImageBlockMatchGatherSSDQCOM, OpImageBlockMatchGatherSADQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must not have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM VUID-vkCmdDispatchGraphAMDX-OpImageBlockMatchWindow-09215 If a OpImageBlockMatchWindow*QCOM or OpImageBlockMatchGather*QCOM instruction is used to read from an VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM VUID-vkCmdDispatchGraphAMDX-OpImageBlockMatchWindow-09216 If a OpImageBlockMatchWindow*QCOM or OpImageBlockMatchGather*QCOM instruction is used to read from an VkImageView as a result of this command, then the image view’s format must be a single-component format VUID-vkCmdDispatchGraphAMDX-OpImageBlockMatchWindow-09217 If a OpImageBlockMatchWindow*QCOM or OpImageBlockMatchGather*QCOM read from a reference image as result of this command, then the specified reference coordinates must not fail integer texel coordinate validation VUID-vkCmdDispatchGraphAMDX-None-07288 Any shader invocation executed by this command must terminate VUID-vkCmdDispatchGraphAMDX-None-09600 If a descriptor with type equal to any of VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM, VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, or VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT is accessed as a result of this command, all image subresources identified by that descriptor must be in the image layout identified when the descriptor was written VUID-vkCmdDispatchGraphAMDX-commandBuffer-10746 The VkDeviceMemory object allocated from a VkMemoryHeap with the VK_MEMORY_HEAP_TILE_MEMORY_BIT_QCOM property that is bound to a resource accessed as a result of this command must be the active bound bound tile memory object in commandBuffer VUID-vkCmdDispatchGraphAMDX-None-10678 If this command is recorded inside a tile shading render pass instance, the stages corresponding to the pipeline bind point used by this command must only include VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_FRAGMENT_BIT, and/or VK_SHADER_STAGE_COMPUTE_BIT VUID-vkCmdDispatchGraphAMDX-None-10679 If this command is recorded where per-tile execution model is enabled, there must be no access to any image while the image was be transitioned to the VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT layout VUID-vkCmdDispatchGraphAMDX-commandBuffer-09181 commandBuffer must not be a protected command buffer VUID-vkCmdDispatchGraphAMDX-commandBuffer-09182 commandBuffer must be a primary command buffer VUID-vkCmdDispatchGraphAMDX-scratch-10192 scratch must be the device address of an allocated memory range at least as large as scratchSize VUID-vkCmdDispatchGraphAMDX-scratchSize-10193 scratchSize must be greater than or equal to VkExecutionGraphPipelineScratchSizeAMDX::minSize returned by vkGetExecutionGraphPipelineScratchSizeAMDX for the bound execution graph pipeline VUID-vkCmdDispatchGraphAMDX-scratch-09184 scratch must be a device address within a VkBuffer created with the VK_BUFFER_USAGE_EXECUTION_GRAPH_SCRATCH_BIT_AMDX or VK_BUFFER_USAGE_2_EXECUTION_GRAPH_SCRATCH_BIT_AMDX flag VUID-vkCmdDispatchGraphAMDX-scratch-10194 The device memory range [scratch,scratch scratchSize] must have been initialized with vkCmdInitializeGraphScratchMemoryAMDX using the bound execution graph pipeline, and not modified after that by anything other than another execution graph dispatch command VUID-vkCmdDispatchGraphAMDX-maxComputeWorkGroupCount-09186 Execution of this command must not cause a node to be dispatched with a larger number of workgroups than that specified by either a MaxNumWorkgroupsAMDX decoration in the dispatched node or maxComputeWorkGroupCount VUID-vkCmdDispatchGraphAMDX-maxExecutionGraphShaderPayloadCount-09187 Execution of this command must not cause any shader to initialize more than maxExecutionGraphShaderPayloadCount output payloads VUID-vkCmdDispatchGraphAMDX-NodeMaxPayloadsAMDX-09188 Execution of this command must not cause any shader that declares NodeMaxPayloadsAMDX to initialize more output payloads than specified by the max number of payloads for that decoration. This requirement applies to each NodeMaxPayloadsAMDX decoration separately VUID-vkCmdDispatchGraphAMDX-None-10195 If the bound execution graph pipeline includes draw nodes, this command must be called within a render pass instance that is compatible with the graphics pipeline used to create each of those nodes VUID-vkCmdDispatchGraphAMDX-pCountInfo-09145 pCountInfo->infos must be a host pointer to a memory allocation at least as large as the product of count and stride VUID-vkCmdDispatchGraphAMDX-infos-09146 Host memory locations at indexes in the range [infos, infos + (count*stride)), at a granularity of stride must contain valid VkDispatchGraphInfoAMDX structures in the first 24 bytes VUID-vkCmdDispatchGraphAMDX-pCountInfo-09147 For each VkDispatchGraphInfoAMDX structure in pCountInfo->infos, payloads must be a host pointer to a memory allocation at least as large as the product of payloadCount and payloadStride VUID-vkCmdDispatchGraphAMDX-pCountInfo-09148 For each VkDispatchGraphInfoAMDX structure in pCountInfo->infos, nodeIndex must be a valid node index in the bound execution graph pipeline, as returned by vkGetExecutionGraphPipelineNodeIndexAMDX VUID-vkCmdDispatchGraphAMDX-pCountInfo-09149 For each VkDispatchGraphInfoAMDX structure in pCountInfo->infos, host memory locations at indexes in the range [payloads, payloads + (payloadCount * payloadStride)), at a granularity of payloadStride must contain a payload matching the size of the input payload expected by the node in nodeIndex in the first bytes Valid Usage (Implicit) VUID-vkCmdDispatchGraphAMDX-commandBuffer-parameter commandBuffer must be a valid VkCommandBuffer handle VUID-vkCmdDispatchGraphAMDX-pCountInfo-parameter pCountInfo must be a valid pointer to a valid VkDispatchGraphCountInfoAMDX structure VUID-vkCmdDispatchGraphAMDX-commandBuffer-recording commandBuffer must be in the recording state VUID-vkCmdDispatchGraphAMDX-commandBuffer-cmdpool The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations VUID-vkCmdDispatchGraphAMDX-videocoding This command must only be called outside of a video coding scope VUID-vkCmdDispatchGraphAMDX-bufferlevel commandBuffer must be a primary VkCommandBuffer Host Synchronization Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized Command Properties Command Buffer Levels Render Pass Scope Video Coding Scope Supported Queue Types Command Type Primary Both Outside Graphics Compute Action To record an execution graph dispatch with node and payload parameters read on device, call: // Provided by VK_AMDX_shader_enqueue void vkCmdDispatchGraphIndirectAMDX( VkCommandBuffer commandBuffer, VkDeviceAddress scratch, VkDeviceSize scratchSize, const VkDispatchGraphCountInfoAMDX* pCountInfo); commandBuffer is the command buffer into which the command will be recorded. scratch is the address of scratch memory to be used. scratchSize is a range in bytes of scratch memory to be used. pCountInfo is a host pointer to a VkDispatchGraphCountInfoAMDX structure defining the nodes which will be initially executed. When this command is executed, the nodes specified in pCountInfo are executed. Nodes executed as part of this command are not implicitly synchronized in any way against each other once they are dispatched. There are no rasterization order guarantees between separately dispatched graphics nodes, though individual primitives within a single dispatch do adhere to rasterization order. Draw calls executed before or after the execution graph also execute relative to each graphics node with respect to rasterization order. For this command, all device/host pointers in substructures are treated as device pointers and read during device execution of this command. The allocation and contents of these pointers only needs to be valid during device execution. All of these addresses will be read in the VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT pipeline stage with the VK_ACCESS_2_SHADER_STORAGE_READ_BIT access flag. Execution of this command may modify any memory locations in the range [scratch,scratch + scratchSize). Accesses to this memory range are performed in the VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT pipeline stage with the VK_ACCESS_2_SHADER_STORAGE_READ_BIT and VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT access flags. This command captures command buffer state for mesh nodes similarly to draw commands. Valid Usage VUID-vkCmdDispatchGraphIndirectAMDX-magFilter-04553 If a VkSampler created with magFilter or minFilter equal to VK_FILTER_LINEAR, reductionMode equal to VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE, and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT VUID-vkCmdDispatchGraphIndirectAMDX-magFilter-09598 If a VkSampler created with magFilter or minFilter equal to VK_FILTER_LINEAR and reductionMode equal to either VK_SAMPLER_REDUCTION_MODE_MIN or VK_SAMPLER_REDUCTION_MODE_MAX is used to sample a VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT VUID-vkCmdDispatchGraphIndirectAMDX-mipmapMode-04770 If a VkSampler created with mipmapMode equal to VK_SAMPLER_MIPMAP_MODE_LINEAR, reductionMode equal to VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE, and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT VUID-vkCmdDispatchGraphIndirectAMDX-mipmapMode-09599 If a VkSampler created with mipmapMode equal to VK_SAMPLER_MIPMAP_MODE_LINEAR and reductionMode equal to either VK_SAMPLER_REDUCTION_MODE_MIN or VK_SAMPLER_REDUCTION_MODE_MAX is used to sample a VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT VUID-vkCmdDispatchGraphIndirectAMDX-unnormalizedCoordinates-09635 If a VkSampler created with unnormalizedCoordinates equal to VK_TRUE is used to sample a VkImageView as a result of this command, then the image view’s levelCount and layerCount must be 1 VUID-vkCmdDispatchGraphIndirectAMDX-None-08609 If a VkSampler created with unnormalizedCoordinates equal to VK_TRUE is used to sample a VkImageView as a result of this command, then the image view’s viewType must be VK_IMAGE_VIEW_TYPE_1D or VK_IMAGE_VIEW_TYPE_2D VUID-vkCmdDispatchGraphIndirectAMDX-None-08610 If a VkSampler created with unnormalizedCoordinates equal to VK_TRUE is used to sample a VkImageView as a result of this command, then the sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name VUID-vkCmdDispatchGraphIndirectAMDX-None-08611 If a VkSampler created with unnormalizedCoordinates equal to VK_TRUE is used to sample a VkImageView as a result of this command, then the sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values VUID-vkCmdDispatchGraphIndirectAMDX-None-06479 If a VkImageView is sampled with depth comparison, the image view’s format features must contain VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT VUID-vkCmdDispatchGraphIndirectAMDX-None-02691 If a VkImageView is accessed using atomic operations as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT VUID-vkCmdDispatchGraphIndirectAMDX-None-07888 If a VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER descriptor is accessed using atomic operations as a result of this command, then the storage texel buffer’s format features must contain VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT VUID-vkCmdDispatchGraphIndirectAMDX-None-02692 If a VkImageView is sampled with VK_FILTER_CUBIC_EXT as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT VUID-vkCmdDispatchGraphIndirectAMDX-None-02693 If the VK_EXT_filter_cubic extension is not enabled and any VkImageView is sampled with VK_FILTER_CUBIC_EXT as a result of this command, it must not have a VkImageViewType of VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY VUID-vkCmdDispatchGraphIndirectAMDX-filterCubic-02694 Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic returned by vkGetPhysicalDeviceImageFormatProperties2 VUID-vkCmdDispatchGraphIndirectAMDX-filterCubicMinmax-02695 Any VkImageView being sampled with VK_FILTER_CUBIC_EXT with a reduction mode of either VK_SAMPLER_REDUCTION_MODE_MIN or VK_SAMPLER_REDUCTION_MODE_MAX as a result of this command must have a VkImageViewType and format that supports cubic filtering together with minmax filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax returned by vkGetPhysicalDeviceImageFormatProperties2 VUID-vkCmdDispatchGraphIndirectAMDX-cubicRangeClamp-09212 If the cubicRangeClamp feature is not enabled, then any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must not have a VkSamplerReductionModeCreateInfo::reductionMode equal to VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM VUID-vkCmdDispatchGraphIndirectAMDX-reductionMode-09213 Any VkImageView being sampled with a VkSamplerReductionModeCreateInfo::reductionMode equal to VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM as a result of this command must sample with VK_FILTER_CUBIC_EXT VUID-vkCmdDispatchGraphIndirectAMDX-selectableCubicWeights-09214 If the selectableCubicWeights feature is not enabled, then any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must have VkSamplerCubicWeightsCreateInfoQCOM::cubicWeights equal to VK_CUBIC_FILTER_WEIGHTS_CATMULL_ROM_QCOM VUID-vkCmdDispatchGraphIndirectAMDX-flags-02696 Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE VUID-vkCmdDispatchGraphIndirectAMDX-OpTypeImage-07027 For any VkImageView being written as a storage image where the image format field of the OpTypeImage is Unknown, the view’s format features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT VUID-vkCmdDispatchGraphIndirectAMDX-OpTypeImage-07028 For any VkImageView being read as a storage image where the image format field of the OpTypeImage is Unknown, the view’s format features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT VUID-vkCmdDispatchGraphIndirectAMDX-OpTypeImage-07029 For any VkBufferView being written as a storage texel buffer where the image format field of the OpTypeImage is Unknown, the view’s buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT VUID-vkCmdDispatchGraphIndirectAMDX-OpTypeImage-07030 Any VkBufferView being read as a storage texel buffer where the image format field of the OpTypeImage is Unknown then the view’s buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT VUID-vkCmdDispatchGraphIndirectAMDX-None-08600 For each set n that is statically used by a bound shader, a descriptor set must have been bound to n at the same pipeline bind point, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline or the VkDescriptorSetLayout array used to create the current VkShaderEXT , as described in Pipeline Layout Compatibility VUID-vkCmdDispatchGraphIndirectAMDX-None-08601 For each push constant that is statically used by a bound shader, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline or the VkDescriptorSetLayout array used to create the current VkShaderEXT , as described in Pipeline Layout Compatibility VUID-vkCmdDispatchGraphIndirectAMDX-None-10068 For each array of resources that is used by a bound shader, the indices used to access members of the array must be less than the descriptor count for the identified binding in the descriptor sets used by this command VUID-vkCmdDispatchGraphIndirectAMDX-maintenance4-08602 If the maintenance4 feature is not enabled, then for each push constant that is statically used by a bound shader, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline or the VkDescriptorSetLayout and VkPushConstantRange arrays used to create the current VkShaderEXT , as described in Pipeline Layout Compatibility VUID-vkCmdDispatchGraphIndirectAMDX-None-08114 Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid as described by descriptor validity if they are statically used by the VkPipeline bound to the pipeline bind point used by this command and the bound VkPipeline was not created with VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT VUID-vkCmdDispatchGraphIndirectAMDX-None-08115 If the descriptors used by the VkPipeline bound to the pipeline bind point were specified via vkCmdBindDescriptorSets, the bound VkPipeline must have been created without VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT VUID-vkCmdDispatchGraphIndirectAMDX-None-08116 Descriptors in bound descriptor buffers, specified via vkCmdSetDescriptorBufferOffsetsEXT, must be valid if they are dynamically used by the VkPipeline bound to the pipeline bind point used by this command and the bound VkPipeline was created with VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT VUID-vkCmdDispatchGraphIndirectAMDX-None-08604 Descriptors in bound descriptor buffers, specified via vkCmdSetDescriptorBufferOffsetsEXT, must be valid if they are dynamically used by any VkShaderEXT bound to a stage corresponding to the pipeline bind point used by this command VUID-vkCmdDispatchGraphIndirectAMDX-None-08117 If the descriptors used by the VkPipeline bound to the pipeline bind point were specified via vkCmdSetDescriptorBufferOffsetsEXT, the bound VkPipeline must have been created with VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT VUID-vkCmdDispatchGraphIndirectAMDX-None-08119 If a descriptor is dynamically used with a VkPipeline created with VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT, the descriptor memory must be resident VUID-vkCmdDispatchGraphIndirectAMDX-None-08605 If a descriptor is dynamically used with a VkShaderEXT created with a VkDescriptorSetLayout that was created with VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT, the descriptor memory must be resident VUID-vkCmdDispatchGraphIndirectAMDX-None-08606 If the shaderObject feature is not enabled, a valid pipeline must be bound to the pipeline bind point used by this command VUID-vkCmdDispatchGraphIndirectAMDX-None-08608 If a pipeline is bound to the pipeline bind point used by this command, there must not have been any calls to dynamic state setting commands for any state specified statically in the VkPipeline object bound to the pipeline bind point used by this command, since that pipeline was bound VUID-vkCmdDispatchGraphIndirectAMDX-uniformBuffers-06935 If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a uniform buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2 for uniformBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point VUID-vkCmdDispatchGraphIndirectAMDX-None-08612 If the robustBufferAccess feature is not enabled, and any VkShaderEXT bound to a stage corresponding to the pipeline bind point used by this command accesses a uniform buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point VUID-vkCmdDispatchGraphIndirectAMDX-storageBuffers-06936 If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a storage buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2 for storageBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point VUID-vkCmdDispatchGraphIndirectAMDX-None-08613 If the robustBufferAccess feature is not enabled, and any VkShaderEXT bound to a stage corresponding to the pipeline bind point used by this command accesses a storage buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point VUID-vkCmdDispatchGraphIndirectAMDX-commandBuffer-02707 If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, any resource accessed by bound shaders must not be a protected resource VUID-vkCmdDispatchGraphIndirectAMDX-viewType-07752 If a VkImageView is accessed as a result of this command, then the image view’s viewType must match the Dim operand of the OpTypeImage as described in Compatibility Between SPIR-V Image Dimensions and Vulkan ImageView Types VUID-vkCmdDispatchGraphIndirectAMDX-format-07753 If a VkImageView or VkBufferView is accessed as a result of this command, then the numeric type of the view’s format and the Sampled Type operand of the OpTypeImage must match VUID-vkCmdDispatchGraphIndirectAMDX-OpImageWrite-08795 If a VkImageView created with a format other than VK_FORMAT_A8_UNORM is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the image view’s format VUID-vkCmdDispatchGraphIndirectAMDX-OpImageWrite-08796 If a VkImageView created with the format VK_FORMAT_A8_UNORM is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have four components VUID-vkCmdDispatchGraphIndirectAMDX-OpImageWrite-04469 If a VkBufferView is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the buffer view’s format VUID-vkCmdDispatchGraphIndirectAMDX-SampledType-04470 If a VkImageView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64 VUID-vkCmdDispatchGraphIndirectAMDX-SampledType-04471 If a VkImageView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32 VUID-vkCmdDispatchGraphIndirectAMDX-SampledType-04472 If a VkBufferView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64 VUID-vkCmdDispatchGraphIndirectAMDX-SampledType-04473 If a VkBufferView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32 VUID-vkCmdDispatchGraphIndirectAMDX-sparseImageInt64Atomics-04474 If the sparseImageInt64Atomics feature is not enabled, VkImage objects created with the VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command VUID-vkCmdDispatchGraphIndirectAMDX-sparseImageInt64Atomics-04475 If the sparseImageInt64Atomics feature is not enabled, VkBuffer objects created with the VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command VUID-vkCmdDispatchGraphIndirectAMDX-OpImageWeightedSampleQCOM-06971 If OpImageWeightedSampleQCOM is used to sample a VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM VUID-vkCmdDispatchGraphIndirectAMDX-OpImageWeightedSampleQCOM-06972 If OpImageWeightedSampleQCOM uses a VkImageView as a sample weight image as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM VUID-vkCmdDispatchGraphIndirectAMDX-OpImageBoxFilterQCOM-06973 If OpImageBoxFilterQCOM is used to sample a VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM VUID-vkCmdDispatchGraphIndirectAMDX-OpImageBlockMatchSSDQCOM-06974 If OpImageBlockMatchSSDQCOM is used to read from an VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM VUID-vkCmdDispatchGraphIndirectAMDX-OpImageBlockMatchSADQCOM-06975 If OpImageBlockMatchSADQCOM is used to read from an VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM VUID-vkCmdDispatchGraphIndirectAMDX-OpImageBlockMatchSADQCOM-06976 If OpImageBlockMatchSADQCOM or OpImageBlockMatchSSDQCOM is used to read from a reference image as result of this command, then the specified reference coordinates must not fail integer texel coordinate validation VUID-vkCmdDispatchGraphIndirectAMDX-OpImageWeightedSampleQCOM-06977 If OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchWindowSSDQCOM, OpImageBlockMatchWindowSADQCOM, OpImageBlockMatchGatherSSDQCOM, OpImageBlockMatchGatherSADQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM VUID-vkCmdDispatchGraphIndirectAMDX-OpImageWeightedSampleQCOM-06978 If any command other than OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchWindowSSDQCOM, OpImageBlockMatchWindowSADQCOM, OpImageBlockMatchGatherSSDQCOM, OpImageBlockMatchGatherSADQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must not have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM VUID-vkCmdDispatchGraphIndirectAMDX-OpImageBlockMatchWindow-09215 If a OpImageBlockMatchWindow*QCOM or OpImageBlockMatchGather*QCOM instruction is used to read from an VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM VUID-vkCmdDispatchGraphIndirectAMDX-OpImageBlockMatchWindow-09216 If a OpImageBlockMatchWindow*QCOM or OpImageBlockMatchGather*QCOM instruction is used to read from an VkImageView as a result of this command, then the image view’s format must be a single-component format VUID-vkCmdDispatchGraphIndirectAMDX-OpImageBlockMatchWindow-09217 If a OpImageBlockMatchWindow*QCOM or OpImageBlockMatchGather*QCOM read from a reference image as result of this command, then the specified reference coordinates must not fail integer texel coordinate validation VUID-vkCmdDispatchGraphIndirectAMDX-None-07288 Any shader invocation executed by this command must terminate VUID-vkCmdDispatchGraphIndirectAMDX-None-09600 If a descriptor with type equal to any of VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM, VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, or VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT is accessed as a result of this command, all image subresources identified by that descriptor must be in the image layout identified when the descriptor was written VUID-vkCmdDispatchGraphIndirectAMDX-commandBuffer-10746 The VkDeviceMemory object allocated from a VkMemoryHeap with the VK_MEMORY_HEAP_TILE_MEMORY_BIT_QCOM property that is bound to a resource accessed as a result of this command must be the active bound bound tile memory object in commandBuffer VUID-vkCmdDispatchGraphIndirectAMDX-None-10678 If this command is recorded inside a tile shading render pass instance, the stages corresponding to the pipeline bind point used by this command must only include VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_FRAGMENT_BIT, and/or VK_SHADER_STAGE_COMPUTE_BIT VUID-vkCmdDispatchGraphIndirectAMDX-None-10679 If this command is recorded where per-tile execution model is enabled, there must be no access to any image while the image was be transitioned to the VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT layout VUID-vkCmdDispatchGraphIndirectAMDX-commandBuffer-09181 commandBuffer must not be a protected command buffer VUID-vkCmdDispatchGraphIndirectAMDX-commandBuffer-09182 commandBuffer must be a primary command buffer VUID-vkCmdDispatchGraphIndirectAMDX-scratch-10192 scratch must be the device address of an allocated memory range at least as large as scratchSize VUID-vkCmdDispatchGraphIndirectAMDX-scratchSize-10193 scratchSize must be greater than or equal to VkExecutionGraphPipelineScratchSizeAMDX::minSize returned by vkGetExecutionGraphPipelineScratchSizeAMDX for the bound execution graph pipeline VUID-vkCmdDispatchGraphIndirectAMDX-scratch-09184 scratch must be a device address within a VkBuffer created with the VK_BUFFER_USAGE_EXECUTION_GRAPH_SCRATCH_BIT_AMDX or VK_BUFFER_USAGE_2_EXECUTION_GRAPH_SCRATCH_BIT_AMDX flag VUID-vkCmdDispatchGraphIndirectAMDX-scratch-10194 The device memory range [scratch,scratch scratchSize] must have been initialized with vkCmdInitializeGraphScratchMemoryAMDX using the bound execution graph pipeline, and not modified after that by anything other than another execution graph dispatch command VUID-vkCmdDispatchGraphIndirectAMDX-maxComputeWorkGroupCount-09186 Execution of this command must not cause a node to be dispatched with a larger number of workgroups than that specified by either a MaxNumWorkgroupsAMDX decoration in the dispatched node or maxComputeWorkGroupCount VUID-vkCmdDispatchGraphIndirectAMDX-maxExecutionGraphShaderPayloadCount-09187 Execution of this command must not cause any shader to initialize more than maxExecutionGraphShaderPayloadCount output payloads VUID-vkCmdDispatchGraphIndirectAMDX-NodeMaxPayloadsAMDX-09188 Execution of this command must not cause any shader that declares NodeMaxPayloadsAMDX to initialize more output payloads than specified by the max number of payloads for that decoration. This requirement applies to each NodeMaxPayloadsAMDX decoration separately VUID-vkCmdDispatchGraphIndirectAMDX-None-10195 If the bound execution graph pipeline includes draw nodes, this command must be called within a render pass instance that is compatible with the graphics pipeline used to create each of those nodes VUID-vkCmdDispatchGraphIndirectAMDX-pCountInfo-09150 pCountInfo->infos must be a device pointer to a memory allocation at least as large as the product of count and stride when this command is executed on the device VUID-vkCmdDispatchGraphIndirectAMDX-pCountInfo-09151 pCountInfo->infos must be a device address within a VkBuffer created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT flag VUID-vkCmdDispatchGraphIndirectAMDX-pCountInfo-09152 pCountInfo->infos must be a multiple of executionGraphDispatchAddressAlignment VUID-vkCmdDispatchGraphIndirectAMDX-infos-09153 Device memory locations at indexes in the range [infos, infos + (count*stride)), at a granularity of stride must contain valid VkDispatchGraphInfoAMDX structures in the first 24 bytes when this command is executed on the device VUID-vkCmdDispatchGraphIndirectAMDX-pCountInfo-09154 For each VkDispatchGraphInfoAMDX structure in pCountInfo->infos, payloads must be a device pointer to a memory allocation at least as large as the product of payloadCount and payloadStride when this command is executed on the device VUID-vkCmdDispatchGraphIndirectAMDX-pCountInfo-09155 For each VkDispatchGraphInfoAMDX structure in pCountInfo->infos, payloads must be a device address within a VkBuffer created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT flag VUID-vkCmdDispatchGraphIndirectAMDX-pCountInfo-09156 For each VkDispatchGraphInfoAMDX structure in pCountInfo->infos, payloads must be a multiple of executionGraphDispatchAddressAlignment VUID-vkCmdDispatchGraphIndirectAMDX-pCountInfo-09157 For each VkDispatchGraphInfoAMDX structure in pCountInfo->infos, nodeIndex must be a valid node index in the bound execution graph pipeline, as returned by vkGetExecutionGraphPipelineNodeIndexAMDX when this command is executed on the device VUID-vkCmdDispatchGraphIndirectAMDX-pCountInfo-09158 For each VkDispatchGraphInfoAMDX structure in pCountInfo->infos, device memory locations at indexes in the range [payloads, payloads + (payloadCount * payloadStride)), at a granularity of payloadStride must contain a payload matching the size of the input payload expected by the node in nodeIndex in the first bytes when this command is executed on the device Valid Usage (Implicit) VUID-vkCmdDispatchGraphIndirectAMDX-commandBuffer-parameter commandBuffer must be a valid VkCommandBuffer handle VUID-vkCmdDispatchGraphIndirectAMDX-pCountInfo-parameter pCountInfo must be a valid pointer to a valid VkDispatchGraphCountInfoAMDX structure VUID-vkCmdDispatchGraphIndirectAMDX-commandBuffer-recording commandBuffer must be in the recording state VUID-vkCmdDispatchGraphIndirectAMDX-commandBuffer-cmdpool The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations VUID-vkCmdDispatchGraphIndirectAMDX-videocoding This command must only be called outside of a video coding scope VUID-vkCmdDispatchGraphIndirectAMDX-bufferlevel commandBuffer must be a primary VkCommandBuffer Host Synchronization Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized Command Properties Command Buffer Levels Render Pass Scope Video Coding Scope Supported Queue Types Command Type Primary Both Outside Graphics Compute Action To record an execution graph dispatch with all parameters read on device, call: // Provided by VK_AMDX_shader_enqueue void vkCmdDispatchGraphIndirectCountAMDX( VkCommandBuffer commandBuffer, VkDeviceAddress scratch, VkDeviceSize scratchSize, VkDeviceAddress countInfo); commandBuffer is the command buffer into which the command will be recorded. scratch is the address of scratch memory to be used. scratchSize is a range in bytes of scratch memory to be used. countInfo is a device address of a VkDispatchGraphCountInfoAMDX structure defining the nodes which will be initially executed. When this command is executed, the nodes specified in countInfo are executed. Nodes executed as part of this command are not implicitly synchronized in any way against each other once they are dispatched. For this command, all pointers in substructures are treated as device pointers and read during device execution of this command. The allocation and contents of these pointers only needs to be valid during device execution. All of these addresses will be read in the VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT pipeline stage with the VK_ACCESS_2_SHADER_STORAGE_READ_BIT access flag. Execution of this command may modify any memory locations in the range [scratch,scratch + scratchSize). Accesses to this memory range are performed in the VK_PIPELINE_STAGE_2_COMPUTE_SHADER_BIT pipeline stage with the VK_ACCESS_2_SHADER_STORAGE_READ_BIT and VK_ACCESS_2_SHADER_STORAGE_WRITE_BIT access flags. Valid Usage VUID-vkCmdDispatchGraphIndirectCountAMDX-magFilter-04553 If a VkSampler created with magFilter or minFilter equal to VK_FILTER_LINEAR, reductionMode equal to VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE, and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT VUID-vkCmdDispatchGraphIndirectCountAMDX-magFilter-09598 If a VkSampler created with magFilter or minFilter equal to VK_FILTER_LINEAR and reductionMode equal to either VK_SAMPLER_REDUCTION_MODE_MIN or VK_SAMPLER_REDUCTION_MODE_MAX is used to sample a VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT VUID-vkCmdDispatchGraphIndirectCountAMDX-mipmapMode-04770 If a VkSampler created with mipmapMode equal to VK_SAMPLER_MIPMAP_MODE_LINEAR, reductionMode equal to VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE, and compareEnable equal to VK_FALSE is used to sample a VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT VUID-vkCmdDispatchGraphIndirectCountAMDX-mipmapMode-09599 If a VkSampler created with mipmapMode equal to VK_SAMPLER_MIPMAP_MODE_LINEAR and reductionMode equal to either VK_SAMPLER_REDUCTION_MODE_MIN or VK_SAMPLER_REDUCTION_MODE_MAX is used to sample a VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT VUID-vkCmdDispatchGraphIndirectCountAMDX-unnormalizedCoordinates-09635 If a VkSampler created with unnormalizedCoordinates equal to VK_TRUE is used to sample a VkImageView as a result of this command, then the image view’s levelCount and layerCount must be 1 VUID-vkCmdDispatchGraphIndirectCountAMDX-None-08609 If a VkSampler created with unnormalizedCoordinates equal to VK_TRUE is used to sample a VkImageView as a result of this command, then the image view’s viewType must be VK_IMAGE_VIEW_TYPE_1D or VK_IMAGE_VIEW_TYPE_2D VUID-vkCmdDispatchGraphIndirectCountAMDX-None-08610 If a VkSampler created with unnormalizedCoordinates equal to VK_TRUE is used to sample a VkImageView as a result of this command, then the sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions with ImplicitLod, Dref or Proj in their name VUID-vkCmdDispatchGraphIndirectCountAMDX-None-08611 If a VkSampler created with unnormalizedCoordinates equal to VK_TRUE is used to sample a VkImageView as a result of this command, then the sampler must not be used with any of the SPIR-V OpImageSample* or OpImageSparseSample* instructions that includes a LOD bias or any offset values VUID-vkCmdDispatchGraphIndirectCountAMDX-None-06479 If a VkImageView is sampled with depth comparison, the image view’s format features must contain VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_DEPTH_COMPARISON_BIT VUID-vkCmdDispatchGraphIndirectCountAMDX-None-02691 If a VkImageView is accessed using atomic operations as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT VUID-vkCmdDispatchGraphIndirectCountAMDX-None-07888 If a VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER descriptor is accessed using atomic operations as a result of this command, then the storage texel buffer’s format features must contain VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT VUID-vkCmdDispatchGraphIndirectCountAMDX-None-02692 If a VkImageView is sampled with VK_FILTER_CUBIC_EXT as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT VUID-vkCmdDispatchGraphIndirectCountAMDX-None-02693 If the VK_EXT_filter_cubic extension is not enabled and any VkImageView is sampled with VK_FILTER_CUBIC_EXT as a result of this command, it must not have a VkImageViewType of VK_IMAGE_VIEW_TYPE_3D, VK_IMAGE_VIEW_TYPE_CUBE, or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY VUID-vkCmdDispatchGraphIndirectCountAMDX-filterCubic-02694 Any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must have a VkImageViewType and format that supports cubic filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubic returned by vkGetPhysicalDeviceImageFormatProperties2 VUID-vkCmdDispatchGraphIndirectCountAMDX-filterCubicMinmax-02695 Any VkImageView being sampled with VK_FILTER_CUBIC_EXT with a reduction mode of either VK_SAMPLER_REDUCTION_MODE_MIN or VK_SAMPLER_REDUCTION_MODE_MAX as a result of this command must have a VkImageViewType and format that supports cubic filtering together with minmax filtering, as specified by VkFilterCubicImageViewImageFormatPropertiesEXT::filterCubicMinmax returned by vkGetPhysicalDeviceImageFormatProperties2 VUID-vkCmdDispatchGraphIndirectCountAMDX-cubicRangeClamp-09212 If the cubicRangeClamp feature is not enabled, then any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must not have a VkSamplerReductionModeCreateInfo::reductionMode equal to VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM VUID-vkCmdDispatchGraphIndirectCountAMDX-reductionMode-09213 Any VkImageView being sampled with a VkSamplerReductionModeCreateInfo::reductionMode equal to VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM as a result of this command must sample with VK_FILTER_CUBIC_EXT VUID-vkCmdDispatchGraphIndirectCountAMDX-selectableCubicWeights-09214 If the selectableCubicWeights feature is not enabled, then any VkImageView being sampled with VK_FILTER_CUBIC_EXT as a result of this command must have VkSamplerCubicWeightsCreateInfoQCOM::cubicWeights equal to VK_CUBIC_FILTER_WEIGHTS_CATMULL_ROM_QCOM VUID-vkCmdDispatchGraphIndirectCountAMDX-flags-02696 Any VkImage created with a VkImageCreateInfo::flags containing VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV sampled as a result of this command must only be sampled using a VkSamplerAddressMode of VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE VUID-vkCmdDispatchGraphIndirectCountAMDX-OpTypeImage-07027 For any VkImageView being written as a storage image where the image format field of the OpTypeImage is Unknown, the view’s format features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT VUID-vkCmdDispatchGraphIndirectCountAMDX-OpTypeImage-07028 For any VkImageView being read as a storage image where the image format field of the OpTypeImage is Unknown, the view’s format features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT VUID-vkCmdDispatchGraphIndirectCountAMDX-OpTypeImage-07029 For any VkBufferView being written as a storage texel buffer where the image format field of the OpTypeImage is Unknown, the view’s buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_WRITE_WITHOUT_FORMAT_BIT VUID-vkCmdDispatchGraphIndirectCountAMDX-OpTypeImage-07030 Any VkBufferView being read as a storage texel buffer where the image format field of the OpTypeImage is Unknown then the view’s buffer features must contain VK_FORMAT_FEATURE_2_STORAGE_READ_WITHOUT_FORMAT_BIT VUID-vkCmdDispatchGraphIndirectCountAMDX-None-08600 For each set n that is statically used by a bound shader, a descriptor set must have been bound to n at the same pipeline bind point, with a VkPipelineLayout that is compatible for set n, with the VkPipelineLayout used to create the current VkPipeline or the VkDescriptorSetLayout array used to create the current VkShaderEXT , as described in Pipeline Layout Compatibility VUID-vkCmdDispatchGraphIndirectCountAMDX-None-08601 For each push constant that is statically used by a bound shader, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline or the VkDescriptorSetLayout array used to create the current VkShaderEXT , as described in Pipeline Layout Compatibility VUID-vkCmdDispatchGraphIndirectCountAMDX-None-10068 For each array of resources that is used by a bound shader, the indices used to access members of the array must be less than the descriptor count for the identified binding in the descriptor sets used by this command VUID-vkCmdDispatchGraphIndirectCountAMDX-maintenance4-08602 If the maintenance4 feature is not enabled, then for each push constant that is statically used by a bound shader, a push constant value must have been set for the same pipeline bind point, with a VkPipelineLayout that is compatible for push constants, with the VkPipelineLayout used to create the current VkPipeline or the VkDescriptorSetLayout and VkPushConstantRange arrays used to create the current VkShaderEXT , as described in Pipeline Layout Compatibility VUID-vkCmdDispatchGraphIndirectCountAMDX-None-08114 Descriptors in each bound descriptor set, specified via vkCmdBindDescriptorSets, must be valid as described by descriptor validity if they are statically used by the VkPipeline bound to the pipeline bind point used by this command and the bound VkPipeline was not created with VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT VUID-vkCmdDispatchGraphIndirectCountAMDX-None-08115 If the descriptors used by the VkPipeline bound to the pipeline bind point were specified via vkCmdBindDescriptorSets, the bound VkPipeline must have been created without VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT VUID-vkCmdDispatchGraphIndirectCountAMDX-None-08116 Descriptors in bound descriptor buffers, specified via vkCmdSetDescriptorBufferOffsetsEXT, must be valid if they are dynamically used by the VkPipeline bound to the pipeline bind point used by this command and the bound VkPipeline was created with VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT VUID-vkCmdDispatchGraphIndirectCountAMDX-None-08604 Descriptors in bound descriptor buffers, specified via vkCmdSetDescriptorBufferOffsetsEXT, must be valid if they are dynamically used by any VkShaderEXT bound to a stage corresponding to the pipeline bind point used by this command VUID-vkCmdDispatchGraphIndirectCountAMDX-None-08117 If the descriptors used by the VkPipeline bound to the pipeline bind point were specified via vkCmdSetDescriptorBufferOffsetsEXT, the bound VkPipeline must have been created with VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT VUID-vkCmdDispatchGraphIndirectCountAMDX-None-08119 If a descriptor is dynamically used with a VkPipeline created with VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT, the descriptor memory must be resident VUID-vkCmdDispatchGraphIndirectCountAMDX-None-08605 If a descriptor is dynamically used with a VkShaderEXT created with a VkDescriptorSetLayout that was created with VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT, the descriptor memory must be resident VUID-vkCmdDispatchGraphIndirectCountAMDX-None-08606 If the shaderObject feature is not enabled, a valid pipeline must be bound to the pipeline bind point used by this command VUID-vkCmdDispatchGraphIndirectCountAMDX-None-08608 If a pipeline is bound to the pipeline bind point used by this command, there must not have been any calls to dynamic state setting commands for any state specified statically in the VkPipeline object bound to the pipeline bind point used by this command, since that pipeline was bound VUID-vkCmdDispatchGraphIndirectCountAMDX-uniformBuffers-06935 If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a uniform buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2 for uniformBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point VUID-vkCmdDispatchGraphIndirectCountAMDX-None-08612 If the robustBufferAccess feature is not enabled, and any VkShaderEXT bound to a stage corresponding to the pipeline bind point used by this command accesses a uniform buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point VUID-vkCmdDispatchGraphIndirectCountAMDX-storageBuffers-06936 If any stage of the VkPipeline object bound to the pipeline bind point used by this command accesses a storage buffer, and that stage was created without enabling either VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS or VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2 for storageBuffers, and the robustBufferAccess feature is not enabled, that stage must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point VUID-vkCmdDispatchGraphIndirectCountAMDX-None-08613 If the robustBufferAccess feature is not enabled, and any VkShaderEXT bound to a stage corresponding to the pipeline bind point used by this command accesses a storage buffer, it must not access values outside of the range of the buffer as specified in the descriptor set bound to the same pipeline bind point VUID-vkCmdDispatchGraphIndirectCountAMDX-commandBuffer-02707 If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, any resource accessed by bound shaders must not be a protected resource VUID-vkCmdDispatchGraphIndirectCountAMDX-viewType-07752 If a VkImageView is accessed as a result of this command, then the image view’s viewType must match the Dim operand of the OpTypeImage as described in Compatibility Between SPIR-V Image Dimensions and Vulkan ImageView Types VUID-vkCmdDispatchGraphIndirectCountAMDX-format-07753 If a VkImageView or VkBufferView is accessed as a result of this command, then the numeric type of the view’s format and the Sampled Type operand of the OpTypeImage must match VUID-vkCmdDispatchGraphIndirectCountAMDX-OpImageWrite-08795 If a VkImageView created with a format other than VK_FORMAT_A8_UNORM is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the image view’s format VUID-vkCmdDispatchGraphIndirectCountAMDX-OpImageWrite-08796 If a VkImageView created with the format VK_FORMAT_A8_UNORM is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have four components VUID-vkCmdDispatchGraphIndirectCountAMDX-OpImageWrite-04469 If a VkBufferView is accessed using OpImageWrite as a result of this command, then the Type of the Texel operand of that instruction must have at least as many components as the buffer view’s format VUID-vkCmdDispatchGraphIndirectCountAMDX-SampledType-04470 If a VkImageView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64 VUID-vkCmdDispatchGraphIndirectCountAMDX-SampledType-04471 If a VkImageView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32 VUID-vkCmdDispatchGraphIndirectCountAMDX-SampledType-04472 If a VkBufferView with a VkFormat that has a 64-bit component width is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 64 VUID-vkCmdDispatchGraphIndirectCountAMDX-SampledType-04473 If a VkBufferView with a VkFormat that has a component width less than 64-bit is accessed as a result of this command, the SampledType of the OpTypeImage operand of that instruction must have a Width of 32 VUID-vkCmdDispatchGraphIndirectCountAMDX-sparseImageInt64Atomics-04474 If the sparseImageInt64Atomics feature is not enabled, VkImage objects created with the VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command VUID-vkCmdDispatchGraphIndirectCountAMDX-sparseImageInt64Atomics-04475 If the sparseImageInt64Atomics feature is not enabled, VkBuffer objects created with the VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT flag must not be accessed by atomic instructions through an OpTypeImage with a SampledType with a Width of 64 by this command VUID-vkCmdDispatchGraphIndirectCountAMDX-OpImageWeightedSampleQCOM-06971 If OpImageWeightedSampleQCOM is used to sample a VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_2_WEIGHT_SAMPLED_IMAGE_BIT_QCOM VUID-vkCmdDispatchGraphIndirectCountAMDX-OpImageWeightedSampleQCOM-06972 If OpImageWeightedSampleQCOM uses a VkImageView as a sample weight image as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_2_WEIGHT_IMAGE_BIT_QCOM VUID-vkCmdDispatchGraphIndirectCountAMDX-OpImageBoxFilterQCOM-06973 If OpImageBoxFilterQCOM is used to sample a VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_2_BOX_FILTER_SAMPLED_BIT_QCOM VUID-vkCmdDispatchGraphIndirectCountAMDX-OpImageBlockMatchSSDQCOM-06974 If OpImageBlockMatchSSDQCOM is used to read from an VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM VUID-vkCmdDispatchGraphIndirectCountAMDX-OpImageBlockMatchSADQCOM-06975 If OpImageBlockMatchSADQCOM is used to read from an VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM VUID-vkCmdDispatchGraphIndirectCountAMDX-OpImageBlockMatchSADQCOM-06976 If OpImageBlockMatchSADQCOM or OpImageBlockMatchSSDQCOM is used to read from a reference image as result of this command, then the specified reference coordinates must not fail integer texel coordinate validation VUID-vkCmdDispatchGraphIndirectCountAMDX-OpImageWeightedSampleQCOM-06977 If OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchWindowSSDQCOM, OpImageBlockMatchWindowSADQCOM, OpImageBlockMatchGatherSSDQCOM, OpImageBlockMatchGatherSADQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM VUID-vkCmdDispatchGraphIndirectCountAMDX-OpImageWeightedSampleQCOM-06978 If any command other than OpImageWeightedSampleQCOM, OpImageBoxFilterQCOM, OpImageBlockMatchWindowSSDQCOM, OpImageBlockMatchWindowSADQCOM, OpImageBlockMatchGatherSSDQCOM, OpImageBlockMatchGatherSADQCOM, OpImageBlockMatchSSDQCOM, or OpImageBlockMatchSADQCOM uses a VkSampler as a result of this command, then the sampler must not have been created with VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM VUID-vkCmdDispatchGraphIndirectCountAMDX-OpImageBlockMatchWindow-09215 If a OpImageBlockMatchWindow*QCOM or OpImageBlockMatchGather*QCOM instruction is used to read from an VkImageView as a result of this command, then the image view’s format features must contain VK_FORMAT_FEATURE_2_BLOCK_MATCHING_BIT_QCOM VUID-vkCmdDispatchGraphIndirectCountAMDX-OpImageBlockMatchWindow-09216 If a OpImageBlockMatchWindow*QCOM or OpImageBlockMatchGather*QCOM instruction is used to read from an VkImageView as a result of this command, then the image view’s format must be a single-component format VUID-vkCmdDispatchGraphIndirectCountAMDX-OpImageBlockMatchWindow-09217 If a OpImageBlockMatchWindow*QCOM or OpImageBlockMatchGather*QCOM read from a reference image as result of this command, then the specified reference coordinates must not fail integer texel coordinate validation VUID-vkCmdDispatchGraphIndirectCountAMDX-None-07288 Any shader invocation executed by this command must terminate VUID-vkCmdDispatchGraphIndirectCountAMDX-None-09600 If a descriptor with type equal to any of VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM, VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, or VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT is accessed as a result of this command, all image subresources identified by that descriptor must be in the image layout identified when the descriptor was written VUID-vkCmdDispatchGraphIndirectCountAMDX-commandBuffer-10746 The VkDeviceMemory object allocated from a VkMemoryHeap with the VK_MEMORY_HEAP_TILE_MEMORY_BIT_QCOM property that is bound to a resource accessed as a result of this command must be the active bound bound tile memory object in commandBuffer VUID-vkCmdDispatchGraphIndirectCountAMDX-None-10678 If this command is recorded inside a tile shading render pass instance, the stages corresponding to the pipeline bind point used by this command must only include VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_FRAGMENT_BIT, and/or VK_SHADER_STAGE_COMPUTE_BIT VUID-vkCmdDispatchGraphIndirectCountAMDX-None-10679 If this command is recorded where per-tile execution model is enabled, there must be no access to any image while the image was be transitioned to the VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT layout VUID-vkCmdDispatchGraphIndirectCountAMDX-commandBuffer-09181 commandBuffer must not be a protected command buffer VUID-vkCmdDispatchGraphIndirectCountAMDX-commandBuffer-09182 commandBuffer must be a primary command buffer VUID-vkCmdDispatchGraphIndirectCountAMDX-scratch-10192 scratch must be the device address of an allocated memory range at least as large as scratchSize VUID-vkCmdDispatchGraphIndirectCountAMDX-scratchSize-10193 scratchSize must be greater than or equal to VkExecutionGraphPipelineScratchSizeAMDX::minSize returned by vkGetExecutionGraphPipelineScratchSizeAMDX for the bound execution graph pipeline VUID-vkCmdDispatchGraphIndirectCountAMDX-scratch-09184 scratch must be a device address within a VkBuffer created with the VK_BUFFER_USAGE_EXECUTION_GRAPH_SCRATCH_BIT_AMDX or VK_BUFFER_USAGE_2_EXECUTION_GRAPH_SCRATCH_BIT_AMDX flag VUID-vkCmdDispatchGraphIndirectCountAMDX-scratch-10194 The device memory range [scratch,scratch scratchSize] must have been initialized with vkCmdInitializeGraphScratchMemoryAMDX using the bound execution graph pipeline, and not modified after that by anything other than another execution graph dispatch command VUID-vkCmdDispatchGraphIndirectCountAMDX-maxComputeWorkGroupCount-09186 Execution of this command must not cause a node to be dispatched with a larger number of workgroups than that specified by either a MaxNumWorkgroupsAMDX decoration in the dispatched node or maxComputeWorkGroupCount VUID-vkCmdDispatchGraphIndirectCountAMDX-maxExecutionGraphShaderPayloadCount-09187 Execution of this command must not cause any shader to initialize more than maxExecutionGraphShaderPayloadCount output payloads VUID-vkCmdDispatchGraphIndirectCountAMDX-NodeMaxPayloadsAMDX-09188 Execution of this command must not cause any shader that declares NodeMaxPayloadsAMDX to initialize more output payloads than specified by the max number of payloads for that decoration. This requirement applies to each NodeMaxPayloadsAMDX decoration separately VUID-vkCmdDispatchGraphIndirectCountAMDX-None-10195 If the bound execution graph pipeline includes draw nodes, this command must be called within a render pass instance that is compatible with the graphics pipeline used to create each of those nodes VUID-vkCmdDispatchGraphIndirectCountAMDX-countInfo-09159 countInfo must be a device pointer to a memory allocation containing a valid VkDispatchGraphCountInfoAMDX structure when this command is executed on the device VUID-vkCmdDispatchGraphIndirectCountAMDX-countInfo-09160 countInfo must be a device address within a VkBuffer created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT flag VUID-vkCmdDispatchGraphIndirectCountAMDX-countInfo-09161 countInfo must be a multiple of executionGraphDispatchAddressAlignment VUID-vkCmdDispatchGraphIndirectCountAMDX-countInfo-09162 countInfo->infos must be a device pointer to a memory allocation at least as large as the product of count and stride when this command is executed on the device VUID-vkCmdDispatchGraphIndirectCountAMDX-countInfo-09163 countInfo->infos must be a device address within a VkBuffer created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT flag VUID-vkCmdDispatchGraphIndirectCountAMDX-countInfo-09164 countInfo->infos must be a multiple of executionGraphDispatchAddressAlignment VUID-vkCmdDispatchGraphIndirectCountAMDX-infos-09165 Device memory locations at indexes in the range [infos, infos + (count*stride)), at a granularity of stride must contain valid VkDispatchGraphInfoAMDX structures in the first 24 bytes when this command is executed on the device VUID-vkCmdDispatchGraphIndirectCountAMDX-countInfo-09166 For each VkDispatchGraphInfoAMDX structure in countInfo->infos, payloads must be a device pointer to a memory allocation at least as large as the product of payloadCount and payloadStride when this command is executed on the device VUID-vkCmdDispatchGraphIndirectCountAMDX-countInfo-09167 For each VkDispatchGraphInfoAMDX structure in countInfo->infos, payloads must be a device address within a VkBuffer created with the VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT flag VUID-vkCmdDispatchGraphIndirectCountAMDX-countInfo-09168 For each VkDispatchGraphInfoAMDX structure in countInfo->infos, payloads must be a multiple of executionGraphDispatchAddressAlignment VUID-vkCmdDispatchGraphIndirectCountAMDX-countInfo-09169 For each VkDispatchGraphInfoAMDX structure in countInfo->infos, nodeIndex must be a valid node index in the bound execution graph pipeline, as returned by vkGetExecutionGraphPipelineNodeIndexAMDX when this command is executed on the device VUID-vkCmdDispatchGraphIndirectCountAMDX-countInfo-09170 For each VkDispatchGraphInfoAMDX structure in countInfo->infos, device memory locations at indexes in the range [payloads, payloads + (payloadCount * payloadStride)), at a granularity of payloadStride must contain a payload matching the size of the input payload expected by the node in nodeIndex in the first bytes when this command is executed on the device Valid Usage (Implicit) VUID-vkCmdDispatchGraphIndirectCountAMDX-commandBuffer-parameter commandBuffer must be a valid VkCommandBuffer handle VUID-vkCmdDispatchGraphIndirectCountAMDX-commandBuffer-recording commandBuffer must be in the recording state VUID-vkCmdDispatchGraphIndirectCountAMDX-commandBuffer-cmdpool The VkCommandPool that commandBuffer was allocated from must support graphics, or compute operations VUID-vkCmdDispatchGraphIndirectCountAMDX-videocoding This command must only be called outside of a video coding scope VUID-vkCmdDispatchGraphIndirectCountAMDX-bufferlevel commandBuffer must be a primary VkCommandBuffer Host Synchronization Host access to the VkCommandPool that commandBuffer was allocated from must be externally synchronized Command Properties Command Buffer Levels Render Pass Scope Video Coding Scope Supported Queue Types Command Type Primary Both Outside Graphics Compute Action The VkDeviceOrHostAddressConstAMDX union is defined as: // Provided by VK_AMDX_shader_enqueue typedef union VkDeviceOrHostAddressConstAMDX { VkDeviceAddress deviceAddress; const void* hostAddress; } VkDeviceOrHostAddressConstAMDX; deviceAddress is a buffer device address as returned by the vkGetBufferDeviceAddressKHR command. hostAddress is a const host memory address. The VkDispatchGraphCountInfoAMDX structure is defined as: // Provided by VK_AMDX_shader_enqueue typedef struct VkDispatchGraphCountInfoAMDX { uint32_t count; VkDeviceOrHostAddressConstAMDX infos; uint64_t stride; } VkDispatchGraphCountInfoAMDX; count is the number of dispatches to perform. infos is the device or host address of a flat array of VkDispatchGraphInfoAMDX structures stride is the byte stride between successive VkDispatchGraphInfoAMDX structures in infos Whether infos is consumed as a device or host pointer is defined by the command this structure is used in. The VkDispatchGraphInfoAMDX structure is defined as: // Provided by VK_AMDX_shader_enqueue typedef struct VkDispatchGraphInfoAMDX { uint32_t nodeIndex; uint32_t payloadCount; VkDeviceOrHostAddressConstAMDX payloads; uint64_t payloadStride; } VkDispatchGraphInfoAMDX; nodeIndex is the index of a node in an execution graph to be dispatched. payloadCount is the number of payloads to dispatch for the specified node. payloads is a device or host address pointer to a flat array of payloads with size equal to the product of payloadCount and payloadStride payloadStride is the byte stride between successive payloads in payloads Whether payloads is consumed as a device or host pointer is defined by the command this structure is used in. Valid Usage VUID-VkDispatchGraphInfoAMDX-payloadCount-09171 payloadCount must be no greater than maxExecutionGraphShaderPayloadCount Compute shaders in an execution graph can use the OpInitializeNodePayloadsAMDX to initialize nodes for dispatch. Any node payload initialized in this way will be enqueued for dispatch once the shader is done writing to the payload. As compilers may be conservative when making this determination, shaders can further call OpFinalizeNodePayloadsAMDX to guarantee that the payload is no longer being written. The Node Name operand of the PayloadNodeNameAMDX decoration on a payload identifies the shader name of the node to be enqueued, and the Shader Index operand of OpInitializeNodePayloadsAMDX identifies the shader index. A node identified in this way is dispatched as described in the following sections. Compute shaders added as nodes to an execution graph are executed differently based on the presence or absence of the StaticNumWorkgroupsAMDX or CoalescingAMDX execution modes. Dispatching a compute shader node that does not declare either the StaticNumWorkgroupsAMDX or CoalescingAMDX execution mode will execute a number of workgroups in each dimension specified by the first 12 bytes of the payload, interpreted as a VkDispatchIndirectCommand. The same payload will be broadcast to each workgroup in the same dispatch. Additional values in the payload are have no effect on execution. Dispatching a compute shader node with the StaticNumWorkgroupsAMDX execution mode will execute workgroups in each dimension according to the x, y, and z size operands to the StaticNumWorkgroupsAMDX execution mode. The same payload will be broadcast to each workgroup in the same dispatch. Any values in the payload have no effect on execution. Dispatching a compute shader node with the CoalescingAMDX execution mode will enqueue a single invocation for execution. Implementations may combine multiple such dispatches into the same workgroup, up to the size of the workgroup. The number of invocations coalesced into a given workgroup in this way can be queried via the CoalescedInputCountAMDX built-in. Any values in the payload have no effect on execution. Graphics pipelines added as nodes to an execution graph are executed in a manner similar to a vkCmdDrawMeshTasksIndirectEXT, using the same payloads as compute shaders, but capturing some state from the command buffer. When an execution graph dispatch is recorded into a command buffer, it captures the following dynamic state for use with draw nodes: VK_DYNAMIC_STATE_VIEWPORT VK_DYNAMIC_STATE_SCISSOR VK_DYNAMIC_STATE_LINE_WIDTH VK_DYNAMIC_STATE_DEPTH_BIAS VK_DYNAMIC_STATE_BLEND_CONSTANTS VK_DYNAMIC_STATE_DEPTH_BOUNDS VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR Other state is not captured, and graphics pipelines must not be created with other dynamic states when used as a library in an execution graph pipeline.

# Development Environment

## Metadata

- **Component**: tutorial
- **Version**: latest
- **URL**: /tutorial/latest/02_Development_environment.html

## Table of Contents

- [Windows](#_windows)
- [Vulkan SDK](#_vulkan_sdk)
- [GLFW](#_glfw)
- [GLM](#_glm)
- [Setting up Visual Studio](#_setting_up_visual_studio)
- [Setting_up_Visual_Studio](#_setting_up_visual_studio)
- [Linux](#_linux)
- [Vulkan Packages](#_vulkan_packages)
- [X Window System and XFree86-VidModeExtension](#_x_window_system_and_xfree86_vidmodeextension)
- [X_Window_System_and_XFree86-VidModeExtension](#_x_window_system_and_xfree86_vidmodeextension)
- [GLFW](#_glfw_2)
- [GLM](#_glm_2)
- [Shader Compiler](#_shader_compiler)
- [Setting up a makefile project](#_setting_up_a_makefile_project)
- [Setting_up_a_makefile_project](#_setting_up_a_makefile_project)
- [MacOS](#_macos)
- [Vulkan SDK](#_vulkan_sdk_2)
- [GLFW](#_glfw_3)
- [GLM](#_glm_3)
- [Setting up Xcode](#_setting_up_xcode)
- [Setting_up_Xcode](#_setting_up_xcode)

## Content

In this chapter we’ll set up your environment for developing Vulkan applications and install some useful libraries. All of the tools we’ll use, with the exception of the compiler, are compatible with Windows, Linux and MacOS, but the steps for installing them differ a bit, which is why they’re described separately here. If you’re developing for Windows, then I will assume that you are using Visual Studio to compile your code. For complete C++17 support, you need to use either Visual Studio 2017 or 2019. The steps outlined below were written for VS 2017. The most important component you’ll need for developing Vulkan applications is the SDK. It includes the headers, standard validation layers, debugging tools and a loader for the Vulkan functions. The loader looks up the functions in the driver at runtime, similarly to GLEW for OpenGL - if you’re familiar with that. The SDK can be downloaded from the LunarG website using the buttons at the bottom of the page. You don’t have to create an account, but it will give you access to some additional documentation that may be useful to you. Proceed through the installation and pay attention to the install location of the SDK. The first thing we’ll do is verify that your graphics card and driver properly support Vulkan. Go to the directory where you installed the SDK, open the Bin directory and run the vkcube.exe demo. You should see the following: If you receive an error message then ensure that your drivers are up-to-date, include the Vulkan runtime and that your graphics card is supported. See the introduction chapter for links to drivers from the major vendors. There is another program in this directory that will be useful for development. The glslangValidator.exe and glslc.exe programs will be used to compile shaders from the human-readable GLSL to bytecode. We’ll cover this in depth in the shader modules chapter. The Bin directory also contains the binaries of the Vulkan loader and the validation layers, while the Lib directory contains the libraries. Lastly, there’s the Include directory that contains the Vulkan headers. Feel free to explore the other files, but we won’t need them for this tutorial. As mentioned before, Vulkan by itself is a platform agnostic API and does not include tools for creating a window to display the rendered results. To benefit from the cross-platform advantages of Vulkan and to avoid the horrors of Win32, we’ll use the GLFW library to create a window, which supports Windows, Linux and MacOS. There are other libraries available for this purpose, like SDL, but the advantage of GLFW is that it also abstracts away some of the other platform-specific things in Vulkan besides just window creation. You can find the latest release of GLFW on the official website. In this tutorial we’ll be using the 64-bit binaries, but you can of course also choose to build in 32 bit mode. In that case make sure to link with the Vulkan SDK binaries in the Lib32 directory instead of Lib. After downloading it, extract the archive to a convenient location. I’ve chosen to create a Libraries directory in the Visual Studio directory under documents. As a pure graphics api, Vulkan does not include a library for linear algebra operations, so we’ll have to download one. GLM is a nice library that is designed for use with graphics APIs and is also commonly used with OpenGL. GLM is a header-only library, so just download the latest version and store it in a convenient location. You should have a directory structure similar to the following now: Now that you’ve installed all of the dependencies we can set up a basic Visual Studio project for Vulkan and write a little bit of code to make sure that everything works. Start Visual Studio and create a new Windows Desktop Wizard project by entering a name and pressing OK. Make sure that Console Application (.exe) is selected as application type so that we have a place to print debug messages to, and check Empty Project to prevent Visual Studio from adding boilerplate code. Press OK to create the project and add a C++ source file. You should already know how to do that, but the steps are included here for completeness. Now add the following code to the file. Don’t worry about trying to understand it right now; we’re just making sure that you can compile and run Vulkan applications. We’ll start from scratch in the next chapter. #define GLFW_INCLUDE_VULKAN #include #define GLM_FORCE_DEPTH_ZERO_TO_ONE #include #include #include int main() { glfwInit(); glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API); GLFWwindow* window = glfwCreateWindow(800, 600, "Vulkan window", nullptr, nullptr); uint32_t extensionCount = 0; vkEnumerateInstanceExtensionProperties(nullptr, &extensionCount, nullptr); std::cout General -> Additional Include Directories and press in the dropdown box. Add the header directories for Vulkan, GLFW and GLM: Next, open the editor for library directories under Linker -> General: And add the locations of the object files for Vulkan and GLFW: Go to Linker -> Input and press in the Additional Dependencies dropdown box. Enter the names of the Vulkan and GLFW object files: And finally change the compiler to support C++17 features: You can now close the project properties dialog. If you did everything right then you should no longer see any more errors being highlighted in the code. Finally, ensure that you are actually compiling in 64 bit mode: Press F5 to compile and run the project and you should see a command prompt and a window pop up like this: The number of extensions should be non-zero. Congratulations, you’re all set for playing with Vulkan! These instructions will be aimed at Ubuntu, Fedora and Arch Linux users, but you may be able to follow along by changing the package manager-specific commands to the ones that are appropriate for you. You should have a compiler that supports C++17 (GCC 7+ or Clang 5+). You’ll also need make. The most important components you’ll need for developing Vulkan applications on Linux are the Vulkan loader, validation layers, and a couple of command-line utilities to test whether your machine is Vulkan-capable: sudo apt install vulkan-tools or sudo dnf install vulkan-tools: Command-line utilities, most importantly vulkaninfo and vkcube. Run these to confirm your machine supports Vulkan. sudo apt install libvulkan-dev or sudo dnf install vulkan-loader-devel : Installs Vulkan loader. The loader looks up the functions in the driver at runtime, similarly to GLEW for OpenGL - if you’re familiar with that. sudo apt install vulkan-validationlayers spirv-tools or sudo dnf install mesa-vulkan-drivers vulkan-validation-layers-devel: Installs the standard validation layers and required SPIR-V tools. These are crucial when debugging Vulkan applications, and we’ll discuss them in the upcoming chapter. On Arch Linux, you can run sudo pacman -S vulkan-devel to install all the required tools above. If installation was successful, you should be all set with the Vulkan portion. Remember to run vkcube and ensure you see the following pop up in a window: If you receive an error message then ensure that your drivers are up-to-date, include the Vulkan runtime and that your graphics card is supported. See the introduction chapter for links to drivers from the major vendors. It is possible that these libraries are not on the system, if not, you can install them using the following commands: sudo apt install libxxf86vm-dev or dnf install libXxf86vm-devel: Provides an interface to the XFree86-VidModeExtension. sudo apt install libxi-dev or dnf install libXi-devel: Provides an X Window System client interface to the XINPUT extension. As mentioned before, Vulkan by itself is a platform agnostic API and does not include tools for creation a window to display the rendered results. To benefit from the cross-platform advantages of Vulkan and to avoid the horrors of X11, we’ll use the GLFW library to create a window, which supports Windows, Linux and MacOS. There are other libraries available for this purpose, like SDL, but the advantage of GLFW is that it also abstracts away some of the other platform-specific things in Vulkan besides just window creation. We’ll be installing GLFW from the following command: sudo apt install libglfw3-dev or sudo dnf install glfw-devel or sudo pacman -S glfw As a pure graphics api, Vulkan does not include a library for linear algebra operations, so we’ll have to download one. GLM is a nice library that is designed for use with graphics APIs and is also commonly used with OpenGL. It is a header-only library that can be installed from the libglm-dev or glm-devel package: sudo apt install libglm-dev or sudo dnf install glm-devel or sudo pacman -S glm We have just about all we need, except we’ll want a program to compile shaders from the human-readable GLSL to bytecode. Two popular shader compilers are Khronos Group’s glslangValidator and Google’s glslc. The latter has a familiar GCC- and Clang-like usage, so we’ll go with that: on Ubuntu, download Google’s unofficial binaries and copy glslc to your /usr/local/bin. Note you may need to sudo depending on your permissions. On Fedora use sudo dnf install glslc, while on Arch Linux run sudo pacman -S shaderc. To test, run glslc and it should rightfully complain we didn’t pass any shaders to compile: glslc: error: no input files We’ll cover glslc in depth in the shader modules chapter. Now that you have installed all of the dependencies, we can set up a basic makefile project for Vulkan and write a little bit of code to make sure that everything works. Create a new directory at a convenient location with a name like VulkanTest. Create a source file called main.cpp and insert the following code. Don’t worry about trying to understand it right now; we’re just making sure that you can compile and run Vulkan applications. We’ll start from scratch in the next chapter. #define GLFW_INCLUDE_VULKAN #include #define GLM_FORCE_DEPTH_ZERO_TO_ONE #include #include #include int main() { glfwInit(); glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API); GLFWwindow* window = glfwCreateWindow(800, 600, "Vulkan window", nullptr, nullptr); uint32_t extensionCount = 0; vkEnumerateInstanceExtensionProperties(nullptr, &extensionCount, nullptr); std::cout Command Line Tool. Select Next, write a name for the project and for Language select C++. Press Next and the project should have been created. Now, let’s change the code in the generated main.cpp file to the following code: #define GLFW_INCLUDE_VULKAN #include #define GLM_FORCE_DEPTH_ZERO_TO_ONE #include #include #include int main() { glfwInit(); glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API); GLFWwindow* window = glfwCreateWindow(800, 600, "Vulkan window", nullptr, nullptr); uint32_t extensionCount = 0; vkEnumerateInstanceExtensionProperties(nullptr, &extensionCount, nullptr); std::cout Scheme > Edit Scheme..., and in the Arguments tab add the two following environment variables: VK_ICD_FILENAMES = vulkansdk/macOS/share/vulkan/icd.d/MoltenVK_icd.json VK_LAYER_PATH = vulkansdk/macOS/share/vulkan/explicit_layer.d Uncheck 'shared'. It should look like so: Finally, you should be all set! Now if you run the project (remembering to setting the build configuration to Debug or Release depending on the configuration you chose) you should see the following: The number of extensions should be non-zero. The other logs are from the libraries, you might get different messages from those depending on your configuration. You are now all set for the real thing.

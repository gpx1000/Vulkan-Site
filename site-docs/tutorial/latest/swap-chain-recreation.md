# Swap chain recreation

## Metadata

- **Component**: tutorial
- **Version**: latest
- **URL**: /tutorial/latest/03_Drawing_a_triangle/04_Swap_chain_recreation.html

## Table of Contents

- [Introduction](#_introduction)
- [Recreating the swap chain](#_recreating_the_swap_chain)
- [Recreating_the_swap_chain](#_recreating_the_swap_chain)
- [Suboptimal or out-of-date swap chain](#_suboptimal_or_out_of_date_swap_chain)
- [Suboptimal_or_out-of-date_swap_chain](#_suboptimal_or_out_of_date_swap_chain)
- [Fixing a deadlock](#_fixing_a_deadlock)
- [Fixing_a_deadlock](#_fixing_a_deadlock)
- [Handling resizes explicitly](#_handling_resizes_explicitly)
- [Handling_resizes_explicitly](#_handling_resizes_explicitly)
- [Handling minimization](#_handling_minimization)

## Content

The application we have now successfully draws a triangle, but there are some circumstances that it isn’t handling properly yet. It is possible for the window surface to change such that the swap chain is no longer compatible with it. One of the reasons that could cause this to happen is the size of the window changing. We have to catch these events and recreate the swap chain. Create a new recreateSwapChain function that calls createSwapChain and all of the creation functions for the objects that depend on the swap chain or the window size. void recreateSwapChain() { vkDeviceWaitIdle(device); createSwapChain(); createImageViews(); createFramebuffers(); } We first call vkDeviceWaitIdle, because just like in the last chapter, we shouldn’t touch resources that may still be in use. Obviously, we’ll have to recreate the swap chain itself. The image views need to be recreated because they are based directly on the swap chain images. Finally, the framebuffers directly depend on the swap chain images, and thus must be recreated as well. To make sure that the old versions of these objects are cleaned up before recreating them, we should move some of the cleanup code to a separate function that we can call from the recreateSwapChain function. Let’s call it cleanupSwapChain: void cleanupSwapChain() { } void recreateSwapChain() { vkDeviceWaitIdle(device); cleanupSwapChain(); createSwapChain(); createImageViews(); createFramebuffers(); } Note that we don’t recreate the renderpass here for simplicity. In theory it can be possible for the swap chain image format to change during an applications' lifetime, e.g. when moving a window from an standard range to an high dynamic range monitor. This may require the application to recreate the renderpass to make sure the change between dynamic ranges is properly reflected. We’ll move the cleanup code of all objects that are recreated as part of a swap chain refresh from cleanup to cleanupSwapChain: void cleanupSwapChain() { for (auto framebuffer : swapChainFramebuffers) { vkDestroyFramebuffer(device, framebuffer, nullptr); } for (auto imageView : swapChainImageViews) { vkDestroyImageView(device, imageView, nullptr); } vkDestroySwapchainKHR(device, swapChain, nullptr); } void cleanup() { cleanupSwapChain(); vkDestroyPipeline(device, graphicsPipeline, nullptr); vkDestroyPipelineLayout(device, pipelineLayout, nullptr); vkDestroyRenderPass(device, renderPass, nullptr); for (size_t i = 0; i inFlightFences; bool framebufferResized = false; The drawFrame function should then be modified to also check for this flag: if (result == VK_ERROR_OUT_OF_DATE_KHR || result == VK_SUBOPTIMAL_KHR || framebufferResized) { framebufferResized = false; recreateSwapChain(); } else if (result != VK_SUCCESS) { ... } It is important to do this after vkQueuePresentKHR to ensure that the semaphores are in a consistent state, otherwise a signaled semaphore may never be properly waited upon. Now to actually detect resizes we can use the glfwSetFramebufferSizeCallback function in the GLFW framework to set up a callback: void initWindow() { glfwInit(); glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API); window = glfwCreateWindow(WIDTH, HEIGHT, "Vulkan", nullptr, nullptr); glfwSetFramebufferSizeCallback(window, framebufferResizeCallback); } static void framebufferResizeCallback(GLFWwindow* window, int width, int height) { } The reason that we’re creating a static function as a callback is because GLFW does not know how to properly call a member function with the right this pointer to our HelloTriangleApplication instance. However, we do get a reference to the GLFWwindow in the callback and there is another GLFW function that allows you to store an arbitrary pointer inside of it: glfwSetWindowUserPointer: window = glfwCreateWindow(WIDTH, HEIGHT, "Vulkan", nullptr, nullptr); glfwSetWindowUserPointer(window, this); glfwSetFramebufferSizeCallback(window, framebufferResizeCallback); This value can now be retrieved from within the callback with glfwGetWindowUserPointer to properly set the flag: static void framebufferResizeCallback(GLFWwindow* window, int width, int height) { auto app = reinterpret_cast(glfwGetWindowUserPointer(window)); app->framebufferResized = true; } Now try to run the program and resize the window to see if the framebuffer is indeed resized properly with the window. There is another case where a swap chain may become out of date and that is a special kind of window resizing: window minimization. This case is special because it will result in a frame buffer size of 0. In this tutorial we will handle that by pausing until the window is in the foreground again by extending the recreateSwapChain function: void recreateSwapChain() { int width = 0, height = 0; glfwGetFramebufferSize(window, &width, &height); while (width == 0 || height == 0) { glfwGetFramebufferSize(window, &width, &height); glfwWaitEvents(); } vkDeviceWaitIdle(device); ... } The initial call to glfwGetFramebufferSize handles the case where the size is already correct and glfwWaitEvents would have nothing to wait on. Congratulations, you’ve now finished your very first well-behaved Vulkan program! In the next chapter we’re going to get rid of the hardcoded vertices in the vertex shader and actually use a vertex buffer. C++ code / Vertex shader / Fragment shader

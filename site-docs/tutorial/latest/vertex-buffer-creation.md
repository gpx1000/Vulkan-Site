# Vertex buffer creation

## Metadata

- **Component**: tutorial
- **Version**: latest
- **URL**: /tutorial/latest/04_Vertex_buffers/01_Vertex_buffer_creation.html

## Table of Contents

- [Introduction](#_introduction)
- [Buffer creation](#_buffer_creation)
- [Memory requirements](#_memory_requirements)
- [Memory allocation](#_memory_allocation)
- [Filling the vertex buffer](#_filling_the_vertex_buffer)
- [Filling_the_vertex_buffer](#_filling_the_vertex_buffer)
- [Binding the vertex buffer](#_binding_the_vertex_buffer)
- [Binding_the_vertex_buffer](#_binding_the_vertex_buffer)

## Content

Buffers in Vulkan are regions of memory used for storing arbitrary data that can be read by the graphics card. They can be used to store vertex data, which we’ll do in this chapter, but they can also be used for many other purposes that we’ll explore in future chapters. Unlike the Vulkan objects we’ve been dealing with so far, buffers do not automatically allocate memory for themselves. The work from the previous chapters has shown that the Vulkan API puts the programmer in control of almost everything and memory management is one of those things. Create a new function createVertexBuffer and call it from initVulkan right before createCommandBuffers. void initVulkan() { createInstance(); setupDebugMessenger(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); createSwapChain(); createImageViews(); createRenderPass(); createGraphicsPipeline(); createFramebuffers(); createCommandPool(); createVertexBuffer(); createCommandBuffers(); createSyncObjects(); } ... void createVertexBuffer() { } Creating a buffer requires us to fill a VkBufferCreateInfo structure. VkBufferCreateInfo bufferInfo{}; bufferInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO; bufferInfo.size = sizeof(vertices[0]) * vertices.size(); The first field of the struct is size, which specifies the size of the buffer in bytes. Calculating the byte size of the vertex data is straightforward with sizeof. bufferInfo.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT; The second field is usage, which indicates for which purposes the data in the buffer is going to be used. It is possible to specify multiple purposes using a bitwise or. Our use case will be a vertex buffer, we’ll look at other types of usage in future chapters. bufferInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE; Just like the images in the swap chain, buffers can also be owned by a specific queue family or be shared between multiple at the same time. The buffer will only be used from the graphics queue, so we can stick to exclusive access. The flags parameter is used to configure sparse buffer memory, which is not relevant right now. We’ll leave it at the default value of 0. We can now create the buffer with vkCreateBuffer. Define a class member to hold the buffer handle and call it vertexBuffer. VkBuffer vertexBuffer; ... void createVertexBuffer() { VkBufferCreateInfo bufferInfo{}; bufferInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO; bufferInfo.size = sizeof(vertices[0]) * vertices.size(); bufferInfo.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT; bufferInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE; if (vkCreateBuffer(device, &bufferInfo, nullptr, &vertexBuffer) != VK_SUCCESS) { throw std::runtime_error("failed to create vertex buffer!"); } } The buffer should be available for use in rendering commands until the end of the program and it does not depend on the swap chain, so we’ll clean it up in the original cleanup function: void cleanup() { cleanupSwapChain(); vkDestroyBuffer(device, vertexBuffer, nullptr); ... } The buffer has been created, but it doesn’t actually have any memory assigned to it yet. The first step of allocating memory for the buffer is to query its memory requirements using the aptly named vkGetBufferMemoryRequirements function. VkMemoryRequirements memRequirements; vkGetBufferMemoryRequirements(device, vertexBuffer, &memRequirements); The VkMemoryRequirements struct has three fields: size: The size of the required amount of memory in bytes, may differ from bufferInfo.size. alignment: The offset in bytes where the buffer begins in the allocated region of memory, depends on bufferInfo.usage and bufferInfo.flags. memoryTypeBits: Bit field of the memory types that are suitable for the buffer. Graphics cards can offer different types of memory to allocate from. Each type of memory varies in terms of allowed operations and performance characteristics. We need to combine the requirements of the buffer and our own application requirements to find the right type of memory to use. Let’s create a new function findMemoryType for this purpose. uint32_t findMemoryType(uint32_t typeFilter, VkMemoryPropertyFlags properties) { } First we need to query info about the available types of memory using vkGetPhysicalDeviceMemoryProperties. VkPhysicalDeviceMemoryProperties memProperties; vkGetPhysicalDeviceMemoryProperties(physicalDevice, &memProperties); The VkPhysicalDeviceMemoryProperties structure has two arrays memoryTypes and memoryHeaps. Memory heaps are distinct memory resources like dedicated VRAM and swap space in RAM for when VRAM runs out. The different types of memory exist within these heaps. Right now we’ll only concern ourselves with the type of memory and not the heap it comes from, but you can imagine that this can affect performance. Let’s first find a memory type that is suitable for the buffer itself: for (uint32_t i = 0; i (vertices.size()), 1, 0, 0); The vkCmdBindVertexBuffers function is used to bind vertex buffers to bindings, like the one we set up in the previous chapter. The first two parameters, besides the command buffer, specify the offset and number of bindings we’re going to specify vertex buffers for. The last two parameters specify the array of vertex buffers to bind and the byte offsets to start reading vertex data from. You should also change the call to vkCmdDraw to pass the number of vertices in the buffer as opposed to the hardcoded number 3. Now run the program and you should see the familiar triangle again: Try changing the color of the top vertex to white by modifying the vertices array: const std::vector vertices = { {{0.0f, -0.5f}, {1.0f, 1.0f, 1.0f}}, {{0.5f, 0.5f}, {0.0f, 1.0f, 0.0f}}, {{-0.5f, 0.5f}, {0.0f, 0.0f, 1.0f}} }; Run the program again and you should see the following: In the next chapter we’ll look at a different way to copy vertex data to a vertex buffer that results in better performance, but takes some more work. C++ code / Vertex shader / Fragment shader

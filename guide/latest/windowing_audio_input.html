<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Windowing, Audio, and Input :: Vulkan Documentation Project</title>
    <meta name="generator" content="Antora 3.1.10">
    <script>
      !function (theme) {
        if (theme === 'dark') document.documentElement.classList.add('dark')
        else document.documentElement.classList.add('light')
      }(localStorage && localStorage.getItem('theme') || (matchMedia('(prefers-color-scheme: dark)')?.matches && 'dark'))
    </script>
    <link rel="stylesheet" href="../../_/css/site.css">
    <link rel="stylesheet" href="../../_/css/vendor/tabs.css">
    <link rel="apple-touch-icon" sizes="180x180" href="../../_/img/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../../_/img/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../../_/img/favicon-16x16.png">
    <link rel="manifest" href="../../_/site.webmanifest">
    <link rel="mask-icon" href="../../_/img/safari-pinned-tab.svg" color="#a41e22">
    <meta name="msapplication-TileColor" content="#ffc40d">
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="../.."><img class="navbar-item" alt="Vulkan White Label" src="../../_/Vulkan_Docs.svg" /></a>
      <div class="navbar-item search hide-for-print">
        <div id="search-field" class="field has-filter">
          <label for="search-input"></label>
          <input id="search-input" type="text" placeholder="Search the docs">
          <label class="filter checkbox">
            <input type="checkbox" data-facet-filter="component:guide" checked> In this component
          </label>
        </div>
      </div>
      <button class="navbar-burger" aria-controls="topbar-nav" aria-expanded="false" aria-label="Toggle main menu">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <!-- <a class="navbar-item" href="#">Home</a> -->
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Specs</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="../../spec/latest/chapters/introduction.html">Vulkan API</a>
            <a class="navbar-item" href="../../glsl/latest/index.html">GLSL</a>
            <a class="navbar-item" href="../../guide/latest/hlsl.html">HLSL</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Education</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="../../refpages/latest/refpages/index.html">Vulkan Reference Pages</a>
            <a class="navbar-item" href="../../features/latest/features/index.html">Vulkan Feature Descriptions</a>
            <a class="navbar-item" href="../../guide/latest/index.html">Vulkan Guide</a>
            <a class="navbar-item" href="../../samples/latest/README.html">Vulkan Samples</a>
            <a class="navbar-item" href="../../tutorial/latest/index.html">Vulkan Tutorial</a>
            <a class="navbar-item" href="https://www.youtube.com/c/vulkan">YouTube</a>
            <a class="navbar-item" href="https://vulkan.org">More Info at Vulkan.org</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Feedback</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="https://github.com/KhronosGroup/Vulkan-Site/issues/new/choose" target="_blank">Report a Problem</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Community</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="https://discord.gg/vulkan">Vulkan Discord</a>
            <a class="navbar-item" href="https://reddit.com/r/vulkan">Reddit</a>
            <a class="navbar-item" href="https://stackoverflow.com/questions/tagged/vulkan">Stack Overflow</a>
            <a class="navbar-item" href="https://fosstodon.org/@vulkan">Mastodon</a>
          </div>
        </div>
      </div>
    </div>
    <label class="theme-toggler">
      <input type="checkbox" id="switch-theme-checkbox" name="switch-theme-checkbox"/>
      <span class="icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="moon" class="svg-inline--fa fa-moon moon" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><path fill="currentColor" d="M223.5 32C100 32 0 132.3 0 256S100 480 223.5 480c60.6 0 115.5-24.2 155.8-63.4c5-4.9 6.3-12.5 3.1-18.7s-10.1-9.7-17-8.5c-9.8 1.7-19.8 2.6-30.1 2.6c-96.9 0-175.5-78.8-175.5-176c0-65.8 36-123.1 89.3-153.3c6.1-3.5 9.2-10.5 7.7-17.3s-7.3-11.9-14.3-12.5c-6.3-.5-12.6-.8-19-.8z"></path>
        </svg>
        <svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="sun" class="svg-inline--fa fa-sun sun" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M361.5 1.2c5 2.1 8.6 6.6 9.6 11.9L391 121l107.9 19.8c5.3 1 9.8 4.6 11.9 9.6s1.5 10.7-1.6 15.2L446.9 256l62.3 90.3c3.1 4.5 3.7 10.2 1.6 15.2s-6.6 8.6-11.9 9.6L391 391 371.1 498.9c-1 5.3-4.6 9.8-9.6 11.9s-10.7 1.5-15.2-1.6L256 446.9l-90.3 62.3c-4.5 3.1-10.2 3.7-15.2 1.6s-8.6-6.6-9.6-11.9L121 391 13.1 371.1c-5.3-1-9.8-4.6-11.9-9.6s-1.5-10.7 1.6-15.2L65.1 256 2.8 165.7c-3.1-4.5-3.7-10.2-1.6-15.2s6.6-8.6 11.9-9.6L121 121 140.9 13.1c1-5.3 4.6-9.8 9.6-11.9s10.7-1.5 15.2 1.6L256 65.1 346.3 2.8c4.5-3.1 10.2-3.7 15.2-1.6zM160 256a96 96 0 1 1 192 0 96 96 0 1 1 -192 0zm224 0a128 128 0 1 0 -256 0 128 128 0 1 0 256 0z"></path>
        </svg></span>
    </label>
  </nav>
</header>
<script>
  window.onload = function() {
    let e = document.getElementById("switch-theme-checkbox")
    e.checked = document.documentElement.classList.contains("dark");
    e.checked ? e.parentElement.classList.add("active") : e.parentElement.classList.remove("active")
  }
  !function() {
    let e = document.getElementById("switch-theme-checkbox")
    e.checked = document.documentElement.classList.contains("dark")
    e.addEventListener("change", function() {
      if (document.documentElement.classList.contains("light")) {
        document.documentElement.classList.remove("light")
        document.documentElement.classList.add("dark")
      } else if (document.documentElement.classList.contains("dark")) {
        document.documentElement.classList.remove("dark")
        document.documentElement.classList.add("light")
      } else {
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
          document.documentElement.classList.add("dark")
        } else {
          document.documentElement.classList.add("light")
        }
      }
      document.documentElement.setAttribute("data-theme", this.checked ? "dark" : "light"),
        function(e) {
          window.localStorage && window.localStorage.setItem("theme", e)
        }(this.checked ? "dark" : "light"), this.checked ? this.parentElement.classList.add("active") : this.parentElement.classList.remove("active")
    }.bind(e))
  }();
</script>
<div class="body">
<div class="nav-container" data-component="guide" data-version="latest" id="split-0">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <button class="nav-menu-toggle" aria-label="Toggle expand/collapse all" style="display: none"></button>
    <h3 class="title"><a href="index.html">Vulkan Guide</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="index.html">Vulkan Guide</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Logistics Overview</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="what_is_vulkan.html">What is Vulkan?</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="what_vulkan_can_do.html">What Vulkan Can Do</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="vulkan_spec.html">Vulkan Specification</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="platforms.html">Platforms</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="checking_for_support.html">Checking For Vulkan Support</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="versions.html">Vulkan Versions &amp; Porting Guide</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="vulkan_profiles.html">Vulkan Profiles</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="vulkan_release_summary.html">Vulkan Release Summary</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="what_is_spirv.html">What is SPIR-V</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="portability_initiative.html">Portability Initiative</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="vulkan_cts.html">Vulkan CTS</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="development_tools.html">Development Tools</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="ide.html">Development Environments &amp; IDEs</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="validation_overview.html">Vulkan Validation Overview</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="decoder_ring.html">Vulkan Decoder Ring</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Using Vulkan</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="deprecated.html">Deprecated</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="loader.html">Loader</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="layers.html">Layers</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="querying_extensions_features.html">Querying Properties, Extensions, Features, Limits, and Formats</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="enabling_extensions.html">Enabling Extensions</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="enabling_features.html">Enabling Features</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="spirv_extensions.html">Using SPIR-V Extensions</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="formats.html">Formats</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="queues.html">Queues</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="wsi.html">Window System Integration (WSI)</a>
  </li>
  <li class="nav-item is-current-page" data-depth="2">
    <a class="nav-link" href="windowing_audio_input.html">Windowing, Audio, and Input</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="pnext_and_stype.html">pNext and sType</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="synchronization.html">Synchronization</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="extensions/VK_KHR_synchronization2.html">VK_KHR_synchronization2</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="swapchain_semaphore_reuse.html">Swapchain Semaphore Reuse</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="synchronization_examples.html">Synchronization Examples</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="memory_allocation.html">Memory Allocation</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="sparse_resources.html">Sparse Resources</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="protected.html">Protected Memory</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="buffer_device_address.html">Buffer Device Address</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="buffer_device_address_alignment.html">Buffer Device Address Alignment</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="pipeline_cache.html">Pipeline Cache</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="threading.html">Threading</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="depth.html">Depth</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="primitive_topology.html">Primitive Topology</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="mapping_data_to_shaders.html">Mapping Data to Shaders</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="storage_image_and_texel_buffers.html">Storage Image and Texel Buffers</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="vertex_input_data_processing.html">Vertex Input Data Processing</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="descriptor_arrays.html">Descriptor Arrays</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="descriptor_dynamic_offset.html">Descriptor Dynamic Offset</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="descriptor_buffer.html">Descriptor Buffer</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="location_component_interface.html">Location and Component Interface</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="push_constants.html">Push Constants</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="ways_to_provide_spirv.html">Ways to Provide SPIR-V</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="robustness.html">Robustness</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="dynamic_state.html">Pipeline Dynamic State</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="dynamic_state_map.html">Dynamic State Map</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="subgroups.html">Subgroups</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="shader_memory_layout.html">Shader Memory Layout</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="atomics.html">Atomics</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="image_copies.html">Image Copies</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="common_pitfalls.html">Common Pitfalls for New Vulkan Developers</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="hlsl.html">HLSL in Vulkan</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="high_level_shader_language_comparison.html">Vulkan High Level Shader Language Comparison</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">When and Why to use Extensions</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="extensions/cleanup.html">Cleanup Extensions</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="extensions/device_groups.html">Device Groups</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="extensions/external.html">External Memory and Synchronization</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="extensions/ray_tracing.html">Ray Tracing</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="extensions/shader_features.html">Shader Features</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="extensions/translation_layer_extensions.html">Translation Layer Extensions</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="extensions/VK_EXT_descriptor_indexing.html">VK_EXT_descriptor_indexing</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="extensions/VK_EXT_inline_uniform_block.html">VK_EXT_inline_uniform_block</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="extensions/VK_EXT_memory_priority.html">VK_EXT_memory_priority</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="extensions/VK_KHR_descriptor_update_template.html">VK_KHR_descriptor_update_template</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="extensions/VK_KHR_draw_indirect_count.html">VK_KHR_draw_indirect_count</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="extensions/VK_KHR_image_format_list.html">VK_KHR_image_format_list</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="extensions/VK_KHR_imageless_framebuffer.html">VK_KHR_imageless_framebuffer</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="extensions/VK_KHR_sampler_ycbcr_conversion.html">VK_KHR_sampler_ycbcr_conversion</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="extensions/VK_KHR_shader_subgroup_uniform_control_flow.html">VK_KHR_shader_subgroup_uniform_control_flow</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="extensions/VK_KHR_debug_utils.html">VK_KHR_debug_utils</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Vulkan Guide</span>
    <span class="version">latest</span>
  </div>
  <ul class="components">
    <li class="component">
      <div class="title"><a href="../../tutorial/latest/00_Introduction.html">Khronos Vulkan Tutorial</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../tutorial/latest/00_Introduction.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../glsl/latest/index.html">OpenGL Shading Language Specification</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../glsl/latest/index.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../refpages/latest/refpages/index.html">Vulkan API Reference Pages</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../refpages/latest/refpages/index.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../features/latest/features/index.html">Vulkan Feature Descriptions</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../features/latest/features/index.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component is-current">
      <div class="title"><a href="index.html">Vulkan Guide</a></div>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="index.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../samples/latest/README.html">Vulkan Samples</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../samples/latest/README.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../spec/latest/index.html">Vulkan Specification</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../spec/latest/index.html">latest</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article" id="split-1">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../../spec/latest/index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="index.html">Vulkan Guide</a></li>
    <li>Using Vulkan</li>
    <li><a href="windowing_audio_input.html">Windowing, Audio, and Input</a></li>
  </ul>
</nav>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Windowing, Audio, and Input</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>This chapter provides boilerplate examples for integrating libraries like GLFW, SDL2, and native platform APIs for window creation and input handling with Vulkan applications.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_overview"><a class="anchor" href="#_overview"></a>Overview</h2>
<div class="sectionbody">
<div class="paragraph">
<p>While Vulkan itself is a graphics and compute API, most applications need to interact with the operating system to create windows, handle user input, and potentially process audio. This chapter covers the most common libraries and approaches for these tasks when developing Vulkan applications.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_window_creation"><a class="anchor" href="#_window_creation"></a>Window Creation</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_glfw"><a class="anchor" href="#_glfw"></a>GLFW</h3>
<div class="paragraph">
<p><a href="https://www.glfw.org/">GLFW</a> is a lightweight, multi-platform library for creating windows, contexts, and surfaces, receiving input and events. It&#8217;s particularly popular for Vulkan development due to its simple API and built-in Vulkan support.</p>
</div>
<div class="sect3">
<h4 id="_setting_up_glfw_with_vulkan"><a class="anchor" href="#_setting_up_glfw_with_vulkan"></a>Setting Up GLFW with Vulkan</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">#define GLFW_INCLUDE_VULKAN
#include &lt;GLFW/glfw3.h&gt;
#include &lt;iostream&gt;

int main() {
    // Initialize GLFW
    if (!glfwInit()) {
        std::cerr &lt;&lt; "Failed to initialize GLFW" &lt;&lt; std::endl;
        return -1;
    }

    // GLFW was originally designed to create an OpenGL context,
    // so we need to tell it not to create one
    glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);

    // Create a window
    GLFWwindow* window = glfwCreateWindow(800, 600, "Vulkan Window", nullptr, nullptr);
    if (!window) {
        std::cerr &lt;&lt; "Failed to create GLFW window" &lt;&lt; std::endl;
        glfwTerminate();
        return -1;
    }

    // Create Vulkan instance (not shown)
    VkInstance instance = VK_NULL_HANDLE;
    // ... create instance ...

    // Create Vulkan surface
    VkSurfaceKHR surface;
    VkResult result = glfwCreateWindowSurface(instance, window, nullptr, &amp;surface);
    if (result != VK_SUCCESS) {
        std::cerr &lt;&lt; "Failed to create window surface" &lt;&lt; std::endl;
        return -1;
    }

    // Main loop
    while (!glfwWindowShouldClose(window)) {
        glfwPollEvents();

        // Render with Vulkan (not shown)
    }

    // Cleanup
    vkDestroySurfaceKHR(instance, surface, nullptr);
    glfwDestroyWindow(window);
    glfwTerminate();

    return 0;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_glfw_input_handling"><a class="anchor" href="#_glfw_input_handling"></a>GLFW Input Handling</h4>
<div class="paragraph">
<p>GLFW provides both polling and callback-based approaches for input handling:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">// Callback for keyboard input
void keyCallback(GLFWwindow* window, int key, int scancode, int action, int mods) {
    if (key == GLFW_KEY_ESCAPE &amp;&amp; action == GLFW_PRESS) {
        glfwSetWindowShouldClose(window, GLFW_TRUE);
    }
}

// Callback for mouse movement
void cursorPositionCallback(GLFWwindow* window, double xpos, double ypos) {
    // Handle mouse movement
    std::cout &lt;&lt; "Mouse position: " &lt;&lt; xpos &lt;&lt; ", " &lt;&lt; ypos &lt;&lt; std::endl;
}

// Callback for mouse buttons
void mouseButtonCallback(GLFWwindow* window, int button, int action, int mods) {
    if (button == GLFW_MOUSE_BUTTON_LEFT &amp;&amp; action == GLFW_PRESS) {
        // Handle left mouse button press
        std::cout &lt;&lt; "Left mouse button pressed" &lt;&lt; std::endl;
    }
}

// In main function, register callbacks:
glfwSetKeyCallback(window, keyCallback);
glfwSetCursorPosCallback(window, cursorPositionCallback);
glfwSetMouseButtonCallback(window, mouseButtonCallback);

// Alternatively, poll for input in the main loop:
if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS) {
    // Move forward
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_sdl2"><a class="anchor" href="#_sdl2"></a>SDL2</h3>
<div class="paragraph">
<p><a href="https://www.libsdl.org/">SDL2</a> (Simple DirectMedia Layer) is a cross-platform development library designed to provide low-level access to audio, keyboard, mouse, joystick, and graphics hardware. It&#8217;s more comprehensive than GLFW, offering audio support and more input options.</p>
</div>
<div class="sect3">
<h4 id="_setting_up_sdl2_with_vulkan"><a class="anchor" href="#_setting_up_sdl2_with_vulkan"></a>Setting Up SDL2 with Vulkan</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">#include &lt;SDL2/SDL.h&gt;
#include &lt;SDL2/SDL_vulkan.h&gt;
#include &lt;vulkan/vulkan.h&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    // Initialize SDL
    if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO) != 0) {
        std::cerr &lt;&lt; "SDL_Init Error: " &lt;&lt; SDL_GetError() &lt;&lt; std::endl;
        return -1;
    }

    // Create window with Vulkan support
    SDL_Window* window = SDL_CreateWindow(
        "Vulkan SDL2 Window",
        SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,
        800, 600,
        SDL_WINDOW_VULKAN | SDL_WINDOW_SHOWN
    );

    if (!window) {
        std::cerr &lt;&lt; "SDL_CreateWindow Error: " &lt;&lt; SDL_GetError() &lt;&lt; std::endl;
        SDL_Quit();
        return -1;
    }

    // Get required Vulkan extensions for SDL
    unsigned int extensionCount;
    if (!SDL_Vulkan_GetInstanceExtensions(window, &amp;extensionCount, nullptr)) {
        std::cerr &lt;&lt; "Failed to get Vulkan extension count" &lt;&lt; std::endl;
        return -1;
    }

    std::vector&lt;const char*&gt; extensions(extensionCount);
    if (!SDL_Vulkan_GetInstanceExtensions(window, &amp;extensionCount, extensions.data())) {
        std::cerr &lt;&lt; "Failed to get Vulkan extensions" &lt;&lt; std::endl;
        return -1;
    }

    // Create Vulkan instance (not shown)
    VkInstance instance = VK_NULL_HANDLE;
    // ... create instance with extensions ...

    // Create Vulkan surface
    VkSurfaceKHR surface;
    if (!SDL_Vulkan_CreateSurface(window, instance, &amp;surface)) {
        std::cerr &lt;&lt; "Failed to create Vulkan surface" &lt;&lt; std::endl;
        return -1;
    }

    // Main loop
    bool running = true;
    SDL_Event event;
    while (running) {
        while (SDL_PollEvent(&amp;event)) {
            if (event.type == SDL_QUIT) {
                running = false;
            }
        }

        // Render with Vulkan (not shown)
    }

    // Cleanup
    vkDestroySurfaceKHR(instance, surface, nullptr);
    SDL_DestroyWindow(window);
    SDL_Quit();

    return 0;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_sdl2_input_handling"><a class="anchor" href="#_sdl2_input_handling"></a>SDL2 Input Handling</h4>
<div class="paragraph">
<p>SDL2 uses an event-based system for input handling:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">// In the main loop
SDL_Event event;
while (SDL_PollEvent(&amp;event)) {
    switch (event.type) {
        case SDL_QUIT:
            running = false;
            break;
        case SDL_KEYDOWN:
            if (event.key.keysym.sym == SDLK_ESCAPE) {
                running = false;
            }
            if (event.key.keysym.sym == SDLK_w) {
                // Move forward
            }
            break;
        case SDL_MOUSEMOTION:
            std::cout &lt;&lt; "Mouse position: " &lt;&lt; event.motion.x &lt;&lt; ", " &lt;&lt; event.motion.y &lt;&lt; std::endl;
            break;
        case SDL_MOUSEBUTTONDOWN:
            if (event.button.button == SDL_BUTTON_LEFT) {
                std::cout &lt;&lt; "Left mouse button pressed" &lt;&lt; std::endl;
            }
            break;
    }
}

// Alternatively, get keyboard state
const Uint8* keyboardState = SDL_GetKeyboardState(NULL);
if (keyboardState[SDL_SCANCODE_W]) {
    // Move forward
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_sdl2_audio_integration"><a class="anchor" href="#_sdl2_audio_integration"></a>SDL2 Audio Integration</h4>
<div class="paragraph">
<p>SDL2 provides a simple audio API:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">// Audio callback function
void audioCallback(void* userdata, Uint8* stream, int len) {
    // Fill the stream buffer with audio data
    // For example, generate a sine wave
    static double phase = 0.0;
    double frequency = 440.0; // A4 note
    double amplitude = 0.25;  // Volume

    for (int i = 0; i &lt; len; i++) {
        stream[i] = (Uint8)(sin(phase) * amplitude * 127.0 + 128.0);
        phase += 2.0 * M_PI * frequency / 44100.0;
        if (phase &gt; 2.0 * M_PI) {
            phase -= 2.0 * M_PI;
        }
    }
}

// Set up audio
SDL_AudioSpec want, have;
SDL_memset(&amp;want, 0, sizeof(want));
want.freq = 44100;
want.format = AUDIO_U8;
want.channels = 1;
want.samples = 4096;
want.callback = audioCallback;

SDL_AudioDeviceID audioDevice = SDL_OpenAudioDevice(NULL, 0, &amp;want, &amp;have, 0);
if (audioDevice == 0) {
    std::cerr &lt;&lt; "Failed to open audio device: " &lt;&lt; SDL_GetError() &lt;&lt; std::endl;
    return -1;
}

// Start playing audio
SDL_PauseAudioDevice(audioDevice, 0);

// Later, when done:
SDL_CloseAudioDevice(audioDevice);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_sfml"><a class="anchor" href="#_sfml"></a>SFML</h3>
<div class="paragraph">
<p><a href="https://www.sfml-dev.org/">SFML</a> (Simple and Fast Multimedia Library) is a multi-platform C++ library designed to provide a simple interface to various multi-media components, such as input, audio and graphics. Compared to GLFW, SFML offers a more extensive set of features and supports more platforms like mobile.</p>
</div>
<div class="sect3">
<h4 id="_setting_up_sfml_with_vulkan"><a class="anchor" href="#_setting_up_sfml_with_vulkan"></a>Setting up SFML with Vulkan</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">#include &lt;SFML/Window.hpp&gt;
#include &lt;vulkan/vulkan.h&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    // Create SFML window
    sf::WindowBase window{sf::VideoMode({800, 600}), "Vulkan SFML Window", sf::Style::Default};

    // Get required Vulkan extensions for SFML
    std::vector&lt;const char*&gt; extensions = sf::Vulkan::getGraphicsRequiredInstanceExtensions();

    // Create Vulkan instance (not shown)
    VkInstance instance = VK_NULL_HANDLE;
    // ... create instance with extensions ...

    // Create Vulkan surface
    VkSurfaceKHR surface;
    if (!window.createVulkanSurface(instance, surface)) {
        std::cerr &lt;&lt; "Failed to create Vulkan surface" &lt;&lt; std::endl;
        return -1;
    }

    // Main loop
    while (window.isOpen()) {
        while (const std::optional event = window.pollEvent()) {
            if (event-&gt;is&lt;sf::Event::Closed&gt;()) {
                window.close();
            }
        }

        // Render with Vulkan (not shown)
    }

    vkDestroySurfaceKHR(instance, surface, nullptr);
    // No explicit SFML cleanup required

    return 0;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_sfml_input_handling"><a class="anchor" href="#_sfml_input_handling"></a>SFML Input Handling</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">// In the main loop
while (window.isOpen()) {
    while (const std::optional event = window.pollEvent()) {
        if (event-&gt;is&lt;sf::Event::Closed&gt;()) {
            window.close();
        }
        if (event-&gt;is&lt;sf::Event::KeyPressed&gt;()) {
            if (event-&gt;getIf&lt;sf::Event::KeyPressed&gt;()-&gt;code == sf::Keyboard::Key::W) {
                // Move forwards
            }
        }
        if (event-&gt;is&lt;sf::Event::MouseButtonPressed&gt;()) {
            if (event-&gt;getIf&lt;sf::Event::MouseButtonPressed&gt;()-&gt;button == sf::Mouse::Button::Left) {
                // Pick object
            }
        }
    }
}

// Alternatively, poll key state
if (sf::Keyboard::isKeyPressed(sf::Keyboard::Key::W)) {
    // Move forward
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_sfml_audio_integration"><a class="anchor" href="#_sfml_audio_integration"></a>SFML Audio Integration</h4>
<div class="paragraph">
<p>SFML provides a simple audio and music API:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">// Load a sound buffer from a wav file
const sf::SoundBuffer buffer("soundfile.wav");
// Create a sound instance of the sound buffer
sf::Sound sound(buffer);
// Play it
sound.play();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">// Load a music track
sf::Music music("soundtrack.ogg");
// Play it
music.play();</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_native_platform_apis"><a class="anchor" href="#_native_platform_apis"></a>Native Platform APIs</h3>
<div class="paragraph">
<p>For applications requiring more direct control or platform-specific features, you can use native APIs for window creation and input handling.</p>
</div>
<div class="sect3">
<h4 id="_windows_win32"><a class="anchor" href="#_windows_win32"></a>Windows (Win32)</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">#define VK_USE_PLATFORM_WIN32_KHR
#include &lt;vulkan/vulkan.h&gt;
#include &lt;windows.h&gt;
#include &lt;iostream&gt;

// Window procedure
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
    switch (uMsg) {
        case WM_CLOSE:
            PostQuitMessage(0);
            return 0;
        case WM_KEYDOWN:
            if (wParam == VK_ESCAPE) {
                PostQuitMessage(0);
            }
            return 0;
        case WM_LBUTTONDOWN:
            std::cout &lt;&lt; "Left mouse button pressed" &lt;&lt; std::endl;
            return 0;
        case WM_MOUSEMOVE:
            std::cout &lt;&lt; "Mouse position: " &lt;&lt; LOWORD(lParam) &lt;&lt; ", " &lt;&lt; HIWORD(lParam) &lt;&lt; std::endl;
            return 0;
        default:
            return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
}

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR pCmdLine, int nCmdShow) {
    // Register window class
    WNDCLASSEX wc = {};
    wc.cbSize = sizeof(WNDCLASSEX);
    wc.style = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc = WindowProc;
    wc.hInstance = hInstance;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.lpszClassName = "VulkanWindowClass";
    RegisterClassEx(&amp;wc);

    // Create window
    HWND hwnd = CreateWindowEx(
        0,
        "VulkanWindowClass",
        "Vulkan Win32 Window",
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT,
        800, 600,
        NULL,
        NULL,
        hInstance,
        NULL
    );

    if (!hwnd) {
        std::cerr &lt;&lt; "Failed to create window" &lt;&lt; std::endl;
        return -1;
    }

    ShowWindow(hwnd, nCmdShow);

    // Create Vulkan instance (not shown)
    VkInstance instance = VK_NULL_HANDLE;
    // ... create instance ...

    // Create Vulkan surface
    VkWin32SurfaceCreateInfoKHR createInfo = {};
    createInfo.sType = VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR;
    createInfo.hwnd = hwnd;
    createInfo.hinstance = hInstance;

    VkSurfaceKHR surface;
    VkResult result = vkCreateWin32SurfaceKHR(instance, &amp;createInfo, nullptr, &amp;surface);
    if (result != VK_SUCCESS) {
        std::cerr &lt;&lt; "Failed to create window surface" &lt;&lt; std::endl;
        return -1;
    }

    // Main loop
    MSG msg = {};
    bool running = true;
    while (running) {
        while (PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE)) {
            if (msg.message == WM_QUIT) {
                running = false;
            }
            TranslateMessage(&amp;msg);
            DispatchMessage(&amp;msg);
        }

        // Render with Vulkan (not shown)
    }

    // Cleanup
    vkDestroySurfaceKHR(instance, surface, nullptr);
    DestroyWindow(hwnd);

    return 0;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_linux_xcb"><a class="anchor" href="#_linux_xcb"></a>Linux (XCB)</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">#define VK_USE_PLATFORM_XCB_KHR
#include &lt;vulkan/vulkan.h&gt;
#include &lt;xcb/xcb.h&gt;
#include &lt;iostream&gt;

int main() {
    // Connect to X server
    xcb_connection_t* connection = xcb_connect(NULL, NULL);
    if (xcb_connection_has_error(connection)) {
        std::cerr &lt;&lt; "Failed to connect to X server" &lt;&lt; std::endl;
        return -1;
    }

    // Get screen
    const xcb_setup_t* setup = xcb_get_setup(connection);
    xcb_screen_iterator_t iter = xcb_setup_roots_iterator(setup);
    xcb_screen_t* screen = iter.data;

    // Create window
    xcb_window_t window = xcb_generate_id(connection);
    uint32_t value_mask = XCB_CW_BACK_PIXEL | XCB_CW_EVENT_MASK;
    uint32_t value_list[2] = {
        screen-&gt;black_pixel,
        XCB_EVENT_MASK_KEY_PRESS | XCB_EVENT_MASK_BUTTON_PRESS | XCB_EVENT_MASK_POINTER_MOTION | XCB_EVENT_MASK_STRUCTURE_NOTIFY
    };

    xcb_create_window(
        connection,
        XCB_COPY_FROM_PARENT,
        window,
        screen-&gt;root,
        0, 0,
        800, 600,
        0,
        XCB_WINDOW_CLASS_INPUT_OUTPUT,
        screen-&gt;root_visual,
        value_mask,
        value_list
    );

    // Set window title
    xcb_change_property(
        connection,
        XCB_PROP_MODE_REPLACE,
        window,
        XCB_ATOM_WM_NAME,
        XCB_ATOM_STRING,
        8,
        13,
        "Vulkan Window"
    );

    // Map window
    xcb_map_window(connection, window);
    xcb_flush(connection);

    // Create Vulkan instance (not shown)
    VkInstance instance = VK_NULL_HANDLE;
    // ... create instance ...

    // Create Vulkan surface
    VkXcbSurfaceCreateInfoKHR createInfo = {};
    createInfo.sType = VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR;
    createInfo.connection = connection;
    createInfo.window = window;

    VkSurfaceKHR surface;
    VkResult result = vkCreateXcbSurfaceKHR(instance, &amp;createInfo, nullptr, &amp;surface);
    if (result != VK_SUCCESS) {
        std::cerr &lt;&lt; "Failed to create window surface" &lt;&lt; std::endl;
        return -1;
    }

    // Main loop
    bool running = true;
    while (running) {
        xcb_generic_event_t* event;
        while ((event = xcb_poll_for_event(connection))) {
            switch (event-&gt;response_type &amp; 0x7f) {
                case XCB_CLIENT_MESSAGE:
                    running = false;
                    break;
                case XCB_KEY_PRESS: {
                    xcb_key_press_event_t* keyEvent = (xcb_key_press_event_t*)event;
                    // Handle key press
                    break;
                }
                case XCB_BUTTON_PRESS: {
                    xcb_button_press_event_t* buttonEvent = (xcb_button_press_event_t*)event;
                    // Handle button press
                    break;
                }
                case XCB_MOTION_NOTIFY: {
                    xcb_motion_notify_event_t* motionEvent = (xcb_motion_notify_event_t*)event;
                    // Handle mouse motion
                    break;
                }
            }
            free(event);
        }

        // Render with Vulkan (not shown)
    }

    // Cleanup
    vkDestroySurfaceKHR(instance, surface, nullptr);
    xcb_destroy_window(connection, window);
    xcb_disconnect(connection);

    return 0;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_linux_wayland"><a class="anchor" href="#_linux_wayland"></a>Linux (Wayland)</h4>
<div class="paragraph">
<p><a href="https://wayland.freedesktop.org/">Wayland</a> is a modern display server protocol for Linux that aims to replace the X Window System. It provides a simpler, more efficient, and more secure architecture for graphical applications.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">#define VK_USE_PLATFORM_WAYLAND_KHR
#include &lt;vulkan/vulkan.h&gt;
#include &lt;wayland-client.h&gt;
#include &lt;iostream&gt;
#include &lt;cstring&gt;

// Wayland protocol listeners
struct WaylandData {
    wl_display* display;
    wl_registry* registry;
    wl_compositor* compositor;
    wl_shell* shell;
    wl_surface* surface;
    wl_shell_surface* shellSurface;
    bool running;
};

// Registry listener callbacks
static void registry_global(void* data, wl_registry* registry, uint32_t id, const char* interface, uint32_t version) {
    WaylandData* waylandData = static_cast&lt;WaylandData*&gt;(data);

    if (strcmp(interface, "wl_compositor") == 0) {
        waylandData-&gt;compositor = static_cast&lt;wl_compositor*&gt;(
            wl_registry_bind(registry, id, &amp;wl_compositor_interface, 1)
        );
    } else if (strcmp(interface, "wl_shell") == 0) {
        waylandData-&gt;shell = static_cast&lt;wl_shell*&gt;(
            wl_registry_bind(registry, id, &amp;wl_shell_interface, 1)
        );
    }
}

static void registry_global_remove(void* data, wl_registry* registry, uint32_t name) {
    // Handle removed global
}

static const wl_registry_listener registry_listener = {
    registry_global,
    registry_global_remove
};

// Shell surface listener callbacks
static void shell_surface_ping(void* data, wl_shell_surface* shell_surface, uint32_t serial) {
    wl_shell_surface_pong(shell_surface, serial);
}

static void shell_surface_configure(void* data, wl_shell_surface* shell_surface, uint32_t edges, int32_t width, int32_t height) {
    // Handle resize
}

static void shell_surface_popup_done(void* data, wl_shell_surface* shell_surface) {
    // Handle popup done
}

static const wl_shell_surface_listener shell_surface_listener = {
    shell_surface_ping,
    shell_surface_configure,
    shell_surface_popup_done
};

int main() {
    WaylandData waylandData = {};

    // Connect to Wayland display
    waylandData.display = wl_display_connect(nullptr);
    if (!waylandData.display) {
        std::cerr &lt;&lt; "Failed to connect to Wayland display" &lt;&lt; std::endl;
        return -1;
    }

    // Get registry
    waylandData.registry = wl_display_get_registry(waylandData.display);
    wl_registry_add_listener(waylandData.registry, &amp;registry_listener, &amp;waylandData);

    // Wait for registry events
    wl_display_roundtrip(waylandData.display);

    // Check if we got the required globals
    if (!waylandData.compositor || !waylandData.shell) {
        std::cerr &lt;&lt; "Failed to get Wayland compositor or shell" &lt;&lt; std::endl;
        return -1;
    }

    // Create surface
    waylandData.surface = wl_compositor_create_surface(waylandData.compositor);
    if (!waylandData.surface) {
        std::cerr &lt;&lt; "Failed to create Wayland surface" &lt;&lt; std::endl;
        return -1;
    }

    // Create shell surface
    waylandData.shellSurface = wl_shell_get_shell_surface(waylandData.shell, waylandData.surface);
    if (!waylandData.shellSurface) {
        std::cerr &lt;&lt; "Failed to create Wayland shell surface" &lt;&lt; std::endl;
        return -1;
    }

    // Set up shell surface
    wl_shell_surface_add_listener(waylandData.shellSurface, &amp;shell_surface_listener, &amp;waylandData);
    wl_shell_surface_set_toplevel(waylandData.shellSurface);
    wl_shell_surface_set_title(waylandData.shellSurface, "Vulkan Wayland Window");

    // Create Vulkan instance (not shown)
    VkInstance instance = VK_NULL_HANDLE;
    // ... create instance with VK_KHR_wayland_surface extension ...

    // Create Vulkan surface
    VkWaylandSurfaceCreateInfoKHR createInfo = {};
    createInfo.sType = VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR;
    createInfo.display = waylandData.display;
    createInfo.surface = waylandData.surface;

    VkSurfaceKHR surface;
    VkResult result = vkCreateWaylandSurfaceKHR(instance, &amp;createInfo, nullptr, &amp;surface);
    if (result != VK_SUCCESS) {
        std::cerr &lt;&lt; "Failed to create Wayland surface for Vulkan" &lt;&lt; std::endl;
        return -1;
    }

    // Main loop
    waylandData.running = true;
    while (waylandData.running) {
        // Process Wayland events
        wl_display_dispatch_pending(waylandData.display);

        // Render with Vulkan (not shown)

        // Flush Wayland commands
        wl_display_flush(waylandData.display);
    }

    // Cleanup
    vkDestroySurfaceKHR(instance, surface, nullptr);

    if (waylandData.shellSurface) {
        wl_shell_surface_destroy(waylandData.shellSurface);
    }

    if (waylandData.surface) {
        wl_surface_destroy(waylandData.surface);
    }

    if (waylandData.shell) {
        wl_shell_destroy(waylandData.shell);
    }

    if (waylandData.compositor) {
        wl_compositor_destroy(waylandData.compositor);
    }

    if (waylandData.registry) {
        wl_registry_destroy(waylandData.registry);
    }

    if (waylandData.display) {
        wl_display_disconnect(waylandData.display);
    }

    return 0;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_macos_cocoa"><a class="anchor" href="#_macos_cocoa"></a>macOS (Cocoa)</h4>
<div class="paragraph">
<p><a href="https://developer.apple.com/documentation/appkit">Cocoa</a> is Apple&#8217;s native object-oriented API for macOS application development. For Vulkan applications on macOS, you typically use MoltenVK, which translates Vulkan calls to Metal.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">#define VK_USE_PLATFORM_MACOS_MVK
#include &lt;vulkan/vulkan.h&gt;
#include &lt;Cocoa/Cocoa.h&gt;
#include &lt;iostream&gt;

// Cocoa application delegate
@interface VulkanAppDelegate : NSObject &lt;NSApplicationDelegate&gt;
@end

@implementation VulkanAppDelegate
- (BOOL)applicationShouldTerminateAfterLastWindowClosed:(NSApplication *)sender {
    return YES;
}
@end

// Cocoa window delegate
@interface VulkanWindowDelegate : NSObject &lt;NSWindowDelegate&gt;
@end

@implementation VulkanWindowDelegate
- (void)windowWillClose:(NSNotification *)notification {
    [NSApp terminate:nil];
}
@end

// Cocoa view for rendering
@interface VulkanView : NSView
@end

@implementation VulkanView
- (BOOL)acceptsFirstResponder {
    return YES;
}

- (void)keyDown:(NSEvent *)event {
    if ([[event characters] isEqualToString:@"\033"]) { // Escape key
        [NSApp terminate:nil];
    }
}

- (void)mouseDown:(NSEvent *)event {
    NSPoint point = [self convertPoint:[event locationInWindow] fromView:nil];
    std::cout &lt;&lt; "Mouse clicked at: " &lt;&lt; point.x &lt;&lt; ", " &lt;&lt; point.y &lt;&lt; std::endl;
}

- (void)mouseMoved:(NSEvent *)event {
    NSPoint point = [self convertPoint:[event locationInWindow] fromView:nil];
    std::cout &lt;&lt; "Mouse moved to: " &lt;&lt; point.x &lt;&lt; ", " &lt;&lt; point.y &lt;&lt; std::endl;
}
@end

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        // Create application
        [NSApplication sharedApplication];
        [NSApp setActivationPolicy:NSApplicationActivationPolicyRegular];

        // Create application delegate
        VulkanAppDelegate *appDelegate = [[VulkanAppDelegate alloc] init];
        [NSApp setDelegate:appDelegate];

        // Create window
        NSRect frame = NSMakeRect(0, 0, 800, 600);
        NSWindow *window = [[NSWindow alloc] initWithContentRect:frame
                                                       styleMask:NSWindowStyleMaskTitled | NSWindowStyleMaskClosable | NSWindowStyleMaskResizable
                                                         backing:NSBackingStoreBuffered
                                                           defer:NO];
        [window setTitle:@"Vulkan macOS Window"];
        [window center];

        // Create window delegate
        VulkanWindowDelegate *windowDelegate = [[VulkanWindowDelegate alloc] init];
        [window setDelegate:windowDelegate];

        // Create view
        VulkanView *view = [[VulkanView alloc] initWithFrame:frame];
        [window setContentView:view];
        [window makeFirstResponder:view];

        // Show window
        [window makeKeyAndOrderFront:nil];
        [NSApp activateIgnoringOtherApps:YES];

        // Create Vulkan instance (not shown)
        VkInstance instance = VK_NULL_HANDLE;
        // ... create instance with VK_MVK_macos_surface extension ...

        // Create Vulkan surface
        VkMacOSSurfaceCreateInfoMVK createInfo = {};
        createInfo.sType = VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK;
        createInfo.pView = (__bridge void*)view;

        VkSurfaceKHR surface;
        VkResult result = vkCreateMacOSSurfaceMVK(instance, &amp;createInfo, nullptr, &amp;surface);
        if (result != VK_SUCCESS) {
            std::cerr &lt;&lt; "Failed to create macOS surface for Vulkan" &lt;&lt; std::endl;
            return -1;
        }

        // Start the application event loop
        [NSApp run];

        // Cleanup (this code won't be reached normally as the app is terminated by Cocoa)
        vkDestroySurfaceKHR(instance, surface, nullptr);
    }

    return 0;
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ios_uikit"><a class="anchor" href="#_ios_uikit"></a>iOS (UIKit)</h4>
<div class="paragraph">
<p><a href="https://developer.apple.com/documentation/uikit">UIKit</a> is Apple&#8217;s framework for building user interfaces for iOS applications. Similar to macOS, Vulkan applications on iOS typically use MoltenVK.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">#define VK_USE_PLATFORM_IOS_MVK
#include &lt;vulkan/vulkan.h&gt;
#include &lt;UIKit/UIKit.h&gt;
#include &lt;iostream&gt;

// UIView subclass for Vulkan rendering
@interface VulkanView : UIView
@end

@implementation VulkanView
+ (Class)layerClass {
    return [CAMetalLayer class];
}
@end

// UIViewController for the Vulkan view
@interface VulkanViewController : UIViewController
@property (nonatomic, strong) VulkanView *vulkanView;
@property (nonatomic, assign) VkInstance instance;
@property (nonatomic, assign) VkSurfaceKHR surface;
@end

@implementation VulkanViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    // Create Vulkan view
    self.vulkanView = [[VulkanView alloc] initWithFrame:self.view.bounds];
    self.vulkanView.autoresizingMask = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight;
    [self.view addSubview:self.vulkanView];

    // Create Vulkan instance (not shown)
    // ... create instance with VK_MVK_ios_surface extension ...

    // Create Vulkan surface
    VkIOSSurfaceCreateInfoMVK createInfo = {};
    createInfo.sType = VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK;
    createInfo.pView = (__bridge void*)self.vulkanView;

    VkResult result = vkCreateIOSSurfaceMVK(self.instance, &amp;createInfo, nullptr, &amp;self.surface);
    if (result != VK_SUCCESS) {
        NSLog(@"Failed to create iOS surface for Vulkan");
    }
}

- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event {
    UITouch *touch = [touches anyObject];
    CGPoint point = [touch locationInView:self.vulkanView];
    NSLog(@"Touch began at: %f, %f", point.x, point.y);
}

- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event {
    UITouch *touch = [touches anyObject];
    CGPoint point = [touch locationInView:self.vulkanView];
    NSLog(@"Touch moved to: %f, %f", point.x, point.y);
}

- (void)dealloc {
    if (self.surface != VK_NULL_HANDLE) {
        vkDestroySurfaceKHR(self.instance, self.surface, nullptr);
    }
}
@end

// AppDelegate
@interface AppDelegate : UIResponder &lt;UIApplicationDelegate&gt;
@property (strong, nonatomic) UIWindow *window;
@end

@implementation AppDelegate

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
    self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];
    self.window.rootViewController = [[VulkanViewController alloc] init];
    [self.window makeKeyAndVisible];
    return YES;
}

@end

int main(int argc, char * argv[]) {
    @autoreleasepool {
        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_android"><a class="anchor" href="#_android"></a>Android</h4>
<div class="paragraph">
<p><a href="https://developer.android.com/">Android</a> is Google&#8217;s mobile operating system. Vulkan is natively supported on Android 7.0 (API level 24) and higher.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">#define VK_USE_PLATFORM_ANDROID_KHR
#include &lt;vulkan/vulkan.h&gt;
#include &lt;android/native_window.h&gt;
#include &lt;android_native_app_glue.h&gt;
#include &lt;android/log.h&gt;

#define LOGI(...) ((void)__android_log_print(ANDROID_LOG_INFO, "VulkanApp", __VA_ARGS__))
#define LOGW(...) ((void)__android_log_print(ANDROID_LOG_WARN, "VulkanApp", __VA_ARGS__))
#define LOGE(...) ((void)__android_log_print(ANDROID_LOG_ERROR, "VulkanApp", __VA_ARGS__))

// Global application state
struct AppState {
    ANativeWindow* window;
    VkInstance instance;
    VkSurfaceKHR surface;
    bool running;
};

// Process Android input events
static int32_t handleInput(struct android_app* app, AInputEvent* event) {
    AppState* appState = (AppState*)app-&gt;userData;

    if (AInputEvent_getType(event) == AINPUT_EVENT_TYPE_MOTION) {
        float x = AMotionEvent_getX(event, 0);
        float y = AMotionEvent_getY(event, 0);

        switch (AMotionEvent_getAction(event) &amp; AMOTION_EVENT_ACTION_MASK) {
            case AMOTION_EVENT_ACTION_DOWN:
                LOGI("Touch down at: %f, %f", x, y);
                return 1;
            case AMOTION_EVENT_ACTION_MOVE:
                LOGI("Touch moved to: %f, %f", x, y);
                return 1;
            case AMOTION_EVENT_ACTION_UP:
                LOGI("Touch up at: %f, %f", x, y);
                return 1;
        }
    } else if (AInputEvent_getType(event) == AINPUT_EVENT_TYPE_KEY) {
        int32_t keyCode = AKeyEvent_getKeyCode(event);
        if (keyCode == AKEYCODE_BACK) {
            appState-&gt;running = false;
            return 1;
        }
    }

    return 0;
}

// Process Android application commands
static void handleCmd(struct android_app* app, int32_t cmd) {
    AppState* appState = (AppState*)app-&gt;userData;

    switch (cmd) {
        case APP_CMD_INIT_WINDOW:
            if (app-&gt;window != NULL) {
                appState-&gt;window = app-&gt;window;

                // Create Vulkan instance (not shown)
                // ... create instance with VK_KHR_android_surface extension ...

                // Create Vulkan surface
                VkAndroidSurfaceCreateInfoKHR createInfo = {};
                createInfo.sType = VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR;
                createInfo.window = appState-&gt;window;

                VkResult result = vkCreateAndroidSurfaceKHR(appState-&gt;instance, &amp;createInfo, nullptr, &amp;appState-&gt;surface);
                if (result != VK_SUCCESS) {
                    LOGE("Failed to create Android surface for Vulkan");
                }
            }
            break;
        case APP_CMD_TERM_WINDOW:
            // Clean up the surface when the window is closed
            if (appState-&gt;surface != VK_NULL_HANDLE) {
                vkDestroySurfaceKHR(appState-&gt;instance, appState-&gt;surface, nullptr);
                appState-&gt;surface = VK_NULL_HANDLE;
            }
            appState-&gt;window = nullptr;
            break;
        case APP_CMD_GAINED_FOCUS:
            // App gained focus, start rendering
            break;
        case APP_CMD_LOST_FOCUS:
            // App lost focus, stop rendering
            break;
    }
}

// Main entry point for Android applications
void android_main(struct android_app* app) {
    AppState appState = {};
    appState.running = true;

    app-&gt;userData = &amp;appState;
    app-&gt;onAppCmd = handleCmd;
    app-&gt;onInputEvent = handleInput;

    // Main loop
    while (app-&gt;destroyRequested == 0 &amp;&amp; appState.running) {
        // Process events
        int events;
        struct android_poll_source* source;

        while (ALooper_pollAll(0, nullptr, &amp;events, (void**)&amp;source) &gt;= 0) {
            if (source != nullptr) {
                source-&gt;process(app, source);
            }
        }

        // Render with Vulkan (not shown)
    }

    // Cleanup
    if (appState.surface != VK_NULL_HANDLE) {
        vkDestroySurfaceKHR(appState.instance, appState.surface, nullptr);
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_audio_integration"><a class="anchor" href="#_audio_integration"></a>Audio Integration</h2>
<div class="sectionbody">
<div class="paragraph">
<p>While Vulkan itself doesn&#8217;t provide audio capabilities, several libraries can be used alongside Vulkan for audio processing.</p>
</div>
<div class="sect2">
<h3 id="_openal"><a class="anchor" href="#_openal"></a>OpenAL</h3>
<div class="paragraph">
<p><a href="https://www.openal.org/">OpenAL</a> is a cross-platform 3D audio API designed for efficient rendering of multichannel three-dimensional positional audio.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">#include &lt;AL/al.h&gt;
#include &lt;AL/alc.h&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

bool initOpenAL() {
    // Open the default device
    ALCdevice* device = alcOpenDevice(nullptr);
    if (!device) {
        std::cerr &lt;&lt; "Failed to open OpenAL device" &lt;&lt; std::endl;
        return false;
    }

    // Create context
    ALCcontext* context = alcCreateContext(device, nullptr);
    if (!context) {
        std::cerr &lt;&lt; "Failed to create OpenAL context" &lt;&lt; std::endl;
        alcCloseDevice(device);
        return false;
    }

    // Make context current
    if (!alcMakeContextCurrent(context)) {
        std::cerr &lt;&lt; "Failed to make OpenAL context current" &lt;&lt; std::endl;
        alcDestroyContext(context);
        alcCloseDevice(device);
        return false;
    }

    return true;
}

void cleanupOpenAL() {
    ALCcontext* context = alcGetCurrentContext();
    ALCdevice* device = alcGetContextsDevice(context);

    alcMakeContextCurrent(nullptr);
    alcDestroyContext(context);
    alcCloseDevice(device);
}

// Example of playing a sound
void playSound(const std::vector&lt;ALubyte&gt;&amp; audioData, ALsizei frequency) {
    // Generate buffer
    ALuint buffer;
    alGenBuffers(1, &amp;buffer);

    // Fill buffer with audio data
    alBufferData(buffer, AL_FORMAT_MONO8, audioData.data(), audioData.size(), frequency);

    // Generate source
    ALuint source;
    alGenSources(1, &amp;source);

    // Attach buffer to source
    alSourcei(source, AL_BUFFER, buffer);

    // Play source
    alSourcePlay(source);

    // Wait for sound to finish (in a real application, you'd handle this differently)
    ALint state;
    do {
        alGetSourcei(source, AL_SOURCE_STATE, &amp;state);
    } while (state == AL_PLAYING);

    // Cleanup
    alDeleteSources(1, &amp;source);
    alDeleteBuffers(1, &amp;buffer);
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_fmod"><a class="anchor" href="#_fmod"></a>FMOD</h3>
<div class="paragraph">
<p><a href="https://www.fmod.com/">FMOD</a> is a proprietary sound effects engine used in many games and applications.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">#include &lt;fmod.hpp&gt;
#include &lt;fmod_errors.h&gt;
#include &lt;iostream&gt;

void ERRCHECK(FMOD_RESULT result) {
    if (result != FMOD_OK) {
        std::cerr &lt;&lt; "FMOD error: " &lt;&lt; FMOD_ErrorString(result) &lt;&lt; std::endl;
        exit(-1);
    }
}

int main() {
    FMOD::System* system = nullptr;
    FMOD::Sound* sound = nullptr;
    FMOD::Channel* channel = nullptr;

    // Create FMOD system
    ERRCHECK(FMOD::System_Create(&amp;system));

    // Initialize FMOD
    ERRCHECK(system-&gt;init(32, FMOD_INIT_NORMAL, nullptr));

    // Load sound
    ERRCHECK(system-&gt;createSound("sound.wav", FMOD_DEFAULT, nullptr, &amp;sound));

    // Play sound
    ERRCHECK(system-&gt;playSound(sound, nullptr, false, &amp;channel));

    // Main loop
    bool running = true;
    while (running) {
        // Update FMOD
        ERRCHECK(system-&gt;update());

        // Check if sound is still playing
        bool isPlaying = false;
        if (channel) {
            channel-&gt;isPlaying(&amp;isPlaying);
            if (!isPlaying) {
                running = false;
            }
        }

        // Your Vulkan rendering code here
    }

    // Cleanup
    ERRCHECK(sound-&gt;release());
    ERRCHECK(system-&gt;close());
    ERRCHECK(system-&gt;release());

    return 0;
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_mobile_audio_integration"><a class="anchor" href="#_mobile_audio_integration"></a>Mobile Audio Integration</h3>
<div class="paragraph">
<p>Mobile platforms have their own audio APIs optimized for mobile devices. These APIs provide features specifically designed for mobile environments, such as handling audio focus changes, managing battery usage, and dealing with interruptions.</p>
</div>
<div class="sect3">
<h4 id="_android_audio"><a class="anchor" href="#_android_audio"></a>Android Audio</h4>
<div class="paragraph">
<p>Android provides AAudio and OpenSL ES (Deprecated) for high-performance audio
 in
gapplications like games.  With the goal of recommending one library to work
across 99% of devices, we recommend
the
Oboe library for
Android audio development.</p>
</div>
<div class="sect4">
<h5 id="_oboe"><a class="anchor" href="#_oboe"></a>Oboe</h5>
<div class="paragraph">
<p><a href="https://github.com/google/oboe">Oboe</a> is a C++ library developed by Google that provides a high-performance, low-latency audio API for Android. It&#8217;s the recommended library for audio in Android applications, especially for games and other applications requiring real-time audio.</p>
</div>
<div class="paragraph">
<p>Oboe provides a unified API that automatically selects the best available audio backend:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>On Android 8.0 (API 26) and higher, it uses AAudio</p>
</li>
<li>
<p>On older Android versions, it falls back to OpenSL ES</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This approach gives you the benefits of AAudio on newer devices while maintaining compatibility with older devices.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">#include &lt;oboe/Oboe.h&gt;
#include &lt;android/log.h&gt;
#include &lt;cmath&gt;

#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, "OboeAudioEngine", __VA_ARGS__)

class OboeAudioEngine : public oboe::AudioStreamCallback {
public:
    OboeAudioEngine() : stream_(nullptr), phase_(0.0f) {}
    ~OboeAudioEngine() { closeStream(); }

    bool setupAudioStream() {
        // Create an audio stream builder
        oboe::AudioStreamBuilder builder;

        // Configure the builder
        builder.setDirection(oboe::Direction::Output)
               -&gt;setPerformanceMode(oboe::PerformanceMode::LowLatency)
               -&gt;setSharingMode(oboe::SharingMode::Exclusive)
               -&gt;setFormat(oboe::AudioFormat::Float)
               -&gt;setChannelCount(oboe::ChannelCount::Stereo)
               -&gt;setCallback(this);

        // Build the stream
        oboe::Result result = builder.openStream(stream_);
        if (result != oboe::Result::OK) {
            LOGE("Failed to create audio stream. Error: %s", oboe::convertToText(result));
            return false;
        }

        // Get the sample rate from the stream (in case the requested sample rate was not available)
        sampleRate_ = stream_-&gt;getSampleRate();

        return true;
    }

    bool startStream() {
        if (!stream_) {
            return false;
        }

        oboe::Result result = stream_-&gt;requestStart();
        if (result != oboe::Result::OK) {
            LOGE("Failed to start audio stream. Error: %s", oboe::convertToText(result));
            return false;
        }

        return true;
    }

    void stopStream() {
        if (stream_) {
            stream_-&gt;requestStop();
        }
    }

    void closeStream() {
        if (stream_) {
            stream_-&gt;close();
            stream_.reset();
        }
    }

    // AudioStreamCallback implementation
    oboe::DataCallbackResult onAudioReady(
            oboe::AudioStream *stream,
            void *audioData,
            int32_t numFrames) override {

        float *buffer = static_cast&lt;float*&gt;(audioData);

        // Generate audio data (simple sine wave example)
        for (int i = 0; i &lt; numFrames * 2; i += 2) {
            float sample = 0.5f * sinf(phase_);

            // Write to stereo channels
            buffer[i] = sample;       // Left channel
            buffer[i + 1] = sample;   // Right channel

            // Update phase
            phase_ += 2.0f * M_PI * 440.0f / sampleRate_; // 440 Hz tone
            if (phase_ &gt;= 2.0f * M_PI) {
                phase_ -= 2.0f * M_PI;
            }
        }

        return oboe::DataCallbackResult::Continue;
    }

    // Error callback
    void onErrorBeforeClose(oboe::AudioStream *stream, oboe::Result error) override {
        LOGE("Oboe error before close: %s", oboe::convertToText(error));
    }

    void onErrorAfterClose(oboe::AudioStream *stream, oboe::Result error) override {
        LOGE("Oboe error after close: %s", oboe::convertToText(error));

        // Reopen the stream if it was disconnected (e.g., when headphones are unplugged)
        if (error == oboe::Result::ErrorDisconnected) {
            closeStream();
            setupAudioStream();
            startStream();
        }
    }

private:
    std::shared_ptr&lt;oboe::AudioStream&gt; stream_;
    float phase_;
    int32_t sampleRate_;
};

// Usage in your Android application:
// OboeAudioEngine audioEngine;
// audioEngine.setupAudioStream();
// audioEngine.startStream();
//
// // When done:
// audioEngine.stopStream();
// audioEngine.closeStream();</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_android_audio_focus"><a class="anchor" href="#_android_audio_focus"></a>Android Audio Focus</h5>
<div class="paragraph">
<p>Handling audio focus is crucial for a good user experience on Android:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">// In your native code, you'll need to call Java methods via JNI
extern "C" {
    JNIEXPORT void JNICALL
    Java_com_example_vulkanaudio_AudioManager_nativeOnAudioFocusGained(JNIEnv *env, jobject thiz) {
        // Resume audio playback
        // For example:
        // audioEngine-&gt;start();
    }

    JNIEXPORT void JNICALL
    Java_com_example_vulkanaudio_AudioManager_nativeOnAudioFocusLost(JNIEnv *env, jobject thiz) {
        // Pause audio playback
        // For example:
        // audioEngine-&gt;stop();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Java side:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class AudioManager {
    private AudioManager.OnAudioFocusChangeListener afChangeListener = new AudioManager.OnAudioFocusChangeListener() {
        public void onAudioFocusChange(int focusChange) {
            if (focusChange == AudioManager.AUDIOFOCUS_LOSS) {
                // Lost focus for an unbounded amount of time
                nativeOnAudioFocusLost();
            } else if (focusChange == AudioManager.AUDIOFOCUS_LOSS_TRANSIENT) {
                // Lost focus for a short time
                nativeOnAudioFocusLost();
            } else if (focusChange == AudioManager.AUDIOFOCUS_GAIN) {
                // Gained focus
                nativeOnAudioFocusGained();
            }
        }
    };

    public void requestAudioFocus() {
        AudioManager audioManager = (AudioManager) getSystemService(Context.AUDIO_SERVICE);
        int result = audioManager.requestAudioFocus(afChangeListener,
                AudioManager.STREAM_MUSIC,
                AudioManager.AUDIOFOCUS_GAIN);

        if (result == AudioManager.AUDIOFOCUS_REQUEST_GRANTED) {
            // Start playback
            nativeOnAudioFocusGained();
        }
    }

    // Native methods
    private native void nativeOnAudioFocusGained();
    private native void nativeOnAudioFocusLost();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ios_audio"><a class="anchor" href="#_ios_audio"></a>iOS Audio</h4>
<div class="paragraph">
<p>iOS provides several audio APIs, with AVAudioEngine being the recommended high-level API and Core Audio for low-level control.</p>
</div>
<div class="sect4">
<h5 id="_avaudioengine"><a class="anchor" href="#_avaudioengine"></a>AVAudioEngine</h5>
<div class="paragraph">
<p><a href="https://developer.apple.com/documentation/avfaudio/avaudioengine">AVAudioEngine</a> is the recommended high-level audio API for iOS applications.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">// This is Objective-C++ code that would be used in your iOS application
#import &lt;AVFoundation/AVFoundation.h&gt;
#include &lt;vector&gt;

class iOSAudioEngine {
public:
    iOSAudioEngine() : audioEngine(nil), playerNode(nil), isPlaying(false) {}

    bool initialize() {
        @autoreleasepool {
            // Create the audio engine
            audioEngine = [[AVAudioEngine alloc] init];
            if (!audioEngine) {
                NSLog(@"Failed to create AVAudioEngine");
                return false;
            }

            // Create a player node
            playerNode = [[AVAudioPlayerNode alloc] init];
            if (!playerNode) {
                NSLog(@"Failed to create AVAudioPlayerNode");
                return false;
            }

            // Attach the player node to the engine
            [audioEngine attachNode:playerNode];

            // Connect the player node to the output
            [audioEngine connect:playerNode to:audioEngine.mainMixerNode format:[audioEngine.mainMixerNode outputFormatForBus:0]];

            // Prepare the engine
            NSError* error = nil;
            if (![audioEngine startAndReturnError:&amp;error]) {
                NSLog(@"Failed to start AVAudioEngine: %@", error);
                return false;
            }

            return true;
        }
    }

    bool playSound(const std::vector&lt;float&gt;&amp; audioData, int sampleRate, int channels) {
        @autoreleasepool {
            if (!audioEngine || !playerNode) {
                return false;
            }

            // Create an audio buffer
            AVAudioFormat* format = [[AVAudioFormat alloc] initStandardFormatWithSampleRate:sampleRate channels:channels];
            AVAudioPCMBuffer* buffer = [[AVAudioPCMBuffer alloc] initWithPCMFormat:format frameCapacity:audioData.size() / channels];

            // Fill the buffer with audio data
            float* bufferData = buffer.floatChannelData[0];
            for (int i = 0; i &lt; audioData.size(); i++) {
                bufferData[i] = audioData[i];
            }
            buffer.frameLength = audioData.size() / channels;

            // Schedule the buffer for playback
            [playerNode scheduleBuffer:buffer completionHandler:^{
                // This is called when the buffer finishes playing
                NSLog(@"Buffer finished playing");
            }];

            // Start playback if not already playing
            if (!isPlaying) {
                [playerNode play];
                isPlaying = true;
            }

            return true;
        }
    }

    void stop() {
        @autoreleasepool {
            if (playerNode &amp;&amp; isPlaying) {
                [playerNode stop];
                isPlaying = false;
            }
        }
    }

    void shutdown() {
        @autoreleasepool {
            if (audioEngine) {
                [audioEngine stop];
                audioEngine = nil;
            }

            playerNode = nil;
            isPlaying = false;
        }
    }

private:
    AVAudioEngine* audioEngine;
    AVAudioPlayerNode* playerNode;
    bool isPlaying;
};

// Usage:
// iOSAudioEngine audioEngine;
// audioEngine.initialize();
//
// // Create audio data
// std::vector&lt;float&gt; audioData = createAudioData();
// audioEngine.playSound(audioData, 44100, 2);
//
// // When done:
// audioEngine.stop();
// audioEngine.shutdown();</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_core_audio"><a class="anchor" href="#_core_audio"></a>Core Audio</h5>
<div class="paragraph">
<p><a href="https://developer.apple.com/documentation/coreaudio">Core Audio</a> provides low-level audio capabilities for iOS applications.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">// This is Objective-C++ code that would be used in your iOS application
#import &lt;AudioToolbox/AudioToolbox.h&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;

class CoreAudioEngine {
public:
    CoreAudioEngine() : audioUnit(nullptr), isInitialized(false) {}

    bool initialize() {
        // Set up the audio component description
        AudioComponentDescription desc;
        desc.componentType = kAudioUnitType_Output;
        desc.componentSubType = kAudioUnitSubType_RemoteIO;
        desc.componentManufacturer = kAudioUnitManufacturer_Apple;
        desc.componentFlags = 0;
        desc.componentFlagsMask = 0;

        // Find the audio component
        AudioComponent component = AudioComponentFindNext(NULL, &amp;desc);
        if (!component) {
            NSLog(@"Failed to find audio component");
            return false;
        }

        // Create the audio unit
        OSStatus status = AudioComponentInstanceNew(component, &amp;audioUnit);
        if (status != noErr) {
            NSLog(@"Failed to create audio unit: %d", (int)status);
            return false;
        }

        // Enable output
        UInt32 enableOutput = 1;
        status = AudioUnitSetProperty(audioUnit,
                                     kAudioOutputUnitProperty_EnableIO,
                                     kAudioUnitScope_Output,
                                     0,
                                     &amp;enableOutput,
                                     sizeof(enableOutput));
        if (status != noErr) {
            NSLog(@"Failed to enable audio output: %d", (int)status);
            return false;
        }

        // Set up the audio format
        AudioStreamBasicDescription audioFormat;
        audioFormat.mSampleRate = 44100;
        audioFormat.mFormatID = kAudioFormatLinearPCM;
        audioFormat.mFormatFlags = kAudioFormatFlagIsFloat | kAudioFormatFlagIsPacked | kAudioFormatFlagIsNonInterleaved;
        audioFormat.mBytesPerPacket = 4;
        audioFormat.mFramesPerPacket = 1;
        audioFormat.mBytesPerFrame = 4;
        audioFormat.mChannelsPerFrame = 2;
        audioFormat.mBitsPerChannel = 32;

        status = AudioUnitSetProperty(audioUnit,
                                     kAudioUnitProperty_StreamFormat,
                                     kAudioUnitScope_Input,
                                     0,
                                     &amp;audioFormat,
                                     sizeof(audioFormat));
        if (status != noErr) {
            NSLog(@"Failed to set audio format: %d", (int)status);
            return false;
        }

        // Set up the render callback
        AURenderCallbackStruct callbackStruct;
        callbackStruct.inputProc = renderCallback;
        callbackStruct.inputProcRefCon = this;

        status = AudioUnitSetProperty(audioUnit,
                                     kAudioUnitProperty_SetRenderCallback,
                                     kAudioUnitScope_Input,
                                     0,
                                     &amp;callbackStruct,
                                     sizeof(callbackStruct));
        if (status != noErr) {
            NSLog(@"Failed to set render callback: %d", (int)status);
            return false;
        }

        // Initialize the audio unit
        status = AudioUnitInitialize(audioUnit);
        if (status != noErr) {
            NSLog(@"Failed to initialize audio unit: %d", (int)status);
            return false;
        }

        isInitialized = true;
        return true;
    }

    bool start() {
        if (!isInitialized) {
            return false;
        }

        OSStatus status = AudioOutputUnitStart(audioUnit);
        if (status != noErr) {
            NSLog(@"Failed to start audio unit: %d", (int)status);
            return false;
        }

        return true;
    }

    void stop() {
        if (isInitialized) {
            AudioOutputUnitStop(audioUnit);
        }
    }

    void shutdown() {
        if (isInitialized) {
            stop();
            AudioUnitUninitialize(audioUnit);
            AudioComponentInstanceDispose(audioUnit);
            audioUnit = nullptr;
            isInitialized = false;
        }
    }

private:
    AudioUnit audioUnit;
    bool isInitialized;
    float phase = 0.0f;

    // Audio render callback
    static OSStatus renderCallback(void* inRefCon,
                                  AudioUnitRenderActionFlags* ioActionFlags,
                                  const AudioTimeStamp* inTimeStamp,
                                  UInt32 inBusNumber,
                                  UInt32 inNumberFrames,
                                  AudioBufferList* ioData) {
        CoreAudioEngine* engine = static_cast&lt;CoreAudioEngine*&gt;(inRefCon);
        return engine-&gt;render(ioActionFlags, inTimeStamp, inBusNumber, inNumberFrames, ioData);
    }

    OSStatus render(AudioUnitRenderActionFlags* ioActionFlags,
                   const AudioTimeStamp* inTimeStamp,
                   UInt32 inBusNumber,
                   UInt32 inNumberFrames,
                   AudioBufferList* ioData) {
        // Generate audio data
        // For example, generate a sine wave
        for (UInt32 i = 0; i &lt; ioData-&gt;mNumberBuffers; i++) {
            float* buffer = static_cast&lt;float*&gt;(ioData-&gt;mBuffers[i].mData);

            for (UInt32 frame = 0; frame &lt; inNumberFrames; frame++) {
                float sample = 0.5f * sinf(phase);
                buffer[frame] = sample;

                // Increment phase for next sample
                phase += 0.01f;
                if (phase &gt; 2.0f * M_PI) {
                    phase -= 2.0f * M_PI;
                }
            }
        }

        return noErr;
    }
};

// Usage:
// CoreAudioEngine audioEngine;
// audioEngine.initialize();
// audioEngine.start();
//
// // When done:
// audioEngine.stop();
// audioEngine.shutdown();</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_ios_audio_session"><a class="anchor" href="#_ios_audio_session"></a>iOS Audio Session</h5>
<div class="paragraph">
<p>Managing the audio session is important for proper audio behavior on iOS:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">// This is Objective-C++ code that would be used in your iOS application
#import &lt;AVFoundation/AVFoundation.h&gt;

class AudioSessionManager {
public:
    bool configureAudioSession() {
        @autoreleasepool {
            NSError* error = nil;

            // Get the shared audio session
            AVAudioSession* session = [AVAudioSession sharedInstance];

            // Set the category
            if (![session setCategory:AVAudioSessionCategoryAmbient
                          withOptions:0
                                error:&amp;error]) {
                NSLog(@"Failed to set audio session category: %@", error);
                return false;
            }

            // Set the mode
            if (![session setMode:AVAudioSessionModeDefault error:&amp;error]) {
                NSLog(@"Failed to set audio session mode: %@", error);
                return false;
            }

            // Activate the audio session
            if (![session setActive:YES error:&amp;error]) {
                NSLog(@"Failed to activate audio session: %@", error);
                return false;
            }

            // Register for interruptions
            [[NSNotificationCenter defaultCenter] addObserver:[NSObject new]
                                                     selector:@selector(handleInterruption:)
                                                         name:AVAudioSessionInterruptionNotification
                                                       object:nil];

            return true;
        }
    }

    void handleInterruption(NSNotification* notification) {
        @autoreleasepool {
            NSDictionary* info = notification.userInfo;
            NSInteger type = [[info valueForKey:AVAudioSessionInterruptionTypeKey] integerValue];

            if (type == AVAudioSessionInterruptionTypeBegan) {
                // Audio session interrupted - pause audio
                NSLog(@"Audio session interrupted");
                // audioEngine-&gt;stop();
            } else if (type == AVAudioSessionInterruptionTypeEnded) {
                NSInteger options = [[info valueForKey:AVAudioSessionInterruptionOptionKey] integerValue];
                if (options == AVAudioSessionInterruptionOptionShouldResume) {
                    // Interruption ended - resume audio
                    NSLog(@"Audio session interruption ended");
                    // audioEngine-&gt;start();
                }
            }
        }
    }
};

// Usage:
// AudioSessionManager sessionManager;
// sessionManager.configureAudioSession();</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_mobile_audio_considerations"><a class="anchor" href="#_mobile_audio_considerations"></a>Mobile Audio Considerations</h4>
<div class="paragraph">
<p>When developing audio for mobile platforms, consider the following:</p>
</div>
<div class="sect4">
<h5 id="_battery_usage"><a class="anchor" href="#_battery_usage"></a>Battery Usage</h5>
<div class="paragraph">
<p>Audio processing can be CPU-intensive and drain the battery. Consider these strategies:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Reduce Sample Rate</strong>: Use lower sample rates when high fidelity isn&#8217;t required.</p>
</li>
<li>
<p><strong>Process in Larger Chunks</strong>: Process audio in larger buffer sizes to reduce CPU wake-ups.</p>
</li>
<li>
<p><strong>Pause Audio</strong>: Pause audio processing when the app is in the background or when audio isn&#8217;t needed.</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="_memory_management"><a class="anchor" href="#_memory_management"></a>Memory Management</h5>
<div class="paragraph">
<p>Mobile devices have limited memory:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Stream Audio</strong>: Stream large audio files rather than loading them entirely into memory.</p>
</li>
<li>
<p><strong>Unload Unused Assets</strong>: Unload audio assets when they&#8217;re not needed.</p>
</li>
<li>
<p><strong>Compress Audio</strong>: Use appropriate compression formats for mobile (AAC for iOS, Opus for Android).</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="_interruptions_and_audio_focus"><a class="anchor" href="#_interruptions_and_audio_focus"></a>Interruptions and Audio Focus</h5>
<div class="paragraph">
<p>Handle audio interruptions gracefully:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Save State</strong>: When interrupted, save the audio state so it can be resumed later.</p>
</li>
<li>
<p><strong>Respect System Volume</strong>: Use the system volume controls rather than implementing your own.</p>
</li>
<li>
<p><strong>Handle Phone Calls</strong>: Pause audio during phone calls and other system interruptions.</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="_latency"><a class="anchor" href="#_latency"></a>Latency</h5>
<div class="paragraph">
<p>Different devices have different audio latency characteristics:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Test on Real Devices</strong>: Simulator audio behavior may differ from real devices.</p>
</li>
<li>
<p><strong>Use Low-Latency Modes</strong>: Both Android and iOS provide low-latency audio modes for real-time applications.</p>
</li>
<li>
<p><strong>Buffer Appropriately</strong>: Balance between latency and audio stability with appropriate buffer sizes.</p>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_integrating_with_vulkan"><a class="anchor" href="#_integrating_with_vulkan"></a>Integrating with Vulkan</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When using these windowing and input libraries with Vulkan, there are a few key considerations:</p>
</div>
<div class="sect2">
<h3 id="_surface_creation"><a class="anchor" href="#_surface_creation"></a>Surface Creation</h3>
<div class="paragraph">
<p>Each windowing library provides a way to create a <code>VkSurfaceKHR</code> object, which is the bridge between Vulkan and the window system:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>GLFW: <code>glfwCreateWindowSurface</code></p>
</li>
<li>
<p>SDL2: <code>SDL_Vulkan_CreateSurface</code></p>
</li>
<li>
<p>Win32: <code>vkCreateWin32SurfaceKHR</code></p>
</li>
<li>
<p>XCB: <code>vkCreateXcbSurfaceKHR</code></p>
</li>
<li>
<p>Wayland: <code>vkCreateWaylandSurfaceKHR</code></p>
</li>
<li>
<p>macOS: <code>vkCreateMacOSSurfaceMVK</code></p>
</li>
<li>
<p>iOS: <code>vkCreateIOSSurfaceMVK</code></p>
</li>
<li>
<p>Android: <code>vkCreateAndroidSurfaceKHR</code></p>
</li>
<li>
<p>Metal: <code>vkCreateMetalSurfaceEXT</code></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_swapchain_management"><a class="anchor" href="#_swapchain_management"></a>Swapchain Management</h3>
<div class="paragraph">
<p>The swapchain needs to be recreated when the window is resized. Here&#8217;s a basic approach:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">void handleWindowResize(VkDevice device, VkSwapchainKHR&amp; swapchain, VkSurfaceKHR surface) {
    // Wait for device to be idle
    vkDeviceWaitIdle(device);

    // Destroy old swapchain
    VkSwapchainKHR oldSwapchain = swapchain;

    // Get new surface capabilities
    VkSurfaceCapabilitiesKHR capabilities;
    vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, &amp;capabilities);

    // Create new swapchain
    VkSwapchainCreateInfoKHR createInfo = {};
    createInfo.sType = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR;
    createInfo.surface = surface;
    createInfo.minImageCount = capabilities.minImageCount + 1;
    createInfo.imageFormat = surfaceFormat.format;
    createInfo.imageColorSpace = surfaceFormat.colorSpace;
    createInfo.imageExtent = capabilities.currentExtent;
    createInfo.imageArrayLayers = 1;
    createInfo.imageUsage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT;
    createInfo.imageSharingMode = VK_SHARING_MODE_EXCLUSIVE;
    createInfo.preTransform = capabilities.currentTransform;
    createInfo.compositeAlpha = VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR;
    createInfo.presentMode = presentMode;
    createInfo.clipped = VK_TRUE;
    createInfo.oldSwapchain = oldSwapchain;

    VkResult result = vkCreateSwapchainKHR(device, &amp;createInfo, nullptr, &amp;swapchain);
    if (result != VK_SUCCESS) {
        throw std::runtime_error("Failed to create swapchain");
    }

    // Destroy old swapchain if it was replaced
    if (oldSwapchain != VK_NULL_HANDLE) {
        vkDestroySwapchainKHR(device, oldSwapchain, nullptr);
    }

    // Recreate swapchain images, image views, framebuffers, etc.
    // ...
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_input_to_vulkan_rendering"><a class="anchor" href="#_input_to_vulkan_rendering"></a>Input to Vulkan Rendering</h3>
<div class="paragraph">
<p>Input handling typically affects the application state, which then influences the Vulkan rendering:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">struct AppState {
    float cameraPosition[3] = {0.0f, 0.0f, 0.0f};
    float cameraRotation[3] = {0.0f, 0.0f, 0.0f};
    // Other state variables
};

// Update state based on input
void handleInput(AppState&amp; state, float deltaTime) {
    // Example with GLFW
    if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS) {
        state.cameraPosition[2] -= 1.0f * deltaTime;
    }
    if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS) {
        state.cameraPosition[2] += 1.0f * deltaTime;
    }
    // Handle other keys and input
}

// In main loop
AppState state;
float lastFrameTime = 0.0f;

while (!glfwWindowShouldClose(window)) {
    float currentTime = glfwGetTime();
    float deltaTime = currentTime - lastFrameTime;
    lastFrameTime = currentTime;

    glfwPollEvents();
    handleInput(state, deltaTime);

    // Update uniform buffers with new state
    updateUniformBuffers(state);

    // Render frame with Vulkan
    drawFrame();
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_best_practices"><a class="anchor" href="#_best_practices"></a>Best Practices</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_performance_considerations"><a class="anchor" href="#_performance_considerations"></a>Performance Considerations</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Minimize Window Resizing</strong>: Recreating the swapchain is expensive, so handle window resizing efficiently.</p>
</li>
<li>
<p><strong>Batch Input Processing</strong>: Process all input events at once rather than handling them individually.</p>
</li>
<li>
<p><strong>Use Double Buffering</strong>: For audio, use double buffering to ensure smooth playback while preparing the next audio segment.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_cross_platform_development"><a class="anchor" href="#_cross_platform_development"></a>Cross-Platform Development</h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Abstract Platform-Specific Code</strong>: Create a platform abstraction layer to handle differences between platforms.</p>
</li>
<li>
<p><strong>Use Cross-Platform Libraries</strong>: Libraries like GLFW and SDL2 already handle most platform-specific details.</p>
</li>
<li>
<p><strong>Test on All Target Platforms</strong>: Different platforms may have subtle differences in behavior.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_error_handling"><a class="anchor" href="#_error_handling"></a>Error Handling</h3>
<div class="paragraph">
<p>Always check return values and handle errors gracefully:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">VkResult result = vkCreateSwapchainKHR(device, &amp;createInfo, nullptr, &amp;swapchain);
if (result != VK_SUCCESS) {
    switch (result) {
        case VK_ERROR_OUT_OF_HOST_MEMORY:
            std::cerr &lt;&lt; "Failed to create swapchain: Out of host memory" &lt;&lt; std::endl;
            break;
        case VK_ERROR_OUT_OF_DEVICE_MEMORY:
            std::cerr &lt;&lt; "Failed to create swapchain: Out of device memory" &lt;&lt; std::endl;
            break;
        case VK_ERROR_DEVICE_LOST:
            std::cerr &lt;&lt; "Failed to create swapchain: Device lost" &lt;&lt; std::endl;
            break;
        case VK_ERROR_SURFACE_LOST_KHR:
            std::cerr &lt;&lt; "Failed to create swapchain: Surface lost" &lt;&lt; std::endl;
            break;
        case VK_ERROR_NATIVE_WINDOW_IN_USE_KHR:
            std::cerr &lt;&lt; "Failed to create swapchain: Native window in use" &lt;&lt; std::endl;
            break;
        default:
            std::cerr &lt;&lt; "Failed to create swapchain: Unknown error" &lt;&lt; std::endl;
            break;
    }
    // Handle error appropriately
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources"><a class="anchor" href="#_resources"></a>Resources</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_libraries"><a class="anchor" href="#_libraries"></a>Libraries</h3>
<div class="ulist">
<ul>
<li>
<p><a href="https://www.glfw.org/">GLFW</a></p>
</li>
<li>
<p><a href="https://www.libsdl.org/">SDL2</a></p>
</li>
<li>
<p><a href="https://www.openal.org/">OpenAL</a></p>
</li>
<li>
<p><a href="https://www.fmod.com/">FMOD</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_examples_and_tutorials"><a class="anchor" href="#_examples_and_tutorials"></a>Examples and Tutorials</h3>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/KhronosGroup/Vulkan-Samples">Khronos Vulkan Samples</a></p>
</li>
<li>
<p><a href="https://github.com/SaschaWillems/Vulkan">Sascha Willems' Vulkan Examples</a></p>
</li>
<li>
<p><a href="https://docs.vulkan.org/tutorial/latest/00_Introduction.html">Vulkan Tutorial</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_documentation"><a class="anchor" href="#_documentation"></a>Documentation</h3>
<div class="ulist">
<ul>
<li>
<p><a href="https://www.glfw.org/docs/latest/">GLFW Documentation</a></p>
</li>
<li>
<p><a href="https://wiki.libsdl.org/SDL2/FrontPage">SDL2 Wiki</a></p>
</li>
<li>
<p><a href="https://www.openal.org/documentation/">OpenAL Documentation</a></p>
</li>
<li>
<p><a href="https://www.fmod.com/resources/documentation-api">FMOD Documentation</a></p>
</li>
<li>
<p><a href="https://github.com/google/oboe">Oboe GitHub Repository</a></p>
</li>
<li>
<p><a href="https://github.com/google/oboe/wiki">Oboe Documentation</a></p>
</li>
<li>
<p><a href="https://developer.apple.com/documentation/avfaudio/avaudioengine">iOS AVAudioEngine Documentation</a></p>
</li>
<li>
<p><a href="https://developer.apple.com/documentation/coreaudio">iOS Core Audio Documentation</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<script id="site-script" src="../../_/js/site.js" data-ui-root-path="../../_"></script>
<script async src="../../_/js/vendor/highlight.js"></script>
<script src="../../_/js/vendor/split.js"></script>
<script>
    // Splitter should only be visible in non-mobile layouts (where a hamburger menu is used for nav)
    var width = (window.innerWidth > 0) ? window.innerWidth : screen.width;
    var mobileNav = (width < 1024);

    if (!mobileNav) {
        var sizes = localStorage.getItem('split-sizes')

        if (sizes) {
            sizes = JSON.parse(sizes)
        } else {
            sizes = [25, 75]
        }

        var split = Split(['#split-0', '#split-1'], {
            sizes: sizes,
            onDragEnd: function (sizes) {
                localStorage.setItem('split-sizes', JSON.stringify(sizes))
            },
        })
    }
</script>
<script src="../../_/js/vendor/lunr.js" defer></script>
<script src="https://cdn.jsdelivr.net/pako/1.0.3/pako.min.js" defer></script>
<script src="../../_/js/search-ui.js" id="search-ui-script" data-site-root-path="../.." data-snippet-length="100" data-stylesheet="../../_/css/search.css" defer></script>
<script>
window.addEventListener('DOMContentLoaded', function(){
  try {
    var script = document.getElementById('search-ui-script');
    var siteRoot = (script && script.getAttribute('data-site-root-path')) || '';
    var manifestUrl = siteRoot + '/search-index/manifest.json';
    fetch(manifestUrl)
      .then(function (r) { return r.ok ? r.json() : Promise.reject(new Error('manifest not found')) })
      .then(function (manifest) { antoraSearch.bootstrap(lunr, manifest, siteRoot); })
      .catch(function () {
        var s = document.createElement('script');
        s.async = true;
        s.src = siteRoot + '/search-index.js';
        document.head.appendChild(s);
      });
  } catch (e) {
    // Fallback to monolithic index if anything goes wrong
    var s = document.createElement('script');
    s.async = true;
    s.src = '../../search-index.js';
    document.head.appendChild(s);
  }
});
</script>
<script async src="../../_/js/vendor/tabs.js"></script>
  </body>
</html>

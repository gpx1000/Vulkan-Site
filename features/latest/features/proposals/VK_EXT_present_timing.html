<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>VK_EXT_present_timing :: Vulkan Documentation Project</title>
    <meta name="generator" content="Antora 3.1.10">
    <script>
      !function (theme) {
        if (theme === 'dark') document.documentElement.classList.add('dark')
        else document.documentElement.classList.add('light')
      }(localStorage && localStorage.getItem('theme') || (matchMedia('(prefers-color-scheme: dark)')?.matches && 'dark'))
    </script>
    <link rel="stylesheet" href="../../../../_/css/site.css">
    <link rel="stylesheet" href="../../../../_/css/vendor/tabs.css">
    <link rel="apple-touch-icon" sizes="180x180" href="../../../../_/img/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../../../../_/img/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../../../../_/img/favicon-16x16.png">
    <link rel="manifest" href="../../../../_/site.webmanifest">
    <link rel="mask-icon" href="../../../../_/img/safari-pinned-tab.svg" color="#a41e22">
    <meta name="msapplication-TileColor" content="#ffc40d">
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="../../../.."><img class="navbar-item no-invert" alt="Vulkan White Label" src="../../../../_/Vulkan_Docs.svg" /></a>
      <div class="navbar-item search hide-for-print">
        <div id="search-field" class="field has-filter">
          <label for="search-input"></label>
          <input id="search-input" type="text" placeholder="Search the docs" aria-label="Search the docs">
          <label class="filter checkbox">
            <input type="checkbox" data-facet-filter="component:features" checked> In this component
          </label>
        </div>
      </div>
      <button class="navbar-burger" aria-controls="topbar-nav" aria-expanded="false" aria-label="Toggle main menu">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <!-- <a class="navbar-item" href="#">Home</a> -->
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Specs</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="../../../../spec/latest/chapters/introduction.html">Vulkan API</a>
            <a class="navbar-item" href="../../../../glsl/latest/index.html">GLSL</a>
            <a class="navbar-item" href="../../../../guide/latest/hlsl.html">HLSL</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Education</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="../../../../refpages/latest/refpages/index.html">Vulkan Reference Pages</a>
            <a class="navbar-item" href="../../../../features/latest/features/index.html">Vulkan Feature Descriptions</a>
            <a class="navbar-item" href="../../../../guide/latest/index.html">Vulkan Guide</a>
            <a class="navbar-item" href="../../../../samples/latest/README.html">Vulkan Samples</a>
            <a class="navbar-item" href="../../../../tutorial/latest/index.html">Vulkan Tutorial</a>
            <a class="navbar-item" href="https://www.youtube.com/c/vulkan">YouTube</a>
            <a class="navbar-item" href="https://vulkan.org">More Info at Vulkan.org</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Feedback</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="https://github.com/KhronosGroup/Vulkan-Site/issues/new/choose" target="_blank">Report a Problem</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Community</a>
          <div class="navbar-dropdown is-right">
            <a class="navbar-item" href="https://discord.gg/vulkan">Vulkan Discord</a>
            <a class="navbar-item" href="https://reddit.com/r/vulkan">Reddit</a>
            <a class="navbar-item" href="https://stackoverflow.com/questions/tagged/vulkan">Stack Overflow</a>
            <a class="navbar-item" href="https://fosstodon.org/@vulkan">Mastodon</a>
          </div>
        </div>
      </div>
    </div>
    <label class="theme-toggler">
      <input type="checkbox" id="switch-theme-checkbox" name="switch-theme-checkbox" aria-label="Toggle color theme" title="Toggle color theme"/>
      <span class="icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="moon" class="svg-inline--fa fa-moon moon" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><path fill="currentColor" d="M223.5 32C100 32 0 132.3 0 256S100 480 223.5 480c60.6 0 115.5-24.2 155.8-63.4c5-4.9 6.3-12.5 3.1-18.7s-10.1-9.7-17-8.5c-9.8 1.7-19.8 2.6-30.1 2.6c-96.9 0-175.5-78.8-175.5-176c0-65.8 36-123.1 89.3-153.3c6.1-3.5 9.2-10.5 7.7-17.3s-7.3-11.9-14.3-12.5c-6.3-.5-12.6-.8-19-.8z"></path>
        </svg>
        <svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="sun" class="svg-inline--fa fa-sun sun" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M361.5 1.2c5 2.1 8.6 6.6 9.6 11.9L391 121l107.9 19.8c5.3 1 9.8 4.6 11.9 9.6s1.5 10.7-1.6 15.2L446.9 256l62.3 90.3c3.1 4.5 3.7 10.2 1.6 15.2s-6.6 8.6-11.9 9.6L391 391 371.1 498.9c-1 5.3-4.6 9.8-9.6 11.9s-10.7 1.5-15.2-1.6L256 446.9l-90.3 62.3c-4.5 3.1-10.2 3.7-15.2 1.6s-8.6-6.6-9.6-11.9L121 391 13.1 371.1c-5.3-1-9.8-4.6-11.9-9.6s-1.5-10.7 1.6-15.2L65.1 256 2.8 165.7c-3.1-4.5-3.7-10.2-1.6-15.2s6.6-8.6 11.9-9.6L121 121 140.9 13.1c1-5.3 4.6-9.8 9.6-11.9s10.7-1.5 15.2 1.6L256 65.1 346.3 2.8c4.5-3.1 10.2-3.7 15.2-1.6zM160 256a96 96 0 1 1 192 0 96 96 0 1 1 -192 0zm224 0a128 128 0 1 0 -256 0 128 128 0 1 0 256 0z"></path>
        </svg></span>
    </label>
  </nav>
</header>
<script>
  window.onload = function() {
    let e = document.getElementById("switch-theme-checkbox")
    e.checked = document.documentElement.classList.contains("dark");
    e.checked ? e.parentElement.classList.add("active") : e.parentElement.classList.remove("active")
  }
  !function() {
    let e = document.getElementById("switch-theme-checkbox")
    e.checked = document.documentElement.classList.contains("dark")
    e.addEventListener("change", function() {
      if (document.documentElement.classList.contains("light")) {
        document.documentElement.classList.remove("light")
        document.documentElement.classList.add("dark")
      } else if (document.documentElement.classList.contains("dark")) {
        document.documentElement.classList.remove("dark")
        document.documentElement.classList.add("light")
      } else {
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
          document.documentElement.classList.add("dark")
        } else {
          document.documentElement.classList.add("light")
        }
      }
      document.documentElement.setAttribute("data-theme", this.checked ? "dark" : "light"),
        function(e) {
          window.localStorage && window.localStorage.setItem("theme", e)
        }(this.checked ? "dark" : "light"), this.checked ? this.parentElement.classList.add("active") : this.parentElement.classList.remove("active")
    }.bind(e))
  }();
</script>
<div class="body">
<div class="nav-container" data-component="features" data-version="latest" id="split-0">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <button class="nav-menu-toggle" aria-label="Toggle expand/collapse all" style="display: none"></button>
    <h3 class="title"><a href="../index.html">Vulkan Feature Descriptions</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../index.html">Vulkan Roadmap and Feature Descriptions</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="Roadmap.html">Vulkan Roadmap</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Feature Descriptions</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_AMDX_dense_geometry_format.html">VK_AMDX_dense_geometry_format</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_AMDX_shader_enqueue.html">VK_AMDX_shader_enqueue</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_AMD_anti_lag.html">VK_AMD_anti_lag</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_AMD_shader_early_and_late_fragment_tests.html">VK_AMD_shader_early_and_late_fragment_tests</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_ANDROID_external_format_resolve.html">VK_ANDROID_external_format_resolve</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_ARM_performance_counters_by_region.html">VK_ARM_performance_counters_by_region</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_ARM_pipeline_opacity_micromap.html">VK_ARM_pipeline_opacity_micromap</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_ARM_render_pass_striped.html">VK_ARM_render_pass_striped</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_ARM_tensors.html">VK_ARM_tensors</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_attachment_feedback_loop_dynamic_state.html">VK_EXT_attachment_feedback_loop_dynamic_state</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_attachment_feedback_loop_layout.html">VK_EXT_attachment_feedback_loop_layout</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_calibrated_timestamps.html">VK_EXT_calibrated_timestamps</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_custom_resolve.html">VK_EXT_custom_resolve</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_depth_bias_control.html">VK_EXT_depth_bias_control</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_depth_clamp_control.html">VK_EXT_depth_clamp_control</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_descriptor_buffer.html">VK_EXT_descriptor_buffer</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_device_fault.html">VK_EXT_device_fault</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_device_generated_commands.html">VK_EXT_device_generated_commands</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_dynamic_rendering_unused_attachments.html">VK_EXT_dynamic_rendering_unused_attachments</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_extended_dynamic_state3.html">VK_EXT_extended_dynamic_state3</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_external_memory_acquire_unmodified.html">VK_EXT_external_memory_acquire_unmodified</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_external_memory_metal.html">VK_EXT_external_memory_metal</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_fragment_density_map_offset.html">VK_EXT_fragment_density_map_offset</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_frame_boundary.html">Proposal: <code>VK_EXT_frame_boundary</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_graphics_pipeline_library.html">VK_EXT_graphics_pipeline_library</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_host_image_copy.html">VK_EXT_host_image_copy</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_image_2d_array_of_3d.html">VK_EXT_image_2d_array_of_3d</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_image_compression_control.html">VK_EXT_image_compression_control</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_image_sliced_view_of_3d.html">VK_EXT_image_sliced_view_of_3d</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_layer_settings.html">VK_EXT_layer_settings</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_legacy_dithering.html">VK_EXT_legacy_dithering</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_legacy_vertex_attributes.html">VK_EXT_legacy_vertex_attributes</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_map_memory_placed.html">VK_EXT_map_memory_placed</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_memory_decompression.html">VK_EXT_memory_decompression</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_mesh_shader.html">VK_EXT_mesh_shader</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_metal_objects.html">VK_EXT_metal_objects</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_multisampled_render_to_single_sampled.html">VK_EXT_multisampled_render_to_single_sampled</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_mutable_descriptor_type.html">VK_EXT_mutable_descriptor_type</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_non_seamless_cube_map.html">VK_EXT_non_seamless_cube_map</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_opacity_micromap.html">VK_EXT_opacity_micromap</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_pipeline_library_group_handles.html">VK_EXT_pipeline_library_group_handles</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_pipeline_protected_access.html">VK_EXT_pipeline_protected_access</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_present_mode_fifo_latest_ready.html">VK_EXT_present_mode_fifo_latest_ready</a>
  </li>
  <li class="nav-item is-current-page" data-depth="2">
    <a class="nav-link" href="VK_EXT_present_timing.html">VK_EXT_present_timing</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_primitives_generated_query.html">VK_EXT_primitives_generated_query</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_rasterization_order_attachment_access.html">VK_EXT_rasterization_order_attachment_access</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_ray_tracing_invocation_reorder.html">VK_EXT_ray_tracing_invocation_reorder</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_shader_64bit_indexing.html">VK_EXT_shader_64bit_indexing</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_shader_float8.html">VK_EXT_shader_float8</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_shader_module_identifier.html">VK_EXT_shader_module_identifier</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_shader_object.html">VK_EXT_shader_object</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_shader_replicated_composites.html">VK_EXT_shader_replicated_composites</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_shader_tile_image.html">VK_EXT_shader_tile_image</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_shader_uniform_buffer_unsized_array.html">VK_EXT_shader_uniform_buffer_unsized_array</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_subpass_merge_feedback.html">VK_EXT_subpass_merge_feedback</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_surface_maintenance1.html">VK_EXT_surface_maintenance1</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_swapchain_maintenance1.html">VK_EXT_swapchain_maintenance1</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_EXT_zero_initialize_device_memory.html">VK_EXT_zero_initialize_device_memory</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_GOOGLE_surfaceless_query.html">VK_GOOGLE_surfaceless_query</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_HUAWEI_cluster_culling_shader.html">VK_HUAWEI_cluster_culling_shader</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_HUAWEI_invocation_mask.html">VK_HUAWEI_invocation_mask</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_compute_shader_derivatives.html">VK_KHR_compute_shader_derivatives</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_cooperative_matrix.html">VK_KHR_cooperative_matrix</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_copy_memory_indirect.html">VK_KHR_copy_memory_indirect</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_dynamic_rendering.html">VK_KHR_dynamic_rendering</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_dynamic_rendering_local_read.html">VK_KHR_dynamic_rendering_local_read</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_fragment_shader_barycentric.html">VK_KHR_fragment_shader_barycentric</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_fragment_shading_rate.html">VK_KHR_fragment_shading_rate</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_load_store_op_none.html">VK_KHR_load_store_op_none</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_maintenance10.html">VK_KHR_maintenance10</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_maintenance5.html">VK_KHR_maintenance5</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_maintenance6.html">VK_KHR_maintenance6</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_maintenance7.html">VK_KHR_maintenance7</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_maintenance8.html">VK_KHR_maintenance8</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_maintenance9.html">VK_KHR_maintenance9</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_map_memory2.html">VK_KHR_map_memory2</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_pipeline_binary.html">VK_KHR_pipeline_binary</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_present_id2.html">VK_KHR_present_id2</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_present_mode_fifo_latest_ready.html">VK_KHR_present_mode_fifo_latest_ready</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_present_wait2.html">VK_KHR_present_wait2</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_ray_tracing_position_fetch.html">VK_KHR_ray_tracing_position_fetch</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_shader_bfloat16.html">VK_KHR_shader_bfloat16</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_shader_expect_assume.html">VK_KHR_shader_expect_assume</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_shader_float_controls2.html">VK_KHR_shader_float_controls2</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_shader_fma.html">VK_KHR_shader_fma</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_shader_integer_dot_product.html">VK_KHR_shader_integer_dot_product</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_shader_maximal_reconvergence.html">VK_KHR_shader_maximal_reconvergence</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_shader_quad_control.html">VK_KHR_shader_quad_control</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_shader_relaxed_extended_instruction.html">VK_KHR_shader_relaxed_extended_instruction</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_shader_subgroup_rotate.html">Subgroup rotation instruction</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_shader_untyped_pointers.html">VK_KHR_shader_untyped_pointers</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_surface_maintenance1.html">VK_KHR_surface_maintenance1</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_swapchain_maintenance1.html">VK_KHR_swapchain_maintenance1</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_unified_image_layouts.html">VK_KHR_unified_image_layouts</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_vertex_attribute_divisor.html">VK_KHR_vertex_attribute_divisor</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_video_decode_av1.html">VK_KHR_video_decode_av1</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_video_decode_h264.html">VK_KHR_video_decode_h264</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_video_decode_h265.html">VK_KHR_video_decode_h265</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_video_decode_queue.html">VK_KHR_video_decode_queue</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_video_decode_vp9.html">VK_KHR_video_decode_vp9</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_video_encode_av1.html">VK_KHR_video_encode_av1</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_video_encode_h264.html">VK_KHR_video_encode_h264</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_video_encode_h265.html">VK_KHR_video_encode_h265</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_video_encode_intra_refresh.html">VK_KHR_video_encode_intra_refresh</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_video_encode_quantization_map.html">VK_KHR_video_encode_quantization_map</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_video_encode_queue.html">VK_KHR_video_encode_queue</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_video_maintenance1.html">VK_KHR_video_maintenance1</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_video_maintenance2.html">VK_KHR_video_maintenance2</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_KHR_video_queue.html">VK_KHR_video_queue</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_LUNARG_direct_driver_loading.html">VK_LUNARG_direct_driver_loading</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_MSFT_layered_driver.html">VK_MSFT_layered_driver</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_NV_cluster_acceleration_structure.html">VK_NV_cluster_acceleration_structure</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_NV_cooperative_matrix2.html">VK_NV_cooperative_matrix2</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_NV_cooperative_vector.html">VK_NV_cooperative_vector</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_NV_display_stereo.html">VK_NV_display_stereo</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_NV_external_compute_queue.html">VK_NV_external_compute_queue</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_NV_partitioned_acceleration_structure.html">VK_NV_partitioned_acceleration_structure</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_NV_ray_tracing_linear_swept_spheres.html">VK_NV_ray_tracing_linear_swept_spheres</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_NV_ray_tracing_validation.html">VK_NV_ray_tracing_validation</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_QCOM_data_graph_model.html">VK_QCOM_data_graph_model</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_QCOM_image_processing.html">VK_QCOM_image_processing</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_QCOM_tile_memory_heap.html">VK_QCOM_tile_memory_heap</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_QCOM_tile_properties.html">VK_QCOM_tile_properties</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_QCOM_tile_shading.html">VK_QCOM_tile_shading</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VK_VERSION_1_4.html">Vulkan 1.4</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="VulkanBase.html">Vulkan Base</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Vulkan Feature Descriptions</span>
    <span class="version">latest</span>
  </div>
  <ul class="components">
    <li class="component">
      <div class="title"><a href="../../../../tutorial/latest/00_Introduction.html">Khronos Vulkan Tutorial</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../tutorial/latest/00_Introduction.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../../../glsl/latest/index.html">OpenGL Shading Language Specification</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../glsl/latest/index.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../../../refpages/latest/refpages/index.html">Vulkan API Reference Pages</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../refpages/latest/refpages/index.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component is-current">
      <div class="title"><a href="../index.html">Vulkan Feature Descriptions</a></div>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../index.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../../../guide/latest/index.html">Vulkan Guide</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../guide/latest/index.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../../../samples/latest/README.html">Vulkan Samples</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../samples/latest/README.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../../../spec/latest/index.html">Vulkan Specification</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../spec/latest/index.html">latest</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article" id="split-1">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../../../../spec/latest/index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../index.html">Vulkan Feature Descriptions</a></li>
    <li>Feature Descriptions</li>
    <li><a href="VK_EXT_present_timing.html">VK_EXT_present_timing</a></li>
  </ul>
</nav>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">VK_EXT_present_timing</h1>
<div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_problem_statement">1. Problem statement</a></li>
<li><a href="#_solution_space">2. Solution Space</a></li>
<li><a href="#_proposal">3. Proposal</a>
<ul class="sectlevel2">
<li><a href="#_features">3.1. Features</a></li>
<li><a href="#present_stages">3.2. Present stages</a></li>
<li><a href="#_enabling_present_timing_for_a_swapchain">3.3. Enabling present timing for a swapchain</a></li>
<li><a href="#_swapchain_timing_information">3.4. Swapchain Timing Information</a></li>
<li><a href="#statistics">3.5. Presentation timings feedback</a></li>
<li><a href="#scheduling">3.6. Scheduling presents</a></li>
</ul>
</li>
<li><a href="#_examples">4. Examples</a>
<ul class="sectlevel2">
<li><a href="#_enabling_present_timing_for_a_swapchain_2">4.1. Enabling present timing for a swapchain</a></li>
<li><a href="#_query_presentation_timing_results">4.2. Query presentation timing results</a></li>
<li><a href="#_handling_vk_error_present_timing_queue_full_ext_waiting_for_results">4.3. Handling <code>VK_ERROR_PRESENT_TIMING_QUEUE_FULL_EXT</code>: waiting for results</a></li>
<li><a href="#_setting_absolute_target_present_times">4.4. Setting absolute target present times</a></li>
</ul>
</li>
<li><a href="#_issues">5. Issues</a>
<ul class="sectlevel2">
<li><a href="#_what_are_the_key_differences_to_vk_google_display_timing">5.1. What are the key differences to <code>VK_GOOGLE_display_timing</code>?</a></li>
<li><a href="#_resolved_how_does_the_application_choose_the_internal_queue_size_to_pass_in_vksetswapchainpresenttimingqueuesize">5.2. RESOLVED: How does the application choose the internal queue size to pass in <code>vkSetSwapchainPresentTimingQueueSize</code>?</a></li>
<li><a href="#_resolved_do_we_need_an_api_to_synchronously_wait_for_present_timing_feedback">5.3. RESOLVED: Do we need an API to synchronously wait for present timing feedback?</a></li>
<li><a href="#_proposed_how_do_we_handle_dynamic_surface_properties_updates">5.4. PROPOSED: How do we handle dynamic surface properties updates?</a></li>
<li><a href="#_proposed_how_are_dropped_presentation_requests_handled">5.5. PROPOSED: How are dropped presentation requests handled?</a></li>
<li><a href="#_proposed_how_do_different_variable_refresh_rate_technologies_interact_with_this_extension">5.6. PROPOSED: How do different variable refresh rate technologies interact with this extension?</a></li>
<li><a href="#_proposed_how_does_an_application_adjust_its_ipd_to_match_the_swapchains_refresh_rate">5.7. PROPOSED: How does an application adjust its IPD to match the swapchain&#8217;s refresh rate?</a></li>
</ul>
</li>
</ul>
</div>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>This extension provides facilities for applications using VK_KHR_swapchain to obtain timing information about the presentation engine&#8217;s display, presentation statistics for each present operation, and to schedule present operations to happen at a specific time.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_problem_statement"><a class="anchor" href="#_problem_statement"></a>1. Problem statement</h2>
<div class="sectionbody">
<div class="paragraph">
<p>As rendering systems have become more complex and more deeply buffered, rendering workloads have grown increasingly independent of the presentation process. Different hardware may even be involved. As a consequence, applications are left without a clear way to align the presentation process with other workloads, particularly rendering.</p>
</div>
<div class="paragraph">
<p>This can result in visual anomalies such as stutter, or increased input latency, when the frames are not being presented to the user at the time the application was expecting it. This effect may be exacerbated in Fixed Refresh Rate (FRR) scenarios when the display refresh rate is not a factor of the application&#8217;s rendered frame rate; for example, rendering 50 frames per second on a 60Hz monitor, which will result in some frames being visible for multiple refresh cycles.</p>
</div>
<div class="paragraph">
<p>To accomplish smooth animation, applications need to predict and schedule when each frame is going to be displayed so that the application&#8217;s simulation time, which places the geometry and camera within a scene, closely matches the display time. This requires various timing information about the presentation engine, such as when previous presentable images were actually displayed and when they could have been displayed, as well as the presentation engine&#8217;s refresh cycle duration.</p>
</div>
<div class="paragraph">
<p>Multimedia applications also typically require accurate frame timing in order to closely match the content&#8217;s expected frame rate and synchronize presentation operations with audio output.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_solution_space"><a class="anchor" href="#_solution_space"></a>2. Solution Space</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Partial solutions exist to address some of the problems described above:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Variable Refresh Rate</p>
</li>
<li>
<p><code>VK_KHR_present_wait</code> and <code>VK_KHR_present_wait2</code></p>
</li>
<li>
<p><code>VK_GOOGLE_display_timing</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Variable Refresh Rate (VRR) technology can mitigate the effects of stutter, because the display may be able to match the variations in present duration, while FRR displays need to wait for a future refresh cycle if an image was not ready in time for its intended present time. Though this limits some of the visual anomalies, it does not address the issue of providing applications feedback and control over the presentation engine timing.</p>
</div>
<div class="paragraph">
<p><code>VK_KHR_present_wait</code> is a Vulkan extension which allows the host to synchronously wait for a present operation to complete. This can be used as a tool to implement efficient frame pacing, but lacks important details such as the latency of the present operation itself, and information about the display timing properties. The <code>VK_KHR_present_wait</code> specification itself also has rather loose requirements which may result in inconsistent implementations.</p>
</div>
<div class="paragraph">
<p><code>VK_GOOGLE_display_timing</code> is currently the only existing extension which provides a solution to this core problem of interacting with the presentation engine&#8217;s timeline. However, it is not implementable by all vendors, and lacks enough details to support technologies such as VRR systems. The proposal that follows is heavily inspired by all the work and discussions surrounding <code>VK_GOOGLE_display_timing</code>, and provides a more granular approach to its features, allowing for wider vendor adoption.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_proposal"><a class="anchor" href="#_proposal"></a>3. Proposal</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_features"><a class="anchor" href="#_features"></a>3.1. Features</h3>
<div class="paragraph">
<p><code>VK_EXT_present_timing</code> exposes three new physical device features:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">typedef struct VkPhysicalDevicePresentTimingFeaturesEXT {
    VkStructureType    sType;
    void*              pNext;
    VkBool32           presentTiming;
    VkBool32           presentAtAbsoluteTime;
    VkBool32           presentAtRelativeTime;
} VkPhysicalDevicePresentTimingFeaturesEXT;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>VK_EXT_present_timing</code> is exposed by the device, <code>presentTiming</code> is required to be supported. This feature allows applications to query details about presentation timing of a given swapchain, such as the refresh rate or supported time domains, as well as statistics about individual present operations.</p>
</div>
<div class="paragraph">
<p>When supported, <code>presentAtAbsoluteTime</code> allows applications to specify an absolute time, in a specific time domain, with each <code>vkQueuePresentKHR</code> call. <code>presentAtRelativeTime</code> allows applications to specify a relative time instead, specifying a minimum duration before a new image can presented. See <a href="#scheduling">Scheduling presents</a>.</p>
</div>
<div class="paragraph">
<p>These features are also advertised for each <code>VkSurfaceKHR</code> object with:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">typedef struct VkPresentTimingSurfaceCapabilitiesEXT {
    VkStructureType           sType;
    void*                     pNext;
    VkBool32                  presentTimingSupported;
    VkBool32                  presentAtAbsoluteTimeSupported;
    VkBool32                  presentAtRelativeTimeSupported;
    VkPresentStageFlagsEXT    presentStageQueries;
} VkPresentTimingSurfaceCapabilitiesEXT;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In addition of the present timing and present scheduling features, surfaces also advertise which <a href="#present_stages">Present stages</a> are available to query timings for.</p>
</div>
</div>
<div class="sect2">
<h3 id="present_stages"><a class="anchor" href="#present_stages"></a>3.2. Present stages</h3>
<div class="paragraph">
<p>It is difficult to define "presentation" while satisfying all implementations, platforms or even display technologies. Thus, this proposal introduces the concept of "present stages": a set of well-defined discrete steps within typical present pipelines.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">typedef enum VkPresentStageFlagBitsEXT {
    VK_PRESENT_STAGE_QUEUE_OPERATIONS_END_BIT_EXT = 0x00000001,
    VK_PRESENT_STAGE_REQUEST_DEQUEUED_BIT_EXT = 0x00000002,
    VK_PRESENT_STAGE_IMAGE_FIRST_PIXEL_OUT_BIT_EXT = 0x00000004,
    VK_PRESENT_STAGE_IMAGE_FIRST_PIXEL_VISIBLE_BIT_EXT = 0x00000008,
} VkPresentStageFlagBitsEXT;</code></pre>
</div>
</div>
<div class="paragraph">
<p>When queueing a presentation request for a swapchain, a set of present stages is specified to inform the implementation that timing for those stages is desired. See <a href="#statistics">Presentation timings feedback</a>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>VK_PRESENT_STAGE_QUEUE_OPERATIONS_END_BIT_EXT</code> marks the end of the set of queue operations enqueued by <code>vkQueuePresentKHR</code> on the provided <code>VkQueue</code>. These queue operations are implementation-specific; the usual example is a blit to a system-specific internal surface suited for presentation.</p>
</li>
<li>
<p><code>VK_PRESENT_STAGE_REQUEST_DEQUEUED_BIT_EXT</code> is the stage after which the presentation request has been dequeued from the swapchain&#8217;s internal presentation request queue, as specified by the active present mode.</p>
</li>
<li>
<p><code>VK_PRESENT_STAGE_IMAGE_FIRST_PIXEL_OUT_BIT_EXT</code> is the stage after which data for the first pixel of the presentation request associated with the image has left the presentation engine for the display hardware.</p>
</li>
<li>
<p><code>VK_PRESENT_STAGE_IMAGE_FIRST_PIXEL_VISIBLE_BIT_EXT</code> is the stage after which a display hardware has made the first pixel visible for the presentation request associated with the image to be presented.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Implementations are required to support at least <code>VK_PRESENT_STAGE_QUEUE_OPERATIONS_END_BIT_EXT</code> in <code>VkPresentTimingSurfaceCapabilitiesEXT::presentStageQueries</code> if <code>presentTimingSupported</code> is <code>VK_TRUE</code> for the surface.</p>
</div>
</div>
<div class="sect2">
<h3 id="_enabling_present_timing_for_a_swapchain"><a class="anchor" href="#_enabling_present_timing_for_a_swapchain"></a>3.3. Enabling present timing for a swapchain</h3>
<div class="paragraph">
<p>To enable present timing for a swapchain, a new flag must be specified in <code>VkSwapchainCreateInfoKHR::flags</code>: <code>VK_SWAPCHAIN_CREATE_PRESENT_TIMING_BIT_EXT</code>.</p>
</div>
<div class="paragraph">
<p>To provide presentation timing results, implementations need to allocate an internal queue and other resources to collect the necessary timestamps. The size of that queue must be specified by the application with a new function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">VkResult vkSetSwapchainPresentTimingQueueSizeEXT(
    VkDevice                                    device,
    VkSwapchainKHR                              swapchain,
    uint32_t                                    size);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Calling this function multiple times causes the results queue to be reallocated to the new size. If the new size cannot hold all the current outstanding results, <code>VK_NOT_READY</code> is returned.</p>
</div>
<div class="paragraph">
<p>Calling <code>vkQueuePresentKHR</code> with non-zero stage queries allocates a slot in that internal queue, while <code>vkGetPastPresentationTimingEXT</code> releases slots when complete results are returned.</p>
</div>
</div>
<div class="sect2">
<h3 id="_swapchain_timing_information"><a class="anchor" href="#_swapchain_timing_information"></a>3.4. Swapchain Timing Information</h3>
<div class="sect3">
<h4 id="_timing_properties"><a class="anchor" href="#_timing_properties"></a>3.4.1. Timing Properties</h4>
<div class="paragraph">
<p>For timing to be meaningful, the application needs to be aware of various properties. Basic properties are exposed in a new structure, <code>VkSwapchainTimingPropertiesEXT</code>, which can be retrieved with:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">VkResult vkGetSwapchainTimingPropertiesEXT(
    VkDevice                                    device,
    VkSwapchainKHR                              swapchain,
    VkSwapchainTimingPropertiesEXT*             pSwapchainTimingProperties,
    uint64_t*                                   pSwapchainTimingPropertiesCounter);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Swapchain timing properties may change dynamically at any time without prior notification. For example, enabling power-saving mode on a device may cause it to lower the display panel&#8217;s refresh rate. To allow applications to detect changes in those properties, a monotonically increasing counter is used by the implementation to identify the current state. This counter increases every time the swapchain properties are modified. <code>pSwapchainTimingPropertiesCounter</code> is a pointer to a <code>uint64_t</code> set by the implementation to the value of the current timing properties counter. Further updates to those properties are also communicated back to the application when querying presentation timings via <code>vkGetPastPresentationTimingEXT</code>.</p>
</div>
<div class="paragraph">
<p><code>vkGetSwapchainTimingPropertiesEXT</code> can return <code>VK_NOT_READY</code>, because some platforms may not provide timing properties until after at least one image has been presented to the swapchain. If timing properties of the swapchain change, updated results may again only be provided until after at least one additional image has been presented.</p>
</div>
<div class="paragraph">
<p>The <code>VkSwapchainTimingPropertiesEXT</code> structure is defined as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">typedef struct VkSwapchainTimingPropertiesEXT {
    VkStructureType    sType;
    const void*        pNext;
    uint64_t           refreshDuration;
    uint64_t           refreshInterval;
} VkSwapchainTimingPropertiesEXT;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>refreshDuration</code> is the duration in nanoseconds of the refresh cycle the presentation engine is operating at.</p>
</li>
<li>
<p><code>refreshInterval</code> is a duration in nanoseconds indicating the interval between refresh cycles.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If <code>refreshDuration</code> is zero, the presentation engine is unable to provide the current refresh cycle duration. Similarly, if <code>refreshInterval</code> is zero, the presentation engine is unable to provide information regarding the dynamics of the refresh cycle.</p>
</div>
<div class="paragraph">
<p>If <code>refreshInterval</code> is <code>UINT64_MAX</code>, the presentation engine is operating in VRR mode, and <code>refreshDuration</code> is the minimum duration of a refresh cycle.</p>
</div>
<div class="paragraph">
<p>When <code>refreshInterval</code> is the same as <code>refreshDuration</code>, the presentation engine is operating in FRR mode.</p>
</div>
<div class="paragraph">
<p>If <code>refreshInterval</code> is not zero and is not <code>UINT64_MAX</code>, <code>refreshDuration</code> is a multiple of <code>refreshInterval</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_time_domains"><a class="anchor" href="#_time_domains"></a>3.4.2. Time Domains</h4>
<div class="paragraph">
<p>Applications also need to query available time domains using:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">VkResult vkGetSwapchainTimeDomainPropertiesEXT(
    VkDevice                                    device,
    VkSwapchainKHR                              swapchain,
    VkSwapchainTimeDomainPropertiesEXT*         pSwapchainTimeDomainProperties,
    uint64_t*                                   pTimeDomainsCounter);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Similar to <a href="#_timing_properties">Timing Properties</a>, supported time domains may change dynamically. <code>pTimeDomainsCounter</code> identifies the current list of available time domains, and further internal changes to this list are notified to the application when calling <code>vkGetPastPresentationTimingEXT</code>.</p>
</div>
<div class="paragraph">
<p>The <code>VkSwapchainTimeDomainPropertiesEXT</code> structure is defined as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">typedef struct VkSwapchainTimeDomainPropertiesEXT {
    VkStructureType    sType;
    void*              pNext;
    uint32_t           timeDomainCount;
    VkTimeDomainKHR    *pTimeDomains;
    uint64_t           *pTimeDomainIds;
} VkSwapchainTimeDomainPropertiesEXT;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>timeDomainCount</code> is an input specifying the size of the <code>pTimeDomains</code> and <code>pTimeDomainIds</code> arrays. If <code>pTimeDomains</code> and <code>pTimeDomainIds</code> are <code>NULL</code>, it is set by the implementation upon return of <code>vkGetSwapchainTimeDomainPropertiesEXT</code> to the number of available time domains. Otherwise, it is set to the number of elements written in <code>pTimeDomains</code> and <code>pTimeDomainIds</code>.</p>
</li>
<li>
<p><code>pTimeDomains</code> is an array of <code>VkTimeDomainKHR</code> currently supported by the swapchain.</p>
</li>
<li>
<p><code>pTimeDomainIds</code> is an array of unique identifiers for each supported time domain. Time domains are assigned a unique identifier within a swapchain by the implementation. This id is used to differentiate between multiple swapchain-local time domains of the same scope.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Two new swapchain-local time domains are added in this proposal as <code>VkTimeDomainKHR</code> values:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">typedef enum VkTimeDomainKHR {
    // ...
    VK_TIME_DOMAIN_PRESENT_STAGE_LOCAL_EXT = 1000208000,
    VK_TIME_DOMAIN_SWAPCHAIN_LOCAL_EXT = 1000208001,
} VkTimeDomainKHR;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>VK_TIME_DOMAIN_PRESENT_STAGE_LOCAL_EXT</code> is a stage-local and swapchain-local time domain. It allows platforms where different presentation stages are handled by independent hardware to report timings in their own time domain. It is required to be supported.</p>
</li>
<li>
<p><code>VK_TIME_DOMAIN_SWAPCHAIN_LOCAL_EXT</code> is a swapchain-local time domain, shared by all present stages.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To calibrate a swapchain-local or stage-local timestamp with another time domain, a new structure can be chained to <code>VkCalibratedTimestampInfoKHR</code> and passed to <code>vkGetCalibratedTimestampsKHR</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">typedef struct VkSwapchainCalibratedTimestampInfoEXT {
    VkStructureType        sType;
    const void*            pNext;
    VkSwapchainKHR         swapchain;
    VkPresentStageFlagsEXT presentStage;
    uint64_t               timeDomainId;
} VkSwapchainCalibratedTimestampInfoEXT;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>presentStage</code> is zero to calibrate a <code>VK_TIME_DOMAIN_SWAPCHAIN_LOCAL_EXT</code> time domain, or a single <code>VkPresentStageFlagsEXT</code> bit to calibrate a <code>VK_TIME_DOMAIN_PRESENT_STAGE_LOCAL_EXT</code> from that stage.</p>
</li>
<li>
<p><code>timeDomainId</code> is the identifier of the swapchain-local time domain returned by <code>vkGetSwapchainTimeDomainPropertiesEXT</code> or <code>vkGetPastPresentationTimingEXT</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="statistics"><a class="anchor" href="#statistics"></a>3.5. Presentation timings feedback</h3>
<div class="paragraph">
<p>Applications can obtain timing information about previous presents using:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">VkResult vkGetPastPresentationTimingEXT(
    VkDevice                                   device,
    const VkPastPresentationTimingInfoEXT*     pPastPresentationTimingInfo,
    VkPastPresentationTimingPropertiesEXT*     pPastPresentationTimingProperties);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>VkPastPresentationTimingInfoEXT</code> is a simple input structure referencing the <code>swapchain</code> to target, allowing for potential future extensions to hook into the <code>pNext</code> chain:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">typedef struct VkPastPresentationTimingInfoEXT {
    VkStructureType                      sType;
    const void*                          pNext;
    VkPastPresentationTimingFlagsEXT     flags;
    VkSwapchainKHR                       swapchain;
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>The flag bits for <code>VkPastPresentationTimingFlagsEXT</code> are defined as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">typedef enum VkPastPresentationTimingFlagBitsEXT {
    VK_PAST_PRESENTATION_TIMING_ALLOW_PARTIAL_RESULTS_BIT_EXT = 0x00000001,
    VK_PAST_PRESENTATION_TIMING_ALLOW_OUT_OF_ORDER_RESULTS_BIT_EXT = 0x00000002,
} VkPastPresentationTimingFlagBitsEXT;
typedef VkFlags VkPastPresentationTimingFlagsEXT;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>VK_PAST_PRESENTATION_TIMING_ALLOW_PARTIAL_RESULTS_BIT_EXT</code> allows <code>vkGetPastPresentationTimingEXT</code> to return partial results for presentation requests that have not completed all requested present stages.</p>
</li>
<li>
<p><code>VK_PAST_PRESENTATION_TIMING_ALLOW_OUT_OF_ORDER_RESULTS_BIT_EXT</code> allows <code>vkGetPastPresentationTimingEXT</code> to return results out of order with respect to the presentation order.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>VkPastPresentationTimingPropertiesEXT</code> structure is defined as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">typedef struct VkPastPresentationTimingPropertiesEXT {
    VkStructureType                 sType;
    const void*                     pNext;
    uint64_t                        timingPropertiesCounter;
    uint64_t                        timeDomainsCounter;
    uint32_t                        presentationTimingCount;
    VkPastPresentationTimingEXT*    pPresentationTimings;
};</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>timingPropertiesCounter</code> is set to the current internal counter of the swapchain&#8217;s timing properties.</p>
</li>
<li>
<p><code>timeDomainsCounter</code> is set to the current internal counter of the swapchain&#8217;s supported time domain list.</p>
</li>
<li>
<p><code>presentationTimingCount</code> specifies the size of the <code>pPresentationTimings</code> array. If <code>pPresentationTimings</code> is <code>NULL</code>, the implementation sets it to the number of pending results available in the swapchain&#8217;s internal queue. Otherwise, it is overwritten upon return with the number of entries written to <code>pPresentationTimings</code>. If the implementation is not able to write all the available results in the provided <code>pPresentationTimings</code> array, <code>VK_INCOMPLETE</code> is returned.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Results for presentation requests whose entries in <code>pPresentationTimings</code> are marked as complete with <code>VkPastPresentationTimingEXT::reportComplete</code> will not be returned anymore. For each of those, a slot in the swapchain&#8217;s internal results queue is released. Incomplete results for presentation requests will keep being reported in further <code>vkGetPastPresentationTimingEXT</code> calls until complete, if the <code>VK_PAST_PRESENTATION_TIMING_ALLOW_PARTIAL_RESULTS_BIT_EXT</code> flag is set in <code>VkPastPresentationTimingInfoEXT::flags</code>.</p>
</div>
<div class="paragraph">
<p><code>VkPastPresentationTimingEXT</code> is defined as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">typedef struct VkPresentStageTimeEXT {
    VkPresentStageFlagsEXT stage;
    uint64_t               time;
} VkPresentStageTimeEXT;

typedef struct VkPastPresentationTimingEXT {
    VkStructureType           sType;
    const void*               pNext;
    uint64_t                  presentId;
    uint64_t                  targetTime;
    uint32_t                  presentStageCount;
    VkPresentStageTimeEXT*    pPresentStages;
    VkTimeDomainKHR           timeDomain;
    uint64_t                  timeDomainId;
    VkBool32                  reportComplete;
} VkPastPresentationTimingEXT;</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>presentId</code> is zero or a present id provided to <code>vkQueuePresentKHR</code> by adding a <code>VkPresentId2KHR</code> to the <code>VkPresentInfoKHR</code> pNext chain. Timing results can be correlated to specific presents using this value.</p>
</li>
<li>
<p><code>targetTime</code> is the target present time or duration in nanoseconds specified by the application for the associated presentation request in <code>VkPresentTimingInfoEXT::targetTime</code>.</p>
</li>
<li>
<p><code>presentStageCount</code> and <code>pPresentStages</code> contain the timing information for the present stages that were specified in the <code>VkPresentTimingInfoEXT</code> passed to the corresponding <code>vkQueuePresentKHR</code> call.</p>
</li>
<li>
<p><code>timeDomain</code> and <code>timeDomainId</code> define the time domain used for <code>pPresentStages</code> result times. It may be different than the time domain specified for the associated <code>vkQueuePresentKHR</code> call if that time domain was unavailable when the presentation request was processed.</p>
</li>
<li>
<p><code>reportComplete</code> indicates whether results for all present stages have been reported.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>presentStageCount</code> and <code>pPresentStages</code> must be setup by the application to hold enough present stage results for the outstanding presentation requests.</p>
</div>
<div class="paragraph">
<p><code>presentStageCount</code> only reports the number of stages which contain definitive results. However, time values in completed <code>pPresentStages</code> can still be 0 for multiple reasons. Most notably, it is possible for a presentation request to never reach some present stages, for example if using a present mode that allows images to be replaced in the queue, such as <code>VK_PRESENT_MODE_FIFO_LATEST_READY_KHR</code>. Platform-specific events can also cause results for some present stages to be unavailable for a specific presentation request.</p>
</div>
<div class="paragraph">
<p>To accommodate for the difference in query latency among the different present stages, timing results can be reported as incomplete when multiple present stages were specified in <code>VkPresentTimingInfoEXT::presentStageQueries</code> and the <code>VK_PAST_PRESENTATION_TIMING_ALLOW_PARTIAL_RESULTS_BIT_EXT</code> flag is set in <code>VkPastPresentationTimingInfoEXT::flags</code>. For example, in more complex topologies of the display system, such as network-based configurations, results for the <code>VK_PRESENT_STAGE_QUEUE_OPERATIONS_END_BIT_EXT</code> present stage can be available much earlier than for subsequent stages.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>One key aspect that is notably missing from this extension is the ability to collect timing information from individual "nodes" of the display topology. A typical example would be a system connected to two displays, running in "mirror" mode so that both will display the swapchain contents; in this case, this API does not provide any way to know which monitor the timings correspond to: the only requirement is that the timings are from an entity that is affected by the presentation. There are security considerations to providing such details that are best covered by system-specific extensions.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="scheduling"><a class="anchor" href="#scheduling"></a>3.6. Scheduling presents</h3>
<div class="paragraph">
<p>A new struct <code>VkPresentTimingsInfoEXT</code> can be appended to the <code>VkPresentInfoKHR</code> pNext chain to specify present timing properties:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">typedef struct VkPresentTimingInfoEXT {
    VkStructureType              sType;
    const void*                  pNext;
    VkPresentTimingInfoFlagsEXT  flags;
    uint64_t                     targetTime;
    uint64_t                     timeDomainId;
    VkPresentStageFlagsEXT       presentStageQueries;
    VkPresentStageFlagsEXT       targetTimeDomainPresentStage;
} VkPresentTimingInfoEXT;

typedef struct VkPresentTimingsInfoEXT {
    VkStructureType                   sType;
    const void*                       pNext;
    uint32_t                          swapchainCount;
    const VkPresentTimingInfoEXT*     pTimingInfos;
} VkPresentTimingsInfoEXT;</code></pre>
</div>
</div>
<div class="paragraph">
<p>For each swapchain referenced in <code>VkPresentInfoKHR</code>, a <code>VkPresentTimingInfoEXT</code> is specified:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>targetTime</code> is the absolute or relative time used to schedule this presentation request.</p>
</li>
<li>
<p><code>timeDomainId</code> is the id of the time domain used to specify <code>time</code> and to query timing results.</p>
</li>
<li>
<p><code>presentStageQueries</code> is a bitmask specifying all the present stages the application would like timings for.</p>
</li>
<li>
<p><code>targetTimeDomainPresentStage</code> is used to associate a stage-local time domain with a specific present stage.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If <code>presentStageQueries</code> is not zero, and the swapchain&#8217;s internal timing queue is full, calling <code>vkQueuePresentKHR</code> yields a new error: <code>VK_ERROR_PRESENT_TIMING_QUEUE_FULL_EXT</code>.</p>
</div>
<div class="paragraph">
<p>The semantics of specifying a target present time only apply to FIFO present modes (<code>VK_PRESENT_MODE_FIFO_KHR</code>, <code>VK_PRESENT_MODE_FIFO_RELAXED_KHR</code> and <code>VK_PRESENT_MODE_FIFO_LATEST_READY_KHR</code>). When attempting to dequeue a presentation request from the FIFO queue, the presentation engine checks the current time against the target time.</p>
</div>
<div class="paragraph">
<p>The <code>VkPresentTimingInfoFlags</code> flags are defined as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">typedef enum VkPresentTimingInfoFlagBitsEXT {
    VK_PRESENT_TIMING_INFO_PRESENT_AT_RELATIVE_TIME_BIT_EXT = 0x00000001,
    VK_PRESENT_TIMING_INFO_PRESENT_AT_NEAREST_REFRESH_CYCLE_BIT_EXT = 0x00000002
} VkPresentTimingInfoFlagBitsEXT;
typedef VkFlags VkPresentTimingInfoFlagsEXT;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>VK_PRESENT_TIMING_INFO_PRESENT_AT_RELATIVE_TIME_BIT_EXT</code> specifies whether <code>time</code> is to be interpreted as an absolute or a relative time value. If <code>time</code> is interpreted as an absolute time, it specifies the earliest time in nanoseconds at which the image should be visible. Otherwise, if it is interpreted as a relative time, it specifies the minimum duration in nanoseconds the previously presented image should be visible.</p>
</div>
<div class="paragraph">
<p>If <code>VK_PRESENT_TIMING_INFO_PRESENT_AT_NEAREST_REFRESH_CYCLE_BIT_EXT</code> is set, it indicates that the application would prefer the image to be made visible during the refresh cycle that is closest to the target present time, even if that refresh cycle starts earlier than the specified <code>time</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>More specifically, the implementation attempts to align the <code>VK_PRESENT_STAGE_IMAGE_FIRST_PIXEL_VISIBLE_BIT_EXT</code> present stage with the requested target present time.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>To maintain a constant image present duration (IPD), applications should use timing information collected via <code>vkGetPastPresentationTimingEXT</code> to determine the target time of each present. If the presentation engine is operating with a fixed refresh rate, the application&#8217;s IPD should be a multiple of <code>VkSwapchainTimingPropertiesEXT::refreshInterval</code>. That is, the quanta for changing the IPD is <code>refreshInterval</code>. For example, if <code>refreshDuration</code> is 16.67ms, the IPD can be 16.67ms, 33.33ms, 50.0ms, etc.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_examples"><a class="anchor" href="#_examples"></a>4. Examples</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_enabling_present_timing_for_a_swapchain_2"><a class="anchor" href="#_enabling_present_timing_for_a_swapchain_2"></a>4.1. Enabling present timing for a swapchain</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">    // Query device features
    VkPhysicalDevicePresentTimingFeaturesEXT deviceFeaturesPresentTiming = {
        .sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_TIMING_FEATURES_EXT
    };

    VkPhysicalDeviceFeatures2 features2 = {
        .sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
        .pNext = &amp;deviceFeaturesPresentTiming
    };

    vkGetPhysicalDeviceFeatures2(physicalDevice, &amp;features2);

    // Create device
    // (...)

    // Create swapchain
    VkSwapchainCreateInfoKHR swapchainCreateInfo = {
        .sType = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR,
        .pNext = NULL,
        .flags = VK_SWAPCHAIN_CREATE_PRESENT_TIMING_BIT_EXT
        // (...)
    };

    result = vkCreateSwapchainKHR(device, &amp;swapchainCreateInfo, NULL, &amp;swapchain);

    // Query timing properties and time domains
    // Note: On some systems, this may only be available after some
    // presentation requests have been processed.
    VkSwapchainTimingPropertiesEXT swapchainTimingProperties = {
        .sType = VK_STRUCTURE_TYPE_SWAPCHAIN_TIMING_PROPERTIES_EXT,
        .pNext = NULL
    };

    uint64_t currentTimingPropertiesCounter = 0;
    result = vkGetSwapchainTimingPropertiesEXT(device, swapchain, &amp;swapchainTimingProperties, &amp;currentTimingPropertiesCounter);

    uint64_t currentTimeDomainsCounter = 0;
    VkSwapchainTimeDomainPropertiesEXT timeDomains = {
        .sType = VK_STRUCTURE_TYPE_SWAPCHAIN_TIME_DOMAIN_PROPERTIES_EXT,
        .pNext = NULL,
        .timeDomainCount = 0,
        .pTimeDomains = NULL,
        .pTimeDomainIds = NULL
    };

    result = vkGetSwapchainTimeDomainPropertiesEXT(device, swapchain, &amp;timeDomains, NULL);
    timeDomains.pTimeDomains = (VkTimeDomainKHR *) malloc(timeDomains.timeDomainCount * sizeof(VkTimeDomainKHR));
    timeDomains.pTimeDomainIds = (uint64_t *) malloc(timeDomains.timeDomainCount * sizeof(uint64_t));
    result = vkGetSwapchainTimeDomainPropertiesEXT(device, swapchain, &amp;timeDomains, &amp;currentTimeDomainsCounter);

    // Find the ID of the current VK_TIME_DOMAIN_SWAPCHAIN_LOCAL_EXT time domain
    uint64_t swapchainLocalTimeDomainId = FindTimeDomain(&amp;timeDomains, VK_TIME_DOMAIN_SWAPCHAIN_LOCAL_EXT);

    // Allocate internal queue to collect present timing results
    const uint32_t maxTimingCount = GetMaxTimingCount(); // Default to sane value, e.g. swapchainImageCount * 2
    result = vkSetSwapchainPresentTimingQueueSizeEXT(device, swapchain, maxTimingCount);

    // (Start presenting...)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_query_presentation_timing_results"><a class="anchor" href="#_query_presentation_timing_results"></a>4.2. Query presentation timing results</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">    // See previous examples for how to get the timing properties and time domain IDs
    uint64_t currentTimingPropertiesCounter = GetCurrentTimingPropertiesCounter(...);
    uint64_t currentTimeDomainsCounter = GetCurrentTimeDomainsCounter(...);
    uint64_t timeDomainId = GetDesiredTimeDomain(...);
    VkPresentStageFlagsEXT presentStageQueries = GetDesiredPresentStageQueries(...);
    uint32_t pendingPresentResults = 0;

    VkPastPresentationTimingEXT *timings = (VkPastPresentationTimingEXT *) malloc(maxTimingCount * sizeof(VkPastPresentationTimingEXT));
    VkPresentStageTimeEXT *stageTimes = (VkPresentStageTimeEXT *) malloc(maxStageCount * maxTimingCount * sizeof(VkPresentStageTimeEXT));

    for (uint32_t i = 0; i &lt; maxTimingCount; ++i) {
        timings[i].sType = VK_STRUCTURE_TYPE_PAST_PRESENTATION_TIMING_EXT;
        timings[i].pNext = NULL;
        timings[i].pPresentStages = stageTimes + i * maxStageCount;
    }

    while (presenting) {
        // Render &amp; Present
        // (...)
        VkPresentTimingInfoEXT timingInfo = {
            .sType = VK_STRUCTURE_TYPE_PRESENT_TIMING_INFO_EXT,
            .pNext = NULL,
            .flags = 0,
            .targetTime = 0,
            .timeDomainId = timeDomainId,
            .presentStageQueries = presentStageQueries
        };

        VkPresentTimingsInfoEXT presentTimingsInfo = {
            .sType = VK_STRUCTURE_TYPE_PRESENT_TIMINGS_INFO_EXT,
            .pNext = NULL,
            .swapchainCount = 1,
            .pTimingInfos = &amp;timingInfo
        };

        presentInfoTail.pNext = &amp;presentTimingsInfo;
        result = vkQueuePresentKHR(...);

        if (result == VK_ERROR_PRESENT_TIMING_QUEUE_FULL_EXT) {
            // We are presenting faster than results are coming in. We can either
            // wait to drain the results queue, grow the results queue, or
            // present again without asking for present timing data.
            // (...)
        }

        if (result != VK_SUCCESS) {
            // Handle vkQueuePresentKHR other non-success return values
            // (...)
        }

        // Track the number of pending present results, each present taking one slot in the internal queue
        pendingPresentResults++;

        VkPastPresentationTimingInfoEXT pastTimingInfo = {
            .sType = VK_STRUCTURE_TYPE_PAST_PRESENTATION_TIMING_INFO_EXT,
            .pNext = NULL,
            .flags = 0,
            .swapchain = swapchain
        };

        VkPastPresentationTimingPropertiesEXT pastTimingProperties = {
            .sType = VK_STRUCTURE_TYPE_PAST_PRESENTATION_TIMING_PROPERTIES_EXT,
            .pNext = NULL,
            .timingPropertiesCounter = 0,
            .timeDomainsCounter = 0,
            .presentationTimingCount = maxTimingCount,
            .pPresentationTimings = timings
        };

        result = vkGetPastPresentationTimingEXT(device, &amp;pastTimingInfo, &amp;pastTimingProperties);

        if (result != VK_SUCCESS) {
            // Handle error
            // (...)
        }

        if (pastTimingProperties.timingPropertiesCounter != currentTimingPropertiesCounter) {
            currentTimingPropertiesCounter = pastTimingProperties.timingPropertiesCounter;
            // Update swapchain timing properties
            // (...)
        }

        if (pastTimingProperties.timeDomainsCounter != currentTimeDomainsCounter) {
            currentTimeDomainsCounter = pastTimingProperties.timeDomainsCounter;
            // Update time domains
            // (...)
        }

        pendingPresentResults -= pastTimingProperties.presentationTimingCount;

        // Process timing results
    }</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_handling_vk_error_present_timing_queue_full_ext_waiting_for_results"><a class="anchor" href="#_handling_vk_error_present_timing_queue_full_ext_waiting_for_results"></a>4.3. Handling <code>VK_ERROR_PRESENT_TIMING_QUEUE_FULL_EXT</code>: waiting for results</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">    VkSwapchainTimingPropertiesEXT swapchainTimingProperties = {
        .sType = VK_STRUCTURE_TYPE_SWAPCHAIN_TIMING_PROPERTIES_EXT,
        .pNext = NULL
    };

    // Initialize timing properties, time domains, timing results queue, etc.
    // (...)

    while (presenting) {
        // Render &amp; Present
        // (...)

        result = vkQueuePresentKHR(...);

        if (result == VK_ERROR_PRESENT_TIMING_QUEUE_FULL_EXT) {
            // Synchronously wait for timing results to be available. There
            // is no synchronization built in the API for this, so the
            // application must poll. We use the refresh cycle duration as
            // our poll interval in this example.

            VkPastPresentationTimingInfoEXT pastTimingInfo = {
                .sType = VK_STRUCTURE_TYPE_PAST_PRESENTATION_TIMING_INFO_EXT,
                .pNext = NULL,
                .flags = 0,
                .swapchain = swapchain
            };

            VkPastPresentationTimingPropertiesEXT pastTimingProperties = {
                .sType = VK_STRUCTURE_TYPE_PAST_PRESENTATION_TIMING_PROPERTIES_EXT,
                .pNext = NULL,
                .timingPropertiesCounter = 0,
                .timeDomainsCounter = 0,
                .presentationTimingCount = 0,
                .pPresentationTimings = NULL
            };

            // Note: this loop can result in stutter if the presentation engine takes a long time to
            // return results. After a couple tries, it would be reasonable to bail and present without
            // requesting timing results.
            uint64_t sleepDuration = swapchainTimingProperties.refreshDuration;

            do {
                result = vkGetPastPresentationTimingEXT(device, &amp;pastTimingInfo, &amp;pastTimingProperties);

                if (result != VK_SUCCESS) {
                    // Handle error
                    // (...)
                }

                if (pastTimingProperties.timingPropertiesCounter != currentTimingPropertiesCounter) {
                    currentTimingPropertiesCounter = pastTimingProperties.timingPropertiesCounter;
                    result = vkGetSwapchainTimingPropertiesEXT(device, swapchain, &amp;swapchainTimingProperties, &amp;currentTimingPropertiesCounter);

                    if (result != VK_SUCCESS) {
                        // Handle error
                        // (...)
                    }

                    sleepDuration = swapchainTimingProperties.refreshDuration;
                }

                // Check pastTimingProperties.timeDomainsCounter as well
                // (...)

                if (pastTimingProperties.presentationTimingCount &gt; 0) {
                    // We have results, break out of the loop and process them
                    break;
                } else {
                    // We do not have results yet, sleep for the refresh cycle duration
                    SleepNS(sleepDuration);
                }

            } while (pastTimingProperties.presentationTimingCount == 0);

            // Actually retrieve the timing results now that we know they are available
            // (...)
        }

        // (...)
    }</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_setting_absolute_target_present_times"><a class="anchor" href="#_setting_absolute_target_present_times"></a>4.4. Setting absolute target present times</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">    // See previous examples for swapchain setup and timing results retrieval
    // (...)
    uint64_t currentPresentId = 1;
    uint64_t lastResultPresentId = 0;
    uint64_t lastResultPresentTime = 0;
    uint64_t targetIPD = defaultPresentDuration;

    while (presenting) {
        uint64_t targetPresentTime;

        if (lastResultDequeuedTime != 0) {
            targetPresentTime = lastResultDequeuedTime + (currentPresentId - lastResultPresentId) * targetIPD;
        } else {
            targetPresentTime = 0; // Present ASAP until we have a baseline
        }

        // Render &amp; Present
        // Note: make sure the rendering is doing a world simulation step that matches the targetIPD
        // (...)

        VkPresentTimingInfoEXT presentTimingInfo = {
            .sType = VK_STRUCTURE_TYPE_PRESENT_TIMING_INFO_EXT,
            .pNext = NULL,
            .flags = VK_PRESENT_TIMING_INFO_PRESENT_AT_NEAREST_REFRESH_CYCLE_BIT_EXT,
            .targetTime = targetPresentTime,
            .timeDomainId = timeDomainId,
            .presentStageQueries = VK_PRESENT_STAGE_IMAGE_FIRST_PIXEL_OUT_BIT_EXT
        };

        VkPresentTimingsInfoEXT presentTimingsInfo = {
            .sType = VK_STRUCTURE_TYPE_PRESENT_TIMINGS_INFO_EXT,
            .pNext = NULL,
            .swapchainCount = 1,
            .pTimingInfos = &amp;presentTimingInfo
        };

        presentInfoTail.pNext = &amp;presentTimingsInfo;

        result = vkQueuePresentKHR(...);

        if (result != VK_SUCCESS) {
            // Handle error
            // (...)
        }

        result = vkGetPastPresentationTimingEXT(device, &amp;pastTimingInfo, &amp;pastTimingProperties);

        if (result != VK_SUCCESS) {
            // Handle error
            // (...)
        }

        // Analyze the timing results and adjust targetIPD if needed
        // (...)

        currentPresentId++;
    }</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_issues"><a class="anchor" href="#_issues"></a>5. Issues</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_what_are_the_key_differences_to_vk_google_display_timing"><a class="anchor" href="#_what_are_the_key_differences_to_vk_google_display_timing"></a>5.1. What are the key differences to <code>VK_GOOGLE_display_timing</code>?</h3>
<div class="paragraph">
<p>The major API changes from <code>VK_GOOGLE_display_timing</code> are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Introduction of present stages with <code>VkPresentStageFlagsEXT</code></p>
</li>
<li>
<p>Rely on <code>VK_KHR_present_id2</code> to specify present Ids</p>
</li>
<li>
<p>Expose features in physical device and surface features</p>
</li>
<li>
<p>Variable refresh rate indicator</p>
</li>
<li>
<p>Progressive timings feedback</p>
</li>
<li>
<p>Allow time domain selection, with new opaque domains dedicated to swapchains</p>
</li>
<li>
<p>Allow for relative present times</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Compared to <code>VK_GOOGLE_display_timing</code>, stricter specification language is also used to allow for more consistent and wider adoption among implementors.</p>
</div>
</div>
<div class="sect2">
<h3 id="_resolved_how_does_the_application_choose_the_internal_queue_size_to_pass_in_vksetswapchainpresenttimingqueuesize"><a class="anchor" href="#_resolved_how_does_the_application_choose_the_internal_queue_size_to_pass_in_vksetswapchainpresenttimingqueuesize"></a>5.2. RESOLVED: How does the application choose the internal queue size to pass in <code>vkSetSwapchainPresentTimingQueueSize</code>?</h3>
<div class="paragraph">
<p>Use reasonable default values, such as a multiple of the swapchain image count.</p>
</div>
<div class="paragraph">
<p>Because presenting when the swapchain&#8217;s internal timing queue is full is considered an error, the latency of the timing results effectively can end up throttling the present rate if the internal queue is small enough. The topology of the presentation engine being generally opaque to applications, there is no indication of the feedback latency before the application starts presenting.</p>
</div>
<div class="paragraph">
<p>Applications which run into feedback latency issues can resize the internal timing queue.</p>
</div>
</div>
<div class="sect2">
<h3 id="_resolved_do_we_need_an_api_to_synchronously_wait_for_present_timing_feedback"><a class="anchor" href="#_resolved_do_we_need_an_api_to_synchronously_wait_for_present_timing_feedback"></a>5.3. RESOLVED: Do we need an API to synchronously wait for present timing feedback?</h3>
<div class="paragraph">
<p>No, because some implementations cannot provide a synchronous wait on those results. However, allow applications to call vkGetPastPresentationTimingEXT without external synchronization.</p>
</div>
</div>
<div class="sect2">
<h3 id="_proposed_how_do_we_handle_dynamic_surface_properties_updates"><a class="anchor" href="#_proposed_how_do_we_handle_dynamic_surface_properties_updates"></a>5.4. PROPOSED: How do we handle dynamic surface properties updates?</h3>
<div class="paragraph">
<p><code>VkSurfaceKHR</code> objects capabilities are dynamic and can respond to a lot of different events. For example, when an application user moves a window to another monitor, it is possible for the underlying surface&#8217;s capabilities to change. In the context of this extension, this means that some of the parameters set in a <code>VkPresentTimingInfoEXT</code> struct and passed to <code>vkQueuePresentKHR</code>, for example, may not be valid by the time the presentation engine processes the presentation request.
The implementation must thus be able to handle parameters that have become invalid without the application&#8217;s knowledge. In those cases, the specification provides sane "fallback" behaviors, e.g. reporting timestamps in a different time domain, reporting 0 values when unavailable, etc.</p>
</div>
</div>
<div class="sect2">
<h3 id="_proposed_how_are_dropped_presentation_requests_handled"><a class="anchor" href="#_proposed_how_are_dropped_presentation_requests_handled"></a>5.5. PROPOSED: How are dropped presentation requests handled?</h3>
<div class="paragraph">
<p>Implementations will return a time of 0 for all present stages that occur after the request is dropped. In the future, <code>VkPastPresentationTimingEXT</code> could be extended to include a flag or status bitfield to indicate the reason the request was dropped.</p>
</div>
</div>
<div class="sect2">
<h3 id="_proposed_how_do_different_variable_refresh_rate_technologies_interact_with_this_extension"><a class="anchor" href="#_proposed_how_do_different_variable_refresh_rate_technologies_interact_with_this_extension"></a>5.6. PROPOSED: How do different variable refresh rate technologies interact with this extension?</h3>
<div class="paragraph">
<p>Expose multiple durations in <code>VkSwapchainTimingPropertiesEXT</code> to describe the variable refresh rate properties of the swapchain. One value is the minimum refresh cycle duration, while the other is the granularity at which the refresh cycle duration can be adjusted when presenting. This allows to support FRR, VRR, and, at least partially, Adaptive Refresh Rate (ARR) technologies. Note these values only reflect the current swapchain&#8217;s behavior, and may be different from the actual display hardware capabilities, which need to be queried separately.</p>
</div>
</div>
<div class="sect2">
<h3 id="_proposed_how_does_an_application_adjust_its_ipd_to_match_the_swapchains_refresh_rate"><a class="anchor" href="#_proposed_how_does_an_application_adjust_its_ipd_to_match_the_swapchains_refresh_rate"></a>5.7. PROPOSED: How does an application adjust its IPD to match the swapchain&#8217;s refresh rate?</h3>
<div class="paragraph">
<p>Applications can know if they are presenting late by comparing a presentation request&#8217;s timing results against their corresponding target present time.</p>
</div>
<div class="paragraph">
<p>If images are consistently presented at their desired present time, applications can query results for the  <code>VK_PRESENT_STAGE_QUEUE_OPERATIONS_END_BIT_EXT</code> and <code>VK_PRESENT_STAGE_REQUEST_DEQUEUED_BIT_EXT</code> stages, and subtract those values to get an estimate of how early presentation requests are. Applications can adjust their IPD or device workload in consequence.</p>
</div>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<script id="site-script" src="../../../../_/js/site.js" data-ui-root-path="../../../../_"></script>
<script async src="../../../../_/js/vendor/highlight.js"></script>
<script src="../../../../_/js/vendor/split.js"></script>
<script>
    // Splitter should only be visible in non-mobile layouts (where a hamburger menu is used for nav)
    var width = (window.innerWidth > 0) ? window.innerWidth : screen.width;
    var mobileNav = (width < 1024);

    if (!mobileNav) {
        var sizes = localStorage.getItem('split-sizes')

        if (sizes) {
            sizes = JSON.parse(sizes)
        } else {
            sizes = [25, 75]
        }

        var split = Split(['#split-0', '#split-1'], {
            sizes: sizes,
            onDragEnd: function (sizes) {
                localStorage.setItem('split-sizes', JSON.stringify(sizes))
            },
        })
    }
</script>
<script src="../../../../_/js/vendor/lunr.js" defer></script>
<script src="https://cdn.jsdelivr.net/pako/1.0.3/pako.min.js" defer></script>
<script src="../../../../_/js/search-ui.js" id="search-ui-script" data-site-root-path="../../../.." data-snippet-length="100" data-stylesheet="../../../../_/css/search.css" defer></script>
<script>
window.addEventListener('DOMContentLoaded', function(){
  try {
    var script = document.getElementById('search-ui-script');
    var siteRoot = (script && script.getAttribute('data-site-root-path')) || '';
    var manifestUrl = siteRoot + '/search-index/manifest.json';
    fetch(manifestUrl)
      .then(function (r) { return r.ok ? r.json() : Promise.reject(new Error('manifest not found')) })
      .then(function (manifest) { antoraSearch.bootstrap(lunr, manifest, siteRoot); })
      .catch(function () {
        var s = document.createElement('script');
        s.async = true;
        s.src = siteRoot + '/search-index.js';
        document.head.appendChild(s);
      });
  } catch (e) {
    // Fallback to monolithic index if anything goes wrong
    var s = document.createElement('script');
    s.async = true;
    s.src = '../../../../search-index.js';
    document.head.appendChild(s);
  }
});
</script>
<script async src="../../../../_/js/vendor/tabs.js"></script>
  </body>
</html>
